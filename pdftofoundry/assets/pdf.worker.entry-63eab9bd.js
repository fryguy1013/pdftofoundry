var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
(function() {
  "use strict";
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  var pdf_worker = { exports: {} };
  var dommatrix = { exports: {} };
  /*!
  * DOMMatrix v1.0.3 (https://thednp.github.io/dommatrix/)
  * Copyright 2022 Â© thednp
  * Licensed under MIT (https://github.com/thednp/DOMMatrix/blob/master/LICENSE)
  */
  var hasRequiredDommatrix;
  function requireDommatrix() {
    if (hasRequiredDommatrix)
      return dommatrix.exports;
    hasRequiredDommatrix = 1;
    (function(module, exports) {
      (function(global2, factory) {
        module.exports = factory();
      })(commonjsGlobal, function() {
        function fromArray(array) {
          var m = new CSSMatrix();
          var a = Array.from(array);
          if (!a.every(function(n) {
            return !Number.isNaN(n);
          })) {
            throw TypeError('CSSMatrix: "' + array + '" must only have numbers.');
          }
          if (a.length === 16) {
            var m11 = a[0];
            var m12 = a[1];
            var m13 = a[2];
            var m14 = a[3];
            var m21 = a[4];
            var m22 = a[5];
            var m23 = a[6];
            var m24 = a[7];
            var m31 = a[8];
            var m32 = a[9];
            var m33 = a[10];
            var m34 = a[11];
            var m41 = a[12];
            var m42 = a[13];
            var m43 = a[14];
            var m44 = a[15];
            m.m11 = m11;
            m.a = m11;
            m.m21 = m21;
            m.c = m21;
            m.m31 = m31;
            m.m41 = m41;
            m.e = m41;
            m.m12 = m12;
            m.b = m12;
            m.m22 = m22;
            m.d = m22;
            m.m32 = m32;
            m.m42 = m42;
            m.f = m42;
            m.m13 = m13;
            m.m23 = m23;
            m.m33 = m33;
            m.m43 = m43;
            m.m14 = m14;
            m.m24 = m24;
            m.m34 = m34;
            m.m44 = m44;
          } else if (a.length === 6) {
            var M11 = a[0];
            var M12 = a[1];
            var M21 = a[2];
            var M22 = a[3];
            var M41 = a[4];
            var M42 = a[5];
            m.m11 = M11;
            m.a = M11;
            m.m12 = M12;
            m.b = M12;
            m.m21 = M21;
            m.c = M21;
            m.m22 = M22;
            m.d = M22;
            m.m41 = M41;
            m.e = M41;
            m.m42 = M42;
            m.f = M42;
          } else {
            throw new TypeError("CSSMatrix: expecting an Array of 6/16 values.");
          }
          return m;
        }
        __name(fromArray, "fromArray");
        function fromMatrix(m) {
          var keys = Object.keys(new CSSMatrix());
          if (typeof m === "object" && keys.every(function(k) {
            return k in m;
          })) {
            return fromArray(
              [
                m.m11,
                m.m12,
                m.m13,
                m.m14,
                m.m21,
                m.m22,
                m.m23,
                m.m24,
                m.m31,
                m.m32,
                m.m33,
                m.m34,
                m.m41,
                m.m42,
                m.m43,
                m.m44
              ]
            );
          }
          throw TypeError('CSSMatrix: "' + JSON.stringify(m) + '" is not a DOMMatrix / CSSMatrix / JSON compatible object.');
        }
        __name(fromMatrix, "fromMatrix");
        function fromString(source) {
          if (typeof source !== "string") {
            throw TypeError('CSSMatrix: "' + source + '" is not a string.');
          }
          var str = String(source).replace(/\s/g, "");
          var m = new CSSMatrix();
          var invalidStringError = 'CSSMatrix: invalid transform string "' + source + '"';
          str.split(")").filter(function(f) {
            return f;
          }).forEach(function(tf) {
            var ref = tf.split("(");
            var prop = ref[0];
            var value = ref[1];
            if (!value) {
              throw TypeError(invalidStringError);
            }
            var components = value.split(",").map(function(n) {
              return n.includes("rad") ? parseFloat(n) * (180 / Math.PI) : parseFloat(n);
            });
            var x = components[0];
            var y = components[1];
            var z = components[2];
            var a = components[3];
            var xyz = [x, y, z];
            var xyza = [x, y, z, a];
            if (prop === "perspective" && x && [y, z].every(function(n) {
              return n === void 0;
            })) {
              m.m34 = -1 / x;
            } else if (prop.includes("matrix") && [6, 16].includes(components.length) && components.every(function(n) {
              return !Number.isNaN(+n);
            })) {
              var values = components.map(function(n) {
                return Math.abs(n) < 1e-6 ? 0 : n;
              });
              m = m.multiply(fromArray(values));
            } else if (prop === "translate3d" && xyz.every(function(n) {
              return !Number.isNaN(+n);
            })) {
              m = m.translate(x, y, z);
            } else if (prop === "translate" && x && z === void 0) {
              m = m.translate(x, y || 0, 0);
            } else if (prop === "rotate3d" && xyza.every(function(n) {
              return !Number.isNaN(+n);
            }) && a) {
              m = m.rotateAxisAngle(x, y, z, a);
            } else if (prop === "rotate" && x && [y, z].every(function(n) {
              return n === void 0;
            })) {
              m = m.rotate(0, 0, x);
            } else if (prop === "scale3d" && xyz.every(function(n) {
              return !Number.isNaN(+n);
            }) && xyz.some(function(n) {
              return n !== 1;
            })) {
              m = m.scale(x, y, z);
            } else if (prop === "scale" && !Number.isNaN(x) && x !== 1 && z === void 0) {
              var nosy = Number.isNaN(+y);
              var sy = nosy ? x : y;
              m = m.scale(x, sy, 1);
            } else if (prop === "skew" && (x || !Number.isNaN(x) && y) && z === void 0) {
              m = m.skew(x, y || 0);
            } else if (/[XYZ]/.test(prop) && x && [y, z].every(function(n) {
              return n === void 0;
            }) && ["translate", "rotate", "scale", "skew"].some(function(p) {
              return prop.includes(p);
            })) {
              if (["skewX", "skewY"].includes(prop)) {
                m = m[prop](x);
              } else {
                var fn = prop.replace(/[XYZ]/, "");
                var axis = prop.replace(fn, "");
                var idx = ["X", "Y", "Z"].indexOf(axis);
                var def = fn === "scale" ? 1 : 0;
                var axeValues = [
                  idx === 0 ? x : def,
                  idx === 1 ? x : def,
                  idx === 2 ? x : def
                ];
                m = m[fn].apply(m, axeValues);
              }
            } else {
              throw TypeError(invalidStringError);
            }
          });
          return m;
        }
        __name(fromString, "fromString");
        function toArray(m, is2D) {
          if (is2D) {
            return [m.a, m.b, m.c, m.d, m.e, m.f];
          }
          return [
            m.m11,
            m.m12,
            m.m13,
            m.m14,
            m.m21,
            m.m22,
            m.m23,
            m.m24,
            m.m31,
            m.m32,
            m.m33,
            m.m34,
            m.m41,
            m.m42,
            m.m43,
            m.m44
          ];
        }
        __name(toArray, "toArray");
        function Translate(x, y, z) {
          var m = new CSSMatrix();
          m.m41 = x;
          m.e = x;
          m.m42 = y;
          m.f = y;
          m.m43 = z;
          return m;
        }
        __name(Translate, "Translate");
        function Rotate(rx, ry, rz) {
          var m = new CSSMatrix();
          var degToRad = Math.PI / 180;
          var radX = rx * degToRad;
          var radY = ry * degToRad;
          var radZ = rz * degToRad;
          var cosx = Math.cos(radX);
          var sinx = -Math.sin(radX);
          var cosy = Math.cos(radY);
          var siny = -Math.sin(radY);
          var cosz = Math.cos(radZ);
          var sinz = -Math.sin(radZ);
          var m11 = cosy * cosz;
          var m12 = -cosy * sinz;
          m.m11 = m11;
          m.a = m11;
          m.m12 = m12;
          m.b = m12;
          m.m13 = siny;
          var m21 = sinx * siny * cosz + cosx * sinz;
          m.m21 = m21;
          m.c = m21;
          var m22 = cosx * cosz - sinx * siny * sinz;
          m.m22 = m22;
          m.d = m22;
          m.m23 = -sinx * cosy;
          m.m31 = sinx * sinz - cosx * siny * cosz;
          m.m32 = sinx * cosz + cosx * siny * sinz;
          m.m33 = cosx * cosy;
          return m;
        }
        __name(Rotate, "Rotate");
        function RotateAxisAngle(x, y, z, alpha) {
          var m = new CSSMatrix();
          var length = Math.sqrt(x * x + y * y + z * z);
          if (length === 0) {
            return m;
          }
          var X = x / length;
          var Y = y / length;
          var Z = z / length;
          var angle = alpha * (Math.PI / 360);
          var sinA = Math.sin(angle);
          var cosA = Math.cos(angle);
          var sinA2 = sinA * sinA;
          var x2 = X * X;
          var y2 = Y * Y;
          var z2 = Z * Z;
          var m11 = 1 - 2 * (y2 + z2) * sinA2;
          m.m11 = m11;
          m.a = m11;
          var m12 = 2 * (X * Y * sinA2 + Z * sinA * cosA);
          m.m12 = m12;
          m.b = m12;
          m.m13 = 2 * (X * Z * sinA2 - Y * sinA * cosA);
          var m21 = 2 * (Y * X * sinA2 - Z * sinA * cosA);
          m.m21 = m21;
          m.c = m21;
          var m22 = 1 - 2 * (z2 + x2) * sinA2;
          m.m22 = m22;
          m.d = m22;
          m.m23 = 2 * (Y * Z * sinA2 + X * sinA * cosA);
          m.m31 = 2 * (Z * X * sinA2 + Y * sinA * cosA);
          m.m32 = 2 * (Z * Y * sinA2 - X * sinA * cosA);
          m.m33 = 1 - 2 * (x2 + y2) * sinA2;
          return m;
        }
        __name(RotateAxisAngle, "RotateAxisAngle");
        function Scale(x, y, z) {
          var m = new CSSMatrix();
          m.m11 = x;
          m.a = x;
          m.m22 = y;
          m.d = y;
          m.m33 = z;
          return m;
        }
        __name(Scale, "Scale");
        function Skew(angleX, angleY) {
          var m = new CSSMatrix();
          if (angleX) {
            var radX = angleX * Math.PI / 180;
            var tX = Math.tan(radX);
            m.m21 = tX;
            m.c = tX;
          }
          if (angleY) {
            var radY = angleY * Math.PI / 180;
            var tY = Math.tan(radY);
            m.m12 = tY;
            m.b = tY;
          }
          return m;
        }
        __name(Skew, "Skew");
        function SkewX(angle) {
          return Skew(angle, 0);
        }
        __name(SkewX, "SkewX");
        function SkewY(angle) {
          return Skew(0, angle);
        }
        __name(SkewY, "SkewY");
        function Multiply(m1, m2) {
          var m11 = m2.m11 * m1.m11 + m2.m12 * m1.m21 + m2.m13 * m1.m31 + m2.m14 * m1.m41;
          var m12 = m2.m11 * m1.m12 + m2.m12 * m1.m22 + m2.m13 * m1.m32 + m2.m14 * m1.m42;
          var m13 = m2.m11 * m1.m13 + m2.m12 * m1.m23 + m2.m13 * m1.m33 + m2.m14 * m1.m43;
          var m14 = m2.m11 * m1.m14 + m2.m12 * m1.m24 + m2.m13 * m1.m34 + m2.m14 * m1.m44;
          var m21 = m2.m21 * m1.m11 + m2.m22 * m1.m21 + m2.m23 * m1.m31 + m2.m24 * m1.m41;
          var m22 = m2.m21 * m1.m12 + m2.m22 * m1.m22 + m2.m23 * m1.m32 + m2.m24 * m1.m42;
          var m23 = m2.m21 * m1.m13 + m2.m22 * m1.m23 + m2.m23 * m1.m33 + m2.m24 * m1.m43;
          var m24 = m2.m21 * m1.m14 + m2.m22 * m1.m24 + m2.m23 * m1.m34 + m2.m24 * m1.m44;
          var m31 = m2.m31 * m1.m11 + m2.m32 * m1.m21 + m2.m33 * m1.m31 + m2.m34 * m1.m41;
          var m32 = m2.m31 * m1.m12 + m2.m32 * m1.m22 + m2.m33 * m1.m32 + m2.m34 * m1.m42;
          var m33 = m2.m31 * m1.m13 + m2.m32 * m1.m23 + m2.m33 * m1.m33 + m2.m34 * m1.m43;
          var m34 = m2.m31 * m1.m14 + m2.m32 * m1.m24 + m2.m33 * m1.m34 + m2.m34 * m1.m44;
          var m41 = m2.m41 * m1.m11 + m2.m42 * m1.m21 + m2.m43 * m1.m31 + m2.m44 * m1.m41;
          var m42 = m2.m41 * m1.m12 + m2.m42 * m1.m22 + m2.m43 * m1.m32 + m2.m44 * m1.m42;
          var m43 = m2.m41 * m1.m13 + m2.m42 * m1.m23 + m2.m43 * m1.m33 + m2.m44 * m1.m43;
          var m44 = m2.m41 * m1.m14 + m2.m42 * m1.m24 + m2.m43 * m1.m34 + m2.m44 * m1.m44;
          return fromArray(
            [
              m11,
              m12,
              m13,
              m14,
              m21,
              m22,
              m23,
              m24,
              m31,
              m32,
              m33,
              m34,
              m41,
              m42,
              m43,
              m44
            ]
          );
        }
        __name(Multiply, "Multiply");
        var CSSMatrix = /* @__PURE__ */ __name(function CSSMatrix2() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var m = this;
          m.a = 1;
          m.b = 0;
          m.c = 0;
          m.d = 1;
          m.e = 0;
          m.f = 0;
          m.m11 = 1;
          m.m12 = 0;
          m.m13 = 0;
          m.m14 = 0;
          m.m21 = 0;
          m.m22 = 1;
          m.m23 = 0;
          m.m24 = 0;
          m.m31 = 0;
          m.m32 = 0;
          m.m33 = 1;
          m.m34 = 0;
          m.m41 = 0;
          m.m42 = 0;
          m.m43 = 0;
          m.m44 = 1;
          if (args.length) {
            var ARGS = [16, 6].some(function(l) {
              return l === args.length;
            }) ? args : args[0];
            return m.setMatrixValue(ARGS);
          }
          return m;
        }, "CSSMatrix");
        var prototypeAccessors = { isIdentity: { configurable: true }, is2D: { configurable: true } };
        prototypeAccessors.isIdentity.get = function() {
          var m = this;
          return m.m11 === 1 && m.m12 === 0 && m.m13 === 0 && m.m14 === 0 && m.m21 === 0 && m.m22 === 1 && m.m23 === 0 && m.m24 === 0 && m.m31 === 0 && m.m32 === 0 && m.m33 === 1 && m.m34 === 0 && m.m41 === 0 && m.m42 === 0 && m.m43 === 0 && m.m44 === 1;
        };
        prototypeAccessors.is2D.get = function() {
          var m = this;
          return m.m31 === 0 && m.m32 === 0 && m.m33 === 1 && m.m34 === 0 && m.m43 === 0 && m.m44 === 1;
        };
        CSSMatrix.prototype.setMatrixValue = /* @__PURE__ */ __name(function setMatrixValue(source) {
          var m = this;
          if (typeof source === "string" && source.length && source !== "none") {
            return fromString(source);
          }
          if ([Array, Float64Array, Float32Array].some(function(a) {
            return source instanceof a;
          })) {
            return fromArray(source);
          }
          if ([CSSMatrix, DOMMatrix, Object].some(function(a) {
            return source instanceof a;
          })) {
            return fromMatrix(source);
          }
          return m;
        }, "setMatrixValue");
        CSSMatrix.prototype.toFloat32Array = /* @__PURE__ */ __name(function toFloat32Array(is2D) {
          return Float32Array.from(toArray(this, is2D));
        }, "toFloat32Array");
        CSSMatrix.prototype.toFloat64Array = /* @__PURE__ */ __name(function toFloat64Array(is2D) {
          return Float64Array.from(toArray(this, is2D));
        }, "toFloat64Array");
        CSSMatrix.prototype.toString = /* @__PURE__ */ __name(function toString() {
          var m = this;
          var is2D = m.is2D;
          var values = m.toFloat64Array(is2D).join(", ");
          var type = is2D ? "matrix" : "matrix3d";
          return type + "(" + values + ")";
        }, "toString");
        CSSMatrix.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
          var m = this;
          var is2D = m.is2D;
          var isIdentity = m.isIdentity;
          return Object.assign({}, m, { is2D, isIdentity });
        }, "toJSON");
        CSSMatrix.prototype.multiply = /* @__PURE__ */ __name(function multiply(m2) {
          return Multiply(this, m2);
        }, "multiply");
        CSSMatrix.prototype.translate = /* @__PURE__ */ __name(function translate(x, y, z) {
          var X = x;
          var Y = y;
          var Z = z;
          if (Y === void 0) {
            Y = 0;
          }
          if (Z === void 0) {
            Z = 0;
          }
          return Multiply(this, Translate(X, Y, Z));
        }, "translate");
        CSSMatrix.prototype.scale = /* @__PURE__ */ __name(function scale(x, y, z) {
          var X = x;
          var Y = y;
          var Z = z;
          if (Y === void 0) {
            Y = x;
          }
          if (Z === void 0) {
            Z = 1;
          }
          return Multiply(this, Scale(X, Y, Z));
        }, "scale");
        CSSMatrix.prototype.rotate = /* @__PURE__ */ __name(function rotate(rx, ry, rz) {
          var RX = rx;
          var RY = ry || 0;
          var RZ = rz || 0;
          if (typeof rx === "number" && ry === void 0 && rz === void 0) {
            RZ = RX;
            RX = 0;
            RY = 0;
          }
          return Multiply(this, Rotate(RX, RY, RZ));
        }, "rotate");
        CSSMatrix.prototype.rotateAxisAngle = /* @__PURE__ */ __name(function rotateAxisAngle(x, y, z, angle) {
          if ([x, y, z, angle].some(function(n) {
            return Number.isNaN(+n);
          })) {
            throw new TypeError("CSSMatrix: expecting 4 values");
          }
          return Multiply(this, RotateAxisAngle(x, y, z, angle));
        }, "rotateAxisAngle");
        CSSMatrix.prototype.skewX = /* @__PURE__ */ __name(function skewX(angle) {
          return Multiply(this, SkewX(angle));
        }, "skewX");
        CSSMatrix.prototype.skewY = /* @__PURE__ */ __name(function skewY(angle) {
          return Multiply(this, SkewY(angle));
        }, "skewY");
        CSSMatrix.prototype.skew = /* @__PURE__ */ __name(function skew(angleX, angleY) {
          return Multiply(this, Skew(angleX, angleY));
        }, "skew");
        CSSMatrix.prototype.transformPoint = /* @__PURE__ */ __name(function transformPoint(t) {
          var m = this;
          var x = m.m11 * t.x + m.m21 * t.y + m.m31 * t.z + m.m41 * t.w;
          var y = m.m12 * t.x + m.m22 * t.y + m.m32 * t.z + m.m42 * t.w;
          var z = m.m13 * t.x + m.m23 * t.y + m.m33 * t.z + m.m43 * t.w;
          var w = m.m14 * t.x + m.m24 * t.y + m.m34 * t.z + m.m44 * t.w;
          return t instanceof DOMPoint ? new DOMPoint(x, y, z, w) : {
            x,
            y,
            z,
            w
          };
        }, "transformPoint");
        Object.defineProperties(CSSMatrix.prototype, prototypeAccessors);
        Object.assign(CSSMatrix, {
          Translate,
          Rotate,
          RotateAxisAngle,
          Scale,
          SkewX,
          SkewY,
          Skew,
          Multiply,
          fromArray,
          fromMatrix,
          fromString,
          toArray
        });
        var version = "1.0.3";
        var Version = version;
        Object.assign(CSSMatrix, { Version });
        return CSSMatrix;
      });
    })(dommatrix);
    return dommatrix.exports;
  }
  __name(requireDommatrix, "requireDommatrix");
  var ponyfill = { exports: {} };
  var hasRequiredPonyfill;
  function requirePonyfill() {
    if (hasRequiredPonyfill)
      return ponyfill.exports;
    hasRequiredPonyfill = 1;
    (function(module, exports) {
      (function(global2, factory) {
        factory(exports);
      })(commonjsGlobal, function(exports2) {
        var SymbolPolyfill = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol : function(description) {
          return "Symbol(" + description + ")";
        };
        function noop() {
          return void 0;
        }
        __name(noop, "noop");
        function getGlobals() {
          if (typeof self !== "undefined") {
            return self;
          } else if (typeof window !== "undefined") {
            return window;
          } else if (typeof commonjsGlobal !== "undefined") {
            return commonjsGlobal;
          }
          return void 0;
        }
        __name(getGlobals, "getGlobals");
        var globals = getGlobals();
        function typeIsObject(x) {
          return typeof x === "object" && x !== null || typeof x === "function";
        }
        __name(typeIsObject, "typeIsObject");
        var rethrowAssertionErrorRejection = noop;
        var originalPromise = Promise;
        var originalPromiseThen = Promise.prototype.then;
        var originalPromiseResolve = Promise.resolve.bind(originalPromise);
        var originalPromiseReject = Promise.reject.bind(originalPromise);
        function newPromise(executor) {
          return new originalPromise(executor);
        }
        __name(newPromise, "newPromise");
        function promiseResolvedWith(value) {
          return originalPromiseResolve(value);
        }
        __name(promiseResolvedWith, "promiseResolvedWith");
        function promiseRejectedWith(reason) {
          return originalPromiseReject(reason);
        }
        __name(promiseRejectedWith, "promiseRejectedWith");
        function PerformPromiseThen(promise, onFulfilled, onRejected) {
          return originalPromiseThen.call(promise, onFulfilled, onRejected);
        }
        __name(PerformPromiseThen, "PerformPromiseThen");
        function uponPromise(promise, onFulfilled, onRejected) {
          PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
        }
        __name(uponPromise, "uponPromise");
        function uponFulfillment(promise, onFulfilled) {
          uponPromise(promise, onFulfilled);
        }
        __name(uponFulfillment, "uponFulfillment");
        function uponRejection(promise, onRejected) {
          uponPromise(promise, void 0, onRejected);
        }
        __name(uponRejection, "uponRejection");
        function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
          return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
        }
        __name(transformPromiseWith, "transformPromiseWith");
        function setPromiseIsHandledToTrue(promise) {
          PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
        }
        __name(setPromiseIsHandledToTrue, "setPromiseIsHandledToTrue");
        var queueMicrotask = function() {
          var globalQueueMicrotask = globals && globals.queueMicrotask;
          if (typeof globalQueueMicrotask === "function") {
            return globalQueueMicrotask;
          }
          var resolvedPromise = promiseResolvedWith(void 0);
          return function(fn) {
            return PerformPromiseThen(resolvedPromise, fn);
          };
        }();
        function reflectCall(F, V, args) {
          if (typeof F !== "function") {
            throw new TypeError("Argument is not a function");
          }
          return Function.prototype.apply.call(F, V, args);
        }
        __name(reflectCall, "reflectCall");
        function promiseCall(F, V, args) {
          try {
            return promiseResolvedWith(reflectCall(F, V, args));
          } catch (value) {
            return promiseRejectedWith(value);
          }
        }
        __name(promiseCall, "promiseCall");
        var QUEUE_MAX_ARRAY_SIZE = 16384;
        var SimpleQueue = (
          /** @class */
          function() {
            function SimpleQueue2() {
              this._cursor = 0;
              this._size = 0;
              this._front = {
                _elements: [],
                _next: void 0
              };
              this._back = this._front;
              this._cursor = 0;
              this._size = 0;
            }
            __name(SimpleQueue2, "SimpleQueue");
            Object.defineProperty(SimpleQueue2.prototype, "length", {
              get: function() {
                return this._size;
              },
              enumerable: false,
              configurable: true
            });
            SimpleQueue2.prototype.push = function(element) {
              var oldBack = this._back;
              var newBack = oldBack;
              if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
                newBack = {
                  _elements: [],
                  _next: void 0
                };
              }
              oldBack._elements.push(element);
              if (newBack !== oldBack) {
                this._back = newBack;
                oldBack._next = newBack;
              }
              ++this._size;
            };
            SimpleQueue2.prototype.shift = function() {
              var oldFront = this._front;
              var newFront = oldFront;
              var oldCursor = this._cursor;
              var newCursor = oldCursor + 1;
              var elements = oldFront._elements;
              var element = elements[oldCursor];
              if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
                newFront = oldFront._next;
                newCursor = 0;
              }
              --this._size;
              this._cursor = newCursor;
              if (oldFront !== newFront) {
                this._front = newFront;
              }
              elements[oldCursor] = void 0;
              return element;
            };
            SimpleQueue2.prototype.forEach = function(callback) {
              var i = this._cursor;
              var node = this._front;
              var elements = node._elements;
              while (i !== elements.length || node._next !== void 0) {
                if (i === elements.length) {
                  node = node._next;
                  elements = node._elements;
                  i = 0;
                  if (elements.length === 0) {
                    break;
                  }
                }
                callback(elements[i]);
                ++i;
              }
            };
            SimpleQueue2.prototype.peek = function() {
              var front = this._front;
              var cursor = this._cursor;
              return front._elements[cursor];
            };
            return SimpleQueue2;
          }()
        );
        function ReadableStreamReaderGenericInitialize(reader, stream) {
          reader._ownerReadableStream = stream;
          stream._reader = reader;
          if (stream._state === "readable") {
            defaultReaderClosedPromiseInitialize(reader);
          } else if (stream._state === "closed") {
            defaultReaderClosedPromiseInitializeAsResolved(reader);
          } else {
            defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
          }
        }
        __name(ReadableStreamReaderGenericInitialize, "ReadableStreamReaderGenericInitialize");
        function ReadableStreamReaderGenericCancel(reader, reason) {
          var stream = reader._ownerReadableStream;
          return ReadableStreamCancel(stream, reason);
        }
        __name(ReadableStreamReaderGenericCancel, "ReadableStreamReaderGenericCancel");
        function ReadableStreamReaderGenericRelease(reader) {
          if (reader._ownerReadableStream._state === "readable") {
            defaultReaderClosedPromiseReject(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));
          } else {
            defaultReaderClosedPromiseResetToRejected(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));
          }
          reader._ownerReadableStream._reader = void 0;
          reader._ownerReadableStream = void 0;
        }
        __name(ReadableStreamReaderGenericRelease, "ReadableStreamReaderGenericRelease");
        function readerLockException(name) {
          return new TypeError("Cannot " + name + " a stream using a released reader");
        }
        __name(readerLockException, "readerLockException");
        function defaultReaderClosedPromiseInitialize(reader) {
          reader._closedPromise = newPromise(function(resolve, reject) {
            reader._closedPromise_resolve = resolve;
            reader._closedPromise_reject = reject;
          });
        }
        __name(defaultReaderClosedPromiseInitialize, "defaultReaderClosedPromiseInitialize");
        function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
          defaultReaderClosedPromiseInitialize(reader);
          defaultReaderClosedPromiseReject(reader, reason);
        }
        __name(defaultReaderClosedPromiseInitializeAsRejected, "defaultReaderClosedPromiseInitializeAsRejected");
        function defaultReaderClosedPromiseInitializeAsResolved(reader) {
          defaultReaderClosedPromiseInitialize(reader);
          defaultReaderClosedPromiseResolve(reader);
        }
        __name(defaultReaderClosedPromiseInitializeAsResolved, "defaultReaderClosedPromiseInitializeAsResolved");
        function defaultReaderClosedPromiseReject(reader, reason) {
          if (reader._closedPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(reader._closedPromise);
          reader._closedPromise_reject(reason);
          reader._closedPromise_resolve = void 0;
          reader._closedPromise_reject = void 0;
        }
        __name(defaultReaderClosedPromiseReject, "defaultReaderClosedPromiseReject");
        function defaultReaderClosedPromiseResetToRejected(reader, reason) {
          defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
        }
        __name(defaultReaderClosedPromiseResetToRejected, "defaultReaderClosedPromiseResetToRejected");
        function defaultReaderClosedPromiseResolve(reader) {
          if (reader._closedPromise_resolve === void 0) {
            return;
          }
          reader._closedPromise_resolve(void 0);
          reader._closedPromise_resolve = void 0;
          reader._closedPromise_reject = void 0;
        }
        __name(defaultReaderClosedPromiseResolve, "defaultReaderClosedPromiseResolve");
        var AbortSteps = SymbolPolyfill("[[AbortSteps]]");
        var ErrorSteps = SymbolPolyfill("[[ErrorSteps]]");
        var CancelSteps = SymbolPolyfill("[[CancelSteps]]");
        var PullSteps = SymbolPolyfill("[[PullSteps]]");
        var NumberIsFinite = Number.isFinite || function(x) {
          return typeof x === "number" && isFinite(x);
        };
        var MathTrunc = Math.trunc || function(v) {
          return v < 0 ? Math.ceil(v) : Math.floor(v);
        };
        function isDictionary(x) {
          return typeof x === "object" || typeof x === "function";
        }
        __name(isDictionary, "isDictionary");
        function assertDictionary(obj, context) {
          if (obj !== void 0 && !isDictionary(obj)) {
            throw new TypeError(context + " is not an object.");
          }
        }
        __name(assertDictionary, "assertDictionary");
        function assertFunction(x, context) {
          if (typeof x !== "function") {
            throw new TypeError(context + " is not a function.");
          }
        }
        __name(assertFunction, "assertFunction");
        function isObject(x) {
          return typeof x === "object" && x !== null || typeof x === "function";
        }
        __name(isObject, "isObject");
        function assertObject(x, context) {
          if (!isObject(x)) {
            throw new TypeError(context + " is not an object.");
          }
        }
        __name(assertObject, "assertObject");
        function assertRequiredArgument(x, position, context) {
          if (x === void 0) {
            throw new TypeError("Parameter " + position + " is required in '" + context + "'.");
          }
        }
        __name(assertRequiredArgument, "assertRequiredArgument");
        function assertRequiredField(x, field, context) {
          if (x === void 0) {
            throw new TypeError(field + " is required in '" + context + "'.");
          }
        }
        __name(assertRequiredField, "assertRequiredField");
        function convertUnrestrictedDouble(value) {
          return Number(value);
        }
        __name(convertUnrestrictedDouble, "convertUnrestrictedDouble");
        function censorNegativeZero(x) {
          return x === 0 ? 0 : x;
        }
        __name(censorNegativeZero, "censorNegativeZero");
        function integerPart(x) {
          return censorNegativeZero(MathTrunc(x));
        }
        __name(integerPart, "integerPart");
        function convertUnsignedLongLongWithEnforceRange(value, context) {
          var lowerBound = 0;
          var upperBound = Number.MAX_SAFE_INTEGER;
          var x = Number(value);
          x = censorNegativeZero(x);
          if (!NumberIsFinite(x)) {
            throw new TypeError(context + " is not a finite number");
          }
          x = integerPart(x);
          if (x < lowerBound || x > upperBound) {
            throw new TypeError(context + " is outside the accepted range of " + lowerBound + " to " + upperBound + ", inclusive");
          }
          if (!NumberIsFinite(x) || x === 0) {
            return 0;
          }
          return x;
        }
        __name(convertUnsignedLongLongWithEnforceRange, "convertUnsignedLongLongWithEnforceRange");
        function assertReadableStream(x, context) {
          if (!IsReadableStream(x)) {
            throw new TypeError(context + " is not a ReadableStream.");
          }
        }
        __name(assertReadableStream, "assertReadableStream");
        function AcquireReadableStreamDefaultReader(stream) {
          return new ReadableStreamDefaultReader(stream);
        }
        __name(AcquireReadableStreamDefaultReader, "AcquireReadableStreamDefaultReader");
        function ReadableStreamAddReadRequest(stream, readRequest) {
          stream._reader._readRequests.push(readRequest);
        }
        __name(ReadableStreamAddReadRequest, "ReadableStreamAddReadRequest");
        function ReadableStreamFulfillReadRequest(stream, chunk, done) {
          var reader = stream._reader;
          var readRequest = reader._readRequests.shift();
          if (done) {
            readRequest._closeSteps();
          } else {
            readRequest._chunkSteps(chunk);
          }
        }
        __name(ReadableStreamFulfillReadRequest, "ReadableStreamFulfillReadRequest");
        function ReadableStreamGetNumReadRequests(stream) {
          return stream._reader._readRequests.length;
        }
        __name(ReadableStreamGetNumReadRequests, "ReadableStreamGetNumReadRequests");
        function ReadableStreamHasDefaultReader(stream) {
          var reader = stream._reader;
          if (reader === void 0) {
            return false;
          }
          if (!IsReadableStreamDefaultReader(reader)) {
            return false;
          }
          return true;
        }
        __name(ReadableStreamHasDefaultReader, "ReadableStreamHasDefaultReader");
        var ReadableStreamDefaultReader = (
          /** @class */
          function() {
            function ReadableStreamDefaultReader2(stream) {
              assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
              assertReadableStream(stream, "First parameter");
              if (IsReadableStreamLocked(stream)) {
                throw new TypeError("This stream has already been locked for exclusive reading by another reader");
              }
              ReadableStreamReaderGenericInitialize(this, stream);
              this._readRequests = new SimpleQueue();
            }
            __name(ReadableStreamDefaultReader2, "ReadableStreamDefaultReader");
            Object.defineProperty(ReadableStreamDefaultReader2.prototype, "closed", {
              /**
               * Returns a promise that will be fulfilled when the stream becomes closed,
               * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.
               */
              get: function() {
                if (!IsReadableStreamDefaultReader(this)) {
                  return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
                }
                return this._closedPromise;
              },
              enumerable: false,
              configurable: true
            });
            ReadableStreamDefaultReader2.prototype.cancel = function(reason) {
              if (reason === void 0) {
                reason = void 0;
              }
              if (!IsReadableStreamDefaultReader(this)) {
                return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
              }
              if (this._ownerReadableStream === void 0) {
                return promiseRejectedWith(readerLockException("cancel"));
              }
              return ReadableStreamReaderGenericCancel(this, reason);
            };
            ReadableStreamDefaultReader2.prototype.read = function() {
              if (!IsReadableStreamDefaultReader(this)) {
                return promiseRejectedWith(defaultReaderBrandCheckException("read"));
              }
              if (this._ownerReadableStream === void 0) {
                return promiseRejectedWith(readerLockException("read from"));
              }
              var resolvePromise;
              var rejectPromise;
              var promise = newPromise(function(resolve, reject) {
                resolvePromise = resolve;
                rejectPromise = reject;
              });
              var readRequest = {
                _chunkSteps: function(chunk) {
                  return resolvePromise({ value: chunk, done: false });
                },
                _closeSteps: function() {
                  return resolvePromise({ value: void 0, done: true });
                },
                _errorSteps: function(e) {
                  return rejectPromise(e);
                }
              };
              ReadableStreamDefaultReaderRead(this, readRequest);
              return promise;
            };
            ReadableStreamDefaultReader2.prototype.releaseLock = function() {
              if (!IsReadableStreamDefaultReader(this)) {
                throw defaultReaderBrandCheckException("releaseLock");
              }
              if (this._ownerReadableStream === void 0) {
                return;
              }
              if (this._readRequests.length > 0) {
                throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
              }
              ReadableStreamReaderGenericRelease(this);
            };
            return ReadableStreamDefaultReader2;
          }()
        );
        Object.defineProperties(ReadableStreamDefaultReader.prototype, {
          cancel: { enumerable: true },
          read: { enumerable: true },
          releaseLock: { enumerable: true },
          closed: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamDefaultReader",
            configurable: true
          });
        }
        function IsReadableStreamDefaultReader(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_readRequests")) {
            return false;
          }
          return x instanceof ReadableStreamDefaultReader;
        }
        __name(IsReadableStreamDefaultReader, "IsReadableStreamDefaultReader");
        function ReadableStreamDefaultReaderRead(reader, readRequest) {
          var stream = reader._ownerReadableStream;
          stream._disturbed = true;
          if (stream._state === "closed") {
            readRequest._closeSteps();
          } else if (stream._state === "errored") {
            readRequest._errorSteps(stream._storedError);
          } else {
            stream._readableStreamController[PullSteps](readRequest);
          }
        }
        __name(ReadableStreamDefaultReaderRead, "ReadableStreamDefaultReaderRead");
        function defaultReaderBrandCheckException(name) {
          return new TypeError("ReadableStreamDefaultReader.prototype." + name + " can only be used on a ReadableStreamDefaultReader");
        }
        __name(defaultReaderBrandCheckException, "defaultReaderBrandCheckException");
        var _a;
        var AsyncIteratorPrototype;
        if (typeof SymbolPolyfill.asyncIterator === "symbol") {
          AsyncIteratorPrototype = (_a = {}, // 25.1.3.1 %AsyncIteratorPrototype% [ @@asyncIterator ] ( )
          // https://tc39.github.io/ecma262/#sec-asynciteratorprototype-asynciterator
          _a[SymbolPolyfill.asyncIterator] = function() {
            return this;
          }, _a);
          Object.defineProperty(AsyncIteratorPrototype, SymbolPolyfill.asyncIterator, { enumerable: false });
        }
        var ReadableStreamAsyncIteratorImpl = (
          /** @class */
          function() {
            function ReadableStreamAsyncIteratorImpl2(reader, preventCancel) {
              this._ongoingPromise = void 0;
              this._isFinished = false;
              this._reader = reader;
              this._preventCancel = preventCancel;
            }
            __name(ReadableStreamAsyncIteratorImpl2, "ReadableStreamAsyncIteratorImpl");
            ReadableStreamAsyncIteratorImpl2.prototype.next = function() {
              var _this = this;
              var nextSteps = /* @__PURE__ */ __name(function() {
                return _this._nextSteps();
              }, "nextSteps");
              this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
              return this._ongoingPromise;
            };
            ReadableStreamAsyncIteratorImpl2.prototype.return = function(value) {
              var _this = this;
              var returnSteps = /* @__PURE__ */ __name(function() {
                return _this._returnSteps(value);
              }, "returnSteps");
              return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
            };
            ReadableStreamAsyncIteratorImpl2.prototype._nextSteps = function() {
              var _this = this;
              if (this._isFinished) {
                return Promise.resolve({ value: void 0, done: true });
              }
              var reader = this._reader;
              if (reader._ownerReadableStream === void 0) {
                return promiseRejectedWith(readerLockException("iterate"));
              }
              var resolvePromise;
              var rejectPromise;
              var promise = newPromise(function(resolve, reject) {
                resolvePromise = resolve;
                rejectPromise = reject;
              });
              var readRequest = {
                _chunkSteps: function(chunk) {
                  _this._ongoingPromise = void 0;
                  queueMicrotask(function() {
                    return resolvePromise({ value: chunk, done: false });
                  });
                },
                _closeSteps: function() {
                  _this._ongoingPromise = void 0;
                  _this._isFinished = true;
                  ReadableStreamReaderGenericRelease(reader);
                  resolvePromise({ value: void 0, done: true });
                },
                _errorSteps: function(reason) {
                  _this._ongoingPromise = void 0;
                  _this._isFinished = true;
                  ReadableStreamReaderGenericRelease(reader);
                  rejectPromise(reason);
                }
              };
              ReadableStreamDefaultReaderRead(reader, readRequest);
              return promise;
            };
            ReadableStreamAsyncIteratorImpl2.prototype._returnSteps = function(value) {
              if (this._isFinished) {
                return Promise.resolve({ value, done: true });
              }
              this._isFinished = true;
              var reader = this._reader;
              if (reader._ownerReadableStream === void 0) {
                return promiseRejectedWith(readerLockException("finish iterating"));
              }
              if (!this._preventCancel) {
                var result = ReadableStreamReaderGenericCancel(reader, value);
                ReadableStreamReaderGenericRelease(reader);
                return transformPromiseWith(result, function() {
                  return { value, done: true };
                });
              }
              ReadableStreamReaderGenericRelease(reader);
              return promiseResolvedWith({ value, done: true });
            };
            return ReadableStreamAsyncIteratorImpl2;
          }()
        );
        var ReadableStreamAsyncIteratorPrototype = {
          next: function() {
            if (!IsReadableStreamAsyncIterator(this)) {
              return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
            }
            return this._asyncIteratorImpl.next();
          },
          return: function(value) {
            if (!IsReadableStreamAsyncIterator(this)) {
              return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
            }
            return this._asyncIteratorImpl.return(value);
          }
        };
        if (AsyncIteratorPrototype !== void 0) {
          Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
        }
        function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
          var reader = AcquireReadableStreamDefaultReader(stream);
          var impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
          var iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
          iterator._asyncIteratorImpl = impl;
          return iterator;
        }
        __name(AcquireReadableStreamAsyncIterator, "AcquireReadableStreamAsyncIterator");
        function IsReadableStreamAsyncIterator(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_asyncIteratorImpl")) {
            return false;
          }
          try {
            return x._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
          } catch (_a2) {
            return false;
          }
        }
        __name(IsReadableStreamAsyncIterator, "IsReadableStreamAsyncIterator");
        function streamAsyncIteratorBrandCheckException(name) {
          return new TypeError("ReadableStreamAsyncIterator." + name + " can only be used on a ReadableSteamAsyncIterator");
        }
        __name(streamAsyncIteratorBrandCheckException, "streamAsyncIteratorBrandCheckException");
        var NumberIsNaN = Number.isNaN || function(x) {
          return x !== x;
        };
        function CreateArrayFromList(elements) {
          return elements.slice();
        }
        __name(CreateArrayFromList, "CreateArrayFromList");
        function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
          new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
        }
        __name(CopyDataBlockBytes, "CopyDataBlockBytes");
        function TransferArrayBuffer(O) {
          return O;
        }
        __name(TransferArrayBuffer, "TransferArrayBuffer");
        function IsDetachedBuffer(O) {
          return false;
        }
        __name(IsDetachedBuffer, "IsDetachedBuffer");
        function ArrayBufferSlice(buffer, begin, end) {
          if (buffer.slice) {
            return buffer.slice(begin, end);
          }
          var length = end - begin;
          var slice = new ArrayBuffer(length);
          CopyDataBlockBytes(slice, 0, buffer, begin, length);
          return slice;
        }
        __name(ArrayBufferSlice, "ArrayBufferSlice");
        function IsNonNegativeNumber(v) {
          if (typeof v !== "number") {
            return false;
          }
          if (NumberIsNaN(v)) {
            return false;
          }
          if (v < 0) {
            return false;
          }
          return true;
        }
        __name(IsNonNegativeNumber, "IsNonNegativeNumber");
        function CloneAsUint8Array(O) {
          var buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
          return new Uint8Array(buffer);
        }
        __name(CloneAsUint8Array, "CloneAsUint8Array");
        function DequeueValue(container) {
          var pair = container._queue.shift();
          container._queueTotalSize -= pair.size;
          if (container._queueTotalSize < 0) {
            container._queueTotalSize = 0;
          }
          return pair.value;
        }
        __name(DequeueValue, "DequeueValue");
        function EnqueueValueWithSize(container, value, size) {
          if (!IsNonNegativeNumber(size) || size === Infinity) {
            throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
          }
          container._queue.push({ value, size });
          container._queueTotalSize += size;
        }
        __name(EnqueueValueWithSize, "EnqueueValueWithSize");
        function PeekQueueValue(container) {
          var pair = container._queue.peek();
          return pair.value;
        }
        __name(PeekQueueValue, "PeekQueueValue");
        function ResetQueue(container) {
          container._queue = new SimpleQueue();
          container._queueTotalSize = 0;
        }
        __name(ResetQueue, "ResetQueue");
        var ReadableStreamBYOBRequest = (
          /** @class */
          function() {
            function ReadableStreamBYOBRequest2() {
              throw new TypeError("Illegal constructor");
            }
            __name(ReadableStreamBYOBRequest2, "ReadableStreamBYOBRequest");
            Object.defineProperty(ReadableStreamBYOBRequest2.prototype, "view", {
              /**
               * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.
               */
              get: function() {
                if (!IsReadableStreamBYOBRequest(this)) {
                  throw byobRequestBrandCheckException("view");
                }
                return this._view;
              },
              enumerable: false,
              configurable: true
            });
            ReadableStreamBYOBRequest2.prototype.respond = function(bytesWritten) {
              if (!IsReadableStreamBYOBRequest(this)) {
                throw byobRequestBrandCheckException("respond");
              }
              assertRequiredArgument(bytesWritten, 1, "respond");
              bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
              if (this._associatedReadableByteStreamController === void 0) {
                throw new TypeError("This BYOB request has been invalidated");
              }
              if (IsDetachedBuffer(this._view.buffer))
                ;
              ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
            };
            ReadableStreamBYOBRequest2.prototype.respondWithNewView = function(view) {
              if (!IsReadableStreamBYOBRequest(this)) {
                throw byobRequestBrandCheckException("respondWithNewView");
              }
              assertRequiredArgument(view, 1, "respondWithNewView");
              if (!ArrayBuffer.isView(view)) {
                throw new TypeError("You can only respond with array buffer views");
              }
              if (this._associatedReadableByteStreamController === void 0) {
                throw new TypeError("This BYOB request has been invalidated");
              }
              if (IsDetachedBuffer(view.buffer))
                ;
              ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
            };
            return ReadableStreamBYOBRequest2;
          }()
        );
        Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
          respond: { enumerable: true },
          respondWithNewView: { enumerable: true },
          view: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamBYOBRequest",
            configurable: true
          });
        }
        var ReadableByteStreamController = (
          /** @class */
          function() {
            function ReadableByteStreamController2() {
              throw new TypeError("Illegal constructor");
            }
            __name(ReadableByteStreamController2, "ReadableByteStreamController");
            Object.defineProperty(ReadableByteStreamController2.prototype, "byobRequest", {
              /**
               * Returns the current BYOB pull request, or `null` if there isn't one.
               */
              get: function() {
                if (!IsReadableByteStreamController(this)) {
                  throw byteStreamControllerBrandCheckException("byobRequest");
                }
                return ReadableByteStreamControllerGetBYOBRequest(this);
              },
              enumerable: false,
              configurable: true
            });
            Object.defineProperty(ReadableByteStreamController2.prototype, "desiredSize", {
              /**
               * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
               * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.
               */
              get: function() {
                if (!IsReadableByteStreamController(this)) {
                  throw byteStreamControllerBrandCheckException("desiredSize");
                }
                return ReadableByteStreamControllerGetDesiredSize(this);
              },
              enumerable: false,
              configurable: true
            });
            ReadableByteStreamController2.prototype.close = function() {
              if (!IsReadableByteStreamController(this)) {
                throw byteStreamControllerBrandCheckException("close");
              }
              if (this._closeRequested) {
                throw new TypeError("The stream has already been closed; do not close it again!");
              }
              var state = this._controlledReadableByteStream._state;
              if (state !== "readable") {
                throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be closed");
              }
              ReadableByteStreamControllerClose(this);
            };
            ReadableByteStreamController2.prototype.enqueue = function(chunk) {
              if (!IsReadableByteStreamController(this)) {
                throw byteStreamControllerBrandCheckException("enqueue");
              }
              assertRequiredArgument(chunk, 1, "enqueue");
              if (!ArrayBuffer.isView(chunk)) {
                throw new TypeError("chunk must be an array buffer view");
              }
              if (chunk.byteLength === 0) {
                throw new TypeError("chunk must have non-zero byteLength");
              }
              if (chunk.buffer.byteLength === 0) {
                throw new TypeError("chunk's buffer must have non-zero byteLength");
              }
              if (this._closeRequested) {
                throw new TypeError("stream is closed or draining");
              }
              var state = this._controlledReadableByteStream._state;
              if (state !== "readable") {
                throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be enqueued to");
              }
              ReadableByteStreamControllerEnqueue(this, chunk);
            };
            ReadableByteStreamController2.prototype.error = function(e) {
              if (e === void 0) {
                e = void 0;
              }
              if (!IsReadableByteStreamController(this)) {
                throw byteStreamControllerBrandCheckException("error");
              }
              ReadableByteStreamControllerError(this, e);
            };
            ReadableByteStreamController2.prototype[CancelSteps] = function(reason) {
              ReadableByteStreamControllerClearPendingPullIntos(this);
              ResetQueue(this);
              var result = this._cancelAlgorithm(reason);
              ReadableByteStreamControllerClearAlgorithms(this);
              return result;
            };
            ReadableByteStreamController2.prototype[PullSteps] = function(readRequest) {
              var stream = this._controlledReadableByteStream;
              if (this._queueTotalSize > 0) {
                var entry = this._queue.shift();
                this._queueTotalSize -= entry.byteLength;
                ReadableByteStreamControllerHandleQueueDrain(this);
                var view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
                readRequest._chunkSteps(view);
                return;
              }
              var autoAllocateChunkSize = this._autoAllocateChunkSize;
              if (autoAllocateChunkSize !== void 0) {
                var buffer = void 0;
                try {
                  buffer = new ArrayBuffer(autoAllocateChunkSize);
                } catch (bufferE) {
                  readRequest._errorSteps(bufferE);
                  return;
                }
                var pullIntoDescriptor = {
                  buffer,
                  bufferByteLength: autoAllocateChunkSize,
                  byteOffset: 0,
                  byteLength: autoAllocateChunkSize,
                  bytesFilled: 0,
                  elementSize: 1,
                  viewConstructor: Uint8Array,
                  readerType: "default"
                };
                this._pendingPullIntos.push(pullIntoDescriptor);
              }
              ReadableStreamAddReadRequest(stream, readRequest);
              ReadableByteStreamControllerCallPullIfNeeded(this);
            };
            return ReadableByteStreamController2;
          }()
        );
        Object.defineProperties(ReadableByteStreamController.prototype, {
          close: { enumerable: true },
          enqueue: { enumerable: true },
          error: { enumerable: true },
          byobRequest: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableByteStreamController",
            configurable: true
          });
        }
        function IsReadableByteStreamController(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableByteStream")) {
            return false;
          }
          return x instanceof ReadableByteStreamController;
        }
        __name(IsReadableByteStreamController, "IsReadableByteStreamController");
        function IsReadableStreamBYOBRequest(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_associatedReadableByteStreamController")) {
            return false;
          }
          return x instanceof ReadableStreamBYOBRequest;
        }
        __name(IsReadableStreamBYOBRequest, "IsReadableStreamBYOBRequest");
        function ReadableByteStreamControllerCallPullIfNeeded(controller) {
          var shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
          if (!shouldPull) {
            return;
          }
          if (controller._pulling) {
            controller._pullAgain = true;
            return;
          }
          controller._pulling = true;
          var pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, function() {
            controller._pulling = false;
            if (controller._pullAgain) {
              controller._pullAgain = false;
              ReadableByteStreamControllerCallPullIfNeeded(controller);
            }
          }, function(e) {
            ReadableByteStreamControllerError(controller, e);
          });
        }
        __name(ReadableByteStreamControllerCallPullIfNeeded, "ReadableByteStreamControllerCallPullIfNeeded");
        function ReadableByteStreamControllerClearPendingPullIntos(controller) {
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          controller._pendingPullIntos = new SimpleQueue();
        }
        __name(ReadableByteStreamControllerClearPendingPullIntos, "ReadableByteStreamControllerClearPendingPullIntos");
        function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
          var done = false;
          if (stream._state === "closed") {
            done = true;
          }
          var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
          if (pullIntoDescriptor.readerType === "default") {
            ReadableStreamFulfillReadRequest(stream, filledView, done);
          } else {
            ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
          }
        }
        __name(ReadableByteStreamControllerCommitPullIntoDescriptor, "ReadableByteStreamControllerCommitPullIntoDescriptor");
        function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
          var bytesFilled = pullIntoDescriptor.bytesFilled;
          var elementSize = pullIntoDescriptor.elementSize;
          return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
        }
        __name(ReadableByteStreamControllerConvertPullIntoDescriptor, "ReadableByteStreamControllerConvertPullIntoDescriptor");
        function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
          controller._queue.push({ buffer, byteOffset, byteLength });
          controller._queueTotalSize += byteLength;
        }
        __name(ReadableByteStreamControllerEnqueueChunkToQueue, "ReadableByteStreamControllerEnqueueChunkToQueue");
        function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
          var elementSize = pullIntoDescriptor.elementSize;
          var currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
          var maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
          var maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
          var maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
          var totalBytesToCopyRemaining = maxBytesToCopy;
          var ready = false;
          if (maxAlignedBytes > currentAlignedBytes) {
            totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
            ready = true;
          }
          var queue = controller._queue;
          while (totalBytesToCopyRemaining > 0) {
            var headOfQueue = queue.peek();
            var bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
            var destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
            if (headOfQueue.byteLength === bytesToCopy) {
              queue.shift();
            } else {
              headOfQueue.byteOffset += bytesToCopy;
              headOfQueue.byteLength -= bytesToCopy;
            }
            controller._queueTotalSize -= bytesToCopy;
            ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
            totalBytesToCopyRemaining -= bytesToCopy;
          }
          return ready;
        }
        __name(ReadableByteStreamControllerFillPullIntoDescriptorFromQueue, "ReadableByteStreamControllerFillPullIntoDescriptorFromQueue");
        function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
          pullIntoDescriptor.bytesFilled += size;
        }
        __name(ReadableByteStreamControllerFillHeadPullIntoDescriptor, "ReadableByteStreamControllerFillHeadPullIntoDescriptor");
        function ReadableByteStreamControllerHandleQueueDrain(controller) {
          if (controller._queueTotalSize === 0 && controller._closeRequested) {
            ReadableByteStreamControllerClearAlgorithms(controller);
            ReadableStreamClose(controller._controlledReadableByteStream);
          } else {
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }
        }
        __name(ReadableByteStreamControllerHandleQueueDrain, "ReadableByteStreamControllerHandleQueueDrain");
        function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
          if (controller._byobRequest === null) {
            return;
          }
          controller._byobRequest._associatedReadableByteStreamController = void 0;
          controller._byobRequest._view = null;
          controller._byobRequest = null;
        }
        __name(ReadableByteStreamControllerInvalidateBYOBRequest, "ReadableByteStreamControllerInvalidateBYOBRequest");
        function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
          while (controller._pendingPullIntos.length > 0) {
            if (controller._queueTotalSize === 0) {
              return;
            }
            var pullIntoDescriptor = controller._pendingPullIntos.peek();
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
              ReadableByteStreamControllerShiftPendingPullInto(controller);
              ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
            }
          }
        }
        __name(ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue, "ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue");
        function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
          var stream = controller._controlledReadableByteStream;
          var elementSize = 1;
          if (view.constructor !== DataView) {
            elementSize = view.constructor.BYTES_PER_ELEMENT;
          }
          var ctor = view.constructor;
          var buffer = TransferArrayBuffer(view.buffer);
          var pullIntoDescriptor = {
            buffer,
            bufferByteLength: buffer.byteLength,
            byteOffset: view.byteOffset,
            byteLength: view.byteLength,
            bytesFilled: 0,
            elementSize,
            viewConstructor: ctor,
            readerType: "byob"
          };
          if (controller._pendingPullIntos.length > 0) {
            controller._pendingPullIntos.push(pullIntoDescriptor);
            ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
            return;
          }
          if (stream._state === "closed") {
            var emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
            readIntoRequest._closeSteps(emptyView);
            return;
          }
          if (controller._queueTotalSize > 0) {
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
              var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
              ReadableByteStreamControllerHandleQueueDrain(controller);
              readIntoRequest._chunkSteps(filledView);
              return;
            }
            if (controller._closeRequested) {
              var e = new TypeError("Insufficient bytes to fill elements in the given buffer");
              ReadableByteStreamControllerError(controller, e);
              readIntoRequest._errorSteps(e);
              return;
            }
          }
          controller._pendingPullIntos.push(pullIntoDescriptor);
          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        __name(ReadableByteStreamControllerPullInto, "ReadableByteStreamControllerPullInto");
        function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
          var stream = controller._controlledReadableByteStream;
          if (ReadableStreamHasBYOBReader(stream)) {
            while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
              var pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
              ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
            }
          }
        }
        __name(ReadableByteStreamControllerRespondInClosedState, "ReadableByteStreamControllerRespondInClosedState");
        function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
          ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
          if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
            return;
          }
          ReadableByteStreamControllerShiftPendingPullInto(controller);
          var remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
          if (remainderSize > 0) {
            var end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            var remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
          }
          pullIntoDescriptor.bytesFilled -= remainderSize;
          ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        }
        __name(ReadableByteStreamControllerRespondInReadableState, "ReadableByteStreamControllerRespondInReadableState");
        function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
          var firstDescriptor = controller._pendingPullIntos.peek();
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          var state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            ReadableByteStreamControllerRespondInClosedState(controller);
          } else {
            ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
          }
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        __name(ReadableByteStreamControllerRespondInternal, "ReadableByteStreamControllerRespondInternal");
        function ReadableByteStreamControllerShiftPendingPullInto(controller) {
          var descriptor = controller._pendingPullIntos.shift();
          return descriptor;
        }
        __name(ReadableByteStreamControllerShiftPendingPullInto, "ReadableByteStreamControllerShiftPendingPullInto");
        function ReadableByteStreamControllerShouldCallPull(controller) {
          var stream = controller._controlledReadableByteStream;
          if (stream._state !== "readable") {
            return false;
          }
          if (controller._closeRequested) {
            return false;
          }
          if (!controller._started) {
            return false;
          }
          if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
          }
          if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
            return true;
          }
          var desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
          if (desiredSize > 0) {
            return true;
          }
          return false;
        }
        __name(ReadableByteStreamControllerShouldCallPull, "ReadableByteStreamControllerShouldCallPull");
        function ReadableByteStreamControllerClearAlgorithms(controller) {
          controller._pullAlgorithm = void 0;
          controller._cancelAlgorithm = void 0;
        }
        __name(ReadableByteStreamControllerClearAlgorithms, "ReadableByteStreamControllerClearAlgorithms");
        function ReadableByteStreamControllerClose(controller) {
          var stream = controller._controlledReadableByteStream;
          if (controller._closeRequested || stream._state !== "readable") {
            return;
          }
          if (controller._queueTotalSize > 0) {
            controller._closeRequested = true;
            return;
          }
          if (controller._pendingPullIntos.length > 0) {
            var firstPendingPullInto = controller._pendingPullIntos.peek();
            if (firstPendingPullInto.bytesFilled > 0) {
              var e = new TypeError("Insufficient bytes to fill elements in the given buffer");
              ReadableByteStreamControllerError(controller, e);
              throw e;
            }
          }
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamClose(stream);
        }
        __name(ReadableByteStreamControllerClose, "ReadableByteStreamControllerClose");
        function ReadableByteStreamControllerEnqueue(controller, chunk) {
          var stream = controller._controlledReadableByteStream;
          if (controller._closeRequested || stream._state !== "readable") {
            return;
          }
          var buffer = chunk.buffer;
          var byteOffset = chunk.byteOffset;
          var byteLength = chunk.byteLength;
          var transferredBuffer = TransferArrayBuffer(buffer);
          if (controller._pendingPullIntos.length > 0) {
            var firstPendingPullInto = controller._pendingPullIntos.peek();
            if (IsDetachedBuffer(firstPendingPullInto.buffer))
              ;
            firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
          }
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          if (ReadableStreamHasDefaultReader(stream)) {
            if (ReadableStreamGetNumReadRequests(stream) === 0) {
              ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            } else {
              if (controller._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerShiftPendingPullInto(controller);
              }
              var transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
              ReadableStreamFulfillReadRequest(stream, transferredView, false);
            }
          } else if (ReadableStreamHasBYOBReader(stream)) {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
          } else {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          }
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        __name(ReadableByteStreamControllerEnqueue, "ReadableByteStreamControllerEnqueue");
        function ReadableByteStreamControllerError(controller, e) {
          var stream = controller._controlledReadableByteStream;
          if (stream._state !== "readable") {
            return;
          }
          ReadableByteStreamControllerClearPendingPullIntos(controller);
          ResetQueue(controller);
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamError(stream, e);
        }
        __name(ReadableByteStreamControllerError, "ReadableByteStreamControllerError");
        function ReadableByteStreamControllerGetBYOBRequest(controller) {
          if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
            var firstDescriptor = controller._pendingPullIntos.peek();
            var view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
            var byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
            SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
            controller._byobRequest = byobRequest;
          }
          return controller._byobRequest;
        }
        __name(ReadableByteStreamControllerGetBYOBRequest, "ReadableByteStreamControllerGetBYOBRequest");
        function ReadableByteStreamControllerGetDesiredSize(controller) {
          var state = controller._controlledReadableByteStream._state;
          if (state === "errored") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return controller._strategyHWM - controller._queueTotalSize;
        }
        __name(ReadableByteStreamControllerGetDesiredSize, "ReadableByteStreamControllerGetDesiredSize");
        function ReadableByteStreamControllerRespond(controller, bytesWritten) {
          var firstDescriptor = controller._pendingPullIntos.peek();
          var state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            if (bytesWritten !== 0) {
              throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
            }
          } else {
            if (bytesWritten === 0) {
              throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
            }
            if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
              throw new RangeError("bytesWritten out of range");
            }
          }
          firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
          ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
        }
        __name(ReadableByteStreamControllerRespond, "ReadableByteStreamControllerRespond");
        function ReadableByteStreamControllerRespondWithNewView(controller, view) {
          var firstDescriptor = controller._pendingPullIntos.peek();
          var state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            if (view.byteLength !== 0) {
              throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
            }
          } else {
            if (view.byteLength === 0) {
              throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
            }
          }
          if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
            throw new RangeError("The region specified by view does not match byobRequest");
          }
          if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
            throw new RangeError("The buffer of view has different capacity than byobRequest");
          }
          if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
            throw new RangeError("The region specified by view is larger than byobRequest");
          }
          var viewByteLength = view.byteLength;
          firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
          ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
        }
        __name(ReadableByteStreamControllerRespondWithNewView, "ReadableByteStreamControllerRespondWithNewView");
        function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
          controller._controlledReadableByteStream = stream;
          controller._pullAgain = false;
          controller._pulling = false;
          controller._byobRequest = null;
          controller._queue = controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._closeRequested = false;
          controller._started = false;
          controller._strategyHWM = highWaterMark;
          controller._pullAlgorithm = pullAlgorithm;
          controller._cancelAlgorithm = cancelAlgorithm;
          controller._autoAllocateChunkSize = autoAllocateChunkSize;
          controller._pendingPullIntos = new SimpleQueue();
          stream._readableStreamController = controller;
          var startResult = startAlgorithm();
          uponPromise(promiseResolvedWith(startResult), function() {
            controller._started = true;
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }, function(r) {
            ReadableByteStreamControllerError(controller, r);
          });
        }
        __name(SetUpReadableByteStreamController, "SetUpReadableByteStreamController");
        function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
          var controller = Object.create(ReadableByteStreamController.prototype);
          var startAlgorithm = /* @__PURE__ */ __name(function() {
            return void 0;
          }, "startAlgorithm");
          var pullAlgorithm = /* @__PURE__ */ __name(function() {
            return promiseResolvedWith(void 0);
          }, "pullAlgorithm");
          var cancelAlgorithm = /* @__PURE__ */ __name(function() {
            return promiseResolvedWith(void 0);
          }, "cancelAlgorithm");
          if (underlyingByteSource.start !== void 0) {
            startAlgorithm = /* @__PURE__ */ __name(function() {
              return underlyingByteSource.start(controller);
            }, "startAlgorithm");
          }
          if (underlyingByteSource.pull !== void 0) {
            pullAlgorithm = /* @__PURE__ */ __name(function() {
              return underlyingByteSource.pull(controller);
            }, "pullAlgorithm");
          }
          if (underlyingByteSource.cancel !== void 0) {
            cancelAlgorithm = /* @__PURE__ */ __name(function(reason) {
              return underlyingByteSource.cancel(reason);
            }, "cancelAlgorithm");
          }
          var autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
          if (autoAllocateChunkSize === 0) {
            throw new TypeError("autoAllocateChunkSize must be greater than 0");
          }
          SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
        }
        __name(SetUpReadableByteStreamControllerFromUnderlyingSource, "SetUpReadableByteStreamControllerFromUnderlyingSource");
        function SetUpReadableStreamBYOBRequest(request, controller, view) {
          request._associatedReadableByteStreamController = controller;
          request._view = view;
        }
        __name(SetUpReadableStreamBYOBRequest, "SetUpReadableStreamBYOBRequest");
        function byobRequestBrandCheckException(name) {
          return new TypeError("ReadableStreamBYOBRequest.prototype." + name + " can only be used on a ReadableStreamBYOBRequest");
        }
        __name(byobRequestBrandCheckException, "byobRequestBrandCheckException");
        function byteStreamControllerBrandCheckException(name) {
          return new TypeError("ReadableByteStreamController.prototype." + name + " can only be used on a ReadableByteStreamController");
        }
        __name(byteStreamControllerBrandCheckException, "byteStreamControllerBrandCheckException");
        function AcquireReadableStreamBYOBReader(stream) {
          return new ReadableStreamBYOBReader(stream);
        }
        __name(AcquireReadableStreamBYOBReader, "AcquireReadableStreamBYOBReader");
        function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
          stream._reader._readIntoRequests.push(readIntoRequest);
        }
        __name(ReadableStreamAddReadIntoRequest, "ReadableStreamAddReadIntoRequest");
        function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
          var reader = stream._reader;
          var readIntoRequest = reader._readIntoRequests.shift();
          if (done) {
            readIntoRequest._closeSteps(chunk);
          } else {
            readIntoRequest._chunkSteps(chunk);
          }
        }
        __name(ReadableStreamFulfillReadIntoRequest, "ReadableStreamFulfillReadIntoRequest");
        function ReadableStreamGetNumReadIntoRequests(stream) {
          return stream._reader._readIntoRequests.length;
        }
        __name(ReadableStreamGetNumReadIntoRequests, "ReadableStreamGetNumReadIntoRequests");
        function ReadableStreamHasBYOBReader(stream) {
          var reader = stream._reader;
          if (reader === void 0) {
            return false;
          }
          if (!IsReadableStreamBYOBReader(reader)) {
            return false;
          }
          return true;
        }
        __name(ReadableStreamHasBYOBReader, "ReadableStreamHasBYOBReader");
        var ReadableStreamBYOBReader = (
          /** @class */
          function() {
            function ReadableStreamBYOBReader2(stream) {
              assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
              assertReadableStream(stream, "First parameter");
              if (IsReadableStreamLocked(stream)) {
                throw new TypeError("This stream has already been locked for exclusive reading by another reader");
              }
              if (!IsReadableByteStreamController(stream._readableStreamController)) {
                throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
              }
              ReadableStreamReaderGenericInitialize(this, stream);
              this._readIntoRequests = new SimpleQueue();
            }
            __name(ReadableStreamBYOBReader2, "ReadableStreamBYOBReader");
            Object.defineProperty(ReadableStreamBYOBReader2.prototype, "closed", {
              /**
               * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
               * the reader's lock is released before the stream finishes closing.
               */
              get: function() {
                if (!IsReadableStreamBYOBReader(this)) {
                  return promiseRejectedWith(byobReaderBrandCheckException("closed"));
                }
                return this._closedPromise;
              },
              enumerable: false,
              configurable: true
            });
            ReadableStreamBYOBReader2.prototype.cancel = function(reason) {
              if (reason === void 0) {
                reason = void 0;
              }
              if (!IsReadableStreamBYOBReader(this)) {
                return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
              }
              if (this._ownerReadableStream === void 0) {
                return promiseRejectedWith(readerLockException("cancel"));
              }
              return ReadableStreamReaderGenericCancel(this, reason);
            };
            ReadableStreamBYOBReader2.prototype.read = function(view) {
              if (!IsReadableStreamBYOBReader(this)) {
                return promiseRejectedWith(byobReaderBrandCheckException("read"));
              }
              if (!ArrayBuffer.isView(view)) {
                return promiseRejectedWith(new TypeError("view must be an array buffer view"));
              }
              if (view.byteLength === 0) {
                return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
              }
              if (view.buffer.byteLength === 0) {
                return promiseRejectedWith(new TypeError("view's buffer must have non-zero byteLength"));
              }
              if (IsDetachedBuffer(view.buffer))
                ;
              if (this._ownerReadableStream === void 0) {
                return promiseRejectedWith(readerLockException("read from"));
              }
              var resolvePromise;
              var rejectPromise;
              var promise = newPromise(function(resolve, reject) {
                resolvePromise = resolve;
                rejectPromise = reject;
              });
              var readIntoRequest = {
                _chunkSteps: function(chunk) {
                  return resolvePromise({ value: chunk, done: false });
                },
                _closeSteps: function(chunk) {
                  return resolvePromise({ value: chunk, done: true });
                },
                _errorSteps: function(e) {
                  return rejectPromise(e);
                }
              };
              ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
              return promise;
            };
            ReadableStreamBYOBReader2.prototype.releaseLock = function() {
              if (!IsReadableStreamBYOBReader(this)) {
                throw byobReaderBrandCheckException("releaseLock");
              }
              if (this._ownerReadableStream === void 0) {
                return;
              }
              if (this._readIntoRequests.length > 0) {
                throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
              }
              ReadableStreamReaderGenericRelease(this);
            };
            return ReadableStreamBYOBReader2;
          }()
        );
        Object.defineProperties(ReadableStreamBYOBReader.prototype, {
          cancel: { enumerable: true },
          read: { enumerable: true },
          releaseLock: { enumerable: true },
          closed: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamBYOBReader",
            configurable: true
          });
        }
        function IsReadableStreamBYOBReader(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_readIntoRequests")) {
            return false;
          }
          return x instanceof ReadableStreamBYOBReader;
        }
        __name(IsReadableStreamBYOBReader, "IsReadableStreamBYOBReader");
        function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
          var stream = reader._ownerReadableStream;
          stream._disturbed = true;
          if (stream._state === "errored") {
            readIntoRequest._errorSteps(stream._storedError);
          } else {
            ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
          }
        }
        __name(ReadableStreamBYOBReaderRead, "ReadableStreamBYOBReaderRead");
        function byobReaderBrandCheckException(name) {
          return new TypeError("ReadableStreamBYOBReader.prototype." + name + " can only be used on a ReadableStreamBYOBReader");
        }
        __name(byobReaderBrandCheckException, "byobReaderBrandCheckException");
        function ExtractHighWaterMark(strategy, defaultHWM) {
          var highWaterMark = strategy.highWaterMark;
          if (highWaterMark === void 0) {
            return defaultHWM;
          }
          if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
            throw new RangeError("Invalid highWaterMark");
          }
          return highWaterMark;
        }
        __name(ExtractHighWaterMark, "ExtractHighWaterMark");
        function ExtractSizeAlgorithm(strategy) {
          var size = strategy.size;
          if (!size) {
            return function() {
              return 1;
            };
          }
          return size;
        }
        __name(ExtractSizeAlgorithm, "ExtractSizeAlgorithm");
        function convertQueuingStrategy(init, context) {
          assertDictionary(init, context);
          var highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
          var size = init === null || init === void 0 ? void 0 : init.size;
          return {
            highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
            size: size === void 0 ? void 0 : convertQueuingStrategySize(size, context + " has member 'size' that")
          };
        }
        __name(convertQueuingStrategy, "convertQueuingStrategy");
        function convertQueuingStrategySize(fn, context) {
          assertFunction(fn, context);
          return function(chunk) {
            return convertUnrestrictedDouble(fn(chunk));
          };
        }
        __name(convertQueuingStrategySize, "convertQueuingStrategySize");
        function convertUnderlyingSink(original, context) {
          assertDictionary(original, context);
          var abort = original === null || original === void 0 ? void 0 : original.abort;
          var close = original === null || original === void 0 ? void 0 : original.close;
          var start = original === null || original === void 0 ? void 0 : original.start;
          var type = original === null || original === void 0 ? void 0 : original.type;
          var write = original === null || original === void 0 ? void 0 : original.write;
          return {
            abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, context + " has member 'abort' that"),
            close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, context + " has member 'close' that"),
            start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, context + " has member 'start' that"),
            write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, context + " has member 'write' that"),
            type
          };
        }
        __name(convertUnderlyingSink, "convertUnderlyingSink");
        function convertUnderlyingSinkAbortCallback(fn, original, context) {
          assertFunction(fn, context);
          return function(reason) {
            return promiseCall(fn, original, [reason]);
          };
        }
        __name(convertUnderlyingSinkAbortCallback, "convertUnderlyingSinkAbortCallback");
        function convertUnderlyingSinkCloseCallback(fn, original, context) {
          assertFunction(fn, context);
          return function() {
            return promiseCall(fn, original, []);
          };
        }
        __name(convertUnderlyingSinkCloseCallback, "convertUnderlyingSinkCloseCallback");
        function convertUnderlyingSinkStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return function(controller) {
            return reflectCall(fn, original, [controller]);
          };
        }
        __name(convertUnderlyingSinkStartCallback, "convertUnderlyingSinkStartCallback");
        function convertUnderlyingSinkWriteCallback(fn, original, context) {
          assertFunction(fn, context);
          return function(chunk, controller) {
            return promiseCall(fn, original, [chunk, controller]);
          };
        }
        __name(convertUnderlyingSinkWriteCallback, "convertUnderlyingSinkWriteCallback");
        function assertWritableStream(x, context) {
          if (!IsWritableStream(x)) {
            throw new TypeError(context + " is not a WritableStream.");
          }
        }
        __name(assertWritableStream, "assertWritableStream");
        function isAbortSignal(value) {
          if (typeof value !== "object" || value === null) {
            return false;
          }
          try {
            return typeof value.aborted === "boolean";
          } catch (_a2) {
            return false;
          }
        }
        __name(isAbortSignal, "isAbortSignal");
        var supportsAbortController = typeof AbortController === "function";
        function createAbortController() {
          if (supportsAbortController) {
            return new AbortController();
          }
          return void 0;
        }
        __name(createAbortController, "createAbortController");
        var WritableStream = (
          /** @class */
          function() {
            function WritableStream2(rawUnderlyingSink, rawStrategy) {
              if (rawUnderlyingSink === void 0) {
                rawUnderlyingSink = {};
              }
              if (rawStrategy === void 0) {
                rawStrategy = {};
              }
              if (rawUnderlyingSink === void 0) {
                rawUnderlyingSink = null;
              } else {
                assertObject(rawUnderlyingSink, "First parameter");
              }
              var strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
              var underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
              InitializeWritableStream(this);
              var type = underlyingSink.type;
              if (type !== void 0) {
                throw new RangeError("Invalid type is specified");
              }
              var sizeAlgorithm = ExtractSizeAlgorithm(strategy);
              var highWaterMark = ExtractHighWaterMark(strategy, 1);
              SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
            }
            __name(WritableStream2, "WritableStream");
            Object.defineProperty(WritableStream2.prototype, "locked", {
              /**
               * Returns whether or not the writable stream is locked to a writer.
               */
              get: function() {
                if (!IsWritableStream(this)) {
                  throw streamBrandCheckException$2("locked");
                }
                return IsWritableStreamLocked(this);
              },
              enumerable: false,
              configurable: true
            });
            WritableStream2.prototype.abort = function(reason) {
              if (reason === void 0) {
                reason = void 0;
              }
              if (!IsWritableStream(this)) {
                return promiseRejectedWith(streamBrandCheckException$2("abort"));
              }
              if (IsWritableStreamLocked(this)) {
                return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
              }
              return WritableStreamAbort(this, reason);
            };
            WritableStream2.prototype.close = function() {
              if (!IsWritableStream(this)) {
                return promiseRejectedWith(streamBrandCheckException$2("close"));
              }
              if (IsWritableStreamLocked(this)) {
                return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
              }
              if (WritableStreamCloseQueuedOrInFlight(this)) {
                return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
              }
              return WritableStreamClose(this);
            };
            WritableStream2.prototype.getWriter = function() {
              if (!IsWritableStream(this)) {
                throw streamBrandCheckException$2("getWriter");
              }
              return AcquireWritableStreamDefaultWriter(this);
            };
            return WritableStream2;
          }()
        );
        Object.defineProperties(WritableStream.prototype, {
          abort: { enumerable: true },
          close: { enumerable: true },
          getWriter: { enumerable: true },
          locked: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStream",
            configurable: true
          });
        }
        function AcquireWritableStreamDefaultWriter(stream) {
          return new WritableStreamDefaultWriter(stream);
        }
        __name(AcquireWritableStreamDefaultWriter, "AcquireWritableStreamDefaultWriter");
        function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
          if (highWaterMark === void 0) {
            highWaterMark = 1;
          }
          if (sizeAlgorithm === void 0) {
            sizeAlgorithm = /* @__PURE__ */ __name(function() {
              return 1;
            }, "sizeAlgorithm");
          }
          var stream = Object.create(WritableStream.prototype);
          InitializeWritableStream(stream);
          var controller = Object.create(WritableStreamDefaultController.prototype);
          SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
          return stream;
        }
        __name(CreateWritableStream, "CreateWritableStream");
        function InitializeWritableStream(stream) {
          stream._state = "writable";
          stream._storedError = void 0;
          stream._writer = void 0;
          stream._writableStreamController = void 0;
          stream._writeRequests = new SimpleQueue();
          stream._inFlightWriteRequest = void 0;
          stream._closeRequest = void 0;
          stream._inFlightCloseRequest = void 0;
          stream._pendingAbortRequest = void 0;
          stream._backpressure = false;
        }
        __name(InitializeWritableStream, "InitializeWritableStream");
        function IsWritableStream(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_writableStreamController")) {
            return false;
          }
          return x instanceof WritableStream;
        }
        __name(IsWritableStream, "IsWritableStream");
        function IsWritableStreamLocked(stream) {
          if (stream._writer === void 0) {
            return false;
          }
          return true;
        }
        __name(IsWritableStreamLocked, "IsWritableStreamLocked");
        function WritableStreamAbort(stream, reason) {
          var _a2;
          if (stream._state === "closed" || stream._state === "errored") {
            return promiseResolvedWith(void 0);
          }
          stream._writableStreamController._abortReason = reason;
          (_a2 = stream._writableStreamController._abortController) === null || _a2 === void 0 ? void 0 : _a2.abort();
          var state = stream._state;
          if (state === "closed" || state === "errored") {
            return promiseResolvedWith(void 0);
          }
          if (stream._pendingAbortRequest !== void 0) {
            return stream._pendingAbortRequest._promise;
          }
          var wasAlreadyErroring = false;
          if (state === "erroring") {
            wasAlreadyErroring = true;
            reason = void 0;
          }
          var promise = newPromise(function(resolve, reject) {
            stream._pendingAbortRequest = {
              _promise: void 0,
              _resolve: resolve,
              _reject: reject,
              _reason: reason,
              _wasAlreadyErroring: wasAlreadyErroring
            };
          });
          stream._pendingAbortRequest._promise = promise;
          if (!wasAlreadyErroring) {
            WritableStreamStartErroring(stream, reason);
          }
          return promise;
        }
        __name(WritableStreamAbort, "WritableStreamAbort");
        function WritableStreamClose(stream) {
          var state = stream._state;
          if (state === "closed" || state === "errored") {
            return promiseRejectedWith(new TypeError("The stream (in " + state + " state) is not in the writable state and cannot be closed"));
          }
          var promise = newPromise(function(resolve, reject) {
            var closeRequest = {
              _resolve: resolve,
              _reject: reject
            };
            stream._closeRequest = closeRequest;
          });
          var writer = stream._writer;
          if (writer !== void 0 && stream._backpressure && state === "writable") {
            defaultWriterReadyPromiseResolve(writer);
          }
          WritableStreamDefaultControllerClose(stream._writableStreamController);
          return promise;
        }
        __name(WritableStreamClose, "WritableStreamClose");
        function WritableStreamAddWriteRequest(stream) {
          var promise = newPromise(function(resolve, reject) {
            var writeRequest = {
              _resolve: resolve,
              _reject: reject
            };
            stream._writeRequests.push(writeRequest);
          });
          return promise;
        }
        __name(WritableStreamAddWriteRequest, "WritableStreamAddWriteRequest");
        function WritableStreamDealWithRejection(stream, error) {
          var state = stream._state;
          if (state === "writable") {
            WritableStreamStartErroring(stream, error);
            return;
          }
          WritableStreamFinishErroring(stream);
        }
        __name(WritableStreamDealWithRejection, "WritableStreamDealWithRejection");
        function WritableStreamStartErroring(stream, reason) {
          var controller = stream._writableStreamController;
          stream._state = "erroring";
          stream._storedError = reason;
          var writer = stream._writer;
          if (writer !== void 0) {
            WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
          }
          if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
            WritableStreamFinishErroring(stream);
          }
        }
        __name(WritableStreamStartErroring, "WritableStreamStartErroring");
        function WritableStreamFinishErroring(stream) {
          stream._state = "errored";
          stream._writableStreamController[ErrorSteps]();
          var storedError = stream._storedError;
          stream._writeRequests.forEach(function(writeRequest) {
            writeRequest._reject(storedError);
          });
          stream._writeRequests = new SimpleQueue();
          if (stream._pendingAbortRequest === void 0) {
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
          }
          var abortRequest = stream._pendingAbortRequest;
          stream._pendingAbortRequest = void 0;
          if (abortRequest._wasAlreadyErroring) {
            abortRequest._reject(storedError);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
          }
          var promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
          uponPromise(promise, function() {
            abortRequest._resolve();
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          }, function(reason) {
            abortRequest._reject(reason);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          });
        }
        __name(WritableStreamFinishErroring, "WritableStreamFinishErroring");
        function WritableStreamFinishInFlightWrite(stream) {
          stream._inFlightWriteRequest._resolve(void 0);
          stream._inFlightWriteRequest = void 0;
        }
        __name(WritableStreamFinishInFlightWrite, "WritableStreamFinishInFlightWrite");
        function WritableStreamFinishInFlightWriteWithError(stream, error) {
          stream._inFlightWriteRequest._reject(error);
          stream._inFlightWriteRequest = void 0;
          WritableStreamDealWithRejection(stream, error);
        }
        __name(WritableStreamFinishInFlightWriteWithError, "WritableStreamFinishInFlightWriteWithError");
        function WritableStreamFinishInFlightClose(stream) {
          stream._inFlightCloseRequest._resolve(void 0);
          stream._inFlightCloseRequest = void 0;
          var state = stream._state;
          if (state === "erroring") {
            stream._storedError = void 0;
            if (stream._pendingAbortRequest !== void 0) {
              stream._pendingAbortRequest._resolve();
              stream._pendingAbortRequest = void 0;
            }
          }
          stream._state = "closed";
          var writer = stream._writer;
          if (writer !== void 0) {
            defaultWriterClosedPromiseResolve(writer);
          }
        }
        __name(WritableStreamFinishInFlightClose, "WritableStreamFinishInFlightClose");
        function WritableStreamFinishInFlightCloseWithError(stream, error) {
          stream._inFlightCloseRequest._reject(error);
          stream._inFlightCloseRequest = void 0;
          if (stream._pendingAbortRequest !== void 0) {
            stream._pendingAbortRequest._reject(error);
            stream._pendingAbortRequest = void 0;
          }
          WritableStreamDealWithRejection(stream, error);
        }
        __name(WritableStreamFinishInFlightCloseWithError, "WritableStreamFinishInFlightCloseWithError");
        function WritableStreamCloseQueuedOrInFlight(stream) {
          if (stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0) {
            return false;
          }
          return true;
        }
        __name(WritableStreamCloseQueuedOrInFlight, "WritableStreamCloseQueuedOrInFlight");
        function WritableStreamHasOperationMarkedInFlight(stream) {
          if (stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0) {
            return false;
          }
          return true;
        }
        __name(WritableStreamHasOperationMarkedInFlight, "WritableStreamHasOperationMarkedInFlight");
        function WritableStreamMarkCloseRequestInFlight(stream) {
          stream._inFlightCloseRequest = stream._closeRequest;
          stream._closeRequest = void 0;
        }
        __name(WritableStreamMarkCloseRequestInFlight, "WritableStreamMarkCloseRequestInFlight");
        function WritableStreamMarkFirstWriteRequestInFlight(stream) {
          stream._inFlightWriteRequest = stream._writeRequests.shift();
        }
        __name(WritableStreamMarkFirstWriteRequestInFlight, "WritableStreamMarkFirstWriteRequestInFlight");
        function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
          if (stream._closeRequest !== void 0) {
            stream._closeRequest._reject(stream._storedError);
            stream._closeRequest = void 0;
          }
          var writer = stream._writer;
          if (writer !== void 0) {
            defaultWriterClosedPromiseReject(writer, stream._storedError);
          }
        }
        __name(WritableStreamRejectCloseAndClosedPromiseIfNeeded, "WritableStreamRejectCloseAndClosedPromiseIfNeeded");
        function WritableStreamUpdateBackpressure(stream, backpressure) {
          var writer = stream._writer;
          if (writer !== void 0 && backpressure !== stream._backpressure) {
            if (backpressure) {
              defaultWriterReadyPromiseReset(writer);
            } else {
              defaultWriterReadyPromiseResolve(writer);
            }
          }
          stream._backpressure = backpressure;
        }
        __name(WritableStreamUpdateBackpressure, "WritableStreamUpdateBackpressure");
        var WritableStreamDefaultWriter = (
          /** @class */
          function() {
            function WritableStreamDefaultWriter2(stream) {
              assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
              assertWritableStream(stream, "First parameter");
              if (IsWritableStreamLocked(stream)) {
                throw new TypeError("This stream has already been locked for exclusive writing by another writer");
              }
              this._ownerWritableStream = stream;
              stream._writer = this;
              var state = stream._state;
              if (state === "writable") {
                if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
                  defaultWriterReadyPromiseInitialize(this);
                } else {
                  defaultWriterReadyPromiseInitializeAsResolved(this);
                }
                defaultWriterClosedPromiseInitialize(this);
              } else if (state === "erroring") {
                defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
                defaultWriterClosedPromiseInitialize(this);
              } else if (state === "closed") {
                defaultWriterReadyPromiseInitializeAsResolved(this);
                defaultWriterClosedPromiseInitializeAsResolved(this);
              } else {
                var storedError = stream._storedError;
                defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
                defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
              }
            }
            __name(WritableStreamDefaultWriter2, "WritableStreamDefaultWriter");
            Object.defineProperty(WritableStreamDefaultWriter2.prototype, "closed", {
              /**
               * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
               * the writerâs lock is released before the stream finishes closing.
               */
              get: function() {
                if (!IsWritableStreamDefaultWriter(this)) {
                  return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
                }
                return this._closedPromise;
              },
              enumerable: false,
              configurable: true
            });
            Object.defineProperty(WritableStreamDefaultWriter2.prototype, "desiredSize", {
              /**
               * Returns the desired size to fill the streamâs internal queue. It can be negative, if the queue is over-full.
               * A producer can use this information to determine the right amount of data to write.
               *
               * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort
               * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when
               * the writerâs lock is released.
               */
              get: function() {
                if (!IsWritableStreamDefaultWriter(this)) {
                  throw defaultWriterBrandCheckException("desiredSize");
                }
                if (this._ownerWritableStream === void 0) {
                  throw defaultWriterLockException("desiredSize");
                }
                return WritableStreamDefaultWriterGetDesiredSize(this);
              },
              enumerable: false,
              configurable: true
            });
            Object.defineProperty(WritableStreamDefaultWriter2.prototype, "ready", {
              /**
               * Returns a promise that will be fulfilled when the desired size to fill the streamâs internal queue transitions
               * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips
               * back to zero or below, the getter will return a new promise that stays pending until the next transition.
               *
               * If the stream becomes errored or aborted, or the writerâs lock is released, the returned promise will become
               * rejected.
               */
              get: function() {
                if (!IsWritableStreamDefaultWriter(this)) {
                  return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
                }
                return this._readyPromise;
              },
              enumerable: false,
              configurable: true
            });
            WritableStreamDefaultWriter2.prototype.abort = function(reason) {
              if (reason === void 0) {
                reason = void 0;
              }
              if (!IsWritableStreamDefaultWriter(this)) {
                return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
              }
              if (this._ownerWritableStream === void 0) {
                return promiseRejectedWith(defaultWriterLockException("abort"));
              }
              return WritableStreamDefaultWriterAbort(this, reason);
            };
            WritableStreamDefaultWriter2.prototype.close = function() {
              if (!IsWritableStreamDefaultWriter(this)) {
                return promiseRejectedWith(defaultWriterBrandCheckException("close"));
              }
              var stream = this._ownerWritableStream;
              if (stream === void 0) {
                return promiseRejectedWith(defaultWriterLockException("close"));
              }
              if (WritableStreamCloseQueuedOrInFlight(stream)) {
                return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
              }
              return WritableStreamDefaultWriterClose(this);
            };
            WritableStreamDefaultWriter2.prototype.releaseLock = function() {
              if (!IsWritableStreamDefaultWriter(this)) {
                throw defaultWriterBrandCheckException("releaseLock");
              }
              var stream = this._ownerWritableStream;
              if (stream === void 0) {
                return;
              }
              WritableStreamDefaultWriterRelease(this);
            };
            WritableStreamDefaultWriter2.prototype.write = function(chunk) {
              if (chunk === void 0) {
                chunk = void 0;
              }
              if (!IsWritableStreamDefaultWriter(this)) {
                return promiseRejectedWith(defaultWriterBrandCheckException("write"));
              }
              if (this._ownerWritableStream === void 0) {
                return promiseRejectedWith(defaultWriterLockException("write to"));
              }
              return WritableStreamDefaultWriterWrite(this, chunk);
            };
            return WritableStreamDefaultWriter2;
          }()
        );
        Object.defineProperties(WritableStreamDefaultWriter.prototype, {
          abort: { enumerable: true },
          close: { enumerable: true },
          releaseLock: { enumerable: true },
          write: { enumerable: true },
          closed: { enumerable: true },
          desiredSize: { enumerable: true },
          ready: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStreamDefaultWriter",
            configurable: true
          });
        }
        function IsWritableStreamDefaultWriter(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_ownerWritableStream")) {
            return false;
          }
          return x instanceof WritableStreamDefaultWriter;
        }
        __name(IsWritableStreamDefaultWriter, "IsWritableStreamDefaultWriter");
        function WritableStreamDefaultWriterAbort(writer, reason) {
          var stream = writer._ownerWritableStream;
          return WritableStreamAbort(stream, reason);
        }
        __name(WritableStreamDefaultWriterAbort, "WritableStreamDefaultWriterAbort");
        function WritableStreamDefaultWriterClose(writer) {
          var stream = writer._ownerWritableStream;
          return WritableStreamClose(stream);
        }
        __name(WritableStreamDefaultWriterClose, "WritableStreamDefaultWriterClose");
        function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
          var stream = writer._ownerWritableStream;
          var state = stream._state;
          if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
            return promiseResolvedWith(void 0);
          }
          if (state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          return WritableStreamDefaultWriterClose(writer);
        }
        __name(WritableStreamDefaultWriterCloseWithErrorPropagation, "WritableStreamDefaultWriterCloseWithErrorPropagation");
        function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
          if (writer._closedPromiseState === "pending") {
            defaultWriterClosedPromiseReject(writer, error);
          } else {
            defaultWriterClosedPromiseResetToRejected(writer, error);
          }
        }
        __name(WritableStreamDefaultWriterEnsureClosedPromiseRejected, "WritableStreamDefaultWriterEnsureClosedPromiseRejected");
        function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
          if (writer._readyPromiseState === "pending") {
            defaultWriterReadyPromiseReject(writer, error);
          } else {
            defaultWriterReadyPromiseResetToRejected(writer, error);
          }
        }
        __name(WritableStreamDefaultWriterEnsureReadyPromiseRejected, "WritableStreamDefaultWriterEnsureReadyPromiseRejected");
        function WritableStreamDefaultWriterGetDesiredSize(writer) {
          var stream = writer._ownerWritableStream;
          var state = stream._state;
          if (state === "errored" || state === "erroring") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
        }
        __name(WritableStreamDefaultWriterGetDesiredSize, "WritableStreamDefaultWriterGetDesiredSize");
        function WritableStreamDefaultWriterRelease(writer) {
          var stream = writer._ownerWritableStream;
          var releasedError = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
          WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
          WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
          stream._writer = void 0;
          writer._ownerWritableStream = void 0;
        }
        __name(WritableStreamDefaultWriterRelease, "WritableStreamDefaultWriterRelease");
        function WritableStreamDefaultWriterWrite(writer, chunk) {
          var stream = writer._ownerWritableStream;
          var controller = stream._writableStreamController;
          var chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
          if (stream !== writer._ownerWritableStream) {
            return promiseRejectedWith(defaultWriterLockException("write to"));
          }
          var state = stream._state;
          if (state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
            return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
          }
          if (state === "erroring") {
            return promiseRejectedWith(stream._storedError);
          }
          var promise = WritableStreamAddWriteRequest(stream);
          WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
          return promise;
        }
        __name(WritableStreamDefaultWriterWrite, "WritableStreamDefaultWriterWrite");
        var closeSentinel = {};
        var WritableStreamDefaultController = (
          /** @class */
          function() {
            function WritableStreamDefaultController2() {
              throw new TypeError("Illegal constructor");
            }
            __name(WritableStreamDefaultController2, "WritableStreamDefaultController");
            Object.defineProperty(WritableStreamDefaultController2.prototype, "abortReason", {
              /**
               * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.
               *
               * @deprecated
               *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.
               *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.
               */
              get: function() {
                if (!IsWritableStreamDefaultController(this)) {
                  throw defaultControllerBrandCheckException$2("abortReason");
                }
                return this._abortReason;
              },
              enumerable: false,
              configurable: true
            });
            Object.defineProperty(WritableStreamDefaultController2.prototype, "signal", {
              /**
               * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.
               */
              get: function() {
                if (!IsWritableStreamDefaultController(this)) {
                  throw defaultControllerBrandCheckException$2("signal");
                }
                if (this._abortController === void 0) {
                  throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
                }
                return this._abortController.signal;
              },
              enumerable: false,
              configurable: true
            });
            WritableStreamDefaultController2.prototype.error = function(e) {
              if (e === void 0) {
                e = void 0;
              }
              if (!IsWritableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$2("error");
              }
              var state = this._controlledWritableStream._state;
              if (state !== "writable") {
                return;
              }
              WritableStreamDefaultControllerError(this, e);
            };
            WritableStreamDefaultController2.prototype[AbortSteps] = function(reason) {
              var result = this._abortAlgorithm(reason);
              WritableStreamDefaultControllerClearAlgorithms(this);
              return result;
            };
            WritableStreamDefaultController2.prototype[ErrorSteps] = function() {
              ResetQueue(this);
            };
            return WritableStreamDefaultController2;
          }()
        );
        Object.defineProperties(WritableStreamDefaultController.prototype, {
          abortReason: { enumerable: true },
          signal: { enumerable: true },
          error: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStreamDefaultController",
            configurable: true
          });
        }
        function IsWritableStreamDefaultController(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_controlledWritableStream")) {
            return false;
          }
          return x instanceof WritableStreamDefaultController;
        }
        __name(IsWritableStreamDefaultController, "IsWritableStreamDefaultController");
        function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
          controller._controlledWritableStream = stream;
          stream._writableStreamController = controller;
          controller._queue = void 0;
          controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._abortReason = void 0;
          controller._abortController = createAbortController();
          controller._started = false;
          controller._strategySizeAlgorithm = sizeAlgorithm;
          controller._strategyHWM = highWaterMark;
          controller._writeAlgorithm = writeAlgorithm;
          controller._closeAlgorithm = closeAlgorithm;
          controller._abortAlgorithm = abortAlgorithm;
          var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
          var startResult = startAlgorithm();
          var startPromise = promiseResolvedWith(startResult);
          uponPromise(startPromise, function() {
            controller._started = true;
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          }, function(r) {
            controller._started = true;
            WritableStreamDealWithRejection(stream, r);
          });
        }
        __name(SetUpWritableStreamDefaultController, "SetUpWritableStreamDefaultController");
        function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
          var controller = Object.create(WritableStreamDefaultController.prototype);
          var startAlgorithm = /* @__PURE__ */ __name(function() {
            return void 0;
          }, "startAlgorithm");
          var writeAlgorithm = /* @__PURE__ */ __name(function() {
            return promiseResolvedWith(void 0);
          }, "writeAlgorithm");
          var closeAlgorithm = /* @__PURE__ */ __name(function() {
            return promiseResolvedWith(void 0);
          }, "closeAlgorithm");
          var abortAlgorithm = /* @__PURE__ */ __name(function() {
            return promiseResolvedWith(void 0);
          }, "abortAlgorithm");
          if (underlyingSink.start !== void 0) {
            startAlgorithm = /* @__PURE__ */ __name(function() {
              return underlyingSink.start(controller);
            }, "startAlgorithm");
          }
          if (underlyingSink.write !== void 0) {
            writeAlgorithm = /* @__PURE__ */ __name(function(chunk) {
              return underlyingSink.write(chunk, controller);
            }, "writeAlgorithm");
          }
          if (underlyingSink.close !== void 0) {
            closeAlgorithm = /* @__PURE__ */ __name(function() {
              return underlyingSink.close();
            }, "closeAlgorithm");
          }
          if (underlyingSink.abort !== void 0) {
            abortAlgorithm = /* @__PURE__ */ __name(function(reason) {
              return underlyingSink.abort(reason);
            }, "abortAlgorithm");
          }
          SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
        }
        __name(SetUpWritableStreamDefaultControllerFromUnderlyingSink, "SetUpWritableStreamDefaultControllerFromUnderlyingSink");
        function WritableStreamDefaultControllerClearAlgorithms(controller) {
          controller._writeAlgorithm = void 0;
          controller._closeAlgorithm = void 0;
          controller._abortAlgorithm = void 0;
          controller._strategySizeAlgorithm = void 0;
        }
        __name(WritableStreamDefaultControllerClearAlgorithms, "WritableStreamDefaultControllerClearAlgorithms");
        function WritableStreamDefaultControllerClose(controller) {
          EnqueueValueWithSize(controller, closeSentinel, 0);
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }
        __name(WritableStreamDefaultControllerClose, "WritableStreamDefaultControllerClose");
        function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
          try {
            return controller._strategySizeAlgorithm(chunk);
          } catch (chunkSizeE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
            return 1;
          }
        }
        __name(WritableStreamDefaultControllerGetChunkSize, "WritableStreamDefaultControllerGetChunkSize");
        function WritableStreamDefaultControllerGetDesiredSize(controller) {
          return controller._strategyHWM - controller._queueTotalSize;
        }
        __name(WritableStreamDefaultControllerGetDesiredSize, "WritableStreamDefaultControllerGetDesiredSize");
        function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
          try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
          } catch (enqueueE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
            return;
          }
          var stream = controller._controlledWritableStream;
          if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
            var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
          }
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }
        __name(WritableStreamDefaultControllerWrite, "WritableStreamDefaultControllerWrite");
        function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
          var stream = controller._controlledWritableStream;
          if (!controller._started) {
            return;
          }
          if (stream._inFlightWriteRequest !== void 0) {
            return;
          }
          var state = stream._state;
          if (state === "erroring") {
            WritableStreamFinishErroring(stream);
            return;
          }
          if (controller._queue.length === 0) {
            return;
          }
          var value = PeekQueueValue(controller);
          if (value === closeSentinel) {
            WritableStreamDefaultControllerProcessClose(controller);
          } else {
            WritableStreamDefaultControllerProcessWrite(controller, value);
          }
        }
        __name(WritableStreamDefaultControllerAdvanceQueueIfNeeded, "WritableStreamDefaultControllerAdvanceQueueIfNeeded");
        function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
          if (controller._controlledWritableStream._state === "writable") {
            WritableStreamDefaultControllerError(controller, error);
          }
        }
        __name(WritableStreamDefaultControllerErrorIfNeeded, "WritableStreamDefaultControllerErrorIfNeeded");
        function WritableStreamDefaultControllerProcessClose(controller) {
          var stream = controller._controlledWritableStream;
          WritableStreamMarkCloseRequestInFlight(stream);
          DequeueValue(controller);
          var sinkClosePromise = controller._closeAlgorithm();
          WritableStreamDefaultControllerClearAlgorithms(controller);
          uponPromise(sinkClosePromise, function() {
            WritableStreamFinishInFlightClose(stream);
          }, function(reason) {
            WritableStreamFinishInFlightCloseWithError(stream, reason);
          });
        }
        __name(WritableStreamDefaultControllerProcessClose, "WritableStreamDefaultControllerProcessClose");
        function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
          var stream = controller._controlledWritableStream;
          WritableStreamMarkFirstWriteRequestInFlight(stream);
          var sinkWritePromise = controller._writeAlgorithm(chunk);
          uponPromise(sinkWritePromise, function() {
            WritableStreamFinishInFlightWrite(stream);
            var state = stream._state;
            DequeueValue(controller);
            if (!WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
              var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
              WritableStreamUpdateBackpressure(stream, backpressure);
            }
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          }, function(reason) {
            if (stream._state === "writable") {
              WritableStreamDefaultControllerClearAlgorithms(controller);
            }
            WritableStreamFinishInFlightWriteWithError(stream, reason);
          });
        }
        __name(WritableStreamDefaultControllerProcessWrite, "WritableStreamDefaultControllerProcessWrite");
        function WritableStreamDefaultControllerGetBackpressure(controller) {
          var desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
          return desiredSize <= 0;
        }
        __name(WritableStreamDefaultControllerGetBackpressure, "WritableStreamDefaultControllerGetBackpressure");
        function WritableStreamDefaultControllerError(controller, error) {
          var stream = controller._controlledWritableStream;
          WritableStreamDefaultControllerClearAlgorithms(controller);
          WritableStreamStartErroring(stream, error);
        }
        __name(WritableStreamDefaultControllerError, "WritableStreamDefaultControllerError");
        function streamBrandCheckException$2(name) {
          return new TypeError("WritableStream.prototype." + name + " can only be used on a WritableStream");
        }
        __name(streamBrandCheckException$2, "streamBrandCheckException$2");
        function defaultControllerBrandCheckException$2(name) {
          return new TypeError("WritableStreamDefaultController.prototype." + name + " can only be used on a WritableStreamDefaultController");
        }
        __name(defaultControllerBrandCheckException$2, "defaultControllerBrandCheckException$2");
        function defaultWriterBrandCheckException(name) {
          return new TypeError("WritableStreamDefaultWriter.prototype." + name + " can only be used on a WritableStreamDefaultWriter");
        }
        __name(defaultWriterBrandCheckException, "defaultWriterBrandCheckException");
        function defaultWriterLockException(name) {
          return new TypeError("Cannot " + name + " a stream using a released writer");
        }
        __name(defaultWriterLockException, "defaultWriterLockException");
        function defaultWriterClosedPromiseInitialize(writer) {
          writer._closedPromise = newPromise(function(resolve, reject) {
            writer._closedPromise_resolve = resolve;
            writer._closedPromise_reject = reject;
            writer._closedPromiseState = "pending";
          });
        }
        __name(defaultWriterClosedPromiseInitialize, "defaultWriterClosedPromiseInitialize");
        function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
          defaultWriterClosedPromiseInitialize(writer);
          defaultWriterClosedPromiseReject(writer, reason);
        }
        __name(defaultWriterClosedPromiseInitializeAsRejected, "defaultWriterClosedPromiseInitializeAsRejected");
        function defaultWriterClosedPromiseInitializeAsResolved(writer) {
          defaultWriterClosedPromiseInitialize(writer);
          defaultWriterClosedPromiseResolve(writer);
        }
        __name(defaultWriterClosedPromiseInitializeAsResolved, "defaultWriterClosedPromiseInitializeAsResolved");
        function defaultWriterClosedPromiseReject(writer, reason) {
          if (writer._closedPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(writer._closedPromise);
          writer._closedPromise_reject(reason);
          writer._closedPromise_resolve = void 0;
          writer._closedPromise_reject = void 0;
          writer._closedPromiseState = "rejected";
        }
        __name(defaultWriterClosedPromiseReject, "defaultWriterClosedPromiseReject");
        function defaultWriterClosedPromiseResetToRejected(writer, reason) {
          defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
        }
        __name(defaultWriterClosedPromiseResetToRejected, "defaultWriterClosedPromiseResetToRejected");
        function defaultWriterClosedPromiseResolve(writer) {
          if (writer._closedPromise_resolve === void 0) {
            return;
          }
          writer._closedPromise_resolve(void 0);
          writer._closedPromise_resolve = void 0;
          writer._closedPromise_reject = void 0;
          writer._closedPromiseState = "resolved";
        }
        __name(defaultWriterClosedPromiseResolve, "defaultWriterClosedPromiseResolve");
        function defaultWriterReadyPromiseInitialize(writer) {
          writer._readyPromise = newPromise(function(resolve, reject) {
            writer._readyPromise_resolve = resolve;
            writer._readyPromise_reject = reject;
          });
          writer._readyPromiseState = "pending";
        }
        __name(defaultWriterReadyPromiseInitialize, "defaultWriterReadyPromiseInitialize");
        function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
          defaultWriterReadyPromiseInitialize(writer);
          defaultWriterReadyPromiseReject(writer, reason);
        }
        __name(defaultWriterReadyPromiseInitializeAsRejected, "defaultWriterReadyPromiseInitializeAsRejected");
        function defaultWriterReadyPromiseInitializeAsResolved(writer) {
          defaultWriterReadyPromiseInitialize(writer);
          defaultWriterReadyPromiseResolve(writer);
        }
        __name(defaultWriterReadyPromiseInitializeAsResolved, "defaultWriterReadyPromiseInitializeAsResolved");
        function defaultWriterReadyPromiseReject(writer, reason) {
          if (writer._readyPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(writer._readyPromise);
          writer._readyPromise_reject(reason);
          writer._readyPromise_resolve = void 0;
          writer._readyPromise_reject = void 0;
          writer._readyPromiseState = "rejected";
        }
        __name(defaultWriterReadyPromiseReject, "defaultWriterReadyPromiseReject");
        function defaultWriterReadyPromiseReset(writer) {
          defaultWriterReadyPromiseInitialize(writer);
        }
        __name(defaultWriterReadyPromiseReset, "defaultWriterReadyPromiseReset");
        function defaultWriterReadyPromiseResetToRejected(writer, reason) {
          defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
        }
        __name(defaultWriterReadyPromiseResetToRejected, "defaultWriterReadyPromiseResetToRejected");
        function defaultWriterReadyPromiseResolve(writer) {
          if (writer._readyPromise_resolve === void 0) {
            return;
          }
          writer._readyPromise_resolve(void 0);
          writer._readyPromise_resolve = void 0;
          writer._readyPromise_reject = void 0;
          writer._readyPromiseState = "fulfilled";
        }
        __name(defaultWriterReadyPromiseResolve, "defaultWriterReadyPromiseResolve");
        var NativeDOMException = typeof DOMException !== "undefined" ? DOMException : void 0;
        function isDOMExceptionConstructor(ctor) {
          if (!(typeof ctor === "function" || typeof ctor === "object")) {
            return false;
          }
          try {
            new ctor();
            return true;
          } catch (_a2) {
            return false;
          }
        }
        __name(isDOMExceptionConstructor, "isDOMExceptionConstructor");
        function createDOMExceptionPolyfill() {
          var ctor = /* @__PURE__ */ __name(function DOMException2(message, name) {
            this.message = message || "";
            this.name = name || "Error";
            if (Error.captureStackTrace) {
              Error.captureStackTrace(this, this.constructor);
            }
          }, "DOMException");
          ctor.prototype = Object.create(Error.prototype);
          Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
          return ctor;
        }
        __name(createDOMExceptionPolyfill, "createDOMExceptionPolyfill");
        var DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
        function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
          var reader = AcquireReadableStreamDefaultReader(source);
          var writer = AcquireWritableStreamDefaultWriter(dest);
          source._disturbed = true;
          var shuttingDown = false;
          var currentWrite = promiseResolvedWith(void 0);
          return newPromise(function(resolve, reject) {
            var abortAlgorithm;
            if (signal !== void 0) {
              abortAlgorithm = /* @__PURE__ */ __name(function() {
                var error = new DOMException$1("Aborted", "AbortError");
                var actions = [];
                if (!preventAbort) {
                  actions.push(function() {
                    if (dest._state === "writable") {
                      return WritableStreamAbort(dest, error);
                    }
                    return promiseResolvedWith(void 0);
                  });
                }
                if (!preventCancel) {
                  actions.push(function() {
                    if (source._state === "readable") {
                      return ReadableStreamCancel(source, error);
                    }
                    return promiseResolvedWith(void 0);
                  });
                }
                shutdownWithAction(function() {
                  return Promise.all(actions.map(function(action) {
                    return action();
                  }));
                }, true, error);
              }, "abortAlgorithm");
              if (signal.aborted) {
                abortAlgorithm();
                return;
              }
              signal.addEventListener("abort", abortAlgorithm);
            }
            function pipeLoop() {
              return newPromise(function(resolveLoop, rejectLoop) {
                function next(done) {
                  if (done) {
                    resolveLoop();
                  } else {
                    PerformPromiseThen(pipeStep(), next, rejectLoop);
                  }
                }
                __name(next, "next");
                next(false);
              });
            }
            __name(pipeLoop, "pipeLoop");
            function pipeStep() {
              if (shuttingDown) {
                return promiseResolvedWith(true);
              }
              return PerformPromiseThen(writer._readyPromise, function() {
                return newPromise(function(resolveRead, rejectRead) {
                  ReadableStreamDefaultReaderRead(reader, {
                    _chunkSteps: function(chunk) {
                      currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop);
                      resolveRead(false);
                    },
                    _closeSteps: function() {
                      return resolveRead(true);
                    },
                    _errorSteps: rejectRead
                  });
                });
              });
            }
            __name(pipeStep, "pipeStep");
            isOrBecomesErrored(source, reader._closedPromise, function(storedError) {
              if (!preventAbort) {
                shutdownWithAction(function() {
                  return WritableStreamAbort(dest, storedError);
                }, true, storedError);
              } else {
                shutdown(true, storedError);
              }
            });
            isOrBecomesErrored(dest, writer._closedPromise, function(storedError) {
              if (!preventCancel) {
                shutdownWithAction(function() {
                  return ReadableStreamCancel(source, storedError);
                }, true, storedError);
              } else {
                shutdown(true, storedError);
              }
            });
            isOrBecomesClosed(source, reader._closedPromise, function() {
              if (!preventClose) {
                shutdownWithAction(function() {
                  return WritableStreamDefaultWriterCloseWithErrorPropagation(writer);
                });
              } else {
                shutdown();
              }
            });
            if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
              var destClosed_1 = new TypeError("the destination writable stream closed before all data could be piped to it");
              if (!preventCancel) {
                shutdownWithAction(function() {
                  return ReadableStreamCancel(source, destClosed_1);
                }, true, destClosed_1);
              } else {
                shutdown(true, destClosed_1);
              }
            }
            setPromiseIsHandledToTrue(pipeLoop());
            function waitForWritesToFinish() {
              var oldCurrentWrite = currentWrite;
              return PerformPromiseThen(currentWrite, function() {
                return oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0;
              });
            }
            __name(waitForWritesToFinish, "waitForWritesToFinish");
            function isOrBecomesErrored(stream, promise, action) {
              if (stream._state === "errored") {
                action(stream._storedError);
              } else {
                uponRejection(promise, action);
              }
            }
            __name(isOrBecomesErrored, "isOrBecomesErrored");
            function isOrBecomesClosed(stream, promise, action) {
              if (stream._state === "closed") {
                action();
              } else {
                uponFulfillment(promise, action);
              }
            }
            __name(isOrBecomesClosed, "isOrBecomesClosed");
            function shutdownWithAction(action, originalIsError, originalError) {
              if (shuttingDown) {
                return;
              }
              shuttingDown = true;
              if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                uponFulfillment(waitForWritesToFinish(), doTheRest);
              } else {
                doTheRest();
              }
              function doTheRest() {
                uponPromise(action(), function() {
                  return finalize(originalIsError, originalError);
                }, function(newError) {
                  return finalize(true, newError);
                });
              }
              __name(doTheRest, "doTheRest");
            }
            __name(shutdownWithAction, "shutdownWithAction");
            function shutdown(isError, error) {
              if (shuttingDown) {
                return;
              }
              shuttingDown = true;
              if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                uponFulfillment(waitForWritesToFinish(), function() {
                  return finalize(isError, error);
                });
              } else {
                finalize(isError, error);
              }
            }
            __name(shutdown, "shutdown");
            function finalize(isError, error) {
              WritableStreamDefaultWriterRelease(writer);
              ReadableStreamReaderGenericRelease(reader);
              if (signal !== void 0) {
                signal.removeEventListener("abort", abortAlgorithm);
              }
              if (isError) {
                reject(error);
              } else {
                resolve(void 0);
              }
            }
            __name(finalize, "finalize");
          });
        }
        __name(ReadableStreamPipeTo, "ReadableStreamPipeTo");
        var ReadableStreamDefaultController = (
          /** @class */
          function() {
            function ReadableStreamDefaultController2() {
              throw new TypeError("Illegal constructor");
            }
            __name(ReadableStreamDefaultController2, "ReadableStreamDefaultController");
            Object.defineProperty(ReadableStreamDefaultController2.prototype, "desiredSize", {
              /**
               * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
               * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.
               */
              get: function() {
                if (!IsReadableStreamDefaultController(this)) {
                  throw defaultControllerBrandCheckException$1("desiredSize");
                }
                return ReadableStreamDefaultControllerGetDesiredSize(this);
              },
              enumerable: false,
              configurable: true
            });
            ReadableStreamDefaultController2.prototype.close = function() {
              if (!IsReadableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$1("close");
              }
              if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
                throw new TypeError("The stream is not in a state that permits close");
              }
              ReadableStreamDefaultControllerClose(this);
            };
            ReadableStreamDefaultController2.prototype.enqueue = function(chunk) {
              if (chunk === void 0) {
                chunk = void 0;
              }
              if (!IsReadableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$1("enqueue");
              }
              if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
                throw new TypeError("The stream is not in a state that permits enqueue");
              }
              return ReadableStreamDefaultControllerEnqueue(this, chunk);
            };
            ReadableStreamDefaultController2.prototype.error = function(e) {
              if (e === void 0) {
                e = void 0;
              }
              if (!IsReadableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$1("error");
              }
              ReadableStreamDefaultControllerError(this, e);
            };
            ReadableStreamDefaultController2.prototype[CancelSteps] = function(reason) {
              ResetQueue(this);
              var result = this._cancelAlgorithm(reason);
              ReadableStreamDefaultControllerClearAlgorithms(this);
              return result;
            };
            ReadableStreamDefaultController2.prototype[PullSteps] = function(readRequest) {
              var stream = this._controlledReadableStream;
              if (this._queue.length > 0) {
                var chunk = DequeueValue(this);
                if (this._closeRequested && this._queue.length === 0) {
                  ReadableStreamDefaultControllerClearAlgorithms(this);
                  ReadableStreamClose(stream);
                } else {
                  ReadableStreamDefaultControllerCallPullIfNeeded(this);
                }
                readRequest._chunkSteps(chunk);
              } else {
                ReadableStreamAddReadRequest(stream, readRequest);
                ReadableStreamDefaultControllerCallPullIfNeeded(this);
              }
            };
            return ReadableStreamDefaultController2;
          }()
        );
        Object.defineProperties(ReadableStreamDefaultController.prototype, {
          close: { enumerable: true },
          enqueue: { enumerable: true },
          error: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamDefaultController",
            configurable: true
          });
        }
        function IsReadableStreamDefaultController(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableStream")) {
            return false;
          }
          return x instanceof ReadableStreamDefaultController;
        }
        __name(IsReadableStreamDefaultController, "IsReadableStreamDefaultController");
        function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
          var shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
          if (!shouldPull) {
            return;
          }
          if (controller._pulling) {
            controller._pullAgain = true;
            return;
          }
          controller._pulling = true;
          var pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, function() {
            controller._pulling = false;
            if (controller._pullAgain) {
              controller._pullAgain = false;
              ReadableStreamDefaultControllerCallPullIfNeeded(controller);
            }
          }, function(e) {
            ReadableStreamDefaultControllerError(controller, e);
          });
        }
        __name(ReadableStreamDefaultControllerCallPullIfNeeded, "ReadableStreamDefaultControllerCallPullIfNeeded");
        function ReadableStreamDefaultControllerShouldCallPull(controller) {
          var stream = controller._controlledReadableStream;
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return false;
          }
          if (!controller._started) {
            return false;
          }
          if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
          }
          var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
          if (desiredSize > 0) {
            return true;
          }
          return false;
        }
        __name(ReadableStreamDefaultControllerShouldCallPull, "ReadableStreamDefaultControllerShouldCallPull");
        function ReadableStreamDefaultControllerClearAlgorithms(controller) {
          controller._pullAlgorithm = void 0;
          controller._cancelAlgorithm = void 0;
          controller._strategySizeAlgorithm = void 0;
        }
        __name(ReadableStreamDefaultControllerClearAlgorithms, "ReadableStreamDefaultControllerClearAlgorithms");
        function ReadableStreamDefaultControllerClose(controller) {
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
          }
          var stream = controller._controlledReadableStream;
          controller._closeRequested = true;
          if (controller._queue.length === 0) {
            ReadableStreamDefaultControllerClearAlgorithms(controller);
            ReadableStreamClose(stream);
          }
        }
        __name(ReadableStreamDefaultControllerClose, "ReadableStreamDefaultControllerClose");
        function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
          }
          var stream = controller._controlledReadableStream;
          if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            ReadableStreamFulfillReadRequest(stream, chunk, false);
          } else {
            var chunkSize = void 0;
            try {
              chunkSize = controller._strategySizeAlgorithm(chunk);
            } catch (chunkSizeE) {
              ReadableStreamDefaultControllerError(controller, chunkSizeE);
              throw chunkSizeE;
            }
            try {
              EnqueueValueWithSize(controller, chunk, chunkSize);
            } catch (enqueueE) {
              ReadableStreamDefaultControllerError(controller, enqueueE);
              throw enqueueE;
            }
          }
          ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }
        __name(ReadableStreamDefaultControllerEnqueue, "ReadableStreamDefaultControllerEnqueue");
        function ReadableStreamDefaultControllerError(controller, e) {
          var stream = controller._controlledReadableStream;
          if (stream._state !== "readable") {
            return;
          }
          ResetQueue(controller);
          ReadableStreamDefaultControllerClearAlgorithms(controller);
          ReadableStreamError(stream, e);
        }
        __name(ReadableStreamDefaultControllerError, "ReadableStreamDefaultControllerError");
        function ReadableStreamDefaultControllerGetDesiredSize(controller) {
          var state = controller._controlledReadableStream._state;
          if (state === "errored") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return controller._strategyHWM - controller._queueTotalSize;
        }
        __name(ReadableStreamDefaultControllerGetDesiredSize, "ReadableStreamDefaultControllerGetDesiredSize");
        function ReadableStreamDefaultControllerHasBackpressure(controller) {
          if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
            return false;
          }
          return true;
        }
        __name(ReadableStreamDefaultControllerHasBackpressure, "ReadableStreamDefaultControllerHasBackpressure");
        function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
          var state = controller._controlledReadableStream._state;
          if (!controller._closeRequested && state === "readable") {
            return true;
          }
          return false;
        }
        __name(ReadableStreamDefaultControllerCanCloseOrEnqueue, "ReadableStreamDefaultControllerCanCloseOrEnqueue");
        function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
          controller._controlledReadableStream = stream;
          controller._queue = void 0;
          controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._started = false;
          controller._closeRequested = false;
          controller._pullAgain = false;
          controller._pulling = false;
          controller._strategySizeAlgorithm = sizeAlgorithm;
          controller._strategyHWM = highWaterMark;
          controller._pullAlgorithm = pullAlgorithm;
          controller._cancelAlgorithm = cancelAlgorithm;
          stream._readableStreamController = controller;
          var startResult = startAlgorithm();
          uponPromise(promiseResolvedWith(startResult), function() {
            controller._started = true;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          }, function(r) {
            ReadableStreamDefaultControllerError(controller, r);
          });
        }
        __name(SetUpReadableStreamDefaultController, "SetUpReadableStreamDefaultController");
        function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
          var controller = Object.create(ReadableStreamDefaultController.prototype);
          var startAlgorithm = /* @__PURE__ */ __name(function() {
            return void 0;
          }, "startAlgorithm");
          var pullAlgorithm = /* @__PURE__ */ __name(function() {
            return promiseResolvedWith(void 0);
          }, "pullAlgorithm");
          var cancelAlgorithm = /* @__PURE__ */ __name(function() {
            return promiseResolvedWith(void 0);
          }, "cancelAlgorithm");
          if (underlyingSource.start !== void 0) {
            startAlgorithm = /* @__PURE__ */ __name(function() {
              return underlyingSource.start(controller);
            }, "startAlgorithm");
          }
          if (underlyingSource.pull !== void 0) {
            pullAlgorithm = /* @__PURE__ */ __name(function() {
              return underlyingSource.pull(controller);
            }, "pullAlgorithm");
          }
          if (underlyingSource.cancel !== void 0) {
            cancelAlgorithm = /* @__PURE__ */ __name(function(reason) {
              return underlyingSource.cancel(reason);
            }, "cancelAlgorithm");
          }
          SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
        }
        __name(SetUpReadableStreamDefaultControllerFromUnderlyingSource, "SetUpReadableStreamDefaultControllerFromUnderlyingSource");
        function defaultControllerBrandCheckException$1(name) {
          return new TypeError("ReadableStreamDefaultController.prototype." + name + " can only be used on a ReadableStreamDefaultController");
        }
        __name(defaultControllerBrandCheckException$1, "defaultControllerBrandCheckException$1");
        function ReadableStreamTee(stream, cloneForBranch2) {
          if (IsReadableByteStreamController(stream._readableStreamController)) {
            return ReadableByteStreamTee(stream);
          }
          return ReadableStreamDefaultTee(stream);
        }
        __name(ReadableStreamTee, "ReadableStreamTee");
        function ReadableStreamDefaultTee(stream, cloneForBranch2) {
          var reader = AcquireReadableStreamDefaultReader(stream);
          var reading = false;
          var readAgain = false;
          var canceled1 = false;
          var canceled2 = false;
          var reason1;
          var reason2;
          var branch1;
          var branch2;
          var resolveCancelPromise;
          var cancelPromise = newPromise(function(resolve) {
            resolveCancelPromise = resolve;
          });
          function pullAlgorithm() {
            if (reading) {
              readAgain = true;
              return promiseResolvedWith(void 0);
            }
            reading = true;
            var readRequest = {
              _chunkSteps: function(chunk) {
                queueMicrotask(function() {
                  readAgain = false;
                  var chunk1 = chunk;
                  var chunk2 = chunk;
                  if (!canceled1) {
                    ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
                  }
                  if (!canceled2) {
                    ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
                  }
                  reading = false;
                  if (readAgain) {
                    pullAlgorithm();
                  }
                });
              },
              _closeSteps: function() {
                reading = false;
                if (!canceled1) {
                  ReadableStreamDefaultControllerClose(branch1._readableStreamController);
                }
                if (!canceled2) {
                  ReadableStreamDefaultControllerClose(branch2._readableStreamController);
                }
                if (!canceled1 || !canceled2) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: function() {
                reading = false;
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promiseResolvedWith(void 0);
          }
          __name(pullAlgorithm, "pullAlgorithm");
          function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
              var compositeReason = CreateArrayFromList([reason1, reason2]);
              var cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          __name(cancel1Algorithm, "cancel1Algorithm");
          function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
              var compositeReason = CreateArrayFromList([reason1, reason2]);
              var cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          __name(cancel2Algorithm, "cancel2Algorithm");
          function startAlgorithm() {
          }
          __name(startAlgorithm, "startAlgorithm");
          branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
          branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
          uponRejection(reader._closedPromise, function(r) {
            ReadableStreamDefaultControllerError(branch1._readableStreamController, r);
            ReadableStreamDefaultControllerError(branch2._readableStreamController, r);
            if (!canceled1 || !canceled2) {
              resolveCancelPromise(void 0);
            }
          });
          return [branch1, branch2];
        }
        __name(ReadableStreamDefaultTee, "ReadableStreamDefaultTee");
        function ReadableByteStreamTee(stream) {
          var reader = AcquireReadableStreamDefaultReader(stream);
          var reading = false;
          var readAgainForBranch1 = false;
          var readAgainForBranch2 = false;
          var canceled1 = false;
          var canceled2 = false;
          var reason1;
          var reason2;
          var branch1;
          var branch2;
          var resolveCancelPromise;
          var cancelPromise = newPromise(function(resolve) {
            resolveCancelPromise = resolve;
          });
          function forwardReaderError(thisReader) {
            uponRejection(thisReader._closedPromise, function(r) {
              if (thisReader !== reader) {
                return;
              }
              ReadableByteStreamControllerError(branch1._readableStreamController, r);
              ReadableByteStreamControllerError(branch2._readableStreamController, r);
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            });
          }
          __name(forwardReaderError, "forwardReaderError");
          function pullWithDefaultReader() {
            if (IsReadableStreamBYOBReader(reader)) {
              ReadableStreamReaderGenericRelease(reader);
              reader = AcquireReadableStreamDefaultReader(stream);
              forwardReaderError(reader);
            }
            var readRequest = {
              _chunkSteps: function(chunk) {
                queueMicrotask(function() {
                  readAgainForBranch1 = false;
                  readAgainForBranch2 = false;
                  var chunk1 = chunk;
                  var chunk2 = chunk;
                  if (!canceled1 && !canceled2) {
                    try {
                      chunk2 = CloneAsUint8Array(chunk);
                    } catch (cloneE) {
                      ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                      ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                      resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                      return;
                    }
                  }
                  if (!canceled1) {
                    ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
                  }
                  if (!canceled2) {
                    ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
                  }
                  reading = false;
                  if (readAgainForBranch1) {
                    pull1Algorithm();
                  } else if (readAgainForBranch2) {
                    pull2Algorithm();
                  }
                });
              },
              _closeSteps: function() {
                reading = false;
                if (!canceled1) {
                  ReadableByteStreamControllerClose(branch1._readableStreamController);
                }
                if (!canceled2) {
                  ReadableByteStreamControllerClose(branch2._readableStreamController);
                }
                if (branch1._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
                }
                if (branch2._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
                }
                if (!canceled1 || !canceled2) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: function() {
                reading = false;
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
          }
          __name(pullWithDefaultReader, "pullWithDefaultReader");
          function pullWithBYOBReader(view, forBranch2) {
            if (IsReadableStreamDefaultReader(reader)) {
              ReadableStreamReaderGenericRelease(reader);
              reader = AcquireReadableStreamBYOBReader(stream);
              forwardReaderError(reader);
            }
            var byobBranch = forBranch2 ? branch2 : branch1;
            var otherBranch = forBranch2 ? branch1 : branch2;
            var readIntoRequest = {
              _chunkSteps: function(chunk) {
                queueMicrotask(function() {
                  readAgainForBranch1 = false;
                  readAgainForBranch2 = false;
                  var byobCanceled = forBranch2 ? canceled2 : canceled1;
                  var otherCanceled = forBranch2 ? canceled1 : canceled2;
                  if (!otherCanceled) {
                    var clonedChunk = void 0;
                    try {
                      clonedChunk = CloneAsUint8Array(chunk);
                    } catch (cloneE) {
                      ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                      ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                      resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                      return;
                    }
                    if (!byobCanceled) {
                      ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                    }
                    ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                  } else if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  reading = false;
                  if (readAgainForBranch1) {
                    pull1Algorithm();
                  } else if (readAgainForBranch2) {
                    pull2Algorithm();
                  }
                });
              },
              _closeSteps: function(chunk) {
                reading = false;
                var byobCanceled = forBranch2 ? canceled2 : canceled1;
                var otherCanceled = forBranch2 ? canceled1 : canceled2;
                if (!byobCanceled) {
                  ReadableByteStreamControllerClose(byobBranch._readableStreamController);
                }
                if (!otherCanceled) {
                  ReadableByteStreamControllerClose(otherBranch._readableStreamController);
                }
                if (chunk !== void 0) {
                  if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                    ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
                  }
                }
                if (!byobCanceled || !otherCanceled) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: function() {
                reading = false;
              }
            };
            ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
          }
          __name(pullWithBYOBReader, "pullWithBYOBReader");
          function pull1Algorithm() {
            if (reading) {
              readAgainForBranch1 = true;
              return promiseResolvedWith(void 0);
            }
            reading = true;
            var byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
            if (byobRequest === null) {
              pullWithDefaultReader();
            } else {
              pullWithBYOBReader(byobRequest._view, false);
            }
            return promiseResolvedWith(void 0);
          }
          __name(pull1Algorithm, "pull1Algorithm");
          function pull2Algorithm() {
            if (reading) {
              readAgainForBranch2 = true;
              return promiseResolvedWith(void 0);
            }
            reading = true;
            var byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
            if (byobRequest === null) {
              pullWithDefaultReader();
            } else {
              pullWithBYOBReader(byobRequest._view, true);
            }
            return promiseResolvedWith(void 0);
          }
          __name(pull2Algorithm, "pull2Algorithm");
          function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
              var compositeReason = CreateArrayFromList([reason1, reason2]);
              var cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          __name(cancel1Algorithm, "cancel1Algorithm");
          function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
              var compositeReason = CreateArrayFromList([reason1, reason2]);
              var cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          __name(cancel2Algorithm, "cancel2Algorithm");
          function startAlgorithm() {
            return;
          }
          __name(startAlgorithm, "startAlgorithm");
          branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
          branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
          forwardReaderError(reader);
          return [branch1, branch2];
        }
        __name(ReadableByteStreamTee, "ReadableByteStreamTee");
        function convertUnderlyingDefaultOrByteSource(source, context) {
          assertDictionary(source, context);
          var original = source;
          var autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
          var cancel = original === null || original === void 0 ? void 0 : original.cancel;
          var pull = original === null || original === void 0 ? void 0 : original.pull;
          var start = original === null || original === void 0 ? void 0 : original.start;
          var type = original === null || original === void 0 ? void 0 : original.type;
          return {
            autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, context + " has member 'autoAllocateChunkSize' that"),
            cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, context + " has member 'cancel' that"),
            pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, context + " has member 'pull' that"),
            start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, context + " has member 'start' that"),
            type: type === void 0 ? void 0 : convertReadableStreamType(type, context + " has member 'type' that")
          };
        }
        __name(convertUnderlyingDefaultOrByteSource, "convertUnderlyingDefaultOrByteSource");
        function convertUnderlyingSourceCancelCallback(fn, original, context) {
          assertFunction(fn, context);
          return function(reason) {
            return promiseCall(fn, original, [reason]);
          };
        }
        __name(convertUnderlyingSourceCancelCallback, "convertUnderlyingSourceCancelCallback");
        function convertUnderlyingSourcePullCallback(fn, original, context) {
          assertFunction(fn, context);
          return function(controller) {
            return promiseCall(fn, original, [controller]);
          };
        }
        __name(convertUnderlyingSourcePullCallback, "convertUnderlyingSourcePullCallback");
        function convertUnderlyingSourceStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return function(controller) {
            return reflectCall(fn, original, [controller]);
          };
        }
        __name(convertUnderlyingSourceStartCallback, "convertUnderlyingSourceStartCallback");
        function convertReadableStreamType(type, context) {
          type = "" + type;
          if (type !== "bytes") {
            throw new TypeError(context + " '" + type + "' is not a valid enumeration value for ReadableStreamType");
          }
          return type;
        }
        __name(convertReadableStreamType, "convertReadableStreamType");
        function convertReaderOptions(options, context) {
          assertDictionary(options, context);
          var mode = options === null || options === void 0 ? void 0 : options.mode;
          return {
            mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, context + " has member 'mode' that")
          };
        }
        __name(convertReaderOptions, "convertReaderOptions");
        function convertReadableStreamReaderMode(mode, context) {
          mode = "" + mode;
          if (mode !== "byob") {
            throw new TypeError(context + " '" + mode + "' is not a valid enumeration value for ReadableStreamReaderMode");
          }
          return mode;
        }
        __name(convertReadableStreamReaderMode, "convertReadableStreamReaderMode");
        function convertIteratorOptions(options, context) {
          assertDictionary(options, context);
          var preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
          return { preventCancel: Boolean(preventCancel) };
        }
        __name(convertIteratorOptions, "convertIteratorOptions");
        function convertPipeOptions(options, context) {
          assertDictionary(options, context);
          var preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;
          var preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
          var preventClose = options === null || options === void 0 ? void 0 : options.preventClose;
          var signal = options === null || options === void 0 ? void 0 : options.signal;
          if (signal !== void 0) {
            assertAbortSignal(signal, context + " has member 'signal' that");
          }
          return {
            preventAbort: Boolean(preventAbort),
            preventCancel: Boolean(preventCancel),
            preventClose: Boolean(preventClose),
            signal
          };
        }
        __name(convertPipeOptions, "convertPipeOptions");
        function assertAbortSignal(signal, context) {
          if (!isAbortSignal(signal)) {
            throw new TypeError(context + " is not an AbortSignal.");
          }
        }
        __name(assertAbortSignal, "assertAbortSignal");
        function convertReadableWritablePair(pair, context) {
          assertDictionary(pair, context);
          var readable = pair === null || pair === void 0 ? void 0 : pair.readable;
          assertRequiredField(readable, "readable", "ReadableWritablePair");
          assertReadableStream(readable, context + " has member 'readable' that");
          var writable = pair === null || pair === void 0 ? void 0 : pair.writable;
          assertRequiredField(writable, "writable", "ReadableWritablePair");
          assertWritableStream(writable, context + " has member 'writable' that");
          return { readable, writable };
        }
        __name(convertReadableWritablePair, "convertReadableWritablePair");
        var ReadableStream2 = (
          /** @class */
          function() {
            function ReadableStream3(rawUnderlyingSource, rawStrategy) {
              if (rawUnderlyingSource === void 0) {
                rawUnderlyingSource = {};
              }
              if (rawStrategy === void 0) {
                rawStrategy = {};
              }
              if (rawUnderlyingSource === void 0) {
                rawUnderlyingSource = null;
              } else {
                assertObject(rawUnderlyingSource, "First parameter");
              }
              var strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
              var underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
              InitializeReadableStream(this);
              if (underlyingSource.type === "bytes") {
                if (strategy.size !== void 0) {
                  throw new RangeError("The strategy for a byte stream cannot have a size function");
                }
                var highWaterMark = ExtractHighWaterMark(strategy, 0);
                SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
              } else {
                var sizeAlgorithm = ExtractSizeAlgorithm(strategy);
                var highWaterMark = ExtractHighWaterMark(strategy, 1);
                SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
              }
            }
            __name(ReadableStream3, "ReadableStream");
            Object.defineProperty(ReadableStream3.prototype, "locked", {
              /**
               * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.
               */
              get: function() {
                if (!IsReadableStream(this)) {
                  throw streamBrandCheckException$1("locked");
                }
                return IsReadableStreamLocked(this);
              },
              enumerable: false,
              configurable: true
            });
            ReadableStream3.prototype.cancel = function(reason) {
              if (reason === void 0) {
                reason = void 0;
              }
              if (!IsReadableStream(this)) {
                return promiseRejectedWith(streamBrandCheckException$1("cancel"));
              }
              if (IsReadableStreamLocked(this)) {
                return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
              }
              return ReadableStreamCancel(this, reason);
            };
            ReadableStream3.prototype.getReader = function(rawOptions) {
              if (rawOptions === void 0) {
                rawOptions = void 0;
              }
              if (!IsReadableStream(this)) {
                throw streamBrandCheckException$1("getReader");
              }
              var options = convertReaderOptions(rawOptions, "First parameter");
              if (options.mode === void 0) {
                return AcquireReadableStreamDefaultReader(this);
              }
              return AcquireReadableStreamBYOBReader(this);
            };
            ReadableStream3.prototype.pipeThrough = function(rawTransform, rawOptions) {
              if (rawOptions === void 0) {
                rawOptions = {};
              }
              if (!IsReadableStream(this)) {
                throw streamBrandCheckException$1("pipeThrough");
              }
              assertRequiredArgument(rawTransform, 1, "pipeThrough");
              var transform = convertReadableWritablePair(rawTransform, "First parameter");
              var options = convertPipeOptions(rawOptions, "Second parameter");
              if (IsReadableStreamLocked(this)) {
                throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
              }
              if (IsWritableStreamLocked(transform.writable)) {
                throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
              }
              var promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
              setPromiseIsHandledToTrue(promise);
              return transform.readable;
            };
            ReadableStream3.prototype.pipeTo = function(destination, rawOptions) {
              if (rawOptions === void 0) {
                rawOptions = {};
              }
              if (!IsReadableStream(this)) {
                return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
              }
              if (destination === void 0) {
                return promiseRejectedWith("Parameter 1 is required in 'pipeTo'.");
              }
              if (!IsWritableStream(destination)) {
                return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
              }
              var options;
              try {
                options = convertPipeOptions(rawOptions, "Second parameter");
              } catch (e) {
                return promiseRejectedWith(e);
              }
              if (IsReadableStreamLocked(this)) {
                return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
              }
              if (IsWritableStreamLocked(destination)) {
                return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
              }
              return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
            };
            ReadableStream3.prototype.tee = function() {
              if (!IsReadableStream(this)) {
                throw streamBrandCheckException$1("tee");
              }
              var branches = ReadableStreamTee(this);
              return CreateArrayFromList(branches);
            };
            ReadableStream3.prototype.values = function(rawOptions) {
              if (rawOptions === void 0) {
                rawOptions = void 0;
              }
              if (!IsReadableStream(this)) {
                throw streamBrandCheckException$1("values");
              }
              var options = convertIteratorOptions(rawOptions, "First parameter");
              return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
            };
            return ReadableStream3;
          }()
        );
        Object.defineProperties(ReadableStream2.prototype, {
          cancel: { enumerable: true },
          getReader: { enumerable: true },
          pipeThrough: { enumerable: true },
          pipeTo: { enumerable: true },
          tee: { enumerable: true },
          values: { enumerable: true },
          locked: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStream",
            configurable: true
          });
        }
        if (typeof SymbolPolyfill.asyncIterator === "symbol") {
          Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.asyncIterator, {
            value: ReadableStream2.prototype.values,
            writable: true,
            configurable: true
          });
        }
        function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
          if (highWaterMark === void 0) {
            highWaterMark = 1;
          }
          if (sizeAlgorithm === void 0) {
            sizeAlgorithm = /* @__PURE__ */ __name(function() {
              return 1;
            }, "sizeAlgorithm");
          }
          var stream = Object.create(ReadableStream2.prototype);
          InitializeReadableStream(stream);
          var controller = Object.create(ReadableStreamDefaultController.prototype);
          SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
          return stream;
        }
        __name(CreateReadableStream, "CreateReadableStream");
        function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
          var stream = Object.create(ReadableStream2.prototype);
          InitializeReadableStream(stream);
          var controller = Object.create(ReadableByteStreamController.prototype);
          SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0);
          return stream;
        }
        __name(CreateReadableByteStream, "CreateReadableByteStream");
        function InitializeReadableStream(stream) {
          stream._state = "readable";
          stream._reader = void 0;
          stream._storedError = void 0;
          stream._disturbed = false;
        }
        __name(InitializeReadableStream, "InitializeReadableStream");
        function IsReadableStream(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_readableStreamController")) {
            return false;
          }
          return x instanceof ReadableStream2;
        }
        __name(IsReadableStream, "IsReadableStream");
        function IsReadableStreamLocked(stream) {
          if (stream._reader === void 0) {
            return false;
          }
          return true;
        }
        __name(IsReadableStreamLocked, "IsReadableStreamLocked");
        function ReadableStreamCancel(stream, reason) {
          stream._disturbed = true;
          if (stream._state === "closed") {
            return promiseResolvedWith(void 0);
          }
          if (stream._state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          ReadableStreamClose(stream);
          var reader = stream._reader;
          if (reader !== void 0 && IsReadableStreamBYOBReader(reader)) {
            reader._readIntoRequests.forEach(function(readIntoRequest) {
              readIntoRequest._closeSteps(void 0);
            });
            reader._readIntoRequests = new SimpleQueue();
          }
          var sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
          return transformPromiseWith(sourceCancelPromise, noop);
        }
        __name(ReadableStreamCancel, "ReadableStreamCancel");
        function ReadableStreamClose(stream) {
          stream._state = "closed";
          var reader = stream._reader;
          if (reader === void 0) {
            return;
          }
          defaultReaderClosedPromiseResolve(reader);
          if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach(function(readRequest) {
              readRequest._closeSteps();
            });
            reader._readRequests = new SimpleQueue();
          }
        }
        __name(ReadableStreamClose, "ReadableStreamClose");
        function ReadableStreamError(stream, e) {
          stream._state = "errored";
          stream._storedError = e;
          var reader = stream._reader;
          if (reader === void 0) {
            return;
          }
          defaultReaderClosedPromiseReject(reader, e);
          if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach(function(readRequest) {
              readRequest._errorSteps(e);
            });
            reader._readRequests = new SimpleQueue();
          } else {
            reader._readIntoRequests.forEach(function(readIntoRequest) {
              readIntoRequest._errorSteps(e);
            });
            reader._readIntoRequests = new SimpleQueue();
          }
        }
        __name(ReadableStreamError, "ReadableStreamError");
        function streamBrandCheckException$1(name) {
          return new TypeError("ReadableStream.prototype." + name + " can only be used on a ReadableStream");
        }
        __name(streamBrandCheckException$1, "streamBrandCheckException$1");
        function convertQueuingStrategyInit(init, context) {
          assertDictionary(init, context);
          var highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
          assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
          return {
            highWaterMark: convertUnrestrictedDouble(highWaterMark)
          };
        }
        __name(convertQueuingStrategyInit, "convertQueuingStrategyInit");
        var byteLengthSizeFunction = /* @__PURE__ */ __name(function(chunk) {
          return chunk.byteLength;
        }, "byteLengthSizeFunction");
        try {
          Object.defineProperty(byteLengthSizeFunction, "name", {
            value: "size",
            configurable: true
          });
        } catch (_a2) {
        }
        var ByteLengthQueuingStrategy = (
          /** @class */
          function() {
            function ByteLengthQueuingStrategy2(options) {
              assertRequiredArgument(options, 1, "ByteLengthQueuingStrategy");
              options = convertQueuingStrategyInit(options, "First parameter");
              this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
            }
            __name(ByteLengthQueuingStrategy2, "ByteLengthQueuingStrategy");
            Object.defineProperty(ByteLengthQueuingStrategy2.prototype, "highWaterMark", {
              /**
               * Returns the high water mark provided to the constructor.
               */
              get: function() {
                if (!IsByteLengthQueuingStrategy(this)) {
                  throw byteLengthBrandCheckException("highWaterMark");
                }
                return this._byteLengthQueuingStrategyHighWaterMark;
              },
              enumerable: false,
              configurable: true
            });
            Object.defineProperty(ByteLengthQueuingStrategy2.prototype, "size", {
              /**
               * Measures the size of `chunk` by returning the value of its `byteLength` property.
               */
              get: function() {
                if (!IsByteLengthQueuingStrategy(this)) {
                  throw byteLengthBrandCheckException("size");
                }
                return byteLengthSizeFunction;
              },
              enumerable: false,
              configurable: true
            });
            return ByteLengthQueuingStrategy2;
          }()
        );
        Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
          highWaterMark: { enumerable: true },
          size: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: "ByteLengthQueuingStrategy",
            configurable: true
          });
        }
        function byteLengthBrandCheckException(name) {
          return new TypeError("ByteLengthQueuingStrategy.prototype." + name + " can only be used on a ByteLengthQueuingStrategy");
        }
        __name(byteLengthBrandCheckException, "byteLengthBrandCheckException");
        function IsByteLengthQueuingStrategy(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_byteLengthQueuingStrategyHighWaterMark")) {
            return false;
          }
          return x instanceof ByteLengthQueuingStrategy;
        }
        __name(IsByteLengthQueuingStrategy, "IsByteLengthQueuingStrategy");
        var countSizeFunction = /* @__PURE__ */ __name(function() {
          return 1;
        }, "countSizeFunction");
        try {
          Object.defineProperty(countSizeFunction, "name", {
            value: "size",
            configurable: true
          });
        } catch (_a2) {
        }
        var CountQueuingStrategy = (
          /** @class */
          function() {
            function CountQueuingStrategy2(options) {
              assertRequiredArgument(options, 1, "CountQueuingStrategy");
              options = convertQueuingStrategyInit(options, "First parameter");
              this._countQueuingStrategyHighWaterMark = options.highWaterMark;
            }
            __name(CountQueuingStrategy2, "CountQueuingStrategy");
            Object.defineProperty(CountQueuingStrategy2.prototype, "highWaterMark", {
              /**
               * Returns the high water mark provided to the constructor.
               */
              get: function() {
                if (!IsCountQueuingStrategy(this)) {
                  throw countBrandCheckException("highWaterMark");
                }
                return this._countQueuingStrategyHighWaterMark;
              },
              enumerable: false,
              configurable: true
            });
            Object.defineProperty(CountQueuingStrategy2.prototype, "size", {
              /**
               * Measures the size of `chunk` by always returning 1.
               * This ensures that the total queue size is a count of the number of chunks in the queue.
               */
              get: function() {
                if (!IsCountQueuingStrategy(this)) {
                  throw countBrandCheckException("size");
                }
                return countSizeFunction;
              },
              enumerable: false,
              configurable: true
            });
            return CountQueuingStrategy2;
          }()
        );
        Object.defineProperties(CountQueuingStrategy.prototype, {
          highWaterMark: { enumerable: true },
          size: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: "CountQueuingStrategy",
            configurable: true
          });
        }
        function countBrandCheckException(name) {
          return new TypeError("CountQueuingStrategy.prototype." + name + " can only be used on a CountQueuingStrategy");
        }
        __name(countBrandCheckException, "countBrandCheckException");
        function IsCountQueuingStrategy(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_countQueuingStrategyHighWaterMark")) {
            return false;
          }
          return x instanceof CountQueuingStrategy;
        }
        __name(IsCountQueuingStrategy, "IsCountQueuingStrategy");
        function convertTransformer(original, context) {
          assertDictionary(original, context);
          var flush = original === null || original === void 0 ? void 0 : original.flush;
          var readableType = original === null || original === void 0 ? void 0 : original.readableType;
          var start = original === null || original === void 0 ? void 0 : original.start;
          var transform = original === null || original === void 0 ? void 0 : original.transform;
          var writableType = original === null || original === void 0 ? void 0 : original.writableType;
          return {
            flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, context + " has member 'flush' that"),
            readableType,
            start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, context + " has member 'start' that"),
            transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, context + " has member 'transform' that"),
            writableType
          };
        }
        __name(convertTransformer, "convertTransformer");
        function convertTransformerFlushCallback(fn, original, context) {
          assertFunction(fn, context);
          return function(controller) {
            return promiseCall(fn, original, [controller]);
          };
        }
        __name(convertTransformerFlushCallback, "convertTransformerFlushCallback");
        function convertTransformerStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return function(controller) {
            return reflectCall(fn, original, [controller]);
          };
        }
        __name(convertTransformerStartCallback, "convertTransformerStartCallback");
        function convertTransformerTransformCallback(fn, original, context) {
          assertFunction(fn, context);
          return function(chunk, controller) {
            return promiseCall(fn, original, [chunk, controller]);
          };
        }
        __name(convertTransformerTransformCallback, "convertTransformerTransformCallback");
        var TransformStream = (
          /** @class */
          function() {
            function TransformStream2(rawTransformer, rawWritableStrategy, rawReadableStrategy) {
              if (rawTransformer === void 0) {
                rawTransformer = {};
              }
              if (rawWritableStrategy === void 0) {
                rawWritableStrategy = {};
              }
              if (rawReadableStrategy === void 0) {
                rawReadableStrategy = {};
              }
              if (rawTransformer === void 0) {
                rawTransformer = null;
              }
              var writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
              var readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
              var transformer = convertTransformer(rawTransformer, "First parameter");
              if (transformer.readableType !== void 0) {
                throw new RangeError("Invalid readableType specified");
              }
              if (transformer.writableType !== void 0) {
                throw new RangeError("Invalid writableType specified");
              }
              var readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
              var readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
              var writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
              var writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
              var startPromise_resolve;
              var startPromise = newPromise(function(resolve) {
                startPromise_resolve = resolve;
              });
              InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
              SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
              if (transformer.start !== void 0) {
                startPromise_resolve(transformer.start(this._transformStreamController));
              } else {
                startPromise_resolve(void 0);
              }
            }
            __name(TransformStream2, "TransformStream");
            Object.defineProperty(TransformStream2.prototype, "readable", {
              /**
               * The readable side of the transform stream.
               */
              get: function() {
                if (!IsTransformStream(this)) {
                  throw streamBrandCheckException("readable");
                }
                return this._readable;
              },
              enumerable: false,
              configurable: true
            });
            Object.defineProperty(TransformStream2.prototype, "writable", {
              /**
               * The writable side of the transform stream.
               */
              get: function() {
                if (!IsTransformStream(this)) {
                  throw streamBrandCheckException("writable");
                }
                return this._writable;
              },
              enumerable: false,
              configurable: true
            });
            return TransformStream2;
          }()
        );
        Object.defineProperties(TransformStream.prototype, {
          readable: { enumerable: true },
          writable: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
            value: "TransformStream",
            configurable: true
          });
        }
        function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
          function startAlgorithm() {
            return startPromise;
          }
          __name(startAlgorithm, "startAlgorithm");
          function writeAlgorithm(chunk) {
            return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
          }
          __name(writeAlgorithm, "writeAlgorithm");
          function abortAlgorithm(reason) {
            return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
          }
          __name(abortAlgorithm, "abortAlgorithm");
          function closeAlgorithm() {
            return TransformStreamDefaultSinkCloseAlgorithm(stream);
          }
          __name(closeAlgorithm, "closeAlgorithm");
          stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
          function pullAlgorithm() {
            return TransformStreamDefaultSourcePullAlgorithm(stream);
          }
          __name(pullAlgorithm, "pullAlgorithm");
          function cancelAlgorithm(reason) {
            TransformStreamErrorWritableAndUnblockWrite(stream, reason);
            return promiseResolvedWith(void 0);
          }
          __name(cancelAlgorithm, "cancelAlgorithm");
          stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
          stream._backpressure = void 0;
          stream._backpressureChangePromise = void 0;
          stream._backpressureChangePromise_resolve = void 0;
          TransformStreamSetBackpressure(stream, true);
          stream._transformStreamController = void 0;
        }
        __name(InitializeTransformStream, "InitializeTransformStream");
        function IsTransformStream(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_transformStreamController")) {
            return false;
          }
          return x instanceof TransformStream;
        }
        __name(IsTransformStream, "IsTransformStream");
        function TransformStreamError(stream, e) {
          ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);
          TransformStreamErrorWritableAndUnblockWrite(stream, e);
        }
        __name(TransformStreamError, "TransformStreamError");
        function TransformStreamErrorWritableAndUnblockWrite(stream, e) {
          TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
          WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);
          if (stream._backpressure) {
            TransformStreamSetBackpressure(stream, false);
          }
        }
        __name(TransformStreamErrorWritableAndUnblockWrite, "TransformStreamErrorWritableAndUnblockWrite");
        function TransformStreamSetBackpressure(stream, backpressure) {
          if (stream._backpressureChangePromise !== void 0) {
            stream._backpressureChangePromise_resolve();
          }
          stream._backpressureChangePromise = newPromise(function(resolve) {
            stream._backpressureChangePromise_resolve = resolve;
          });
          stream._backpressure = backpressure;
        }
        __name(TransformStreamSetBackpressure, "TransformStreamSetBackpressure");
        var TransformStreamDefaultController = (
          /** @class */
          function() {
            function TransformStreamDefaultController2() {
              throw new TypeError("Illegal constructor");
            }
            __name(TransformStreamDefaultController2, "TransformStreamDefaultController");
            Object.defineProperty(TransformStreamDefaultController2.prototype, "desiredSize", {
              /**
               * Returns the desired size to fill the readable sideâs internal queue. It can be negative, if the queue is over-full.
               */
              get: function() {
                if (!IsTransformStreamDefaultController(this)) {
                  throw defaultControllerBrandCheckException("desiredSize");
                }
                var readableController = this._controlledTransformStream._readable._readableStreamController;
                return ReadableStreamDefaultControllerGetDesiredSize(readableController);
              },
              enumerable: false,
              configurable: true
            });
            TransformStreamDefaultController2.prototype.enqueue = function(chunk) {
              if (chunk === void 0) {
                chunk = void 0;
              }
              if (!IsTransformStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException("enqueue");
              }
              TransformStreamDefaultControllerEnqueue(this, chunk);
            };
            TransformStreamDefaultController2.prototype.error = function(reason) {
              if (reason === void 0) {
                reason = void 0;
              }
              if (!IsTransformStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException("error");
              }
              TransformStreamDefaultControllerError(this, reason);
            };
            TransformStreamDefaultController2.prototype.terminate = function() {
              if (!IsTransformStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException("terminate");
              }
              TransformStreamDefaultControllerTerminate(this);
            };
            return TransformStreamDefaultController2;
          }()
        );
        Object.defineProperties(TransformStreamDefaultController.prototype, {
          enqueue: { enumerable: true },
          error: { enumerable: true },
          terminate: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "TransformStreamDefaultController",
            configurable: true
          });
        }
        function IsTransformStreamDefaultController(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_controlledTransformStream")) {
            return false;
          }
          return x instanceof TransformStreamDefaultController;
        }
        __name(IsTransformStreamDefaultController, "IsTransformStreamDefaultController");
        function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
          controller._controlledTransformStream = stream;
          stream._transformStreamController = controller;
          controller._transformAlgorithm = transformAlgorithm;
          controller._flushAlgorithm = flushAlgorithm;
        }
        __name(SetUpTransformStreamDefaultController, "SetUpTransformStreamDefaultController");
        function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
          var controller = Object.create(TransformStreamDefaultController.prototype);
          var transformAlgorithm = /* @__PURE__ */ __name(function(chunk) {
            try {
              TransformStreamDefaultControllerEnqueue(controller, chunk);
              return promiseResolvedWith(void 0);
            } catch (transformResultE) {
              return promiseRejectedWith(transformResultE);
            }
          }, "transformAlgorithm");
          var flushAlgorithm = /* @__PURE__ */ __name(function() {
            return promiseResolvedWith(void 0);
          }, "flushAlgorithm");
          if (transformer.transform !== void 0) {
            transformAlgorithm = /* @__PURE__ */ __name(function(chunk) {
              return transformer.transform(chunk, controller);
            }, "transformAlgorithm");
          }
          if (transformer.flush !== void 0) {
            flushAlgorithm = /* @__PURE__ */ __name(function() {
              return transformer.flush(controller);
            }, "flushAlgorithm");
          }
          SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
        }
        __name(SetUpTransformStreamDefaultControllerFromTransformer, "SetUpTransformStreamDefaultControllerFromTransformer");
        function TransformStreamDefaultControllerClearAlgorithms(controller) {
          controller._transformAlgorithm = void 0;
          controller._flushAlgorithm = void 0;
        }
        __name(TransformStreamDefaultControllerClearAlgorithms, "TransformStreamDefaultControllerClearAlgorithms");
        function TransformStreamDefaultControllerEnqueue(controller, chunk) {
          var stream = controller._controlledTransformStream;
          var readableController = stream._readable._readableStreamController;
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
            throw new TypeError("Readable side is not in a state that permits enqueue");
          }
          try {
            ReadableStreamDefaultControllerEnqueue(readableController, chunk);
          } catch (e) {
            TransformStreamErrorWritableAndUnblockWrite(stream, e);
            throw stream._readable._storedError;
          }
          var backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
          if (backpressure !== stream._backpressure) {
            TransformStreamSetBackpressure(stream, true);
          }
        }
        __name(TransformStreamDefaultControllerEnqueue, "TransformStreamDefaultControllerEnqueue");
        function TransformStreamDefaultControllerError(controller, e) {
          TransformStreamError(controller._controlledTransformStream, e);
        }
        __name(TransformStreamDefaultControllerError, "TransformStreamDefaultControllerError");
        function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
          var transformPromise = controller._transformAlgorithm(chunk);
          return transformPromiseWith(transformPromise, void 0, function(r) {
            TransformStreamError(controller._controlledTransformStream, r);
            throw r;
          });
        }
        __name(TransformStreamDefaultControllerPerformTransform, "TransformStreamDefaultControllerPerformTransform");
        function TransformStreamDefaultControllerTerminate(controller) {
          var stream = controller._controlledTransformStream;
          var readableController = stream._readable._readableStreamController;
          ReadableStreamDefaultControllerClose(readableController);
          var error = new TypeError("TransformStream terminated");
          TransformStreamErrorWritableAndUnblockWrite(stream, error);
        }
        __name(TransformStreamDefaultControllerTerminate, "TransformStreamDefaultControllerTerminate");
        function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
          var controller = stream._transformStreamController;
          if (stream._backpressure) {
            var backpressureChangePromise = stream._backpressureChangePromise;
            return transformPromiseWith(backpressureChangePromise, function() {
              var writable = stream._writable;
              var state = writable._state;
              if (state === "erroring") {
                throw writable._storedError;
              }
              return TransformStreamDefaultControllerPerformTransform(controller, chunk);
            });
          }
          return TransformStreamDefaultControllerPerformTransform(controller, chunk);
        }
        __name(TransformStreamDefaultSinkWriteAlgorithm, "TransformStreamDefaultSinkWriteAlgorithm");
        function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
          TransformStreamError(stream, reason);
          return promiseResolvedWith(void 0);
        }
        __name(TransformStreamDefaultSinkAbortAlgorithm, "TransformStreamDefaultSinkAbortAlgorithm");
        function TransformStreamDefaultSinkCloseAlgorithm(stream) {
          var readable = stream._readable;
          var controller = stream._transformStreamController;
          var flushPromise = controller._flushAlgorithm();
          TransformStreamDefaultControllerClearAlgorithms(controller);
          return transformPromiseWith(flushPromise, function() {
            if (readable._state === "errored") {
              throw readable._storedError;
            }
            ReadableStreamDefaultControllerClose(readable._readableStreamController);
          }, function(r) {
            TransformStreamError(stream, r);
            throw readable._storedError;
          });
        }
        __name(TransformStreamDefaultSinkCloseAlgorithm, "TransformStreamDefaultSinkCloseAlgorithm");
        function TransformStreamDefaultSourcePullAlgorithm(stream) {
          TransformStreamSetBackpressure(stream, false);
          return stream._backpressureChangePromise;
        }
        __name(TransformStreamDefaultSourcePullAlgorithm, "TransformStreamDefaultSourcePullAlgorithm");
        function defaultControllerBrandCheckException(name) {
          return new TypeError("TransformStreamDefaultController.prototype." + name + " can only be used on a TransformStreamDefaultController");
        }
        __name(defaultControllerBrandCheckException, "defaultControllerBrandCheckException");
        function streamBrandCheckException(name) {
          return new TypeError("TransformStream.prototype." + name + " can only be used on a TransformStream");
        }
        __name(streamBrandCheckException, "streamBrandCheckException");
        exports2.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
        exports2.CountQueuingStrategy = CountQueuingStrategy;
        exports2.ReadableByteStreamController = ReadableByteStreamController;
        exports2.ReadableStream = ReadableStream2;
        exports2.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
        exports2.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
        exports2.ReadableStreamDefaultController = ReadableStreamDefaultController;
        exports2.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
        exports2.TransformStream = TransformStream;
        exports2.TransformStreamDefaultController = TransformStreamDefaultController;
        exports2.WritableStream = WritableStream;
        exports2.WritableStreamDefaultController = WritableStreamDefaultController;
        exports2.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    })(ponyfill, ponyfill.exports);
    return ponyfill.exports;
  }
  __name(requirePonyfill, "requirePonyfill");
  (function(module, exports) {
    (/* @__PURE__ */ __name(function webpackUniversalModuleDefinition(root, factory) {
      module.exports = factory();
    }, "webpackUniversalModuleDefinition"))(globalThis, () => {
      return (
        /******/
        (() => {
          var __webpack_modules__ = [
            ,
            /* 1 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.WorkerTask = exports2.WorkerMessageHandler = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _primitives = __w_pdfjs_require__2(130);
              var _core_utils = __w_pdfjs_require__2(131);
              var _pdf_manager = __w_pdfjs_require__2(133);
              var _cleanup_helper = __w_pdfjs_require__2(196);
              var _writer = __w_pdfjs_require__2(190);
              var _is_node = __w_pdfjs_require__2(4);
              var _message_handler = __w_pdfjs_require__2(227);
              var _worker_stream = __w_pdfjs_require__2(228);
              const _WorkerTask = class _WorkerTask {
                constructor(name) {
                  this.name = name;
                  this.terminated = false;
                  this._capability = (0, _util.createPromiseCapability)();
                }
                get finished() {
                  return this._capability.promise;
                }
                finish() {
                  this._capability.resolve();
                }
                terminate() {
                  this.terminated = true;
                }
                ensureNotTerminated() {
                  if (this.terminated) {
                    throw new Error("Worker task was terminated");
                  }
                }
              };
              __name(_WorkerTask, "WorkerTask");
              let WorkerTask = _WorkerTask;
              exports2.WorkerTask = WorkerTask;
              const _WorkerMessageHandler = class _WorkerMessageHandler {
                static setup(handler, port) {
                  let testMessageProcessed = false;
                  handler.on("test", /* @__PURE__ */ __name(function wphSetupTest(data) {
                    if (testMessageProcessed) {
                      return;
                    }
                    testMessageProcessed = true;
                    handler.send("test", data instanceof Uint8Array);
                  }, "wphSetupTest"));
                  handler.on("configure", /* @__PURE__ */ __name(function wphConfigure(data) {
                    (0, _util.setVerbosityLevel)(data.verbosity);
                  }, "wphConfigure"));
                  handler.on("GetDocRequest", /* @__PURE__ */ __name(function wphSetupDoc(data) {
                    return _WorkerMessageHandler.createDocumentHandler(data, port);
                  }, "wphSetupDoc"));
                }
                static createDocumentHandler(docParams, port) {
                  let pdfManager;
                  let terminated = false;
                  let cancelXHRs = null;
                  const WorkerTasks = [];
                  const verbosity = (0, _util.getVerbosityLevel)();
                  const apiVersion = docParams.apiVersion;
                  const workerVersion = "2.16.105";
                  if (apiVersion !== workerVersion) {
                    throw new Error(`The API version "${apiVersion}" does not match the Worker version "${workerVersion}".`);
                  }
                  const enumerableProperties = [];
                  for (const property in []) {
                    enumerableProperties.push(property);
                  }
                  if (enumerableProperties.length) {
                    throw new Error("The `Array.prototype` contains unexpected enumerable properties: " + enumerableProperties.join(", ") + "; thus breaking e.g. `for...in` iteration of `Array`s.");
                  }
                  if (typeof ReadableStream === "undefined") {
                    const partialMsg = "The browser/environment lacks native support for critical functionality used by the PDF.js library (e.g. `ReadableStream`); ";
                    if (_is_node.isNodeJS) {
                      throw new Error(partialMsg + "please use a `legacy`-build instead.");
                    }
                    throw new Error(partialMsg + "please update to a supported browser.");
                  }
                  const docId = docParams.docId;
                  const docBaseUrl = docParams.docBaseUrl;
                  const workerHandlerName = docParams.docId + "_worker";
                  let handler = new _message_handler.MessageHandler(workerHandlerName, docId, port);
                  function ensureNotTerminated() {
                    if (terminated) {
                      throw new Error("Worker was terminated");
                    }
                  }
                  __name(ensureNotTerminated, "ensureNotTerminated");
                  function startWorkerTask(task) {
                    WorkerTasks.push(task);
                  }
                  __name(startWorkerTask, "startWorkerTask");
                  function finishWorkerTask(task) {
                    task.finish();
                    const i = WorkerTasks.indexOf(task);
                    WorkerTasks.splice(i, 1);
                  }
                  __name(finishWorkerTask, "finishWorkerTask");
                  async function loadDocument(recoveryMode) {
                    await pdfManager.ensureDoc("checkHeader");
                    await pdfManager.ensureDoc("parseStartXRef");
                    await pdfManager.ensureDoc("parse", [recoveryMode]);
                    await pdfManager.ensureDoc("checkFirstPage", [recoveryMode]);
                    await pdfManager.ensureDoc("checkLastPage", [recoveryMode]);
                    const isPureXfa = await pdfManager.ensureDoc("isPureXfa");
                    if (isPureXfa) {
                      const task = new WorkerTask("loadXfaFonts");
                      startWorkerTask(task);
                      await Promise.all([pdfManager.loadXfaFonts(handler, task).catch((reason) => {
                      }).then(() => finishWorkerTask(task)), pdfManager.loadXfaImages()]);
                    }
                    const [numPages, fingerprints] = await Promise.all([pdfManager.ensureDoc("numPages"), pdfManager.ensureDoc("fingerprints")]);
                    const htmlForXfa = isPureXfa ? await pdfManager.ensureDoc("htmlForXfa") : null;
                    return {
                      numPages,
                      fingerprints,
                      htmlForXfa
                    };
                  }
                  __name(loadDocument, "loadDocument");
                  function getPdfManager(data, evaluatorOptions, enableXfa) {
                    const pdfManagerCapability = (0, _util.createPromiseCapability)();
                    let newPdfManager;
                    const source = data.source;
                    if (source.data) {
                      try {
                        newPdfManager = new _pdf_manager.LocalPdfManager(docId, source.data, source.password, handler, evaluatorOptions, enableXfa, docBaseUrl);
                        pdfManagerCapability.resolve(newPdfManager);
                      } catch (ex) {
                        pdfManagerCapability.reject(ex);
                      }
                      return pdfManagerCapability.promise;
                    }
                    let pdfStream, cachedChunks = [];
                    try {
                      pdfStream = new _worker_stream.PDFWorkerStream(handler);
                    } catch (ex) {
                      pdfManagerCapability.reject(ex);
                      return pdfManagerCapability.promise;
                    }
                    const fullRequest = pdfStream.getFullReader();
                    fullRequest.headersReady.then(function() {
                      if (!fullRequest.isRangeSupported) {
                        return;
                      }
                      const disableAutoFetch = source.disableAutoFetch || fullRequest.isStreamingSupported;
                      newPdfManager = new _pdf_manager.NetworkPdfManager(docId, pdfStream, {
                        msgHandler: handler,
                        password: source.password,
                        length: fullRequest.contentLength,
                        disableAutoFetch,
                        rangeChunkSize: source.rangeChunkSize
                      }, evaluatorOptions, enableXfa, docBaseUrl);
                      for (const chunk of cachedChunks) {
                        newPdfManager.sendProgressiveData(chunk);
                      }
                      cachedChunks = [];
                      pdfManagerCapability.resolve(newPdfManager);
                      cancelXHRs = null;
                    }).catch(function(reason) {
                      pdfManagerCapability.reject(reason);
                      cancelXHRs = null;
                    });
                    let loaded = 0;
                    const flushChunks = /* @__PURE__ */ __name(function() {
                      const pdfFile = (0, _util.arraysToBytes)(cachedChunks);
                      if (source.length && pdfFile.length !== source.length) {
                        (0, _util.warn)("reported HTTP length is different from actual");
                      }
                      try {
                        newPdfManager = new _pdf_manager.LocalPdfManager(docId, pdfFile, source.password, handler, evaluatorOptions, enableXfa, docBaseUrl);
                        pdfManagerCapability.resolve(newPdfManager);
                      } catch (ex) {
                        pdfManagerCapability.reject(ex);
                      }
                      cachedChunks = [];
                    }, "flushChunks");
                    const readPromise = new Promise(function(resolve, reject) {
                      const readChunk = /* @__PURE__ */ __name(function(_ref) {
                        let {
                          value,
                          done
                        } = _ref;
                        try {
                          ensureNotTerminated();
                          if (done) {
                            if (!newPdfManager) {
                              flushChunks();
                            }
                            cancelXHRs = null;
                            return;
                          }
                          loaded += (0, _util.arrayByteLength)(value);
                          if (!fullRequest.isStreamingSupported) {
                            handler.send("DocProgress", {
                              loaded,
                              total: Math.max(loaded, fullRequest.contentLength || 0)
                            });
                          }
                          if (newPdfManager) {
                            newPdfManager.sendProgressiveData(value);
                          } else {
                            cachedChunks.push(value);
                          }
                          fullRequest.read().then(readChunk, reject);
                        } catch (e) {
                          reject(e);
                        }
                      }, "readChunk");
                      fullRequest.read().then(readChunk, reject);
                    });
                    readPromise.catch(function(e) {
                      pdfManagerCapability.reject(e);
                      cancelXHRs = null;
                    });
                    cancelXHRs = /* @__PURE__ */ __name(function(reason) {
                      pdfStream.cancelAllRequests(reason);
                    }, "cancelXHRs");
                    return pdfManagerCapability.promise;
                  }
                  __name(getPdfManager, "getPdfManager");
                  function setupDoc(data) {
                    function onSuccess(doc) {
                      ensureNotTerminated();
                      handler.send("GetDoc", {
                        pdfInfo: doc
                      });
                    }
                    __name(onSuccess, "onSuccess");
                    function onFailure(ex) {
                      ensureNotTerminated();
                      if (ex instanceof _util.PasswordException) {
                        const task = new WorkerTask(`PasswordException: response ${ex.code}`);
                        startWorkerTask(task);
                        handler.sendWithPromise("PasswordRequest", ex).then(function(_ref2) {
                          let {
                            password
                          } = _ref2;
                          finishWorkerTask(task);
                          pdfManager.updatePassword(password);
                          pdfManagerReady();
                        }).catch(function() {
                          finishWorkerTask(task);
                          handler.send("DocException", ex);
                        });
                      } else if (ex instanceof _util.InvalidPDFException || ex instanceof _util.MissingPDFException || ex instanceof _util.UnexpectedResponseException || ex instanceof _util.UnknownErrorException) {
                        handler.send("DocException", ex);
                      } else {
                        handler.send("DocException", new _util.UnknownErrorException(ex.message, ex.toString()));
                      }
                    }
                    __name(onFailure, "onFailure");
                    function pdfManagerReady() {
                      ensureNotTerminated();
                      loadDocument(false).then(onSuccess, function(reason) {
                        ensureNotTerminated();
                        if (!(reason instanceof _core_utils.XRefParseException)) {
                          onFailure(reason);
                          return;
                        }
                        pdfManager.requestLoadedStream();
                        pdfManager.onLoadedStream().then(function() {
                          ensureNotTerminated();
                          loadDocument(true).then(onSuccess, onFailure);
                        });
                      });
                    }
                    __name(pdfManagerReady, "pdfManagerReady");
                    ensureNotTerminated();
                    const evaluatorOptions = {
                      maxImageSize: data.maxImageSize,
                      disableFontFace: data.disableFontFace,
                      ignoreErrors: data.ignoreErrors,
                      isEvalSupported: data.isEvalSupported,
                      fontExtraProperties: data.fontExtraProperties,
                      useSystemFonts: data.useSystemFonts,
                      cMapUrl: data.cMapUrl,
                      standardFontDataUrl: data.standardFontDataUrl
                    };
                    getPdfManager(data, evaluatorOptions, data.enableXfa).then(function(newPdfManager) {
                      if (terminated) {
                        newPdfManager.terminate(new _util.AbortException("Worker was terminated."));
                        throw new Error("Worker was terminated");
                      }
                      pdfManager = newPdfManager;
                      pdfManager.onLoadedStream().then(function(stream) {
                        handler.send("DataLoaded", {
                          length: stream.bytes.byteLength
                        });
                      });
                    }).then(pdfManagerReady, onFailure);
                  }
                  __name(setupDoc, "setupDoc");
                  handler.on("GetPage", /* @__PURE__ */ __name(function wphSetupGetPage(data) {
                    return pdfManager.getPage(data.pageIndex).then(function(page) {
                      return Promise.all([pdfManager.ensure(page, "rotate"), pdfManager.ensure(page, "ref"), pdfManager.ensure(page, "userUnit"), pdfManager.ensure(page, "view")]).then(function(_ref3) {
                        let [rotate, ref, userUnit, view] = _ref3;
                        return {
                          rotate,
                          ref,
                          userUnit,
                          view
                        };
                      });
                    });
                  }, "wphSetupGetPage"));
                  handler.on("GetPageIndex", /* @__PURE__ */ __name(function wphSetupGetPageIndex(data) {
                    const pageRef = _primitives.Ref.get(data.num, data.gen);
                    return pdfManager.ensureCatalog("getPageIndex", [pageRef]);
                  }, "wphSetupGetPageIndex"));
                  handler.on("GetDestinations", /* @__PURE__ */ __name(function wphSetupGetDestinations(data) {
                    return pdfManager.ensureCatalog("destinations");
                  }, "wphSetupGetDestinations"));
                  handler.on("GetDestination", /* @__PURE__ */ __name(function wphSetupGetDestination(data) {
                    return pdfManager.ensureCatalog("getDestination", [data.id]);
                  }, "wphSetupGetDestination"));
                  handler.on("GetPageLabels", /* @__PURE__ */ __name(function wphSetupGetPageLabels(data) {
                    return pdfManager.ensureCatalog("pageLabels");
                  }, "wphSetupGetPageLabels"));
                  handler.on("GetPageLayout", /* @__PURE__ */ __name(function wphSetupGetPageLayout(data) {
                    return pdfManager.ensureCatalog("pageLayout");
                  }, "wphSetupGetPageLayout"));
                  handler.on("GetPageMode", /* @__PURE__ */ __name(function wphSetupGetPageMode(data) {
                    return pdfManager.ensureCatalog("pageMode");
                  }, "wphSetupGetPageMode"));
                  handler.on("GetViewerPreferences", function(data) {
                    return pdfManager.ensureCatalog("viewerPreferences");
                  });
                  handler.on("GetOpenAction", function(data) {
                    return pdfManager.ensureCatalog("openAction");
                  });
                  handler.on("GetAttachments", /* @__PURE__ */ __name(function wphSetupGetAttachments(data) {
                    return pdfManager.ensureCatalog("attachments");
                  }, "wphSetupGetAttachments"));
                  handler.on("GetJavaScript", /* @__PURE__ */ __name(function wphSetupGetJavaScript(data) {
                    return pdfManager.ensureCatalog("javaScript");
                  }, "wphSetupGetJavaScript"));
                  handler.on("GetDocJSActions", /* @__PURE__ */ __name(function wphSetupGetDocJSActions(data) {
                    return pdfManager.ensureCatalog("jsActions");
                  }, "wphSetupGetDocJSActions"));
                  handler.on("GetPageJSActions", function(_ref4) {
                    let {
                      pageIndex
                    } = _ref4;
                    return pdfManager.getPage(pageIndex).then(function(page) {
                      return pdfManager.ensure(page, "jsActions");
                    });
                  });
                  handler.on("GetOutline", /* @__PURE__ */ __name(function wphSetupGetOutline(data) {
                    return pdfManager.ensureCatalog("documentOutline");
                  }, "wphSetupGetOutline"));
                  handler.on("GetOptionalContentConfig", function(data) {
                    return pdfManager.ensureCatalog("optionalContentConfig");
                  });
                  handler.on("GetPermissions", function(data) {
                    return pdfManager.ensureCatalog("permissions");
                  });
                  handler.on("GetMetadata", /* @__PURE__ */ __name(function wphSetupGetMetadata(data) {
                    return Promise.all([pdfManager.ensureDoc("documentInfo"), pdfManager.ensureCatalog("metadata")]);
                  }, "wphSetupGetMetadata"));
                  handler.on("GetMarkInfo", /* @__PURE__ */ __name(function wphSetupGetMarkInfo(data) {
                    return pdfManager.ensureCatalog("markInfo");
                  }, "wphSetupGetMarkInfo"));
                  handler.on("GetData", /* @__PURE__ */ __name(function wphSetupGetData(data) {
                    pdfManager.requestLoadedStream();
                    return pdfManager.onLoadedStream().then(function(stream) {
                      return stream.bytes;
                    });
                  }, "wphSetupGetData"));
                  handler.on("GetAnnotations", function(_ref5) {
                    let {
                      pageIndex,
                      intent
                    } = _ref5;
                    return pdfManager.getPage(pageIndex).then(function(page) {
                      const task = new WorkerTask(`GetAnnotations: page ${pageIndex}`);
                      startWorkerTask(task);
                      return page.getAnnotationsData(handler, task, intent).then((data) => {
                        finishWorkerTask(task);
                        return data;
                      }, (reason) => {
                        finishWorkerTask(task);
                      });
                    });
                  });
                  handler.on("GetFieldObjects", function(data) {
                    return pdfManager.ensureDoc("fieldObjects");
                  });
                  handler.on("HasJSActions", function(data) {
                    return pdfManager.ensureDoc("hasJSActions");
                  });
                  handler.on("GetCalculationOrderIds", function(data) {
                    return pdfManager.ensureDoc("calculationOrderIds");
                  });
                  handler.on("SaveDocument", function(_ref6) {
                    let {
                      isPureXfa,
                      numPages,
                      annotationStorage,
                      filename
                    } = _ref6;
                    pdfManager.requestLoadedStream();
                    const newAnnotationsByPage = !isPureXfa ? (0, _core_utils.getNewAnnotationsMap)(annotationStorage) : null;
                    const promises = [pdfManager.onLoadedStream(), pdfManager.ensureCatalog("acroForm"), pdfManager.ensureCatalog("acroFormRef"), pdfManager.ensureDoc("xref"), pdfManager.ensureDoc("startXRef")];
                    if (newAnnotationsByPage) {
                      for (const [pageIndex, annotations] of newAnnotationsByPage) {
                        promises.push(pdfManager.getPage(pageIndex).then((page) => {
                          const task = new WorkerTask(`Save (editor): page ${pageIndex}`);
                          return page.saveNewAnnotations(handler, task, annotations).finally(function() {
                            finishWorkerTask(task);
                          });
                        }));
                      }
                    }
                    if (isPureXfa) {
                      promises.push(pdfManager.serializeXfaData(annotationStorage));
                    } else {
                      for (let pageIndex = 0; pageIndex < numPages; pageIndex++) {
                        promises.push(pdfManager.getPage(pageIndex).then(function(page) {
                          const task = new WorkerTask(`Save: page ${pageIndex}`);
                          return page.save(handler, task, annotationStorage).finally(function() {
                            finishWorkerTask(task);
                          });
                        }));
                      }
                    }
                    return Promise.all(promises).then(function(_ref7) {
                      let [stream, acroForm, acroFormRef, xref, startXRef, ...refs] = _ref7;
                      let newRefs = [];
                      let xfaData = null;
                      if (isPureXfa) {
                        xfaData = refs[0];
                        if (!xfaData) {
                          return stream.bytes;
                        }
                      } else {
                        newRefs = refs.flat(2);
                        if (newRefs.length === 0) {
                          return stream.bytes;
                        }
                      }
                      const xfa = acroForm instanceof _primitives.Dict && acroForm.get("XFA") || null;
                      let xfaDatasetsRef = null;
                      let hasXfaDatasetsEntry = false;
                      if (Array.isArray(xfa)) {
                        for (let i = 0, ii = xfa.length; i < ii; i += 2) {
                          if (xfa[i] === "datasets") {
                            xfaDatasetsRef = xfa[i + 1];
                            acroFormRef = null;
                            hasXfaDatasetsEntry = true;
                          }
                        }
                        if (xfaDatasetsRef === null) {
                          xfaDatasetsRef = xref.getNewRef();
                        }
                      } else if (xfa) {
                        acroFormRef = null;
                        (0, _util.warn)("Unsupported XFA type.");
                      }
                      let newXrefInfo = /* @__PURE__ */ Object.create(null);
                      if (xref.trailer) {
                        const infoObj = /* @__PURE__ */ Object.create(null);
                        const xrefInfo = xref.trailer.get("Info") || null;
                        if (xrefInfo instanceof _primitives.Dict) {
                          xrefInfo.forEach((key, value) => {
                            if (typeof value === "string") {
                              infoObj[key] = (0, _util.stringToPDFString)(value);
                            }
                          });
                        }
                        newXrefInfo = {
                          rootRef: xref.trailer.getRaw("Root") || null,
                          encryptRef: xref.trailer.getRaw("Encrypt") || null,
                          newRef: xref.getNewRef(),
                          infoRef: xref.trailer.getRaw("Info") || null,
                          info: infoObj,
                          fileIds: xref.trailer.get("ID") || null,
                          startXRef,
                          filename
                        };
                      }
                      xref.resetNewRef();
                      return (0, _writer.incrementalUpdate)({
                        originalData: stream.bytes,
                        xrefInfo: newXrefInfo,
                        newRefs,
                        xref,
                        hasXfa: !!xfa,
                        xfaDatasetsRef,
                        hasXfaDatasetsEntry,
                        acroFormRef,
                        acroForm,
                        xfaData
                      });
                    });
                  });
                  handler.on("GetOperatorList", /* @__PURE__ */ __name(function wphSetupRenderPage(data, sink) {
                    const pageIndex = data.pageIndex;
                    pdfManager.getPage(pageIndex).then(function(page) {
                      const task = new WorkerTask(`GetOperatorList: page ${pageIndex}`);
                      startWorkerTask(task);
                      const start = verbosity >= _util.VerbosityLevel.INFOS ? Date.now() : 0;
                      page.getOperatorList({
                        handler,
                        sink,
                        task,
                        intent: data.intent,
                        cacheKey: data.cacheKey,
                        annotationStorage: data.annotationStorage
                      }).then(function(operatorListInfo) {
                        finishWorkerTask(task);
                        if (start) {
                          (0, _util.info)(`page=${pageIndex + 1} - getOperatorList: time=${Date.now() - start}ms, len=${operatorListInfo.length}`);
                        }
                        sink.close();
                      }, function(reason) {
                        finishWorkerTask(task);
                        if (task.terminated) {
                          return;
                        }
                        handler.send("UnsupportedFeature", {
                          featureId: _util.UNSUPPORTED_FEATURES.errorOperatorList
                        });
                        sink.error(reason);
                      });
                    });
                  }, "wphSetupRenderPage"));
                  handler.on("GetTextContent", /* @__PURE__ */ __name(function wphExtractText(data, sink) {
                    const pageIndex = data.pageIndex;
                    pdfManager.getPage(pageIndex).then(function(page) {
                      const task = new WorkerTask("GetTextContent: page " + pageIndex);
                      startWorkerTask(task);
                      const start = verbosity >= _util.VerbosityLevel.INFOS ? Date.now() : 0;
                      page.extractTextContent({
                        handler,
                        task,
                        sink,
                        includeMarkedContent: data.includeMarkedContent,
                        combineTextItems: data.combineTextItems
                      }).then(function() {
                        finishWorkerTask(task);
                        if (start) {
                          (0, _util.info)(`page=${pageIndex + 1} - getTextContent: time=${Date.now() - start}ms`);
                        }
                        sink.close();
                      }, function(reason) {
                        finishWorkerTask(task);
                        if (task.terminated) {
                          return;
                        }
                        sink.error(reason);
                      });
                    });
                  }, "wphExtractText"));
                  handler.on("GetStructTree", /* @__PURE__ */ __name(function wphGetStructTree(data) {
                    return pdfManager.getPage(data.pageIndex).then(function(page) {
                      return pdfManager.ensure(page, "getStructTree");
                    });
                  }, "wphGetStructTree"));
                  handler.on("FontFallback", function(data) {
                    return pdfManager.fontFallback(data.id, handler);
                  });
                  handler.on("Cleanup", /* @__PURE__ */ __name(function wphCleanup(data) {
                    return pdfManager.cleanup(true);
                  }, "wphCleanup"));
                  handler.on("Terminate", /* @__PURE__ */ __name(function wphTerminate(data) {
                    terminated = true;
                    const waitOn = [];
                    if (pdfManager) {
                      pdfManager.terminate(new _util.AbortException("Worker was terminated."));
                      const cleanupPromise = pdfManager.cleanup();
                      waitOn.push(cleanupPromise);
                      pdfManager = null;
                    } else {
                      (0, _cleanup_helper.clearGlobalCaches)();
                    }
                    if (cancelXHRs) {
                      cancelXHRs(new _util.AbortException("Worker was terminated."));
                    }
                    for (const task of WorkerTasks) {
                      waitOn.push(task.finished);
                      task.terminate();
                    }
                    return Promise.all(waitOn).then(function() {
                      handler.destroy();
                      handler = null;
                    });
                  }, "wphTerminate"));
                  handler.on("Ready", /* @__PURE__ */ __name(function wphReady(data) {
                    setupDoc(docParams);
                    docParams = null;
                  }, "wphReady"));
                  return workerHandlerName;
                }
                static initializeFromPort(port) {
                  const handler = new _message_handler.MessageHandler("worker", "main", port);
                  _WorkerMessageHandler.setup(handler, port);
                  handler.send("ready", null);
                }
              };
              __name(_WorkerMessageHandler, "WorkerMessageHandler");
              let WorkerMessageHandler = _WorkerMessageHandler;
              exports2.WorkerMessageHandler = WorkerMessageHandler;
              function isMessagePort(maybePort) {
                return typeof maybePort.postMessage === "function" && "onmessage" in maybePort;
              }
              __name(isMessagePort, "isMessagePort");
              if (typeof window === "undefined" && !_is_node.isNodeJS && typeof self !== "undefined" && isMessagePort(self)) {
                WorkerMessageHandler.initializeFromPort(self);
              }
            },
            /* 2 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.VerbosityLevel = exports2.Util = exports2.UnknownErrorException = exports2.UnexpectedResponseException = exports2.UNSUPPORTED_FEATURES = exports2.TextRenderingMode = exports2.StreamType = exports2.RenderingIntentFlag = exports2.PermissionFlag = exports2.PasswordResponses = exports2.PasswordException = exports2.PageActionEventType = exports2.OPS = exports2.MissingPDFException = exports2.LINE_FACTOR = exports2.LINE_DESCENT_FACTOR = exports2.InvalidPDFException = exports2.ImageKind = exports2.IDENTITY_MATRIX = exports2.FormatError = exports2.FontType = exports2.FeatureTest = exports2.FONT_IDENTITY_MATRIX = exports2.DocumentActionEventType = exports2.CMapCompressionType = exports2.BaseException = exports2.AnnotationType = exports2.AnnotationStateModelType = exports2.AnnotationReviewState = exports2.AnnotationReplyType = exports2.AnnotationMode = exports2.AnnotationMarkedState = exports2.AnnotationFlag = exports2.AnnotationFieldFlag = exports2.AnnotationEditorType = exports2.AnnotationEditorPrefix = exports2.AnnotationEditorParamsType = exports2.AnnotationBorderStyleType = exports2.AnnotationActionEventType = exports2.AbortException = void 0;
              exports2.arrayByteLength = arrayByteLength;
              exports2.arraysToBytes = arraysToBytes;
              exports2.assert = assert;
              exports2.bytesToString = bytesToString;
              exports2.createPromiseCapability = createPromiseCapability;
              exports2.createValidAbsoluteUrl = createValidAbsoluteUrl;
              exports2.escapeString = escapeString;
              exports2.getModificationDate = getModificationDate;
              exports2.getVerbosityLevel = getVerbosityLevel;
              exports2.info = info;
              exports2.isArrayBuffer = isArrayBuffer;
              exports2.isArrayEqual = isArrayEqual;
              exports2.isAscii = isAscii;
              exports2.objectFromMap = objectFromMap;
              exports2.objectSize = objectSize;
              exports2.setVerbosityLevel = setVerbosityLevel;
              exports2.shadow = shadow;
              exports2.string32 = string32;
              exports2.stringToBytes = stringToBytes;
              exports2.stringToPDFString = stringToPDFString;
              exports2.stringToUTF16BEString = stringToUTF16BEString;
              exports2.stringToUTF8String = stringToUTF8String;
              exports2.unreachable = unreachable;
              exports2.utf8StringToString = utf8StringToString;
              exports2.warn = warn;
              __w_pdfjs_require__2(3);
              const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
              exports2.IDENTITY_MATRIX = IDENTITY_MATRIX;
              const FONT_IDENTITY_MATRIX = [1e-3, 0, 0, 1e-3, 0, 0];
              exports2.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
              const LINE_FACTOR = 1.35;
              exports2.LINE_FACTOR = LINE_FACTOR;
              const LINE_DESCENT_FACTOR = 0.35;
              exports2.LINE_DESCENT_FACTOR = LINE_DESCENT_FACTOR;
              const RenderingIntentFlag = {
                ANY: 1,
                DISPLAY: 2,
                PRINT: 4,
                ANNOTATIONS_FORMS: 16,
                ANNOTATIONS_STORAGE: 32,
                ANNOTATIONS_DISABLE: 64,
                OPLIST: 256
              };
              exports2.RenderingIntentFlag = RenderingIntentFlag;
              const AnnotationMode = {
                DISABLE: 0,
                ENABLE: 1,
                ENABLE_FORMS: 2,
                ENABLE_STORAGE: 3
              };
              exports2.AnnotationMode = AnnotationMode;
              const AnnotationEditorPrefix = "pdfjs_internal_editor_";
              exports2.AnnotationEditorPrefix = AnnotationEditorPrefix;
              const AnnotationEditorType = {
                DISABLE: -1,
                NONE: 0,
                FREETEXT: 3,
                INK: 15
              };
              exports2.AnnotationEditorType = AnnotationEditorType;
              const AnnotationEditorParamsType = {
                FREETEXT_SIZE: 1,
                FREETEXT_COLOR: 2,
                FREETEXT_OPACITY: 3,
                INK_COLOR: 11,
                INK_THICKNESS: 12,
                INK_OPACITY: 13
              };
              exports2.AnnotationEditorParamsType = AnnotationEditorParamsType;
              const PermissionFlag = {
                PRINT: 4,
                MODIFY_CONTENTS: 8,
                COPY: 16,
                MODIFY_ANNOTATIONS: 32,
                FILL_INTERACTIVE_FORMS: 256,
                COPY_FOR_ACCESSIBILITY: 512,
                ASSEMBLE: 1024,
                PRINT_HIGH_QUALITY: 2048
              };
              exports2.PermissionFlag = PermissionFlag;
              const TextRenderingMode = {
                FILL: 0,
                STROKE: 1,
                FILL_STROKE: 2,
                INVISIBLE: 3,
                FILL_ADD_TO_PATH: 4,
                STROKE_ADD_TO_PATH: 5,
                FILL_STROKE_ADD_TO_PATH: 6,
                ADD_TO_PATH: 7,
                FILL_STROKE_MASK: 3,
                ADD_TO_PATH_FLAG: 4
              };
              exports2.TextRenderingMode = TextRenderingMode;
              const ImageKind = {
                GRAYSCALE_1BPP: 1,
                RGB_24BPP: 2,
                RGBA_32BPP: 3
              };
              exports2.ImageKind = ImageKind;
              const AnnotationType = {
                TEXT: 1,
                LINK: 2,
                FREETEXT: 3,
                LINE: 4,
                SQUARE: 5,
                CIRCLE: 6,
                POLYGON: 7,
                POLYLINE: 8,
                HIGHLIGHT: 9,
                UNDERLINE: 10,
                SQUIGGLY: 11,
                STRIKEOUT: 12,
                STAMP: 13,
                CARET: 14,
                INK: 15,
                POPUP: 16,
                FILEATTACHMENT: 17,
                SOUND: 18,
                MOVIE: 19,
                WIDGET: 20,
                SCREEN: 21,
                PRINTERMARK: 22,
                TRAPNET: 23,
                WATERMARK: 24,
                THREED: 25,
                REDACT: 26
              };
              exports2.AnnotationType = AnnotationType;
              const AnnotationStateModelType = {
                MARKED: "Marked",
                REVIEW: "Review"
              };
              exports2.AnnotationStateModelType = AnnotationStateModelType;
              const AnnotationMarkedState = {
                MARKED: "Marked",
                UNMARKED: "Unmarked"
              };
              exports2.AnnotationMarkedState = AnnotationMarkedState;
              const AnnotationReviewState = {
                ACCEPTED: "Accepted",
                REJECTED: "Rejected",
                CANCELLED: "Cancelled",
                COMPLETED: "Completed",
                NONE: "None"
              };
              exports2.AnnotationReviewState = AnnotationReviewState;
              const AnnotationReplyType = {
                GROUP: "Group",
                REPLY: "R"
              };
              exports2.AnnotationReplyType = AnnotationReplyType;
              const AnnotationFlag = {
                INVISIBLE: 1,
                HIDDEN: 2,
                PRINT: 4,
                NOZOOM: 8,
                NOROTATE: 16,
                NOVIEW: 32,
                READONLY: 64,
                LOCKED: 128,
                TOGGLENOVIEW: 256,
                LOCKEDCONTENTS: 512
              };
              exports2.AnnotationFlag = AnnotationFlag;
              const AnnotationFieldFlag = {
                READONLY: 1,
                REQUIRED: 2,
                NOEXPORT: 4,
                MULTILINE: 4096,
                PASSWORD: 8192,
                NOTOGGLETOOFF: 16384,
                RADIO: 32768,
                PUSHBUTTON: 65536,
                COMBO: 131072,
                EDIT: 262144,
                SORT: 524288,
                FILESELECT: 1048576,
                MULTISELECT: 2097152,
                DONOTSPELLCHECK: 4194304,
                DONOTSCROLL: 8388608,
                COMB: 16777216,
                RICHTEXT: 33554432,
                RADIOSINUNISON: 33554432,
                COMMITONSELCHANGE: 67108864
              };
              exports2.AnnotationFieldFlag = AnnotationFieldFlag;
              const AnnotationBorderStyleType = {
                SOLID: 1,
                DASHED: 2,
                BEVELED: 3,
                INSET: 4,
                UNDERLINE: 5
              };
              exports2.AnnotationBorderStyleType = AnnotationBorderStyleType;
              const AnnotationActionEventType = {
                E: "Mouse Enter",
                X: "Mouse Exit",
                D: "Mouse Down",
                U: "Mouse Up",
                Fo: "Focus",
                Bl: "Blur",
                PO: "PageOpen",
                PC: "PageClose",
                PV: "PageVisible",
                PI: "PageInvisible",
                K: "Keystroke",
                F: "Format",
                V: "Validate",
                C: "Calculate"
              };
              exports2.AnnotationActionEventType = AnnotationActionEventType;
              const DocumentActionEventType = {
                WC: "WillClose",
                WS: "WillSave",
                DS: "DidSave",
                WP: "WillPrint",
                DP: "DidPrint"
              };
              exports2.DocumentActionEventType = DocumentActionEventType;
              const PageActionEventType = {
                O: "PageOpen",
                C: "PageClose"
              };
              exports2.PageActionEventType = PageActionEventType;
              const StreamType = {
                UNKNOWN: "UNKNOWN",
                FLATE: "FLATE",
                LZW: "LZW",
                DCT: "DCT",
                JPX: "JPX",
                JBIG: "JBIG",
                A85: "A85",
                AHX: "AHX",
                CCF: "CCF",
                RLX: "RLX"
              };
              exports2.StreamType = StreamType;
              const FontType = {
                UNKNOWN: "UNKNOWN",
                TYPE1: "TYPE1",
                TYPE1STANDARD: "TYPE1STANDARD",
                TYPE1C: "TYPE1C",
                CIDFONTTYPE0: "CIDFONTTYPE0",
                CIDFONTTYPE0C: "CIDFONTTYPE0C",
                TRUETYPE: "TRUETYPE",
                CIDFONTTYPE2: "CIDFONTTYPE2",
                TYPE3: "TYPE3",
                OPENTYPE: "OPENTYPE",
                TYPE0: "TYPE0",
                MMTYPE1: "MMTYPE1"
              };
              exports2.FontType = FontType;
              const VerbosityLevel = {
                ERRORS: 0,
                WARNINGS: 1,
                INFOS: 5
              };
              exports2.VerbosityLevel = VerbosityLevel;
              const CMapCompressionType = {
                NONE: 0,
                BINARY: 1,
                STREAM: 2
              };
              exports2.CMapCompressionType = CMapCompressionType;
              const OPS = {
                dependency: 1,
                setLineWidth: 2,
                setLineCap: 3,
                setLineJoin: 4,
                setMiterLimit: 5,
                setDash: 6,
                setRenderingIntent: 7,
                setFlatness: 8,
                setGState: 9,
                save: 10,
                restore: 11,
                transform: 12,
                moveTo: 13,
                lineTo: 14,
                curveTo: 15,
                curveTo2: 16,
                curveTo3: 17,
                closePath: 18,
                rectangle: 19,
                stroke: 20,
                closeStroke: 21,
                fill: 22,
                eoFill: 23,
                fillStroke: 24,
                eoFillStroke: 25,
                closeFillStroke: 26,
                closeEOFillStroke: 27,
                endPath: 28,
                clip: 29,
                eoClip: 30,
                beginText: 31,
                endText: 32,
                setCharSpacing: 33,
                setWordSpacing: 34,
                setHScale: 35,
                setLeading: 36,
                setFont: 37,
                setTextRenderingMode: 38,
                setTextRise: 39,
                moveText: 40,
                setLeadingMoveText: 41,
                setTextMatrix: 42,
                nextLine: 43,
                showText: 44,
                showSpacedText: 45,
                nextLineShowText: 46,
                nextLineSetSpacingShowText: 47,
                setCharWidth: 48,
                setCharWidthAndBounds: 49,
                setStrokeColorSpace: 50,
                setFillColorSpace: 51,
                setStrokeColor: 52,
                setStrokeColorN: 53,
                setFillColor: 54,
                setFillColorN: 55,
                setStrokeGray: 56,
                setFillGray: 57,
                setStrokeRGBColor: 58,
                setFillRGBColor: 59,
                setStrokeCMYKColor: 60,
                setFillCMYKColor: 61,
                shadingFill: 62,
                beginInlineImage: 63,
                beginImageData: 64,
                endInlineImage: 65,
                paintXObject: 66,
                markPoint: 67,
                markPointProps: 68,
                beginMarkedContent: 69,
                beginMarkedContentProps: 70,
                endMarkedContent: 71,
                beginCompat: 72,
                endCompat: 73,
                paintFormXObjectBegin: 74,
                paintFormXObjectEnd: 75,
                beginGroup: 76,
                endGroup: 77,
                beginAnnotations: 78,
                endAnnotations: 79,
                beginAnnotation: 80,
                endAnnotation: 81,
                paintJpegXObject: 82,
                paintImageMaskXObject: 83,
                paintImageMaskXObjectGroup: 84,
                paintImageXObject: 85,
                paintInlineImageXObject: 86,
                paintInlineImageXObjectGroup: 87,
                paintImageXObjectRepeat: 88,
                paintImageMaskXObjectRepeat: 89,
                paintSolidColorImageMask: 90,
                constructPath: 91
              };
              exports2.OPS = OPS;
              const UNSUPPORTED_FEATURES = {
                unknown: "unknown",
                forms: "forms",
                javaScript: "javaScript",
                signatures: "signatures",
                smask: "smask",
                shadingPattern: "shadingPattern",
                font: "font",
                errorTilingPattern: "errorTilingPattern",
                errorExtGState: "errorExtGState",
                errorXObject: "errorXObject",
                errorFontLoadType3: "errorFontLoadType3",
                errorFontState: "errorFontState",
                errorFontMissing: "errorFontMissing",
                errorFontTranslate: "errorFontTranslate",
                errorColorSpace: "errorColorSpace",
                errorOperatorList: "errorOperatorList",
                errorFontToUnicode: "errorFontToUnicode",
                errorFontLoadNative: "errorFontLoadNative",
                errorFontBuildPath: "errorFontBuildPath",
                errorFontGetPath: "errorFontGetPath",
                errorMarkedContent: "errorMarkedContent",
                errorContentSubStream: "errorContentSubStream"
              };
              exports2.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
              const PasswordResponses = {
                NEED_PASSWORD: 1,
                INCORRECT_PASSWORD: 2
              };
              exports2.PasswordResponses = PasswordResponses;
              let verbosity = VerbosityLevel.WARNINGS;
              function setVerbosityLevel(level) {
                if (Number.isInteger(level)) {
                  verbosity = level;
                }
              }
              __name(setVerbosityLevel, "setVerbosityLevel");
              function getVerbosityLevel() {
                return verbosity;
              }
              __name(getVerbosityLevel, "getVerbosityLevel");
              function info(msg) {
                if (verbosity >= VerbosityLevel.INFOS) {
                  console.log(`Info: ${msg}`);
                }
              }
              __name(info, "info");
              function warn(msg) {
                if (verbosity >= VerbosityLevel.WARNINGS) {
                  console.log(`Warning: ${msg}`);
                }
              }
              __name(warn, "warn");
              function unreachable(msg) {
                throw new Error(msg);
              }
              __name(unreachable, "unreachable");
              function assert(cond, msg) {
                if (!cond) {
                  unreachable(msg);
                }
              }
              __name(assert, "assert");
              function _isValidProtocol(url) {
                if (!url) {
                  return false;
                }
                switch (url.protocol) {
                  case "http:":
                  case "https:":
                  case "ftp:":
                  case "mailto:":
                  case "tel:":
                    return true;
                  default:
                    return false;
                }
              }
              __name(_isValidProtocol, "_isValidProtocol");
              function createValidAbsoluteUrl(url) {
                let baseUrl = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                if (!url) {
                  return null;
                }
                try {
                  if (options && typeof url === "string") {
                    if (options.addDefaultProtocol && url.startsWith("www.")) {
                      const dots = url.match(/\./g);
                      if (dots && dots.length >= 2) {
                        url = `http://${url}`;
                      }
                    }
                    if (options.tryConvertEncoding) {
                      try {
                        url = stringToUTF8String(url);
                      } catch (ex) {
                      }
                    }
                  }
                  const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);
                  if (_isValidProtocol(absoluteUrl)) {
                    return absoluteUrl;
                  }
                } catch (ex) {
                }
                return null;
              }
              __name(createValidAbsoluteUrl, "createValidAbsoluteUrl");
              function shadow(obj, prop, value) {
                Object.defineProperty(obj, prop, {
                  value,
                  enumerable: true,
                  configurable: true,
                  writable: false
                });
                return value;
              }
              __name(shadow, "shadow");
              const BaseException = (/* @__PURE__ */ __name(function BaseExceptionClosure() {
                function BaseException2(message, name) {
                  if (this.constructor === BaseException2) {
                    unreachable("Cannot initialize BaseException.");
                  }
                  this.message = message;
                  this.name = name;
                }
                __name(BaseException2, "BaseException");
                BaseException2.prototype = new Error();
                BaseException2.constructor = BaseException2;
                return BaseException2;
              }, "BaseExceptionClosure"))();
              exports2.BaseException = BaseException;
              const _PasswordException = class _PasswordException extends BaseException {
                constructor(msg, code) {
                  super(msg, "PasswordException");
                  this.code = code;
                }
              };
              __name(_PasswordException, "PasswordException");
              let PasswordException = _PasswordException;
              exports2.PasswordException = PasswordException;
              const _UnknownErrorException = class _UnknownErrorException extends BaseException {
                constructor(msg, details) {
                  super(msg, "UnknownErrorException");
                  this.details = details;
                }
              };
              __name(_UnknownErrorException, "UnknownErrorException");
              let UnknownErrorException = _UnknownErrorException;
              exports2.UnknownErrorException = UnknownErrorException;
              const _InvalidPDFException = class _InvalidPDFException extends BaseException {
                constructor(msg) {
                  super(msg, "InvalidPDFException");
                }
              };
              __name(_InvalidPDFException, "InvalidPDFException");
              let InvalidPDFException = _InvalidPDFException;
              exports2.InvalidPDFException = InvalidPDFException;
              const _MissingPDFException = class _MissingPDFException extends BaseException {
                constructor(msg) {
                  super(msg, "MissingPDFException");
                }
              };
              __name(_MissingPDFException, "MissingPDFException");
              let MissingPDFException = _MissingPDFException;
              exports2.MissingPDFException = MissingPDFException;
              const _UnexpectedResponseException = class _UnexpectedResponseException extends BaseException {
                constructor(msg, status) {
                  super(msg, "UnexpectedResponseException");
                  this.status = status;
                }
              };
              __name(_UnexpectedResponseException, "UnexpectedResponseException");
              let UnexpectedResponseException = _UnexpectedResponseException;
              exports2.UnexpectedResponseException = UnexpectedResponseException;
              const _FormatError = class _FormatError extends BaseException {
                constructor(msg) {
                  super(msg, "FormatError");
                }
              };
              __name(_FormatError, "FormatError");
              let FormatError = _FormatError;
              exports2.FormatError = FormatError;
              const _AbortException = class _AbortException extends BaseException {
                constructor(msg) {
                  super(msg, "AbortException");
                }
              };
              __name(_AbortException, "AbortException");
              let AbortException = _AbortException;
              exports2.AbortException = AbortException;
              function bytesToString(bytes) {
                if (typeof bytes !== "object" || bytes === null || bytes.length === void 0) {
                  unreachable("Invalid argument for bytesToString");
                }
                const length = bytes.length;
                const MAX_ARGUMENT_COUNT = 8192;
                if (length < MAX_ARGUMENT_COUNT) {
                  return String.fromCharCode.apply(null, bytes);
                }
                const strBuf = [];
                for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
                  const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
                  const chunk = bytes.subarray(i, chunkEnd);
                  strBuf.push(String.fromCharCode.apply(null, chunk));
                }
                return strBuf.join("");
              }
              __name(bytesToString, "bytesToString");
              function stringToBytes(str) {
                if (typeof str !== "string") {
                  unreachable("Invalid argument for stringToBytes");
                }
                const length = str.length;
                const bytes = new Uint8Array(length);
                for (let i = 0; i < length; ++i) {
                  bytes[i] = str.charCodeAt(i) & 255;
                }
                return bytes;
              }
              __name(stringToBytes, "stringToBytes");
              function arrayByteLength(arr) {
                if (arr.length !== void 0) {
                  return arr.length;
                }
                if (arr.byteLength !== void 0) {
                  return arr.byteLength;
                }
                unreachable("Invalid argument for arrayByteLength");
              }
              __name(arrayByteLength, "arrayByteLength");
              function arraysToBytes(arr) {
                const length = arr.length;
                if (length === 1 && arr[0] instanceof Uint8Array) {
                  return arr[0];
                }
                let resultLength = 0;
                for (let i = 0; i < length; i++) {
                  resultLength += arrayByteLength(arr[i]);
                }
                let pos = 0;
                const data = new Uint8Array(resultLength);
                for (let i = 0; i < length; i++) {
                  let item = arr[i];
                  if (!(item instanceof Uint8Array)) {
                    if (typeof item === "string") {
                      item = stringToBytes(item);
                    } else {
                      item = new Uint8Array(item);
                    }
                  }
                  const itemLength = item.byteLength;
                  data.set(item, pos);
                  pos += itemLength;
                }
                return data;
              }
              __name(arraysToBytes, "arraysToBytes");
              function string32(value) {
                return String.fromCharCode(value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255);
              }
              __name(string32, "string32");
              function objectSize(obj) {
                return Object.keys(obj).length;
              }
              __name(objectSize, "objectSize");
              function objectFromMap(map) {
                const obj = /* @__PURE__ */ Object.create(null);
                for (const [key, value] of map) {
                  obj[key] = value;
                }
                return obj;
              }
              __name(objectFromMap, "objectFromMap");
              function isLittleEndian() {
                const buffer8 = new Uint8Array(4);
                buffer8[0] = 1;
                const view32 = new Uint32Array(buffer8.buffer, 0, 1);
                return view32[0] === 1;
              }
              __name(isLittleEndian, "isLittleEndian");
              function isEvalSupported() {
                try {
                  new Function("");
                  return true;
                } catch (e) {
                  return false;
                }
              }
              __name(isEvalSupported, "isEvalSupported");
              const _FeatureTest = class _FeatureTest {
                static get isLittleEndian() {
                  return shadow(this, "isLittleEndian", isLittleEndian());
                }
                static get isEvalSupported() {
                  return shadow(this, "isEvalSupported", isEvalSupported());
                }
                static get isOffscreenCanvasSupported() {
                  return shadow(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas !== "undefined");
                }
              };
              __name(_FeatureTest, "FeatureTest");
              let FeatureTest = _FeatureTest;
              exports2.FeatureTest = FeatureTest;
              const hexNumbers = [...Array(256).keys()].map((n) => n.toString(16).padStart(2, "0"));
              const _Util = class _Util {
                static makeHexColor(r, g, b) {
                  return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;
                }
                static scaleMinMax(transform, minMax) {
                  let temp;
                  if (transform[0]) {
                    if (transform[0] < 0) {
                      temp = minMax[0];
                      minMax[0] = minMax[1];
                      minMax[1] = temp;
                    }
                    minMax[0] *= transform[0];
                    minMax[1] *= transform[0];
                    if (transform[3] < 0) {
                      temp = minMax[2];
                      minMax[2] = minMax[3];
                      minMax[3] = temp;
                    }
                    minMax[2] *= transform[3];
                    minMax[3] *= transform[3];
                  } else {
                    temp = minMax[0];
                    minMax[0] = minMax[2];
                    minMax[2] = temp;
                    temp = minMax[1];
                    minMax[1] = minMax[3];
                    minMax[3] = temp;
                    if (transform[1] < 0) {
                      temp = minMax[2];
                      minMax[2] = minMax[3];
                      minMax[3] = temp;
                    }
                    minMax[2] *= transform[1];
                    minMax[3] *= transform[1];
                    if (transform[2] < 0) {
                      temp = minMax[0];
                      minMax[0] = minMax[1];
                      minMax[1] = temp;
                    }
                    minMax[0] *= transform[2];
                    minMax[1] *= transform[2];
                  }
                  minMax[0] += transform[4];
                  minMax[1] += transform[4];
                  minMax[2] += transform[5];
                  minMax[3] += transform[5];
                }
                static transform(m1, m2) {
                  return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
                }
                static applyTransform(p, m) {
                  const xt = p[0] * m[0] + p[1] * m[2] + m[4];
                  const yt = p[0] * m[1] + p[1] * m[3] + m[5];
                  return [xt, yt];
                }
                static applyInverseTransform(p, m) {
                  const d = m[0] * m[3] - m[1] * m[2];
                  const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
                  const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
                  return [xt, yt];
                }
                static getAxialAlignedBoundingBox(r, m) {
                  const p1 = _Util.applyTransform(r, m);
                  const p2 = _Util.applyTransform(r.slice(2, 4), m);
                  const p3 = _Util.applyTransform([r[0], r[3]], m);
                  const p4 = _Util.applyTransform([r[2], r[1]], m);
                  return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
                }
                static inverseTransform(m) {
                  const d = m[0] * m[3] - m[1] * m[2];
                  return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
                }
                static apply3dTransform(m, v) {
                  return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
                }
                static singularValueDecompose2dScale(m) {
                  const transpose = [m[0], m[2], m[1], m[3]];
                  const a = m[0] * transpose[0] + m[1] * transpose[2];
                  const b = m[0] * transpose[1] + m[1] * transpose[3];
                  const c = m[2] * transpose[0] + m[3] * transpose[2];
                  const d = m[2] * transpose[1] + m[3] * transpose[3];
                  const first = (a + d) / 2;
                  const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;
                  const sx = first + second || 1;
                  const sy = first - second || 1;
                  return [Math.sqrt(sx), Math.sqrt(sy)];
                }
                static normalizeRect(rect) {
                  const r = rect.slice(0);
                  if (rect[0] > rect[2]) {
                    r[0] = rect[2];
                    r[2] = rect[0];
                  }
                  if (rect[1] > rect[3]) {
                    r[1] = rect[3];
                    r[3] = rect[1];
                  }
                  return r;
                }
                static intersect(rect1, rect2) {
                  const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));
                  const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));
                  if (xLow > xHigh) {
                    return null;
                  }
                  const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));
                  const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));
                  if (yLow > yHigh) {
                    return null;
                  }
                  return [xLow, yLow, xHigh, yHigh];
                }
                static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) {
                  const tvalues = [], bounds = [[], []];
                  let a, b, c, t, t1, t2, b2ac, sqrtb2ac;
                  for (let i = 0; i < 2; ++i) {
                    if (i === 0) {
                      b = 6 * x0 - 12 * x1 + 6 * x2;
                      a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
                      c = 3 * x1 - 3 * x0;
                    } else {
                      b = 6 * y0 - 12 * y1 + 6 * y2;
                      a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
                      c = 3 * y1 - 3 * y0;
                    }
                    if (Math.abs(a) < 1e-12) {
                      if (Math.abs(b) < 1e-12) {
                        continue;
                      }
                      t = -c / b;
                      if (0 < t && t < 1) {
                        tvalues.push(t);
                      }
                      continue;
                    }
                    b2ac = b * b - 4 * c * a;
                    sqrtb2ac = Math.sqrt(b2ac);
                    if (b2ac < 0) {
                      continue;
                    }
                    t1 = (-b + sqrtb2ac) / (2 * a);
                    if (0 < t1 && t1 < 1) {
                      tvalues.push(t1);
                    }
                    t2 = (-b - sqrtb2ac) / (2 * a);
                    if (0 < t2 && t2 < 1) {
                      tvalues.push(t2);
                    }
                  }
                  let j = tvalues.length, mt;
                  const jlen = j;
                  while (j--) {
                    t = tvalues[j];
                    mt = 1 - t;
                    bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
                    bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
                  }
                  bounds[0][jlen] = x0;
                  bounds[1][jlen] = y0;
                  bounds[0][jlen + 1] = x3;
                  bounds[1][jlen + 1] = y3;
                  bounds[0].length = bounds[1].length = jlen + 2;
                  return [Math.min(...bounds[0]), Math.min(...bounds[1]), Math.max(...bounds[0]), Math.max(...bounds[1])];
                }
              };
              __name(_Util, "Util");
              let Util = _Util;
              exports2.Util = Util;
              const PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
              function stringToPDFString(str) {
                if (str[0] >= "Ã¯") {
                  let encoding;
                  if (str[0] === "Ã¾" && str[1] === "Ã¿") {
                    encoding = "utf-16be";
                  } else if (str[0] === "Ã¿" && str[1] === "Ã¾") {
                    encoding = "utf-16le";
                  } else if (str[0] === "Ã¯" && str[1] === "Â»" && str[2] === "Â¿") {
                    encoding = "utf-8";
                  }
                  if (encoding) {
                    try {
                      const decoder = new TextDecoder(encoding, {
                        fatal: true
                      });
                      const buffer = stringToBytes(str);
                      return decoder.decode(buffer);
                    } catch (ex) {
                      warn(`stringToPDFString: "${ex}".`);
                    }
                  }
                }
                const strBuf = [];
                for (let i = 0, ii = str.length; i < ii; i++) {
                  const code = PDFStringTranslateTable[str.charCodeAt(i)];
                  strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
                }
                return strBuf.join("");
              }
              __name(stringToPDFString, "stringToPDFString");
              function escapeString(str) {
                return str.replace(/([()\\\n\r])/g, (match) => {
                  if (match === "\n") {
                    return "\\n";
                  } else if (match === "\r") {
                    return "\\r";
                  }
                  return `\\${match}`;
                });
              }
              __name(escapeString, "escapeString");
              function isAscii(str) {
                return /^[\x00-\x7F]*$/.test(str);
              }
              __name(isAscii, "isAscii");
              function stringToUTF16BEString(str) {
                const buf = ["Ã¾Ã¿"];
                for (let i = 0, ii = str.length; i < ii; i++) {
                  const char = str.charCodeAt(i);
                  buf.push(String.fromCharCode(char >> 8 & 255), String.fromCharCode(char & 255));
                }
                return buf.join("");
              }
              __name(stringToUTF16BEString, "stringToUTF16BEString");
              function stringToUTF8String(str) {
                return decodeURIComponent(escape(str));
              }
              __name(stringToUTF8String, "stringToUTF8String");
              function utf8StringToString(str) {
                return unescape(encodeURIComponent(str));
              }
              __name(utf8StringToString, "utf8StringToString");
              function isArrayBuffer(v) {
                return typeof v === "object" && v !== null && v.byteLength !== void 0;
              }
              __name(isArrayBuffer, "isArrayBuffer");
              function isArrayEqual(arr1, arr2) {
                if (arr1.length !== arr2.length) {
                  return false;
                }
                for (let i = 0, ii = arr1.length; i < ii; i++) {
                  if (arr1[i] !== arr2[i]) {
                    return false;
                  }
                }
                return true;
              }
              __name(isArrayEqual, "isArrayEqual");
              function getModificationDate() {
                let date = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : /* @__PURE__ */ new Date();
                const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, "0"), date.getUTCDate().toString().padStart(2, "0"), date.getUTCHours().toString().padStart(2, "0"), date.getUTCMinutes().toString().padStart(2, "0"), date.getUTCSeconds().toString().padStart(2, "0")];
                return buffer.join("");
              }
              __name(getModificationDate, "getModificationDate");
              function createPromiseCapability() {
                const capability = /* @__PURE__ */ Object.create(null);
                let isSettled = false;
                Object.defineProperty(capability, "settled", {
                  get() {
                    return isSettled;
                  }
                });
                capability.promise = new Promise(function(resolve, reject) {
                  capability.resolve = function(data) {
                    isSettled = true;
                    resolve(data);
                  };
                  capability.reject = function(reason) {
                    isSettled = true;
                    reject(reason);
                  };
                });
                return capability;
              }
              __name(createPromiseCapability, "createPromiseCapability");
            },
            /* 3 */
            /***/
            (__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var _is_node = __w_pdfjs_require__2(4);
              if (!globalThis._pdfjsCompatibilityChecked) {
                globalThis._pdfjsCompatibilityChecked = true;
                (/* @__PURE__ */ __name(function checkNodeBtoa() {
                  if (globalThis.btoa || !_is_node.isNodeJS) {
                    return;
                  }
                  globalThis.btoa = function(chars) {
                    return Buffer.from(chars, "binary").toString("base64");
                  };
                }, "checkNodeBtoa"))();
                (/* @__PURE__ */ __name(function checkNodeAtob() {
                  if (globalThis.atob || !_is_node.isNodeJS) {
                    return;
                  }
                  globalThis.atob = function(input) {
                    return Buffer.from(input, "base64").toString("binary");
                  };
                }, "checkNodeAtob"))();
                (/* @__PURE__ */ __name(function checkDOMMatrix() {
                  if (globalThis.DOMMatrix || !_is_node.isNodeJS) {
                    return;
                  }
                  globalThis.DOMMatrix = requireDommatrix();
                }, "checkDOMMatrix"))();
                (/* @__PURE__ */ __name(function checkReadableStream() {
                  if (globalThis.ReadableStream || !_is_node.isNodeJS) {
                    return;
                  }
                  globalThis.ReadableStream = requirePonyfill().ReadableStream;
                }, "checkReadableStream"))();
                (/* @__PURE__ */ __name(function checkArrayAt() {
                  if (Array.prototype.at) {
                    return;
                  }
                  __w_pdfjs_require__2(5);
                }, "checkArrayAt"))();
                (/* @__PURE__ */ __name(function checkTypedArrayAt() {
                  if (Uint8Array.prototype.at) {
                    return;
                  }
                  __w_pdfjs_require__2(77);
                }, "checkTypedArrayAt"))();
                (/* @__PURE__ */ __name(function checkStructuredClone() {
                  if (globalThis.structuredClone) {
                    return;
                  }
                  __w_pdfjs_require__2(87);
                }, "checkStructuredClone"))();
              }
            },
            /* 4 */
            /***/
            (__unused_webpack_module, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.isNodeJS = void 0;
              const isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
              exports2.isNodeJS = isNodeJS;
            },
            /* 5 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              __w_pdfjs_require__2(6);
              var entryUnbind = __w_pdfjs_require__2(76);
              module2.exports = entryUnbind("Array", "at");
            },
            /* 6 */
            /***/
            (__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var $ = __w_pdfjs_require__2(7);
              var toObject = __w_pdfjs_require__2(42);
              var lengthOfArrayLike = __w_pdfjs_require__2(66);
              var toIntegerOrInfinity = __w_pdfjs_require__2(64);
              var addToUnscopables = __w_pdfjs_require__2(71);
              $({
                target: "Array",
                proto: true
              }, {
                at: /* @__PURE__ */ __name(function at(index) {
                  var O = toObject(this);
                  var len = lengthOfArrayLike(O);
                  var relativeIndex = toIntegerOrInfinity(index);
                  var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
                  return k < 0 || k >= len ? void 0 : O[k];
                }, "at")
              });
              addToUnscopables("at");
            },
            /* 7 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var getOwnPropertyDescriptor = __w_pdfjs_require__2(9).f;
              var createNonEnumerableProperty = __w_pdfjs_require__2(46);
              var defineBuiltIn = __w_pdfjs_require__2(50);
              var defineGlobalProperty = __w_pdfjs_require__2(40);
              var copyConstructorProperties = __w_pdfjs_require__2(58);
              var isForced = __w_pdfjs_require__2(70);
              module2.exports = function(options, source) {
                var TARGET = options.target;
                var GLOBAL = options.global;
                var STATIC = options.stat;
                var FORCED, target, key, targetProperty, sourceProperty, descriptor;
                if (GLOBAL) {
                  target = global2;
                } else if (STATIC) {
                  target = global2[TARGET] || defineGlobalProperty(TARGET, {});
                } else {
                  target = (global2[TARGET] || {}).prototype;
                }
                if (target)
                  for (key in source) {
                    sourceProperty = source[key];
                    if (options.dontCallGetSet) {
                      descriptor = getOwnPropertyDescriptor(target, key);
                      targetProperty = descriptor && descriptor.value;
                    } else
                      targetProperty = target[key];
                    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
                    if (!FORCED && targetProperty !== void 0) {
                      if (typeof sourceProperty == typeof targetProperty)
                        continue;
                      copyConstructorProperties(sourceProperty, targetProperty);
                    }
                    if (options.sham || targetProperty && targetProperty.sham) {
                      createNonEnumerableProperty(sourceProperty, "sham", true);
                    }
                    defineBuiltIn(target, key, sourceProperty, options);
                  }
              };
            },
            /* 8 */
            /***/
            (module2) => {
              var check = /* @__PURE__ */ __name(function(it) {
                return it && it.Math == Math && it;
              }, "check");
              module2.exports = check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || function() {
                return this;
              }() || Function("return this")();
            },
            /* 9 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              var DESCRIPTORS = __w_pdfjs_require__2(10);
              var call = __w_pdfjs_require__2(12);
              var propertyIsEnumerableModule = __w_pdfjs_require__2(14);
              var createPropertyDescriptor = __w_pdfjs_require__2(15);
              var toIndexedObject = __w_pdfjs_require__2(16);
              var toPropertyKey = __w_pdfjs_require__2(21);
              var hasOwn = __w_pdfjs_require__2(41);
              var IE8_DOM_DEFINE = __w_pdfjs_require__2(44);
              var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
              exports2.f = DESCRIPTORS ? $getOwnPropertyDescriptor : /* @__PURE__ */ __name(function getOwnPropertyDescriptor(O, P) {
                O = toIndexedObject(O);
                P = toPropertyKey(P);
                if (IE8_DOM_DEFINE)
                  try {
                    return $getOwnPropertyDescriptor(O, P);
                  } catch (error) {
                  }
                if (hasOwn(O, P))
                  return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
              }, "getOwnPropertyDescriptor");
            },
            /* 10 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var fails = __w_pdfjs_require__2(11);
              module2.exports = !fails(function() {
                return Object.defineProperty({}, 1, {
                  get: function() {
                    return 7;
                  }
                })[1] != 7;
              });
            },
            /* 11 */
            /***/
            (module2) => {
              module2.exports = function(exec) {
                try {
                  return !!exec();
                } catch (error) {
                  return true;
                }
              };
            },
            /* 12 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var NATIVE_BIND = __w_pdfjs_require__2(13);
              var call = Function.prototype.call;
              module2.exports = NATIVE_BIND ? call.bind(call) : function() {
                return call.apply(call, arguments);
              };
            },
            /* 13 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var fails = __w_pdfjs_require__2(11);
              module2.exports = !fails(function() {
                var test = (function() {
                }).bind();
                return typeof test != "function" || test.hasOwnProperty("prototype");
              });
            },
            /* 14 */
            /***/
            (__unused_webpack_module, exports2) => {
              var $propertyIsEnumerable = {}.propertyIsEnumerable;
              var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
              var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
              exports2.f = NASHORN_BUG ? /* @__PURE__ */ __name(function propertyIsEnumerable(V) {
                var descriptor = getOwnPropertyDescriptor(this, V);
                return !!descriptor && descriptor.enumerable;
              }, "propertyIsEnumerable") : $propertyIsEnumerable;
            },
            /* 15 */
            /***/
            (module2) => {
              module2.exports = function(bitmap, value) {
                return {
                  enumerable: !(bitmap & 1),
                  configurable: !(bitmap & 2),
                  writable: !(bitmap & 4),
                  value
                };
              };
            },
            /* 16 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var IndexedObject = __w_pdfjs_require__2(17);
              var requireObjectCoercible = __w_pdfjs_require__2(20);
              module2.exports = function(it) {
                return IndexedObject(requireObjectCoercible(it));
              };
            },
            /* 17 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var uncurryThis = __w_pdfjs_require__2(18);
              var fails = __w_pdfjs_require__2(11);
              var classof = __w_pdfjs_require__2(19);
              var $Object = Object;
              var split = uncurryThis("".split);
              module2.exports = fails(function() {
                return !$Object("z").propertyIsEnumerable(0);
              }) ? function(it) {
                return classof(it) == "String" ? split(it, "") : $Object(it);
              } : $Object;
            },
            /* 18 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var NATIVE_BIND = __w_pdfjs_require__2(13);
              var FunctionPrototype = Function.prototype;
              var bind = FunctionPrototype.bind;
              var call = FunctionPrototype.call;
              var uncurryThis = NATIVE_BIND && bind.bind(call, call);
              module2.exports = NATIVE_BIND ? function(fn) {
                return fn && uncurryThis(fn);
              } : function(fn) {
                return fn && function() {
                  return call.apply(fn, arguments);
                };
              };
            },
            /* 19 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var uncurryThis = __w_pdfjs_require__2(18);
              var toString = uncurryThis({}.toString);
              var stringSlice = uncurryThis("".slice);
              module2.exports = function(it) {
                return stringSlice(toString(it), 8, -1);
              };
            },
            /* 20 */
            /***/
            (module2) => {
              var $TypeError = TypeError;
              module2.exports = function(it) {
                if (it == void 0)
                  throw $TypeError("Can't call method on " + it);
                return it;
              };
            },
            /* 21 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var toPrimitive = __w_pdfjs_require__2(22);
              var isSymbol = __w_pdfjs_require__2(25);
              module2.exports = function(argument) {
                var key = toPrimitive(argument, "string");
                return isSymbol(key) ? key : key + "";
              };
            },
            /* 22 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var call = __w_pdfjs_require__2(12);
              var isObject = __w_pdfjs_require__2(23);
              var isSymbol = __w_pdfjs_require__2(25);
              var getMethod = __w_pdfjs_require__2(32);
              var ordinaryToPrimitive = __w_pdfjs_require__2(35);
              var wellKnownSymbol = __w_pdfjs_require__2(36);
              var $TypeError = TypeError;
              var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
              module2.exports = function(input, pref) {
                if (!isObject(input) || isSymbol(input))
                  return input;
                var exoticToPrim = getMethod(input, TO_PRIMITIVE);
                var result;
                if (exoticToPrim) {
                  if (pref === void 0)
                    pref = "default";
                  result = call(exoticToPrim, input, pref);
                  if (!isObject(result) || isSymbol(result))
                    return result;
                  throw $TypeError("Can't convert object to primitive value");
                }
                if (pref === void 0)
                  pref = "number";
                return ordinaryToPrimitive(input, pref);
              };
            },
            /* 23 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var isCallable = __w_pdfjs_require__2(24);
              module2.exports = function(it) {
                return typeof it == "object" ? it !== null : isCallable(it);
              };
            },
            /* 24 */
            /***/
            (module2) => {
              module2.exports = function(argument) {
                return typeof argument == "function";
              };
            },
            /* 25 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var getBuiltIn = __w_pdfjs_require__2(26);
              var isCallable = __w_pdfjs_require__2(24);
              var isPrototypeOf = __w_pdfjs_require__2(27);
              var USE_SYMBOL_AS_UID = __w_pdfjs_require__2(28);
              var $Object = Object;
              module2.exports = USE_SYMBOL_AS_UID ? function(it) {
                return typeof it == "symbol";
              } : function(it) {
                var $Symbol = getBuiltIn("Symbol");
                return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
              };
            },
            /* 26 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var isCallable = __w_pdfjs_require__2(24);
              var aFunction = /* @__PURE__ */ __name(function(argument) {
                return isCallable(argument) ? argument : void 0;
              }, "aFunction");
              module2.exports = function(namespace, method) {
                return arguments.length < 2 ? aFunction(global2[namespace]) : global2[namespace] && global2[namespace][method];
              };
            },
            /* 27 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var uncurryThis = __w_pdfjs_require__2(18);
              module2.exports = uncurryThis({}.isPrototypeOf);
            },
            /* 28 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var NATIVE_SYMBOL = __w_pdfjs_require__2(29);
              module2.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
            },
            /* 29 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var V8_VERSION = __w_pdfjs_require__2(30);
              var fails = __w_pdfjs_require__2(11);
              module2.exports = !!Object.getOwnPropertySymbols && !fails(function() {
                var symbol = Symbol();
                return !String(symbol) || !(Object(symbol) instanceof Symbol) || !Symbol.sham && V8_VERSION && V8_VERSION < 41;
              });
            },
            /* 30 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var userAgent = __w_pdfjs_require__2(31);
              var process2 = global2.process;
              var Deno2 = global2.Deno;
              var versions = process2 && process2.versions || Deno2 && Deno2.version;
              var v8 = versions && versions.v8;
              var match, version;
              if (v8) {
                match = v8.split(".");
                version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
              }
              if (!version && userAgent) {
                match = userAgent.match(/Edge\/(\d+)/);
                if (!match || match[1] >= 74) {
                  match = userAgent.match(/Chrome\/(\d+)/);
                  if (match)
                    version = +match[1];
                }
              }
              module2.exports = version;
            },
            /* 31 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var getBuiltIn = __w_pdfjs_require__2(26);
              module2.exports = getBuiltIn("navigator", "userAgent") || "";
            },
            /* 32 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var aCallable = __w_pdfjs_require__2(33);
              module2.exports = function(V, P) {
                var func = V[P];
                return func == null ? void 0 : aCallable(func);
              };
            },
            /* 33 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var isCallable = __w_pdfjs_require__2(24);
              var tryToString = __w_pdfjs_require__2(34);
              var $TypeError = TypeError;
              module2.exports = function(argument) {
                if (isCallable(argument))
                  return argument;
                throw $TypeError(tryToString(argument) + " is not a function");
              };
            },
            /* 34 */
            /***/
            (module2) => {
              var $String = String;
              module2.exports = function(argument) {
                try {
                  return $String(argument);
                } catch (error) {
                  return "Object";
                }
              };
            },
            /* 35 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var call = __w_pdfjs_require__2(12);
              var isCallable = __w_pdfjs_require__2(24);
              var isObject = __w_pdfjs_require__2(23);
              var $TypeError = TypeError;
              module2.exports = function(input, pref) {
                var fn, val;
                if (pref === "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))
                  return val;
                if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input)))
                  return val;
                if (pref !== "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))
                  return val;
                throw $TypeError("Can't convert object to primitive value");
              };
            },
            /* 36 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var shared = __w_pdfjs_require__2(37);
              var hasOwn = __w_pdfjs_require__2(41);
              var uid = __w_pdfjs_require__2(43);
              var NATIVE_SYMBOL = __w_pdfjs_require__2(29);
              var USE_SYMBOL_AS_UID = __w_pdfjs_require__2(28);
              var WellKnownSymbolsStore = shared("wks");
              var Symbol2 = global2.Symbol;
              var symbolFor = Symbol2 && Symbol2["for"];
              var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
              module2.exports = function(name) {
                if (!hasOwn(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == "string")) {
                  var description = "Symbol." + name;
                  if (NATIVE_SYMBOL && hasOwn(Symbol2, name)) {
                    WellKnownSymbolsStore[name] = Symbol2[name];
                  } else if (USE_SYMBOL_AS_UID && symbolFor) {
                    WellKnownSymbolsStore[name] = symbolFor(description);
                  } else {
                    WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
                  }
                }
                return WellKnownSymbolsStore[name];
              };
            },
            /* 37 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var IS_PURE = __w_pdfjs_require__2(38);
              var store = __w_pdfjs_require__2(39);
              (module2.exports = function(key, value) {
                return store[key] || (store[key] = value !== void 0 ? value : {});
              })("versions", []).push({
                version: "3.24.1",
                mode: IS_PURE ? "pure" : "global",
                copyright: "Â© 2014-2022 Denis Pushkarev (zloirock.ru)",
                license: "https://github.com/zloirock/core-js/blob/v3.24.1/LICENSE",
                source: "https://github.com/zloirock/core-js"
              });
            },
            /* 38 */
            /***/
            (module2) => {
              module2.exports = false;
            },
            /* 39 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var defineGlobalProperty = __w_pdfjs_require__2(40);
              var SHARED = "__core-js_shared__";
              var store = global2[SHARED] || defineGlobalProperty(SHARED, {});
              module2.exports = store;
            },
            /* 40 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var defineProperty = Object.defineProperty;
              module2.exports = function(key, value) {
                try {
                  defineProperty(global2, key, {
                    value,
                    configurable: true,
                    writable: true
                  });
                } catch (error) {
                  global2[key] = value;
                }
                return value;
              };
            },
            /* 41 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var uncurryThis = __w_pdfjs_require__2(18);
              var toObject = __w_pdfjs_require__2(42);
              var hasOwnProperty = uncurryThis({}.hasOwnProperty);
              module2.exports = Object.hasOwn || /* @__PURE__ */ __name(function hasOwn(it, key) {
                return hasOwnProperty(toObject(it), key);
              }, "hasOwn");
            },
            /* 42 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var requireObjectCoercible = __w_pdfjs_require__2(20);
              var $Object = Object;
              module2.exports = function(argument) {
                return $Object(requireObjectCoercible(argument));
              };
            },
            /* 43 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var uncurryThis = __w_pdfjs_require__2(18);
              var id = 0;
              var postfix = Math.random();
              var toString = uncurryThis(1 .toString);
              module2.exports = function(key) {
                return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString(++id + postfix, 36);
              };
            },
            /* 44 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var DESCRIPTORS = __w_pdfjs_require__2(10);
              var fails = __w_pdfjs_require__2(11);
              var createElement = __w_pdfjs_require__2(45);
              module2.exports = !DESCRIPTORS && !fails(function() {
                return Object.defineProperty(createElement("div"), "a", {
                  get: function() {
                    return 7;
                  }
                }).a != 7;
              });
            },
            /* 45 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var isObject = __w_pdfjs_require__2(23);
              var document2 = global2.document;
              var EXISTS = isObject(document2) && isObject(document2.createElement);
              module2.exports = function(it) {
                return EXISTS ? document2.createElement(it) : {};
              };
            },
            /* 46 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var DESCRIPTORS = __w_pdfjs_require__2(10);
              var definePropertyModule = __w_pdfjs_require__2(47);
              var createPropertyDescriptor = __w_pdfjs_require__2(15);
              module2.exports = DESCRIPTORS ? function(object, key, value) {
                return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
              } : function(object, key, value) {
                object[key] = value;
                return object;
              };
            },
            /* 47 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              var DESCRIPTORS = __w_pdfjs_require__2(10);
              var IE8_DOM_DEFINE = __w_pdfjs_require__2(44);
              var V8_PROTOTYPE_DEFINE_BUG = __w_pdfjs_require__2(48);
              var anObject = __w_pdfjs_require__2(49);
              var toPropertyKey = __w_pdfjs_require__2(21);
              var $TypeError = TypeError;
              var $defineProperty = Object.defineProperty;
              var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
              var ENUMERABLE = "enumerable";
              var CONFIGURABLE = "configurable";
              var WRITABLE = "writable";
              exports2.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? /* @__PURE__ */ __name(function defineProperty(O, P, Attributes) {
                anObject(O);
                P = toPropertyKey(P);
                anObject(Attributes);
                if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
                  var current = $getOwnPropertyDescriptor(O, P);
                  if (current && current[WRITABLE]) {
                    O[P] = Attributes.value;
                    Attributes = {
                      configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
                      enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
                      writable: false
                    };
                  }
                }
                return $defineProperty(O, P, Attributes);
              }, "defineProperty") : $defineProperty : /* @__PURE__ */ __name(function defineProperty(O, P, Attributes) {
                anObject(O);
                P = toPropertyKey(P);
                anObject(Attributes);
                if (IE8_DOM_DEFINE)
                  try {
                    return $defineProperty(O, P, Attributes);
                  } catch (error) {
                  }
                if ("get" in Attributes || "set" in Attributes)
                  throw $TypeError("Accessors not supported");
                if ("value" in Attributes)
                  O[P] = Attributes.value;
                return O;
              }, "defineProperty");
            },
            /* 48 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var DESCRIPTORS = __w_pdfjs_require__2(10);
              var fails = __w_pdfjs_require__2(11);
              module2.exports = DESCRIPTORS && fails(function() {
                return Object.defineProperty(function() {
                }, "prototype", {
                  value: 42,
                  writable: false
                }).prototype != 42;
              });
            },
            /* 49 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var isObject = __w_pdfjs_require__2(23);
              var $String = String;
              var $TypeError = TypeError;
              module2.exports = function(argument) {
                if (isObject(argument))
                  return argument;
                throw $TypeError($String(argument) + " is not an object");
              };
            },
            /* 50 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var isCallable = __w_pdfjs_require__2(24);
              var definePropertyModule = __w_pdfjs_require__2(47);
              var makeBuiltIn = __w_pdfjs_require__2(51);
              var defineGlobalProperty = __w_pdfjs_require__2(40);
              module2.exports = function(O, key, value, options) {
                if (!options)
                  options = {};
                var simple = options.enumerable;
                var name = options.name !== void 0 ? options.name : key;
                if (isCallable(value))
                  makeBuiltIn(value, name, options);
                if (options.global) {
                  if (simple)
                    O[key] = value;
                  else
                    defineGlobalProperty(key, value);
                } else {
                  try {
                    if (!options.unsafe)
                      delete O[key];
                    else if (O[key])
                      simple = true;
                  } catch (error) {
                  }
                  if (simple)
                    O[key] = value;
                  else
                    definePropertyModule.f(O, key, {
                      value,
                      enumerable: false,
                      configurable: !options.nonConfigurable,
                      writable: !options.nonWritable
                    });
                }
                return O;
              };
            },
            /* 51 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var fails = __w_pdfjs_require__2(11);
              var isCallable = __w_pdfjs_require__2(24);
              var hasOwn = __w_pdfjs_require__2(41);
              var DESCRIPTORS = __w_pdfjs_require__2(10);
              var CONFIGURABLE_FUNCTION_NAME = __w_pdfjs_require__2(52).CONFIGURABLE;
              var inspectSource = __w_pdfjs_require__2(53);
              var InternalStateModule = __w_pdfjs_require__2(54);
              var enforceInternalState = InternalStateModule.enforce;
              var getInternalState = InternalStateModule.get;
              var defineProperty = Object.defineProperty;
              var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function() {
                return defineProperty(function() {
                }, "length", { value: 8 }).length !== 8;
              });
              var TEMPLATE = String(String).split("String");
              var makeBuiltIn = module2.exports = function(value, name, options) {
                if (String(name).slice(0, 7) === "Symbol(") {
                  name = "[" + String(name).replace(/^Symbol\(([^)]*)\)/, "$1") + "]";
                }
                if (options && options.getter)
                  name = "get " + name;
                if (options && options.setter)
                  name = "set " + name;
                if (!hasOwn(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
                  if (DESCRIPTORS)
                    defineProperty(value, "name", {
                      value: name,
                      configurable: true
                    });
                  else
                    value.name = name;
                }
                if (CONFIGURABLE_LENGTH && options && hasOwn(options, "arity") && value.length !== options.arity) {
                  defineProperty(value, "length", { value: options.arity });
                }
                try {
                  if (options && hasOwn(options, "constructor") && options.constructor) {
                    if (DESCRIPTORS)
                      defineProperty(value, "prototype", { writable: false });
                  } else if (value.prototype)
                    value.prototype = void 0;
                } catch (error) {
                }
                var state = enforceInternalState(value);
                if (!hasOwn(state, "source")) {
                  state.source = TEMPLATE.join(typeof name == "string" ? name : "");
                }
                return value;
              };
              Function.prototype.toString = makeBuiltIn(/* @__PURE__ */ __name(function toString() {
                return isCallable(this) && getInternalState(this).source || inspectSource(this);
              }, "toString"), "toString");
            },
            /* 52 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var DESCRIPTORS = __w_pdfjs_require__2(10);
              var hasOwn = __w_pdfjs_require__2(41);
              var FunctionPrototype = Function.prototype;
              var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
              var EXISTS = hasOwn(FunctionPrototype, "name");
              var PROPER = EXISTS && (/* @__PURE__ */ __name(function something() {
              }, "something")).name === "something";
              var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
              module2.exports = {
                EXISTS,
                PROPER,
                CONFIGURABLE
              };
            },
            /* 53 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var uncurryThis = __w_pdfjs_require__2(18);
              var isCallable = __w_pdfjs_require__2(24);
              var store = __w_pdfjs_require__2(39);
              var functionToString = uncurryThis(Function.toString);
              if (!isCallable(store.inspectSource)) {
                store.inspectSource = function(it) {
                  return functionToString(it);
                };
              }
              module2.exports = store.inspectSource;
            },
            /* 54 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var NATIVE_WEAK_MAP = __w_pdfjs_require__2(55);
              var global2 = __w_pdfjs_require__2(8);
              var uncurryThis = __w_pdfjs_require__2(18);
              var isObject = __w_pdfjs_require__2(23);
              var createNonEnumerableProperty = __w_pdfjs_require__2(46);
              var hasOwn = __w_pdfjs_require__2(41);
              var shared = __w_pdfjs_require__2(39);
              var sharedKey = __w_pdfjs_require__2(56);
              var hiddenKeys = __w_pdfjs_require__2(57);
              var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
              var TypeError2 = global2.TypeError;
              var WeakMap2 = global2.WeakMap;
              var set, get, has;
              var enforce = /* @__PURE__ */ __name(function(it) {
                return has(it) ? get(it) : set(it, {});
              }, "enforce");
              var getterFor = /* @__PURE__ */ __name(function(TYPE) {
                return function(it) {
                  var state;
                  if (!isObject(it) || (state = get(it)).type !== TYPE) {
                    throw TypeError2("Incompatible receiver, " + TYPE + " required");
                  }
                  return state;
                };
              }, "getterFor");
              if (NATIVE_WEAK_MAP || shared.state) {
                var store = shared.state || (shared.state = new WeakMap2());
                var wmget = uncurryThis(store.get);
                var wmhas = uncurryThis(store.has);
                var wmset = uncurryThis(store.set);
                set = /* @__PURE__ */ __name(function(it, metadata) {
                  if (wmhas(store, it))
                    throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
                  metadata.facade = it;
                  wmset(store, it, metadata);
                  return metadata;
                }, "set");
                get = /* @__PURE__ */ __name(function(it) {
                  return wmget(store, it) || {};
                }, "get");
                has = /* @__PURE__ */ __name(function(it) {
                  return wmhas(store, it);
                }, "has");
              } else {
                var STATE = sharedKey("state");
                hiddenKeys[STATE] = true;
                set = /* @__PURE__ */ __name(function(it, metadata) {
                  if (hasOwn(it, STATE))
                    throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
                  metadata.facade = it;
                  createNonEnumerableProperty(it, STATE, metadata);
                  return metadata;
                }, "set");
                get = /* @__PURE__ */ __name(function(it) {
                  return hasOwn(it, STATE) ? it[STATE] : {};
                }, "get");
                has = /* @__PURE__ */ __name(function(it) {
                  return hasOwn(it, STATE);
                }, "has");
              }
              module2.exports = {
                set,
                get,
                has,
                enforce,
                getterFor
              };
            },
            /* 55 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var isCallable = __w_pdfjs_require__2(24);
              var inspectSource = __w_pdfjs_require__2(53);
              var WeakMap2 = global2.WeakMap;
              module2.exports = isCallable(WeakMap2) && /native code/.test(inspectSource(WeakMap2));
            },
            /* 56 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var shared = __w_pdfjs_require__2(37);
              var uid = __w_pdfjs_require__2(43);
              var keys = shared("keys");
              module2.exports = function(key) {
                return keys[key] || (keys[key] = uid(key));
              };
            },
            /* 57 */
            /***/
            (module2) => {
              module2.exports = {};
            },
            /* 58 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var hasOwn = __w_pdfjs_require__2(41);
              var ownKeys = __w_pdfjs_require__2(59);
              var getOwnPropertyDescriptorModule = __w_pdfjs_require__2(9);
              var definePropertyModule = __w_pdfjs_require__2(47);
              module2.exports = function(target, source, exceptions) {
                var keys = ownKeys(source);
                var defineProperty = definePropertyModule.f;
                var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
                for (var i = 0; i < keys.length; i++) {
                  var key = keys[i];
                  if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
                    defineProperty(target, key, getOwnPropertyDescriptor(source, key));
                  }
                }
              };
            },
            /* 59 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var getBuiltIn = __w_pdfjs_require__2(26);
              var uncurryThis = __w_pdfjs_require__2(18);
              var getOwnPropertyNamesModule = __w_pdfjs_require__2(60);
              var getOwnPropertySymbolsModule = __w_pdfjs_require__2(69);
              var anObject = __w_pdfjs_require__2(49);
              var concat = uncurryThis([].concat);
              module2.exports = getBuiltIn("Reflect", "ownKeys") || /* @__PURE__ */ __name(function ownKeys(it) {
                var keys = getOwnPropertyNamesModule.f(anObject(it));
                var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
                return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
              }, "ownKeys");
            },
            /* 60 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              var internalObjectKeys = __w_pdfjs_require__2(61);
              var enumBugKeys = __w_pdfjs_require__2(68);
              var hiddenKeys = enumBugKeys.concat("length", "prototype");
              exports2.f = Object.getOwnPropertyNames || /* @__PURE__ */ __name(function getOwnPropertyNames(O) {
                return internalObjectKeys(O, hiddenKeys);
              }, "getOwnPropertyNames");
            },
            /* 61 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var uncurryThis = __w_pdfjs_require__2(18);
              var hasOwn = __w_pdfjs_require__2(41);
              var toIndexedObject = __w_pdfjs_require__2(16);
              var indexOf = __w_pdfjs_require__2(62).indexOf;
              var hiddenKeys = __w_pdfjs_require__2(57);
              var push = uncurryThis([].push);
              module2.exports = function(object, names) {
                var O = toIndexedObject(object);
                var i = 0;
                var result = [];
                var key;
                for (key in O)
                  !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
                while (names.length > i)
                  if (hasOwn(O, key = names[i++])) {
                    ~indexOf(result, key) || push(result, key);
                  }
                return result;
              };
            },
            /* 62 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var toIndexedObject = __w_pdfjs_require__2(16);
              var toAbsoluteIndex = __w_pdfjs_require__2(63);
              var lengthOfArrayLike = __w_pdfjs_require__2(66);
              var createMethod = /* @__PURE__ */ __name(function(IS_INCLUDES) {
                return function($this, el, fromIndex) {
                  var O = toIndexedObject($this);
                  var length = lengthOfArrayLike(O);
                  var index = toAbsoluteIndex(fromIndex, length);
                  var value;
                  if (IS_INCLUDES && el != el)
                    while (length > index) {
                      value = O[index++];
                      if (value != value)
                        return true;
                    }
                  else
                    for (; length > index; index++) {
                      if ((IS_INCLUDES || index in O) && O[index] === el)
                        return IS_INCLUDES || index || 0;
                    }
                  return !IS_INCLUDES && -1;
                };
              }, "createMethod");
              module2.exports = {
                includes: createMethod(true),
                indexOf: createMethod(false)
              };
            },
            /* 63 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var toIntegerOrInfinity = __w_pdfjs_require__2(64);
              var max = Math.max;
              var min = Math.min;
              module2.exports = function(index, length) {
                var integer = toIntegerOrInfinity(index);
                return integer < 0 ? max(integer + length, 0) : min(integer, length);
              };
            },
            /* 64 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var trunc = __w_pdfjs_require__2(65);
              module2.exports = function(argument) {
                var number = +argument;
                return number !== number || number === 0 ? 0 : trunc(number);
              };
            },
            /* 65 */
            /***/
            (module2) => {
              var ceil = Math.ceil;
              var floor = Math.floor;
              module2.exports = Math.trunc || /* @__PURE__ */ __name(function trunc(x) {
                var n = +x;
                return (n > 0 ? floor : ceil)(n);
              }, "trunc");
            },
            /* 66 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var toLength = __w_pdfjs_require__2(67);
              module2.exports = function(obj) {
                return toLength(obj.length);
              };
            },
            /* 67 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var toIntegerOrInfinity = __w_pdfjs_require__2(64);
              var min = Math.min;
              module2.exports = function(argument) {
                return argument > 0 ? min(toIntegerOrInfinity(argument), 9007199254740991) : 0;
              };
            },
            /* 68 */
            /***/
            (module2) => {
              module2.exports = [
                "constructor",
                "hasOwnProperty",
                "isPrototypeOf",
                "propertyIsEnumerable",
                "toLocaleString",
                "toString",
                "valueOf"
              ];
            },
            /* 69 */
            /***/
            (__unused_webpack_module, exports2) => {
              exports2.f = Object.getOwnPropertySymbols;
            },
            /* 70 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var fails = __w_pdfjs_require__2(11);
              var isCallable = __w_pdfjs_require__2(24);
              var replacement = /#|\.prototype\./;
              var isForced = /* @__PURE__ */ __name(function(feature, detection) {
                var value = data[normalize(feature)];
                return value == POLYFILL ? true : value == NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
              }, "isForced");
              var normalize = isForced.normalize = function(string) {
                return String(string).replace(replacement, ".").toLowerCase();
              };
              var data = isForced.data = {};
              var NATIVE = isForced.NATIVE = "N";
              var POLYFILL = isForced.POLYFILL = "P";
              module2.exports = isForced;
            },
            /* 71 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var wellKnownSymbol = __w_pdfjs_require__2(36);
              var create = __w_pdfjs_require__2(72);
              var defineProperty = __w_pdfjs_require__2(47).f;
              var UNSCOPABLES = wellKnownSymbol("unscopables");
              var ArrayPrototype = Array.prototype;
              if (ArrayPrototype[UNSCOPABLES] == void 0) {
                defineProperty(ArrayPrototype, UNSCOPABLES, {
                  configurable: true,
                  value: create(null)
                });
              }
              module2.exports = function(key) {
                ArrayPrototype[UNSCOPABLES][key] = true;
              };
            },
            /* 72 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var anObject = __w_pdfjs_require__2(49);
              var definePropertiesModule = __w_pdfjs_require__2(73);
              var enumBugKeys = __w_pdfjs_require__2(68);
              var hiddenKeys = __w_pdfjs_require__2(57);
              var html = __w_pdfjs_require__2(75);
              var documentCreateElement = __w_pdfjs_require__2(45);
              var sharedKey = __w_pdfjs_require__2(56);
              var GT = ">";
              var LT = "<";
              var PROTOTYPE = "prototype";
              var SCRIPT = "script";
              var IE_PROTO = sharedKey("IE_PROTO");
              var EmptyConstructor = /* @__PURE__ */ __name(function() {
              }, "EmptyConstructor");
              var scriptTag = /* @__PURE__ */ __name(function(content) {
                return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
              }, "scriptTag");
              var NullProtoObjectViaActiveX = /* @__PURE__ */ __name(function(activeXDocument2) {
                activeXDocument2.write(scriptTag(""));
                activeXDocument2.close();
                var temp = activeXDocument2.parentWindow.Object;
                activeXDocument2 = null;
                return temp;
              }, "NullProtoObjectViaActiveX");
              var NullProtoObjectViaIFrame = /* @__PURE__ */ __name(function() {
                var iframe = documentCreateElement("iframe");
                var JS = "java" + SCRIPT + ":";
                var iframeDocument;
                iframe.style.display = "none";
                html.appendChild(iframe);
                iframe.src = String(JS);
                iframeDocument = iframe.contentWindow.document;
                iframeDocument.open();
                iframeDocument.write(scriptTag("document.F=Object"));
                iframeDocument.close();
                return iframeDocument.F;
              }, "NullProtoObjectViaIFrame");
              var activeXDocument;
              var NullProtoObject = /* @__PURE__ */ __name(function() {
                try {
                  activeXDocument = new ActiveXObject("htmlfile");
                } catch (error) {
                }
                NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
                var length = enumBugKeys.length;
                while (length--)
                  delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
                return NullProtoObject();
              }, "NullProtoObject");
              hiddenKeys[IE_PROTO] = true;
              module2.exports = Object.create || /* @__PURE__ */ __name(function create(O, Properties) {
                var result;
                if (O !== null) {
                  EmptyConstructor[PROTOTYPE] = anObject(O);
                  result = new EmptyConstructor();
                  EmptyConstructor[PROTOTYPE] = null;
                  result[IE_PROTO] = O;
                } else
                  result = NullProtoObject();
                return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
              }, "create");
            },
            /* 73 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              var DESCRIPTORS = __w_pdfjs_require__2(10);
              var V8_PROTOTYPE_DEFINE_BUG = __w_pdfjs_require__2(48);
              var definePropertyModule = __w_pdfjs_require__2(47);
              var anObject = __w_pdfjs_require__2(49);
              var toIndexedObject = __w_pdfjs_require__2(16);
              var objectKeys = __w_pdfjs_require__2(74);
              exports2.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : /* @__PURE__ */ __name(function defineProperties(O, Properties) {
                anObject(O);
                var props = toIndexedObject(Properties);
                var keys = objectKeys(Properties);
                var length = keys.length;
                var index = 0;
                var key;
                while (length > index)
                  definePropertyModule.f(O, key = keys[index++], props[key]);
                return O;
              }, "defineProperties");
            },
            /* 74 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var internalObjectKeys = __w_pdfjs_require__2(61);
              var enumBugKeys = __w_pdfjs_require__2(68);
              module2.exports = Object.keys || /* @__PURE__ */ __name(function keys(O) {
                return internalObjectKeys(O, enumBugKeys);
              }, "keys");
            },
            /* 75 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var getBuiltIn = __w_pdfjs_require__2(26);
              module2.exports = getBuiltIn("document", "documentElement");
            },
            /* 76 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              var uncurryThis = __w_pdfjs_require__2(18);
              module2.exports = function(CONSTRUCTOR, METHOD) {
                return uncurryThis(global2[CONSTRUCTOR].prototype[METHOD]);
              };
            },
            /* 77 */
            /***/
            (__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__2) => {
              __w_pdfjs_require__2(78);
            },
            /* 78 */
            /***/
            (__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var ArrayBufferViewCore = __w_pdfjs_require__2(79);
              var lengthOfArrayLike = __w_pdfjs_require__2(66);
              var toIntegerOrInfinity = __w_pdfjs_require__2(64);
              var aTypedArray = ArrayBufferViewCore.aTypedArray;
              var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
              exportTypedArrayMethod("at", /* @__PURE__ */ __name(function at(index) {
                var O = aTypedArray(this);
                var len = lengthOfArrayLike(O);
                var relativeIndex = toIntegerOrInfinity(index);
                var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
                return k < 0 || k >= len ? void 0 : O[k];
              }, "at"));
            },
            /* 79 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var NATIVE_ARRAY_BUFFER = __w_pdfjs_require__2(80);
              var DESCRIPTORS = __w_pdfjs_require__2(10);
              var global2 = __w_pdfjs_require__2(8);
              var isCallable = __w_pdfjs_require__2(24);
              var isObject = __w_pdfjs_require__2(23);
              var hasOwn = __w_pdfjs_require__2(41);
              var classof = __w_pdfjs_require__2(81);
              var tryToString = __w_pdfjs_require__2(34);
              var createNonEnumerableProperty = __w_pdfjs_require__2(46);
              var defineBuiltIn = __w_pdfjs_require__2(50);
              var defineProperty = __w_pdfjs_require__2(47).f;
              var isPrototypeOf = __w_pdfjs_require__2(27);
              var getPrototypeOf = __w_pdfjs_require__2(83);
              var setPrototypeOf = __w_pdfjs_require__2(85);
              var wellKnownSymbol = __w_pdfjs_require__2(36);
              var uid = __w_pdfjs_require__2(43);
              var InternalStateModule = __w_pdfjs_require__2(54);
              var enforceInternalState = InternalStateModule.enforce;
              var getInternalState = InternalStateModule.get;
              var Int8Array2 = global2.Int8Array;
              var Int8ArrayPrototype = Int8Array2 && Int8Array2.prototype;
              var Uint8ClampedArray2 = global2.Uint8ClampedArray;
              var Uint8ClampedArrayPrototype = Uint8ClampedArray2 && Uint8ClampedArray2.prototype;
              var TypedArray = Int8Array2 && getPrototypeOf(Int8Array2);
              var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
              var ObjectPrototype = Object.prototype;
              var TypeError2 = global2.TypeError;
              var TO_STRING_TAG = wellKnownSymbol("toStringTag");
              var TYPED_ARRAY_TAG = uid("TYPED_ARRAY_TAG");
              var TYPED_ARRAY_CONSTRUCTOR = "TypedArrayConstructor";
              var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global2.opera) !== "Opera";
              var TYPED_ARRAY_TAG_REQUIRED = false;
              var NAME, Constructor, Prototype;
              var TypedArrayConstructorsList = {
                Int8Array: 1,
                Uint8Array: 1,
                Uint8ClampedArray: 1,
                Int16Array: 2,
                Uint16Array: 2,
                Int32Array: 4,
                Uint32Array: 4,
                Float32Array: 4,
                Float64Array: 8
              };
              var BigIntArrayConstructorsList = {
                BigInt64Array: 8,
                BigUint64Array: 8
              };
              var isView = /* @__PURE__ */ __name(function isView2(it) {
                if (!isObject(it))
                  return false;
                var klass = classof(it);
                return klass === "DataView" || hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
              }, "isView");
              var getTypedArrayConstructor = /* @__PURE__ */ __name(function(it) {
                var proto = getPrototypeOf(it);
                if (!isObject(proto))
                  return;
                var state = getInternalState(proto);
                return state && hasOwn(state, TYPED_ARRAY_CONSTRUCTOR) ? state[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor(proto);
              }, "getTypedArrayConstructor");
              var isTypedArray = /* @__PURE__ */ __name(function(it) {
                if (!isObject(it))
                  return false;
                var klass = classof(it);
                return hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
              }, "isTypedArray");
              var aTypedArray = /* @__PURE__ */ __name(function(it) {
                if (isTypedArray(it))
                  return it;
                throw TypeError2("Target is not a typed array");
              }, "aTypedArray");
              var aTypedArrayConstructor = /* @__PURE__ */ __name(function(C) {
                if (isCallable(C) && (!setPrototypeOf || isPrototypeOf(TypedArray, C)))
                  return C;
                throw TypeError2(tryToString(C) + " is not a typed array constructor");
              }, "aTypedArrayConstructor");
              var exportTypedArrayMethod = /* @__PURE__ */ __name(function(KEY, property, forced, options) {
                if (!DESCRIPTORS)
                  return;
                if (forced)
                  for (var ARRAY in TypedArrayConstructorsList) {
                    var TypedArrayConstructor = global2[ARRAY];
                    if (TypedArrayConstructor && hasOwn(TypedArrayConstructor.prototype, KEY))
                      try {
                        delete TypedArrayConstructor.prototype[KEY];
                      } catch (error) {
                        try {
                          TypedArrayConstructor.prototype[KEY] = property;
                        } catch (error2) {
                        }
                      }
                  }
                if (!TypedArrayPrototype[KEY] || forced) {
                  defineBuiltIn(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property, options);
                }
              }, "exportTypedArrayMethod");
              var exportTypedArrayStaticMethod = /* @__PURE__ */ __name(function(KEY, property, forced) {
                var ARRAY, TypedArrayConstructor;
                if (!DESCRIPTORS)
                  return;
                if (setPrototypeOf) {
                  if (forced)
                    for (ARRAY in TypedArrayConstructorsList) {
                      TypedArrayConstructor = global2[ARRAY];
                      if (TypedArrayConstructor && hasOwn(TypedArrayConstructor, KEY))
                        try {
                          delete TypedArrayConstructor[KEY];
                        } catch (error) {
                        }
                    }
                  if (!TypedArray[KEY] || forced) {
                    try {
                      return defineBuiltIn(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);
                    } catch (error) {
                    }
                  } else
                    return;
                }
                for (ARRAY in TypedArrayConstructorsList) {
                  TypedArrayConstructor = global2[ARRAY];
                  if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
                    defineBuiltIn(TypedArrayConstructor, KEY, property);
                  }
                }
              }, "exportTypedArrayStaticMethod");
              for (NAME in TypedArrayConstructorsList) {
                Constructor = global2[NAME];
                Prototype = Constructor && Constructor.prototype;
                if (Prototype)
                  enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
                else
                  NATIVE_ARRAY_BUFFER_VIEWS = false;
              }
              for (NAME in BigIntArrayConstructorsList) {
                Constructor = global2[NAME];
                Prototype = Constructor && Constructor.prototype;
                if (Prototype)
                  enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
              }
              if (!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) {
                TypedArray = /* @__PURE__ */ __name(function TypedArray2() {
                  throw TypeError2("Incorrect invocation");
                }, "TypedArray");
                if (NATIVE_ARRAY_BUFFER_VIEWS)
                  for (NAME in TypedArrayConstructorsList) {
                    if (global2[NAME])
                      setPrototypeOf(global2[NAME], TypedArray);
                  }
              }
              if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
                TypedArrayPrototype = TypedArray.prototype;
                if (NATIVE_ARRAY_BUFFER_VIEWS)
                  for (NAME in TypedArrayConstructorsList) {
                    if (global2[NAME])
                      setPrototypeOf(global2[NAME].prototype, TypedArrayPrototype);
                  }
              }
              if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
                setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
              }
              if (DESCRIPTORS && !hasOwn(TypedArrayPrototype, TO_STRING_TAG)) {
                TYPED_ARRAY_TAG_REQUIRED = true;
                defineProperty(TypedArrayPrototype, TO_STRING_TAG, {
                  get: function() {
                    return isObject(this) ? this[TYPED_ARRAY_TAG] : void 0;
                  }
                });
                for (NAME in TypedArrayConstructorsList)
                  if (global2[NAME]) {
                    createNonEnumerableProperty(global2[NAME], TYPED_ARRAY_TAG, NAME);
                  }
              }
              module2.exports = {
                NATIVE_ARRAY_BUFFER_VIEWS,
                TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG,
                aTypedArray,
                aTypedArrayConstructor,
                exportTypedArrayMethod,
                exportTypedArrayStaticMethod,
                getTypedArrayConstructor,
                isView,
                isTypedArray,
                TypedArray,
                TypedArrayPrototype
              };
            },
            /* 80 */
            /***/
            (module2) => {
              module2.exports = typeof ArrayBuffer != "undefined" && typeof DataView != "undefined";
            },
            /* 81 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var TO_STRING_TAG_SUPPORT = __w_pdfjs_require__2(82);
              var isCallable = __w_pdfjs_require__2(24);
              var classofRaw = __w_pdfjs_require__2(19);
              var wellKnownSymbol = __w_pdfjs_require__2(36);
              var TO_STRING_TAG = wellKnownSymbol("toStringTag");
              var $Object = Object;
              var CORRECT_ARGUMENTS = classofRaw(function() {
                return arguments;
              }()) == "Arguments";
              var tryGet = /* @__PURE__ */ __name(function(it, key) {
                try {
                  return it[key];
                } catch (error) {
                }
              }, "tryGet");
              module2.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
                var O, tag, result;
                return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && isCallable(O.callee) ? "Arguments" : result;
              };
            },
            /* 82 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var wellKnownSymbol = __w_pdfjs_require__2(36);
              var TO_STRING_TAG = wellKnownSymbol("toStringTag");
              var test = {};
              test[TO_STRING_TAG] = "z";
              module2.exports = String(test) === "[object z]";
            },
            /* 83 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var hasOwn = __w_pdfjs_require__2(41);
              var isCallable = __w_pdfjs_require__2(24);
              var toObject = __w_pdfjs_require__2(42);
              var sharedKey = __w_pdfjs_require__2(56);
              var CORRECT_PROTOTYPE_GETTER = __w_pdfjs_require__2(84);
              var IE_PROTO = sharedKey("IE_PROTO");
              var $Object = Object;
              var ObjectPrototype = $Object.prototype;
              module2.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O) {
                var object = toObject(O);
                if (hasOwn(object, IE_PROTO))
                  return object[IE_PROTO];
                var constructor = object.constructor;
                if (isCallable(constructor) && object instanceof constructor) {
                  return constructor.prototype;
                }
                return object instanceof $Object ? ObjectPrototype : null;
              };
            },
            /* 84 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var fails = __w_pdfjs_require__2(11);
              module2.exports = !fails(function() {
                function F() {
                }
                __name(F, "F");
                F.prototype.constructor = null;
                return Object.getPrototypeOf(new F()) !== F.prototype;
              });
            },
            /* 85 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var uncurryThis = __w_pdfjs_require__2(18);
              var anObject = __w_pdfjs_require__2(49);
              var aPossiblePrototype = __w_pdfjs_require__2(86);
              module2.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
                var CORRECT_SETTER = false;
                var test = {};
                var setter;
                try {
                  setter = uncurryThis(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set);
                  setter(test, []);
                  CORRECT_SETTER = test instanceof Array;
                } catch (error) {
                }
                return /* @__PURE__ */ __name(function setPrototypeOf(O, proto) {
                  anObject(O);
                  aPossiblePrototype(proto);
                  if (CORRECT_SETTER)
                    setter(O, proto);
                  else
                    O.__proto__ = proto;
                  return O;
                }, "setPrototypeOf");
              }() : void 0);
            },
            /* 86 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var isCallable = __w_pdfjs_require__2(24);
              var $String = String;
              var $TypeError = TypeError;
              module2.exports = function(argument) {
                if (typeof argument == "object" || isCallable(argument))
                  return argument;
                throw $TypeError("Can't set " + $String(argument) + " as a prototype");
              };
            },
            /* 87 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              __w_pdfjs_require__2(88);
              __w_pdfjs_require__2(94);
              __w_pdfjs_require__2(96);
              __w_pdfjs_require__2(118);
              __w_pdfjs_require__2(120);
              var path = __w_pdfjs_require__2(129);
              module2.exports = path.structuredClone;
            },
            /* 88 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var toIndexedObject = __w_pdfjs_require__2(16);
              var addToUnscopables = __w_pdfjs_require__2(71);
              var Iterators = __w_pdfjs_require__2(89);
              var InternalStateModule = __w_pdfjs_require__2(54);
              var defineProperty = __w_pdfjs_require__2(47).f;
              var defineIterator = __w_pdfjs_require__2(90);
              var IS_PURE = __w_pdfjs_require__2(38);
              var DESCRIPTORS = __w_pdfjs_require__2(10);
              var ARRAY_ITERATOR = "Array Iterator";
              var setInternalState = InternalStateModule.set;
              var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
              module2.exports = defineIterator(Array, "Array", function(iterated, kind) {
                setInternalState(this, {
                  type: ARRAY_ITERATOR,
                  target: toIndexedObject(iterated),
                  index: 0,
                  kind
                });
              }, function() {
                var state = getInternalState(this);
                var target = state.target;
                var kind = state.kind;
                var index = state.index++;
                if (!target || index >= target.length) {
                  state.target = void 0;
                  return {
                    value: void 0,
                    done: true
                  };
                }
                if (kind == "keys")
                  return {
                    value: index,
                    done: false
                  };
                if (kind == "values")
                  return {
                    value: target[index],
                    done: false
                  };
                return {
                  value: [
                    index,
                    target[index]
                  ],
                  done: false
                };
              }, "values");
              var values = Iterators.Arguments = Iterators.Array;
              addToUnscopables("keys");
              addToUnscopables("values");
              addToUnscopables("entries");
              if (!IS_PURE && DESCRIPTORS && values.name !== "values")
                try {
                  defineProperty(values, "name", { value: "values" });
                } catch (error) {
                }
            },
            /* 89 */
            /***/
            (module2) => {
              module2.exports = {};
            },
            /* 90 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var $ = __w_pdfjs_require__2(7);
              var call = __w_pdfjs_require__2(12);
              var IS_PURE = __w_pdfjs_require__2(38);
              var FunctionName = __w_pdfjs_require__2(52);
              var isCallable = __w_pdfjs_require__2(24);
              var createIteratorConstructor = __w_pdfjs_require__2(91);
              var getPrototypeOf = __w_pdfjs_require__2(83);
              var setPrototypeOf = __w_pdfjs_require__2(85);
              var setToStringTag = __w_pdfjs_require__2(93);
              var createNonEnumerableProperty = __w_pdfjs_require__2(46);
              var defineBuiltIn = __w_pdfjs_require__2(50);
              var wellKnownSymbol = __w_pdfjs_require__2(36);
              var Iterators = __w_pdfjs_require__2(89);
              var IteratorsCore = __w_pdfjs_require__2(92);
              var PROPER_FUNCTION_NAME = FunctionName.PROPER;
              var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
              var IteratorPrototype = IteratorsCore.IteratorPrototype;
              var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
              var ITERATOR = wellKnownSymbol("iterator");
              var KEYS = "keys";
              var VALUES = "values";
              var ENTRIES = "entries";
              var returnThis = /* @__PURE__ */ __name(function() {
                return this;
              }, "returnThis");
              module2.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
                createIteratorConstructor(IteratorConstructor, NAME, next);
                var getIterationMethod = /* @__PURE__ */ __name(function(KIND) {
                  if (KIND === DEFAULT && defaultIterator)
                    return defaultIterator;
                  if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
                    return IterablePrototype[KIND];
                  switch (KIND) {
                    case KEYS:
                      return /* @__PURE__ */ __name(function keys() {
                        return new IteratorConstructor(this, KIND);
                      }, "keys");
                    case VALUES:
                      return /* @__PURE__ */ __name(function values() {
                        return new IteratorConstructor(this, KIND);
                      }, "values");
                    case ENTRIES:
                      return /* @__PURE__ */ __name(function entries() {
                        return new IteratorConstructor(this, KIND);
                      }, "entries");
                  }
                  return function() {
                    return new IteratorConstructor(this);
                  };
                }, "getIterationMethod");
                var TO_STRING_TAG = NAME + " Iterator";
                var INCORRECT_VALUES_NAME = false;
                var IterablePrototype = Iterable.prototype;
                var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
                var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
                var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
                var CurrentIteratorPrototype, methods, KEY;
                if (anyNativeIterator) {
                  CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
                  if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
                    if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
                      if (setPrototypeOf) {
                        setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
                      } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
                        defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
                      }
                    }
                    setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
                    if (IS_PURE)
                      Iterators[TO_STRING_TAG] = returnThis;
                  }
                }
                if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
                  if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
                    createNonEnumerableProperty(IterablePrototype, "name", VALUES);
                  } else {
                    INCORRECT_VALUES_NAME = true;
                    defaultIterator = /* @__PURE__ */ __name(function values() {
                      return call(nativeIterator, this);
                    }, "values");
                  }
                }
                if (DEFAULT) {
                  methods = {
                    values: getIterationMethod(VALUES),
                    keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
                    entries: getIterationMethod(ENTRIES)
                  };
                  if (FORCED)
                    for (KEY in methods) {
                      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
                        defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
                      }
                    }
                  else
                    $({
                      target: NAME,
                      proto: true,
                      forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
                    }, methods);
                }
                if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
                  defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
                }
                Iterators[NAME] = defaultIterator;
                return methods;
              };
            },
            /* 91 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var IteratorPrototype = __w_pdfjs_require__2(92).IteratorPrototype;
              var create = __w_pdfjs_require__2(72);
              var createPropertyDescriptor = __w_pdfjs_require__2(15);
              var setToStringTag = __w_pdfjs_require__2(93);
              var Iterators = __w_pdfjs_require__2(89);
              var returnThis = /* @__PURE__ */ __name(function() {
                return this;
              }, "returnThis");
              module2.exports = function(IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
                var TO_STRING_TAG = NAME + " Iterator";
                IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
                setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
                Iterators[TO_STRING_TAG] = returnThis;
                return IteratorConstructor;
              };
            },
            /* 92 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var fails = __w_pdfjs_require__2(11);
              var isCallable = __w_pdfjs_require__2(24);
              var create = __w_pdfjs_require__2(72);
              var getPrototypeOf = __w_pdfjs_require__2(83);
              var defineBuiltIn = __w_pdfjs_require__2(50);
              var wellKnownSymbol = __w_pdfjs_require__2(36);
              var IS_PURE = __w_pdfjs_require__2(38);
              var ITERATOR = wellKnownSymbol("iterator");
              var BUGGY_SAFARI_ITERATORS = false;
              var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
              if ([].keys) {
                arrayIterator = [].keys();
                if (!("next" in arrayIterator))
                  BUGGY_SAFARI_ITERATORS = true;
                else {
                  PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
                  if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
                    IteratorPrototype = PrototypeOfArrayIteratorPrototype;
                }
              }
              var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == void 0 || fails(function() {
                var test = {};
                return IteratorPrototype[ITERATOR].call(test) !== test;
              });
              if (NEW_ITERATOR_PROTOTYPE)
                IteratorPrototype = {};
              else if (IS_PURE)
                IteratorPrototype = create(IteratorPrototype);
              if (!isCallable(IteratorPrototype[ITERATOR])) {
                defineBuiltIn(IteratorPrototype, ITERATOR, function() {
                  return this;
                });
              }
              module2.exports = {
                IteratorPrototype,
                BUGGY_SAFARI_ITERATORS
              };
            },
            /* 93 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var defineProperty = __w_pdfjs_require__2(47).f;
              var hasOwn = __w_pdfjs_require__2(41);
              var wellKnownSymbol = __w_pdfjs_require__2(36);
              var TO_STRING_TAG = wellKnownSymbol("toStringTag");
              module2.exports = function(target, TAG, STATIC) {
                if (target && !STATIC)
                  target = target.prototype;
                if (target && !hasOwn(target, TO_STRING_TAG)) {
                  defineProperty(target, TO_STRING_TAG, {
                    configurable: true,
                    value: TAG
                  });
                }
              };
            },
            /* 94 */
            /***/
            (__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var TO_STRING_TAG_SUPPORT = __w_pdfjs_require__2(82);
              var defineBuiltIn = __w_pdfjs_require__2(50);
              var toString = __w_pdfjs_require__2(95);
              if (!TO_STRING_TAG_SUPPORT) {
                defineBuiltIn(Object.prototype, "toString", toString, { unsafe: true });
              }
            },
            /* 95 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var TO_STRING_TAG_SUPPORT = __w_pdfjs_require__2(82);
              var classof = __w_pdfjs_require__2(81);
              module2.exports = TO_STRING_TAG_SUPPORT ? {}.toString : /* @__PURE__ */ __name(function toString() {
                return "[object " + classof(this) + "]";
              }, "toString");
            },
            /* 96 */
            /***/
            (__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__2) => {
              __w_pdfjs_require__2(97);
            },
            /* 97 */
            /***/
            (__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var collection = __w_pdfjs_require__2(98);
              var collectionStrong = __w_pdfjs_require__2(115);
              collection("Map", function(init) {
                return /* @__PURE__ */ __name(function Map2() {
                  return init(this, arguments.length ? arguments[0] : void 0);
                }, "Map");
              }, collectionStrong);
            },
            /* 98 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var $ = __w_pdfjs_require__2(7);
              var global2 = __w_pdfjs_require__2(8);
              var uncurryThis = __w_pdfjs_require__2(18);
              var isForced = __w_pdfjs_require__2(70);
              var defineBuiltIn = __w_pdfjs_require__2(50);
              var InternalMetadataModule = __w_pdfjs_require__2(99);
              var iterate = __w_pdfjs_require__2(106);
              var anInstance = __w_pdfjs_require__2(112);
              var isCallable = __w_pdfjs_require__2(24);
              var isObject = __w_pdfjs_require__2(23);
              var fails = __w_pdfjs_require__2(11);
              var checkCorrectnessOfIteration = __w_pdfjs_require__2(113);
              var setToStringTag = __w_pdfjs_require__2(93);
              var inheritIfRequired = __w_pdfjs_require__2(114);
              module2.exports = function(CONSTRUCTOR_NAME, wrapper, common) {
                var IS_MAP = CONSTRUCTOR_NAME.indexOf("Map") !== -1;
                var IS_WEAK = CONSTRUCTOR_NAME.indexOf("Weak") !== -1;
                var ADDER = IS_MAP ? "set" : "add";
                var NativeConstructor = global2[CONSTRUCTOR_NAME];
                var NativePrototype = NativeConstructor && NativeConstructor.prototype;
                var Constructor = NativeConstructor;
                var exported = {};
                var fixMethod = /* @__PURE__ */ __name(function(KEY) {
                  var uncurriedNativeMethod = uncurryThis(NativePrototype[KEY]);
                  defineBuiltIn(NativePrototype, KEY, KEY == "add" ? /* @__PURE__ */ __name(function add(value) {
                    uncurriedNativeMethod(this, value === 0 ? 0 : value);
                    return this;
                  }, "add") : KEY == "delete" ? function(key) {
                    return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
                  } : KEY == "get" ? /* @__PURE__ */ __name(function get(key) {
                    return IS_WEAK && !isObject(key) ? void 0 : uncurriedNativeMethod(this, key === 0 ? 0 : key);
                  }, "get") : KEY == "has" ? /* @__PURE__ */ __name(function has(key) {
                    return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
                  }, "has") : /* @__PURE__ */ __name(function set(key, value) {
                    uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
                    return this;
                  }, "set"));
                }, "fixMethod");
                var REPLACE = isForced(CONSTRUCTOR_NAME, !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails(function() {
                  new NativeConstructor().entries().next();
                })));
                if (REPLACE) {
                  Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
                  InternalMetadataModule.enable();
                } else if (isForced(CONSTRUCTOR_NAME, true)) {
                  var instance = new Constructor();
                  var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
                  var THROWS_ON_PRIMITIVES = fails(function() {
                    instance.has(1);
                  });
                  var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function(iterable) {
                    new NativeConstructor(iterable);
                  });
                  var BUGGY_ZERO = !IS_WEAK && fails(function() {
                    var $instance = new NativeConstructor();
                    var index = 5;
                    while (index--)
                      $instance[ADDER](index, index);
                    return !$instance.has(-0);
                  });
                  if (!ACCEPT_ITERABLES) {
                    Constructor = wrapper(function(dummy, iterable) {
                      anInstance(dummy, NativePrototype);
                      var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
                      if (iterable != void 0)
                        iterate(iterable, that[ADDER], {
                          that,
                          AS_ENTRIES: IS_MAP
                        });
                      return that;
                    });
                    Constructor.prototype = NativePrototype;
                    NativePrototype.constructor = Constructor;
                  }
                  if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
                    fixMethod("delete");
                    fixMethod("has");
                    IS_MAP && fixMethod("get");
                  }
                  if (BUGGY_ZERO || HASNT_CHAINING)
                    fixMethod(ADDER);
                  if (IS_WEAK && NativePrototype.clear)
                    delete NativePrototype.clear;
                }
                exported[CONSTRUCTOR_NAME] = Constructor;
                $({
                  global: true,
                  constructor: true,
                  forced: Constructor != NativeConstructor
                }, exported);
                setToStringTag(Constructor, CONSTRUCTOR_NAME);
                if (!IS_WEAK)
                  common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
                return Constructor;
              };
            },
            /* 99 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var $ = __w_pdfjs_require__2(7);
              var uncurryThis = __w_pdfjs_require__2(18);
              var hiddenKeys = __w_pdfjs_require__2(57);
              var isObject = __w_pdfjs_require__2(23);
              var hasOwn = __w_pdfjs_require__2(41);
              var defineProperty = __w_pdfjs_require__2(47).f;
              var getOwnPropertyNamesModule = __w_pdfjs_require__2(60);
              var getOwnPropertyNamesExternalModule = __w_pdfjs_require__2(100);
              var isExtensible = __w_pdfjs_require__2(103);
              var uid = __w_pdfjs_require__2(43);
              var FREEZING = __w_pdfjs_require__2(105);
              var REQUIRED = false;
              var METADATA = uid("meta");
              var id = 0;
              var setMetadata = /* @__PURE__ */ __name(function(it) {
                defineProperty(it, METADATA, {
                  value: {
                    objectID: "O" + id++,
                    weakData: {}
                  }
                });
              }, "setMetadata");
              var fastKey = /* @__PURE__ */ __name(function(it, create) {
                if (!isObject(it))
                  return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
                if (!hasOwn(it, METADATA)) {
                  if (!isExtensible(it))
                    return "F";
                  if (!create)
                    return "E";
                  setMetadata(it);
                }
                return it[METADATA].objectID;
              }, "fastKey");
              var getWeakData = /* @__PURE__ */ __name(function(it, create) {
                if (!hasOwn(it, METADATA)) {
                  if (!isExtensible(it))
                    return true;
                  if (!create)
                    return false;
                  setMetadata(it);
                }
                return it[METADATA].weakData;
              }, "getWeakData");
              var onFreeze = /* @__PURE__ */ __name(function(it) {
                if (FREEZING && REQUIRED && isExtensible(it) && !hasOwn(it, METADATA))
                  setMetadata(it);
                return it;
              }, "onFreeze");
              var enable = /* @__PURE__ */ __name(function() {
                meta.enable = function() {
                };
                REQUIRED = true;
                var getOwnPropertyNames = getOwnPropertyNamesModule.f;
                var splice = uncurryThis([].splice);
                var test = {};
                test[METADATA] = 1;
                if (getOwnPropertyNames(test).length) {
                  getOwnPropertyNamesModule.f = function(it) {
                    var result = getOwnPropertyNames(it);
                    for (var i = 0, length = result.length; i < length; i++) {
                      if (result[i] === METADATA) {
                        splice(result, i, 1);
                        break;
                      }
                    }
                    return result;
                  };
                  $({
                    target: "Object",
                    stat: true,
                    forced: true
                  }, { getOwnPropertyNames: getOwnPropertyNamesExternalModule.f });
                }
              }, "enable");
              var meta = module2.exports = {
                enable,
                fastKey,
                getWeakData,
                onFreeze
              };
              hiddenKeys[METADATA] = true;
            },
            /* 100 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var classof = __w_pdfjs_require__2(19);
              var toIndexedObject = __w_pdfjs_require__2(16);
              var $getOwnPropertyNames = __w_pdfjs_require__2(60).f;
              var arraySlice = __w_pdfjs_require__2(101);
              var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
              var getWindowNames = /* @__PURE__ */ __name(function(it) {
                try {
                  return $getOwnPropertyNames(it);
                } catch (error) {
                  return arraySlice(windowNames);
                }
              }, "getWindowNames");
              module2.exports.f = /* @__PURE__ */ __name(function getOwnPropertyNames(it) {
                return windowNames && classof(it) == "Window" ? getWindowNames(it) : $getOwnPropertyNames(toIndexedObject(it));
              }, "getOwnPropertyNames");
            },
            /* 101 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var toAbsoluteIndex = __w_pdfjs_require__2(63);
              var lengthOfArrayLike = __w_pdfjs_require__2(66);
              var createProperty = __w_pdfjs_require__2(102);
              var $Array = Array;
              var max = Math.max;
              module2.exports = function(O, start, end) {
                var length = lengthOfArrayLike(O);
                var k = toAbsoluteIndex(start, length);
                var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
                var result = $Array(max(fin - k, 0));
                for (var n = 0; k < fin; k++, n++)
                  createProperty(result, n, O[k]);
                result.length = n;
                return result;
              };
            },
            /* 102 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var toPropertyKey = __w_pdfjs_require__2(21);
              var definePropertyModule = __w_pdfjs_require__2(47);
              var createPropertyDescriptor = __w_pdfjs_require__2(15);
              module2.exports = function(object, key, value) {
                var propertyKey = toPropertyKey(key);
                if (propertyKey in object)
                  definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
                else
                  object[propertyKey] = value;
              };
            },
            /* 103 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var fails = __w_pdfjs_require__2(11);
              var isObject = __w_pdfjs_require__2(23);
              var classof = __w_pdfjs_require__2(19);
              var ARRAY_BUFFER_NON_EXTENSIBLE = __w_pdfjs_require__2(104);
              var $isExtensible = Object.isExtensible;
              var FAILS_ON_PRIMITIVES = fails(function() {
              });
              module2.exports = FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE ? /* @__PURE__ */ __name(function isExtensible(it) {
                if (!isObject(it))
                  return false;
                if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) == "ArrayBuffer")
                  return false;
                return $isExtensible ? $isExtensible(it) : true;
              }, "isExtensible") : $isExtensible;
            },
            /* 104 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var fails = __w_pdfjs_require__2(11);
              module2.exports = fails(function() {
                if (typeof ArrayBuffer == "function") {
                  var buffer = new ArrayBuffer(8);
                  if (Object.isExtensible(buffer))
                    Object.defineProperty(buffer, "a", { value: 8 });
                }
              });
            },
            /* 105 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var fails = __w_pdfjs_require__2(11);
              module2.exports = !fails(function() {
                return Object.isExtensible(Object.preventExtensions({}));
              });
            },
            /* 106 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var bind = __w_pdfjs_require__2(107);
              var call = __w_pdfjs_require__2(12);
              var anObject = __w_pdfjs_require__2(49);
              var tryToString = __w_pdfjs_require__2(34);
              var isArrayIteratorMethod = __w_pdfjs_require__2(108);
              var lengthOfArrayLike = __w_pdfjs_require__2(66);
              var isPrototypeOf = __w_pdfjs_require__2(27);
              var getIterator = __w_pdfjs_require__2(109);
              var getIteratorMethod = __w_pdfjs_require__2(110);
              var iteratorClose = __w_pdfjs_require__2(111);
              var $TypeError = TypeError;
              var Result = /* @__PURE__ */ __name(function(stopped, result) {
                this.stopped = stopped;
                this.result = result;
              }, "Result");
              var ResultPrototype = Result.prototype;
              module2.exports = function(iterable, unboundFunction, options) {
                var that = options && options.that;
                var AS_ENTRIES = !!(options && options.AS_ENTRIES);
                var IS_RECORD = !!(options && options.IS_RECORD);
                var IS_ITERATOR = !!(options && options.IS_ITERATOR);
                var INTERRUPTED = !!(options && options.INTERRUPTED);
                var fn = bind(unboundFunction, that);
                var iterator, iterFn, index, length, result, next, step;
                var stop = /* @__PURE__ */ __name(function(condition) {
                  if (iterator)
                    iteratorClose(iterator, "normal", condition);
                  return new Result(true, condition);
                }, "stop");
                var callFn = /* @__PURE__ */ __name(function(value) {
                  if (AS_ENTRIES) {
                    anObject(value);
                    return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
                  }
                  return INTERRUPTED ? fn(value, stop) : fn(value);
                }, "callFn");
                if (IS_RECORD) {
                  iterator = iterable.iterator;
                } else if (IS_ITERATOR) {
                  iterator = iterable;
                } else {
                  iterFn = getIteratorMethod(iterable);
                  if (!iterFn)
                    throw $TypeError(tryToString(iterable) + " is not iterable");
                  if (isArrayIteratorMethod(iterFn)) {
                    for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
                      result = callFn(iterable[index]);
                      if (result && isPrototypeOf(ResultPrototype, result))
                        return result;
                    }
                    return new Result(false);
                  }
                  iterator = getIterator(iterable, iterFn);
                }
                next = IS_RECORD ? iterable.next : iterator.next;
                while (!(step = call(next, iterator)).done) {
                  try {
                    result = callFn(step.value);
                  } catch (error) {
                    iteratorClose(iterator, "throw", error);
                  }
                  if (typeof result == "object" && result && isPrototypeOf(ResultPrototype, result))
                    return result;
                }
                return new Result(false);
              };
            },
            /* 107 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var uncurryThis = __w_pdfjs_require__2(18);
              var aCallable = __w_pdfjs_require__2(33);
              var NATIVE_BIND = __w_pdfjs_require__2(13);
              var bind = uncurryThis(uncurryThis.bind);
              module2.exports = function(fn, that) {
                aCallable(fn);
                return that === void 0 ? fn : NATIVE_BIND ? bind(fn, that) : function() {
                  return fn.apply(that, arguments);
                };
              };
            },
            /* 108 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var wellKnownSymbol = __w_pdfjs_require__2(36);
              var Iterators = __w_pdfjs_require__2(89);
              var ITERATOR = wellKnownSymbol("iterator");
              var ArrayPrototype = Array.prototype;
              module2.exports = function(it) {
                return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
              };
            },
            /* 109 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var call = __w_pdfjs_require__2(12);
              var aCallable = __w_pdfjs_require__2(33);
              var anObject = __w_pdfjs_require__2(49);
              var tryToString = __w_pdfjs_require__2(34);
              var getIteratorMethod = __w_pdfjs_require__2(110);
              var $TypeError = TypeError;
              module2.exports = function(argument, usingIterator) {
                var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
                if (aCallable(iteratorMethod))
                  return anObject(call(iteratorMethod, argument));
                throw $TypeError(tryToString(argument) + " is not iterable");
              };
            },
            /* 110 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var classof = __w_pdfjs_require__2(81);
              var getMethod = __w_pdfjs_require__2(32);
              var Iterators = __w_pdfjs_require__2(89);
              var wellKnownSymbol = __w_pdfjs_require__2(36);
              var ITERATOR = wellKnownSymbol("iterator");
              module2.exports = function(it) {
                if (it != void 0)
                  return getMethod(it, ITERATOR) || getMethod(it, "@@iterator") || Iterators[classof(it)];
              };
            },
            /* 111 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var call = __w_pdfjs_require__2(12);
              var anObject = __w_pdfjs_require__2(49);
              var getMethod = __w_pdfjs_require__2(32);
              module2.exports = function(iterator, kind, value) {
                var innerResult, innerError;
                anObject(iterator);
                try {
                  innerResult = getMethod(iterator, "return");
                  if (!innerResult) {
                    if (kind === "throw")
                      throw value;
                    return value;
                  }
                  innerResult = call(innerResult, iterator);
                } catch (error) {
                  innerError = true;
                  innerResult = error;
                }
                if (kind === "throw")
                  throw value;
                if (innerError)
                  throw innerResult;
                anObject(innerResult);
                return value;
              };
            },
            /* 112 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var isPrototypeOf = __w_pdfjs_require__2(27);
              var $TypeError = TypeError;
              module2.exports = function(it, Prototype) {
                if (isPrototypeOf(Prototype, it))
                  return it;
                throw $TypeError("Incorrect invocation");
              };
            },
            /* 113 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var wellKnownSymbol = __w_pdfjs_require__2(36);
              var ITERATOR = wellKnownSymbol("iterator");
              var SAFE_CLOSING = false;
              try {
                var called = 0;
                var iteratorWithReturn = {
                  next: function() {
                    return { done: !!called++ };
                  },
                  "return": function() {
                    SAFE_CLOSING = true;
                  }
                };
                iteratorWithReturn[ITERATOR] = function() {
                  return this;
                };
                Array.from(iteratorWithReturn, function() {
                  throw 2;
                });
              } catch (error) {
              }
              module2.exports = function(exec, SKIP_CLOSING) {
                if (!SKIP_CLOSING && !SAFE_CLOSING)
                  return false;
                var ITERATION_SUPPORT = false;
                try {
                  var object = {};
                  object[ITERATOR] = function() {
                    return {
                      next: function() {
                        return { done: ITERATION_SUPPORT = true };
                      }
                    };
                  };
                  exec(object);
                } catch (error) {
                }
                return ITERATION_SUPPORT;
              };
            },
            /* 114 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var isCallable = __w_pdfjs_require__2(24);
              var isObject = __w_pdfjs_require__2(23);
              var setPrototypeOf = __w_pdfjs_require__2(85);
              module2.exports = function($this, dummy, Wrapper) {
                var NewTarget, NewTargetPrototype;
                if (setPrototypeOf && isCallable(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype)
                  setPrototypeOf($this, NewTargetPrototype);
                return $this;
              };
            },
            /* 115 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var defineProperty = __w_pdfjs_require__2(47).f;
              var create = __w_pdfjs_require__2(72);
              var defineBuiltIns = __w_pdfjs_require__2(116);
              var bind = __w_pdfjs_require__2(107);
              var anInstance = __w_pdfjs_require__2(112);
              var iterate = __w_pdfjs_require__2(106);
              var defineIterator = __w_pdfjs_require__2(90);
              var setSpecies = __w_pdfjs_require__2(117);
              var DESCRIPTORS = __w_pdfjs_require__2(10);
              var fastKey = __w_pdfjs_require__2(99).fastKey;
              var InternalStateModule = __w_pdfjs_require__2(54);
              var setInternalState = InternalStateModule.set;
              var internalStateGetterFor = InternalStateModule.getterFor;
              module2.exports = {
                getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
                  var Constructor = wrapper(function(that, iterable) {
                    anInstance(that, Prototype);
                    setInternalState(that, {
                      type: CONSTRUCTOR_NAME,
                      index: create(null),
                      first: void 0,
                      last: void 0,
                      size: 0
                    });
                    if (!DESCRIPTORS)
                      that.size = 0;
                    if (iterable != void 0)
                      iterate(iterable, that[ADDER], {
                        that,
                        AS_ENTRIES: IS_MAP
                      });
                  });
                  var Prototype = Constructor.prototype;
                  var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
                  var define = /* @__PURE__ */ __name(function(that, key, value) {
                    var state = getInternalState(that);
                    var entry = getEntry(that, key);
                    var previous, index;
                    if (entry) {
                      entry.value = value;
                    } else {
                      state.last = entry = {
                        index: index = fastKey(key, true),
                        key,
                        value,
                        previous: previous = state.last,
                        next: void 0,
                        removed: false
                      };
                      if (!state.first)
                        state.first = entry;
                      if (previous)
                        previous.next = entry;
                      if (DESCRIPTORS)
                        state.size++;
                      else
                        that.size++;
                      if (index !== "F")
                        state.index[index] = entry;
                    }
                    return that;
                  }, "define");
                  var getEntry = /* @__PURE__ */ __name(function(that, key) {
                    var state = getInternalState(that);
                    var index = fastKey(key);
                    var entry;
                    if (index !== "F")
                      return state.index[index];
                    for (entry = state.first; entry; entry = entry.next) {
                      if (entry.key == key)
                        return entry;
                    }
                  }, "getEntry");
                  defineBuiltIns(Prototype, {
                    clear: /* @__PURE__ */ __name(function clear() {
                      var that = this;
                      var state = getInternalState(that);
                      var data = state.index;
                      var entry = state.first;
                      while (entry) {
                        entry.removed = true;
                        if (entry.previous)
                          entry.previous = entry.previous.next = void 0;
                        delete data[entry.index];
                        entry = entry.next;
                      }
                      state.first = state.last = void 0;
                      if (DESCRIPTORS)
                        state.size = 0;
                      else
                        that.size = 0;
                    }, "clear"),
                    "delete": function(key) {
                      var that = this;
                      var state = getInternalState(that);
                      var entry = getEntry(that, key);
                      if (entry) {
                        var next = entry.next;
                        var prev = entry.previous;
                        delete state.index[entry.index];
                        entry.removed = true;
                        if (prev)
                          prev.next = next;
                        if (next)
                          next.previous = prev;
                        if (state.first == entry)
                          state.first = next;
                        if (state.last == entry)
                          state.last = prev;
                        if (DESCRIPTORS)
                          state.size--;
                        else
                          that.size--;
                      }
                      return !!entry;
                    },
                    forEach: /* @__PURE__ */ __name(function forEach(callbackfn) {
                      var state = getInternalState(this);
                      var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
                      var entry;
                      while (entry = entry ? entry.next : state.first) {
                        boundFunction(entry.value, entry.key, this);
                        while (entry && entry.removed)
                          entry = entry.previous;
                      }
                    }, "forEach"),
                    has: /* @__PURE__ */ __name(function has(key) {
                      return !!getEntry(this, key);
                    }, "has")
                  });
                  defineBuiltIns(Prototype, IS_MAP ? {
                    get: /* @__PURE__ */ __name(function get(key) {
                      var entry = getEntry(this, key);
                      return entry && entry.value;
                    }, "get"),
                    set: /* @__PURE__ */ __name(function set(key, value) {
                      return define(this, key === 0 ? 0 : key, value);
                    }, "set")
                  } : {
                    add: /* @__PURE__ */ __name(function add(value) {
                      return define(this, value = value === 0 ? 0 : value, value);
                    }, "add")
                  });
                  if (DESCRIPTORS)
                    defineProperty(Prototype, "size", {
                      get: function() {
                        return getInternalState(this).size;
                      }
                    });
                  return Constructor;
                },
                setStrong: function(Constructor, CONSTRUCTOR_NAME, IS_MAP) {
                  var ITERATOR_NAME = CONSTRUCTOR_NAME + " Iterator";
                  var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
                  var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
                  defineIterator(Constructor, CONSTRUCTOR_NAME, function(iterated, kind) {
                    setInternalState(this, {
                      type: ITERATOR_NAME,
                      target: iterated,
                      state: getInternalCollectionState(iterated),
                      kind,
                      last: void 0
                    });
                  }, function() {
                    var state = getInternalIteratorState(this);
                    var kind = state.kind;
                    var entry = state.last;
                    while (entry && entry.removed)
                      entry = entry.previous;
                    if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
                      state.target = void 0;
                      return {
                        value: void 0,
                        done: true
                      };
                    }
                    if (kind == "keys")
                      return {
                        value: entry.key,
                        done: false
                      };
                    if (kind == "values")
                      return {
                        value: entry.value,
                        done: false
                      };
                    return {
                      value: [
                        entry.key,
                        entry.value
                      ],
                      done: false
                    };
                  }, IS_MAP ? "entries" : "values", !IS_MAP, true);
                  setSpecies(CONSTRUCTOR_NAME);
                }
              };
            },
            /* 116 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var defineBuiltIn = __w_pdfjs_require__2(50);
              module2.exports = function(target, src, options) {
                for (var key in src)
                  defineBuiltIn(target, key, src[key], options);
                return target;
              };
            },
            /* 117 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var getBuiltIn = __w_pdfjs_require__2(26);
              var definePropertyModule = __w_pdfjs_require__2(47);
              var wellKnownSymbol = __w_pdfjs_require__2(36);
              var DESCRIPTORS = __w_pdfjs_require__2(10);
              var SPECIES = wellKnownSymbol("species");
              module2.exports = function(CONSTRUCTOR_NAME) {
                var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
                var defineProperty = definePropertyModule.f;
                if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
                  defineProperty(Constructor, SPECIES, {
                    configurable: true,
                    get: function() {
                      return this;
                    }
                  });
                }
              };
            },
            /* 118 */
            /***/
            (__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__2) => {
              __w_pdfjs_require__2(119);
            },
            /* 119 */
            /***/
            (__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var collection = __w_pdfjs_require__2(98);
              var collectionStrong = __w_pdfjs_require__2(115);
              collection("Set", function(init) {
                return /* @__PURE__ */ __name(function Set2() {
                  return init(this, arguments.length ? arguments[0] : void 0);
                }, "Set");
              }, collectionStrong);
            },
            /* 120 */
            /***/
            (__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var IS_PURE = __w_pdfjs_require__2(38);
              var $ = __w_pdfjs_require__2(7);
              var global2 = __w_pdfjs_require__2(8);
              var getBuiltin = __w_pdfjs_require__2(26);
              var uncurryThis = __w_pdfjs_require__2(18);
              var fails = __w_pdfjs_require__2(11);
              var uid = __w_pdfjs_require__2(43);
              var isCallable = __w_pdfjs_require__2(24);
              var isConstructor = __w_pdfjs_require__2(121);
              var isObject = __w_pdfjs_require__2(23);
              var isSymbol = __w_pdfjs_require__2(25);
              var iterate = __w_pdfjs_require__2(106);
              var anObject = __w_pdfjs_require__2(49);
              var classof = __w_pdfjs_require__2(81);
              var hasOwn = __w_pdfjs_require__2(41);
              var createProperty = __w_pdfjs_require__2(102);
              var createNonEnumerableProperty = __w_pdfjs_require__2(46);
              var lengthOfArrayLike = __w_pdfjs_require__2(66);
              var validateArgumentsLength = __w_pdfjs_require__2(122);
              var getRegExpFlags = __w_pdfjs_require__2(123);
              var ERROR_STACK_INSTALLABLE = __w_pdfjs_require__2(125);
              var V8 = __w_pdfjs_require__2(30);
              var IS_BROWSER = __w_pdfjs_require__2(126);
              var IS_DENO = __w_pdfjs_require__2(127);
              var IS_NODE = __w_pdfjs_require__2(128);
              var Object2 = global2.Object;
              var Date2 = global2.Date;
              var Error2 = global2.Error;
              var EvalError = global2.EvalError;
              var RangeError2 = global2.RangeError;
              var ReferenceError2 = global2.ReferenceError;
              var SyntaxError = global2.SyntaxError;
              var TypeError2 = global2.TypeError;
              var URIError = global2.URIError;
              var PerformanceMark = global2.PerformanceMark;
              var WebAssembly = global2.WebAssembly;
              var CompileError = WebAssembly && WebAssembly.CompileError || Error2;
              var LinkError = WebAssembly && WebAssembly.LinkError || Error2;
              var RuntimeError = WebAssembly && WebAssembly.RuntimeError || Error2;
              var DOMException2 = getBuiltin("DOMException");
              var Set2 = getBuiltin("Set");
              var Map2 = getBuiltin("Map");
              var MapPrototype = Map2.prototype;
              var mapHas = uncurryThis(MapPrototype.has);
              var mapGet = uncurryThis(MapPrototype.get);
              var mapSet = uncurryThis(MapPrototype.set);
              var setAdd = uncurryThis(Set2.prototype.add);
              var objectKeys = getBuiltin("Object", "keys");
              var push = uncurryThis([].push);
              var booleanValueOf = uncurryThis(true.valueOf);
              var numberValueOf = uncurryThis(1 .valueOf);
              var stringValueOf = uncurryThis("".valueOf);
              var getTime = uncurryThis(Date2.prototype.getTime);
              var PERFORMANCE_MARK = uid("structuredClone");
              var DATA_CLONE_ERROR = "DataCloneError";
              var TRANSFERRING = "Transferring";
              var checkBasicSemantic = /* @__PURE__ */ __name(function(structuredCloneImplementation) {
                return !fails(function() {
                  var set1 = new global2.Set([7]);
                  var set2 = structuredCloneImplementation(set1);
                  var number = structuredCloneImplementation(Object2(7));
                  return set2 == set1 || !set2.has(7) || typeof number != "object" || number != 7;
                }) && structuredCloneImplementation;
              }, "checkBasicSemantic");
              var checkErrorsCloning = /* @__PURE__ */ __name(function(structuredCloneImplementation, $Error) {
                return !fails(function() {
                  var error = new $Error();
                  var test = structuredCloneImplementation({
                    a: error,
                    b: error
                  });
                  return !(test && test.a === test.b && test.a instanceof $Error && test.a.stack === error.stack);
                });
              }, "checkErrorsCloning");
              var checkNewErrorsCloningSemantic = /* @__PURE__ */ __name(function(structuredCloneImplementation) {
                return !fails(function() {
                  var test = structuredCloneImplementation(new global2.AggregateError([1], PERFORMANCE_MARK, { cause: 3 }));
                  return test.name != "AggregateError" || test.errors[0] != 1 || test.message != PERFORMANCE_MARK || test.cause != 3;
                });
              }, "checkNewErrorsCloningSemantic");
              var nativeStructuredClone = global2.structuredClone;
              var FORCED_REPLACEMENT = IS_PURE || !checkErrorsCloning(nativeStructuredClone, Error2) || !checkErrorsCloning(nativeStructuredClone, DOMException2) || !checkNewErrorsCloningSemantic(nativeStructuredClone);
              var structuredCloneFromMark = !nativeStructuredClone && checkBasicSemantic(function(value) {
                return new PerformanceMark(PERFORMANCE_MARK, { detail: value }).detail;
              });
              var nativeRestrictedStructuredClone = checkBasicSemantic(nativeStructuredClone) || structuredCloneFromMark;
              var throwUncloneable = /* @__PURE__ */ __name(function(type) {
                throw new DOMException2("Uncloneable type: " + type, DATA_CLONE_ERROR);
              }, "throwUncloneable");
              var throwUnpolyfillable = /* @__PURE__ */ __name(function(type, kind) {
                throw new DOMException2((kind || "Cloning") + " of " + type + " cannot be properly polyfilled in this engine", DATA_CLONE_ERROR);
              }, "throwUnpolyfillable");
              var structuredCloneInternal = /* @__PURE__ */ __name(function(value, map) {
                if (isSymbol(value))
                  throwUncloneable("Symbol");
                if (!isObject(value))
                  return value;
                if (map) {
                  if (mapHas(map, value))
                    return mapGet(map, value);
                } else
                  map = new Map2();
                var type = classof(value);
                var deep = false;
                var C, name, cloned, dataTransfer, i, length, keys, key, source, target;
                switch (type) {
                  case "Array":
                    cloned = [];
                    deep = true;
                    break;
                  case "Object":
                    cloned = {};
                    deep = true;
                    break;
                  case "Map":
                    cloned = new Map2();
                    deep = true;
                    break;
                  case "Set":
                    cloned = new Set2();
                    deep = true;
                    break;
                  case "RegExp":
                    cloned = new RegExp(value.source, getRegExpFlags(value));
                    break;
                  case "Error":
                    name = value.name;
                    switch (name) {
                      case "AggregateError":
                        cloned = getBuiltin("AggregateError")([]);
                        break;
                      case "EvalError":
                        cloned = EvalError();
                        break;
                      case "RangeError":
                        cloned = RangeError2();
                        break;
                      case "ReferenceError":
                        cloned = ReferenceError2();
                        break;
                      case "SyntaxError":
                        cloned = SyntaxError();
                        break;
                      case "TypeError":
                        cloned = TypeError2();
                        break;
                      case "URIError":
                        cloned = URIError();
                        break;
                      case "CompileError":
                        cloned = CompileError();
                        break;
                      case "LinkError":
                        cloned = LinkError();
                        break;
                      case "RuntimeError":
                        cloned = RuntimeError();
                        break;
                      default:
                        cloned = Error2();
                    }
                    deep = true;
                    break;
                  case "DOMException":
                    cloned = new DOMException2(value.message, value.name);
                    deep = true;
                    break;
                  case "DataView":
                  case "Int8Array":
                  case "Uint8Array":
                  case "Uint8ClampedArray":
                  case "Int16Array":
                  case "Uint16Array":
                  case "Int32Array":
                  case "Uint32Array":
                  case "Float32Array":
                  case "Float64Array":
                  case "BigInt64Array":
                  case "BigUint64Array":
                    C = global2[type];
                    if (!isObject(C))
                      throwUnpolyfillable(type);
                    cloned = new C(structuredCloneInternal(value.buffer, map), value.byteOffset, type === "DataView" ? value.byteLength : value.length);
                    break;
                  case "DOMQuad":
                    try {
                      cloned = new DOMQuad(structuredCloneInternal(value.p1, map), structuredCloneInternal(value.p2, map), structuredCloneInternal(value.p3, map), structuredCloneInternal(value.p4, map));
                    } catch (error) {
                      if (nativeRestrictedStructuredClone) {
                        cloned = nativeRestrictedStructuredClone(value);
                      } else
                        throwUnpolyfillable(type);
                    }
                    break;
                  case "FileList":
                    C = global2.DataTransfer;
                    if (isConstructor(C)) {
                      dataTransfer = new C();
                      for (i = 0, length = lengthOfArrayLike(value); i < length; i++) {
                        dataTransfer.items.add(structuredCloneInternal(value[i], map));
                      }
                      cloned = dataTransfer.files;
                    } else if (nativeRestrictedStructuredClone) {
                      cloned = nativeRestrictedStructuredClone(value);
                    } else
                      throwUnpolyfillable(type);
                    break;
                  case "ImageData":
                    try {
                      cloned = new ImageData(structuredCloneInternal(value.data, map), value.width, value.height, { colorSpace: value.colorSpace });
                    } catch (error) {
                      if (nativeRestrictedStructuredClone) {
                        cloned = nativeRestrictedStructuredClone(value);
                      } else
                        throwUnpolyfillable(type);
                    }
                    break;
                  default:
                    if (nativeRestrictedStructuredClone) {
                      cloned = nativeRestrictedStructuredClone(value);
                    } else
                      switch (type) {
                        case "BigInt":
                          cloned = Object2(value.valueOf());
                          break;
                        case "Boolean":
                          cloned = Object2(booleanValueOf(value));
                          break;
                        case "Number":
                          cloned = Object2(numberValueOf(value));
                          break;
                        case "String":
                          cloned = Object2(stringValueOf(value));
                          break;
                        case "Date":
                          cloned = new Date2(getTime(value));
                          break;
                        case "ArrayBuffer":
                          C = global2.DataView;
                          if (!C && typeof value.slice != "function")
                            throwUnpolyfillable(type);
                          try {
                            if (typeof value.slice == "function") {
                              cloned = value.slice(0);
                            } else {
                              length = value.byteLength;
                              cloned = new ArrayBuffer(length);
                              source = new C(value);
                              target = new C(cloned);
                              for (i = 0; i < length; i++) {
                                target.setUint8(i, source.getUint8(i));
                              }
                            }
                          } catch (error) {
                            throw new DOMException2("ArrayBuffer is detached", DATA_CLONE_ERROR);
                          }
                          break;
                        case "SharedArrayBuffer":
                          cloned = value;
                          break;
                        case "Blob":
                          try {
                            cloned = value.slice(0, value.size, value.type);
                          } catch (error) {
                            throwUnpolyfillable(type);
                          }
                          break;
                        case "DOMPoint":
                        case "DOMPointReadOnly":
                          C = global2[type];
                          try {
                            cloned = C.fromPoint ? C.fromPoint(value) : new C(value.x, value.y, value.z, value.w);
                          } catch (error) {
                            throwUnpolyfillable(type);
                          }
                          break;
                        case "DOMRect":
                        case "DOMRectReadOnly":
                          C = global2[type];
                          try {
                            cloned = C.fromRect ? C.fromRect(value) : new C(value.x, value.y, value.width, value.height);
                          } catch (error) {
                            throwUnpolyfillable(type);
                          }
                          break;
                        case "DOMMatrix":
                        case "DOMMatrixReadOnly":
                          C = global2[type];
                          try {
                            cloned = C.fromMatrix ? C.fromMatrix(value) : new C(value);
                          } catch (error) {
                            throwUnpolyfillable(type);
                          }
                          break;
                        case "AudioData":
                        case "VideoFrame":
                          if (!isCallable(value.clone))
                            throwUnpolyfillable(type);
                          try {
                            cloned = value.clone();
                          } catch (error) {
                            throwUncloneable(type);
                          }
                          break;
                        case "File":
                          try {
                            cloned = new File([value], value.name, value);
                          } catch (error) {
                            throwUnpolyfillable(type);
                          }
                          break;
                        case "CryptoKey":
                        case "GPUCompilationMessage":
                        case "GPUCompilationInfo":
                        case "ImageBitmap":
                        case "RTCCertificate":
                        case "WebAssembly.Module":
                          throwUnpolyfillable(type);
                        default:
                          throwUncloneable(type);
                      }
                }
                mapSet(map, value, cloned);
                if (deep)
                  switch (type) {
                    case "Array":
                    case "Object":
                      keys = objectKeys(value);
                      for (i = 0, length = lengthOfArrayLike(keys); i < length; i++) {
                        key = keys[i];
                        createProperty(cloned, key, structuredCloneInternal(value[key], map));
                      }
                      break;
                    case "Map":
                      value.forEach(function(v, k) {
                        mapSet(cloned, structuredCloneInternal(k, map), structuredCloneInternal(v, map));
                      });
                      break;
                    case "Set":
                      value.forEach(function(v) {
                        setAdd(cloned, structuredCloneInternal(v, map));
                      });
                      break;
                    case "Error":
                      createNonEnumerableProperty(cloned, "message", structuredCloneInternal(value.message, map));
                      if (hasOwn(value, "cause")) {
                        createNonEnumerableProperty(cloned, "cause", structuredCloneInternal(value.cause, map));
                      }
                      if (name == "AggregateError") {
                        cloned.errors = structuredCloneInternal(value.errors, map);
                      }
                    case "DOMException":
                      if (ERROR_STACK_INSTALLABLE) {
                        createNonEnumerableProperty(cloned, "stack", structuredCloneInternal(value.stack, map));
                      }
                  }
                return cloned;
              }, "structuredCloneInternal");
              var PROPER_TRANSFER = nativeStructuredClone && !fails(function() {
                if (IS_DENO && V8 > 92 || IS_NODE && V8 > 94 || IS_BROWSER && V8 > 97)
                  return false;
                var buffer = new ArrayBuffer(8);
                var clone = nativeStructuredClone(buffer, { transfer: [buffer] });
                return buffer.byteLength != 0 || clone.byteLength != 8;
              });
              var tryToTransfer = /* @__PURE__ */ __name(function(rawTransfer, map) {
                if (!isObject(rawTransfer))
                  throw TypeError2("Transfer option cannot be converted to a sequence");
                var transfer = [];
                iterate(rawTransfer, function(value2) {
                  push(transfer, anObject(value2));
                });
                var i = 0;
                var length = lengthOfArrayLike(transfer);
                var value, type, C, transferredArray, transferred, canvas, context;
                if (PROPER_TRANSFER) {
                  transferredArray = nativeStructuredClone(transfer, { transfer });
                  while (i < length)
                    mapSet(map, transfer[i], transferredArray[i++]);
                } else
                  while (i < length) {
                    value = transfer[i++];
                    if (mapHas(map, value))
                      throw new DOMException2("Duplicate transferable", DATA_CLONE_ERROR);
                    type = classof(value);
                    switch (type) {
                      case "ImageBitmap":
                        C = global2.OffscreenCanvas;
                        if (!isConstructor(C))
                          throwUnpolyfillable(type, TRANSFERRING);
                        try {
                          canvas = new C(value.width, value.height);
                          context = canvas.getContext("bitmaprenderer");
                          context.transferFromImageBitmap(value);
                          transferred = canvas.transferToImageBitmap();
                        } catch (error) {
                        }
                        break;
                      case "AudioData":
                      case "VideoFrame":
                        if (!isCallable(value.clone) || !isCallable(value.close))
                          throwUnpolyfillable(type, TRANSFERRING);
                        try {
                          transferred = value.clone();
                          value.close();
                        } catch (error) {
                        }
                        break;
                      case "ArrayBuffer":
                      case "MessagePort":
                      case "OffscreenCanvas":
                      case "ReadableStream":
                      case "TransformStream":
                      case "WritableStream":
                        throwUnpolyfillable(type, TRANSFERRING);
                    }
                    if (transferred === void 0)
                      throw new DOMException2("This object cannot be transferred: " + type, DATA_CLONE_ERROR);
                    mapSet(map, value, transferred);
                  }
              }, "tryToTransfer");
              $({
                global: true,
                enumerable: true,
                sham: !PROPER_TRANSFER,
                forced: FORCED_REPLACEMENT
              }, {
                structuredClone: /* @__PURE__ */ __name(function structuredClone(value) {
                  var options = validateArgumentsLength(arguments.length, 1) > 1 && arguments[1] != null ? anObject(arguments[1]) : void 0;
                  var transfer = options ? options.transfer : void 0;
                  var map;
                  if (transfer !== void 0) {
                    map = new Map2();
                    tryToTransfer(transfer, map);
                  }
                  return structuredCloneInternal(value, map);
                }, "structuredClone")
              });
            },
            /* 121 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var uncurryThis = __w_pdfjs_require__2(18);
              var fails = __w_pdfjs_require__2(11);
              var isCallable = __w_pdfjs_require__2(24);
              var classof = __w_pdfjs_require__2(81);
              var getBuiltIn = __w_pdfjs_require__2(26);
              var inspectSource = __w_pdfjs_require__2(53);
              var noop = /* @__PURE__ */ __name(function() {
              }, "noop");
              var empty = [];
              var construct = getBuiltIn("Reflect", "construct");
              var constructorRegExp = /^\s*(?:class|function)\b/;
              var exec = uncurryThis(constructorRegExp.exec);
              var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);
              var isConstructorModern = /* @__PURE__ */ __name(function isConstructor(argument) {
                if (!isCallable(argument))
                  return false;
                try {
                  construct(noop, empty, argument);
                  return true;
                } catch (error) {
                  return false;
                }
              }, "isConstructor");
              var isConstructorLegacy = /* @__PURE__ */ __name(function isConstructor(argument) {
                if (!isCallable(argument))
                  return false;
                switch (classof(argument)) {
                  case "AsyncFunction":
                  case "GeneratorFunction":
                  case "AsyncGeneratorFunction":
                    return false;
                }
                try {
                  return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
                } catch (error) {
                  return true;
                }
              }, "isConstructor");
              isConstructorLegacy.sham = true;
              module2.exports = !construct || fails(function() {
                var called;
                return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
                  called = true;
                }) || called;
              }) ? isConstructorLegacy : isConstructorModern;
            },
            /* 122 */
            /***/
            (module2) => {
              var $TypeError = TypeError;
              module2.exports = function(passed, required) {
                if (passed < required)
                  throw $TypeError("Not enough arguments");
                return passed;
              };
            },
            /* 123 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var call = __w_pdfjs_require__2(12);
              var hasOwn = __w_pdfjs_require__2(41);
              var isPrototypeOf = __w_pdfjs_require__2(27);
              var regExpFlags = __w_pdfjs_require__2(124);
              var RegExpPrototype = RegExp.prototype;
              module2.exports = function(R) {
                var flags = R.flags;
                return flags === void 0 && !("flags" in RegExpPrototype) && !hasOwn(R, "flags") && isPrototypeOf(RegExpPrototype, R) ? call(regExpFlags, R) : flags;
              };
            },
            /* 124 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var anObject = __w_pdfjs_require__2(49);
              module2.exports = function() {
                var that = anObject(this);
                var result = "";
                if (that.hasIndices)
                  result += "d";
                if (that.global)
                  result += "g";
                if (that.ignoreCase)
                  result += "i";
                if (that.multiline)
                  result += "m";
                if (that.dotAll)
                  result += "s";
                if (that.unicode)
                  result += "u";
                if (that.unicodeSets)
                  result += "v";
                if (that.sticky)
                  result += "y";
                return result;
              };
            },
            /* 125 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var fails = __w_pdfjs_require__2(11);
              var createPropertyDescriptor = __w_pdfjs_require__2(15);
              module2.exports = !fails(function() {
                var error = Error("a");
                if (!("stack" in error))
                  return true;
                Object.defineProperty(error, "stack", createPropertyDescriptor(1, 7));
                return error.stack !== 7;
              });
            },
            /* 126 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var IS_DENO = __w_pdfjs_require__2(127);
              var IS_NODE = __w_pdfjs_require__2(128);
              module2.exports = !IS_DENO && !IS_NODE && typeof window == "object" && typeof document == "object";
            },
            /* 127 */
            /***/
            (module2) => {
              module2.exports = typeof Deno == "object" && Deno && typeof Deno.version == "object";
            },
            /* 128 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var classof = __w_pdfjs_require__2(19);
              var global2 = __w_pdfjs_require__2(8);
              module2.exports = classof(global2.process) == "process";
            },
            /* 129 */
            /***/
            (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var global2 = __w_pdfjs_require__2(8);
              module2.exports = global2;
            },
            /* 130 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.RefSetCache = exports2.RefSet = exports2.Ref = exports2.Name = exports2.EOF = exports2.Dict = exports2.Cmd = exports2.CIRCULAR_REF = void 0;
              exports2.clearPrimitiveCaches = clearPrimitiveCaches;
              exports2.isCmd = isCmd;
              exports2.isDict = isDict;
              exports2.isName = isName;
              exports2.isRefsEqual = isRefsEqual;
              var _util = __w_pdfjs_require__2(2);
              const CIRCULAR_REF = Symbol("CIRCULAR_REF");
              exports2.CIRCULAR_REF = CIRCULAR_REF;
              const EOF = Symbol("EOF");
              exports2.EOF = EOF;
              const Name = (/* @__PURE__ */ __name(function NameClosure() {
                let nameCache = /* @__PURE__ */ Object.create(null);
                const _Name = class _Name {
                  constructor(name) {
                    this.name = name;
                  }
                  static get(name) {
                    return nameCache[name] || (nameCache[name] = new _Name(name));
                  }
                  static _clearCache() {
                    nameCache = /* @__PURE__ */ Object.create(null);
                  }
                };
                __name(_Name, "Name");
                let Name2 = _Name;
                return Name2;
              }, "NameClosure"))();
              exports2.Name = Name;
              const Cmd = (/* @__PURE__ */ __name(function CmdClosure() {
                let cmdCache = /* @__PURE__ */ Object.create(null);
                const _Cmd = class _Cmd {
                  constructor(cmd) {
                    this.cmd = cmd;
                  }
                  static get(cmd) {
                    return cmdCache[cmd] || (cmdCache[cmd] = new _Cmd(cmd));
                  }
                  static _clearCache() {
                    cmdCache = /* @__PURE__ */ Object.create(null);
                  }
                };
                __name(_Cmd, "Cmd");
                let Cmd2 = _Cmd;
                return Cmd2;
              }, "CmdClosure"))();
              exports2.Cmd = Cmd;
              const nonSerializable = /* @__PURE__ */ __name(function nonSerializableClosure() {
                return nonSerializable;
              }, "nonSerializableClosure");
              const _Dict = class _Dict {
                constructor() {
                  let xref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                  this._map = /* @__PURE__ */ Object.create(null);
                  this.xref = xref;
                  this.objId = null;
                  this.suppressEncryption = false;
                  this.__nonSerializable__ = nonSerializable;
                }
                assignXref(newXref) {
                  this.xref = newXref;
                }
                get size() {
                  return Object.keys(this._map).length;
                }
                get(key1, key2, key3) {
                  let value = this._map[key1];
                  if (value === void 0 && key2 !== void 0) {
                    value = this._map[key2];
                    if (value === void 0 && key3 !== void 0) {
                      value = this._map[key3];
                    }
                  }
                  if (value instanceof Ref && this.xref) {
                    return this.xref.fetch(value, this.suppressEncryption);
                  }
                  return value;
                }
                async getAsync(key1, key2, key3) {
                  let value = this._map[key1];
                  if (value === void 0 && key2 !== void 0) {
                    value = this._map[key2];
                    if (value === void 0 && key3 !== void 0) {
                      value = this._map[key3];
                    }
                  }
                  if (value instanceof Ref && this.xref) {
                    return this.xref.fetchAsync(value, this.suppressEncryption);
                  }
                  return value;
                }
                getArray(key1, key2, key3) {
                  let value = this._map[key1];
                  if (value === void 0 && key2 !== void 0) {
                    value = this._map[key2];
                    if (value === void 0 && key3 !== void 0) {
                      value = this._map[key3];
                    }
                  }
                  if (value instanceof Ref && this.xref) {
                    value = this.xref.fetch(value, this.suppressEncryption);
                  }
                  if (Array.isArray(value)) {
                    value = value.slice();
                    for (let i = 0, ii = value.length; i < ii; i++) {
                      if (value[i] instanceof Ref && this.xref) {
                        value[i] = this.xref.fetch(value[i], this.suppressEncryption);
                      }
                    }
                  }
                  return value;
                }
                getRaw(key) {
                  return this._map[key];
                }
                getKeys() {
                  return Object.keys(this._map);
                }
                getRawValues() {
                  return Object.values(this._map);
                }
                set(key, value) {
                  this._map[key] = value;
                }
                has(key) {
                  return this._map[key] !== void 0;
                }
                forEach(callback) {
                  for (const key in this._map) {
                    callback(key, this.get(key));
                  }
                }
                static get empty() {
                  const emptyDict = new _Dict(null);
                  emptyDict.set = (key, value) => {
                    (0, _util.unreachable)("Should not call `set` on the empty dictionary.");
                  };
                  return (0, _util.shadow)(this, "empty", emptyDict);
                }
                static merge(_ref) {
                  let {
                    xref,
                    dictArray,
                    mergeSubDicts = false
                  } = _ref;
                  const mergedDict = new _Dict(xref), properties = /* @__PURE__ */ new Map();
                  for (const dict of dictArray) {
                    if (!(dict instanceof _Dict)) {
                      continue;
                    }
                    for (const [key, value] of Object.entries(dict._map)) {
                      let property = properties.get(key);
                      if (property === void 0) {
                        property = [];
                        properties.set(key, property);
                      } else if (!mergeSubDicts || !(value instanceof _Dict)) {
                        continue;
                      }
                      property.push(value);
                    }
                  }
                  for (const [name, values] of properties) {
                    if (values.length === 1 || !(values[0] instanceof _Dict)) {
                      mergedDict._map[name] = values[0];
                      continue;
                    }
                    const subDict = new _Dict(xref);
                    for (const dict of values) {
                      for (const [key, value] of Object.entries(dict._map)) {
                        if (subDict._map[key] === void 0) {
                          subDict._map[key] = value;
                        }
                      }
                    }
                    if (subDict.size > 0) {
                      mergedDict._map[name] = subDict;
                    }
                  }
                  properties.clear();
                  return mergedDict.size > 0 ? mergedDict : _Dict.empty;
                }
              };
              __name(_Dict, "Dict");
              let Dict = _Dict;
              exports2.Dict = Dict;
              const Ref = (/* @__PURE__ */ __name(function RefClosure() {
                let refCache = /* @__PURE__ */ Object.create(null);
                const _Ref = class _Ref {
                  constructor(num, gen) {
                    this.num = num;
                    this.gen = gen;
                  }
                  toString() {
                    if (this.gen === 0) {
                      return `${this.num}R`;
                    }
                    return `${this.num}R${this.gen}`;
                  }
                  static get(num, gen) {
                    const key = gen === 0 ? `${num}R` : `${num}R${gen}`;
                    return refCache[key] || (refCache[key] = new _Ref(num, gen));
                  }
                  static _clearCache() {
                    refCache = /* @__PURE__ */ Object.create(null);
                  }
                };
                __name(_Ref, "Ref");
                let Ref2 = _Ref;
                return Ref2;
              }, "RefClosure"))();
              exports2.Ref = Ref;
              const _RefSet = class _RefSet {
                constructor() {
                  let parent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                  this._set = new Set(parent && parent._set);
                }
                has(ref) {
                  return this._set.has(ref.toString());
                }
                put(ref) {
                  this._set.add(ref.toString());
                }
                remove(ref) {
                  this._set.delete(ref.toString());
                }
                [Symbol.iterator]() {
                  return this._set.values();
                }
                clear() {
                  this._set.clear();
                }
              };
              __name(_RefSet, "RefSet");
              let RefSet = _RefSet;
              exports2.RefSet = RefSet;
              const _RefSetCache = class _RefSetCache {
                constructor() {
                  this._map = /* @__PURE__ */ new Map();
                }
                get size() {
                  return this._map.size;
                }
                get(ref) {
                  return this._map.get(ref.toString());
                }
                has(ref) {
                  return this._map.has(ref.toString());
                }
                put(ref, obj) {
                  this._map.set(ref.toString(), obj);
                }
                putAlias(ref, aliasRef) {
                  this._map.set(ref.toString(), this.get(aliasRef));
                }
                [Symbol.iterator]() {
                  return this._map.values();
                }
                clear() {
                  this._map.clear();
                }
              };
              __name(_RefSetCache, "RefSetCache");
              let RefSetCache = _RefSetCache;
              exports2.RefSetCache = RefSetCache;
              function isName(v, name) {
                return v instanceof Name && (name === void 0 || v.name === name);
              }
              __name(isName, "isName");
              function isCmd(v, cmd) {
                return v instanceof Cmd && (cmd === void 0 || v.cmd === cmd);
              }
              __name(isCmd, "isCmd");
              function isDict(v, type) {
                return v instanceof Dict && (type === void 0 || isName(v.get("Type"), type));
              }
              __name(isDict, "isDict");
              function isRefsEqual(v1, v2) {
                return v1.num === v2.num && v1.gen === v2.gen;
              }
              __name(isRefsEqual, "isRefsEqual");
              function clearPrimitiveCaches() {
                Cmd._clearCache();
                Name._clearCache();
                Ref._clearCache();
              }
              __name(clearPrimitiveCaches, "clearPrimitiveCaches");
            },
            /* 131 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.XRefParseException = exports2.XRefEntryException = exports2.ParserEOFException = exports2.MissingDataException = exports2.DocStats = void 0;
              exports2.collectActions = collectActions;
              exports2.encodeToXmlString = encodeToXmlString;
              exports2.escapePDFName = escapePDFName;
              exports2.getArrayLookupTableFactory = getArrayLookupTableFactory;
              exports2.getInheritableProperty = getInheritableProperty;
              exports2.getLookupTableFactory = getLookupTableFactory;
              exports2.getNewAnnotationsMap = getNewAnnotationsMap;
              exports2.isWhiteSpace = isWhiteSpace;
              exports2.log2 = log2;
              exports2.numberToString = numberToString;
              exports2.parseXFAPath = parseXFAPath;
              exports2.readInt8 = readInt8;
              exports2.readUint16 = readUint16;
              exports2.readUint32 = readUint32;
              exports2.recoverJsURL = recoverJsURL;
              exports2.toRomanNumerals = toRomanNumerals;
              exports2.validateCSSFont = validateCSSFont;
              var _util = __w_pdfjs_require__2(2);
              var _primitives = __w_pdfjs_require__2(130);
              var _base_stream = __w_pdfjs_require__2(132);
              function getLookupTableFactory(initializer) {
                let lookup;
                return function() {
                  if (initializer) {
                    lookup = /* @__PURE__ */ Object.create(null);
                    initializer(lookup);
                    initializer = null;
                  }
                  return lookup;
                };
              }
              __name(getLookupTableFactory, "getLookupTableFactory");
              function getArrayLookupTableFactory(initializer) {
                let lookup;
                return function() {
                  if (initializer) {
                    let arr = initializer();
                    initializer = null;
                    lookup = /* @__PURE__ */ Object.create(null);
                    for (let i = 0, ii = arr.length; i < ii; i += 2) {
                      lookup[arr[i]] = arr[i + 1];
                    }
                    arr = null;
                  }
                  return lookup;
                };
              }
              __name(getArrayLookupTableFactory, "getArrayLookupTableFactory");
              const _MissingDataException = class _MissingDataException extends _util.BaseException {
                constructor(begin, end) {
                  super(`Missing data [${begin}, ${end})`, "MissingDataException");
                  this.begin = begin;
                  this.end = end;
                }
              };
              __name(_MissingDataException, "MissingDataException");
              let MissingDataException = _MissingDataException;
              exports2.MissingDataException = MissingDataException;
              const _ParserEOFException = class _ParserEOFException extends _util.BaseException {
                constructor(msg) {
                  super(msg, "ParserEOFException");
                }
              };
              __name(_ParserEOFException, "ParserEOFException");
              let ParserEOFException = _ParserEOFException;
              exports2.ParserEOFException = ParserEOFException;
              const _XRefEntryException = class _XRefEntryException extends _util.BaseException {
                constructor(msg) {
                  super(msg, "XRefEntryException");
                }
              };
              __name(_XRefEntryException, "XRefEntryException");
              let XRefEntryException = _XRefEntryException;
              exports2.XRefEntryException = XRefEntryException;
              const _XRefParseException = class _XRefParseException extends _util.BaseException {
                constructor(msg) {
                  super(msg, "XRefParseException");
                }
              };
              __name(_XRefParseException, "XRefParseException");
              let XRefParseException = _XRefParseException;
              exports2.XRefParseException = XRefParseException;
              const _DocStats = class _DocStats {
                constructor(handler) {
                  this._handler = handler;
                  this._streamTypes = /* @__PURE__ */ new Set();
                  this._fontTypes = /* @__PURE__ */ new Set();
                }
                _send() {
                  const streamTypes = /* @__PURE__ */ Object.create(null), fontTypes = /* @__PURE__ */ Object.create(null);
                  for (const type of this._streamTypes) {
                    streamTypes[type] = true;
                  }
                  for (const type of this._fontTypes) {
                    fontTypes[type] = true;
                  }
                  this._handler.send("DocStats", {
                    streamTypes,
                    fontTypes
                  });
                }
                addStreamType(type) {
                  if (this._streamTypes.has(type)) {
                    return;
                  }
                  this._streamTypes.add(type);
                  this._send();
                }
                addFontType(type) {
                  if (this._fontTypes.has(type)) {
                    return;
                  }
                  this._fontTypes.add(type);
                  this._send();
                }
              };
              __name(_DocStats, "DocStats");
              let DocStats = _DocStats;
              exports2.DocStats = DocStats;
              function getInheritableProperty(_ref) {
                let {
                  dict,
                  key,
                  getArray = false,
                  stopWhenFound = true
                } = _ref;
                let values;
                const visited = new _primitives.RefSet();
                while (dict instanceof _primitives.Dict && !(dict.objId && visited.has(dict.objId))) {
                  if (dict.objId) {
                    visited.put(dict.objId);
                  }
                  const value = getArray ? dict.getArray(key) : dict.get(key);
                  if (value !== void 0) {
                    if (stopWhenFound) {
                      return value;
                    }
                    if (!values) {
                      values = [];
                    }
                    values.push(value);
                  }
                  dict = dict.get("Parent");
                }
                return values;
              }
              __name(getInheritableProperty, "getInheritableProperty");
              const ROMAN_NUMBER_MAP = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
              function toRomanNumerals(number) {
                let lowerCase = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                (0, _util.assert)(Number.isInteger(number) && number > 0, "The number should be a positive integer.");
                const romanBuf = [];
                let pos;
                while (number >= 1e3) {
                  number -= 1e3;
                  romanBuf.push("M");
                }
                pos = number / 100 | 0;
                number %= 100;
                romanBuf.push(ROMAN_NUMBER_MAP[pos]);
                pos = number / 10 | 0;
                number %= 10;
                romanBuf.push(ROMAN_NUMBER_MAP[10 + pos]);
                romanBuf.push(ROMAN_NUMBER_MAP[20 + number]);
                const romanStr = romanBuf.join("");
                return lowerCase ? romanStr.toLowerCase() : romanStr;
              }
              __name(toRomanNumerals, "toRomanNumerals");
              function log2(x) {
                if (x <= 0) {
                  return 0;
                }
                return Math.ceil(Math.log2(x));
              }
              __name(log2, "log2");
              function readInt8(data, offset) {
                return data[offset] << 24 >> 24;
              }
              __name(readInt8, "readInt8");
              function readUint16(data, offset) {
                return data[offset] << 8 | data[offset + 1];
              }
              __name(readUint16, "readUint16");
              function readUint32(data, offset) {
                return (data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3]) >>> 0;
              }
              __name(readUint32, "readUint32");
              function isWhiteSpace(ch) {
                return ch === 32 || ch === 9 || ch === 13 || ch === 10;
              }
              __name(isWhiteSpace, "isWhiteSpace");
              function parseXFAPath(path) {
                const positionPattern = /(.+)\[(\d+)\]$/;
                return path.split(".").map((component) => {
                  const m = component.match(positionPattern);
                  if (m) {
                    return {
                      name: m[1],
                      pos: parseInt(m[2], 10)
                    };
                  }
                  return {
                    name: component,
                    pos: 0
                  };
                });
              }
              __name(parseXFAPath, "parseXFAPath");
              function escapePDFName(str) {
                const buffer = [];
                let start = 0;
                for (let i = 0, ii = str.length; i < ii; i++) {
                  const char = str.charCodeAt(i);
                  if (char < 33 || char > 126 || char === 35 || char === 40 || char === 41 || char === 60 || char === 62 || char === 91 || char === 93 || char === 123 || char === 125 || char === 47 || char === 37) {
                    if (start < i) {
                      buffer.push(str.substring(start, i));
                    }
                    buffer.push(`#${char.toString(16)}`);
                    start = i + 1;
                  }
                }
                if (buffer.length === 0) {
                  return str;
                }
                if (start < str.length) {
                  buffer.push(str.substring(start, str.length));
                }
                return buffer.join("");
              }
              __name(escapePDFName, "escapePDFName");
              function _collectJS(entry, xref, list, parents) {
                if (!entry) {
                  return;
                }
                let parent = null;
                if (entry instanceof _primitives.Ref) {
                  if (parents.has(entry)) {
                    return;
                  }
                  parent = entry;
                  parents.put(parent);
                  entry = xref.fetch(entry);
                }
                if (Array.isArray(entry)) {
                  for (const element of entry) {
                    _collectJS(element, xref, list, parents);
                  }
                } else if (entry instanceof _primitives.Dict) {
                  if ((0, _primitives.isName)(entry.get("S"), "JavaScript")) {
                    const js = entry.get("JS");
                    let code;
                    if (js instanceof _base_stream.BaseStream) {
                      code = js.getString();
                    } else if (typeof js === "string") {
                      code = js;
                    }
                    code = code && (0, _util.stringToPDFString)(code).replace(/\u0000/g, "");
                    if (code) {
                      list.push(code);
                    }
                  }
                  _collectJS(entry.getRaw("Next"), xref, list, parents);
                }
                if (parent) {
                  parents.remove(parent);
                }
              }
              __name(_collectJS, "_collectJS");
              function collectActions(xref, dict, eventType) {
                const actions = /* @__PURE__ */ Object.create(null);
                const additionalActionsDicts = getInheritableProperty({
                  dict,
                  key: "AA",
                  stopWhenFound: false
                });
                if (additionalActionsDicts) {
                  for (let i = additionalActionsDicts.length - 1; i >= 0; i--) {
                    const additionalActions = additionalActionsDicts[i];
                    if (!(additionalActions instanceof _primitives.Dict)) {
                      continue;
                    }
                    for (const key of additionalActions.getKeys()) {
                      const action = eventType[key];
                      if (!action) {
                        continue;
                      }
                      const actionDict = additionalActions.getRaw(key);
                      const parents = new _primitives.RefSet();
                      const list = [];
                      _collectJS(actionDict, xref, list, parents);
                      if (list.length > 0) {
                        actions[action] = list;
                      }
                    }
                  }
                }
                if (dict.has("A")) {
                  const actionDict = dict.get("A");
                  const parents = new _primitives.RefSet();
                  const list = [];
                  _collectJS(actionDict, xref, list, parents);
                  if (list.length > 0) {
                    actions.Action = list;
                  }
                }
                return (0, _util.objectSize)(actions) > 0 ? actions : null;
              }
              __name(collectActions, "collectActions");
              const XMLEntities = {
                60: "&lt;",
                62: "&gt;",
                38: "&amp;",
                34: "&quot;",
                39: "&apos;"
              };
              function encodeToXmlString(str) {
                const buffer = [];
                let start = 0;
                for (let i = 0, ii = str.length; i < ii; i++) {
                  const char = str.codePointAt(i);
                  if (32 <= char && char <= 126) {
                    const entity = XMLEntities[char];
                    if (entity) {
                      if (start < i) {
                        buffer.push(str.substring(start, i));
                      }
                      buffer.push(entity);
                      start = i + 1;
                    }
                  } else {
                    if (start < i) {
                      buffer.push(str.substring(start, i));
                    }
                    buffer.push(`&#x${char.toString(16).toUpperCase()};`);
                    if (char > 55295 && (char < 57344 || char > 65533)) {
                      i++;
                    }
                    start = i + 1;
                  }
                }
                if (buffer.length === 0) {
                  return str;
                }
                if (start < str.length) {
                  buffer.push(str.substring(start, str.length));
                }
                return buffer.join("");
              }
              __name(encodeToXmlString, "encodeToXmlString");
              function validateCSSFont(cssFontInfo) {
                const DEFAULT_CSS_FONT_OBLIQUE = "14";
                const DEFAULT_CSS_FONT_WEIGHT = "400";
                const CSS_FONT_WEIGHT_VALUES = /* @__PURE__ */ new Set(["100", "200", "300", "400", "500", "600", "700", "800", "900", "1000", "normal", "bold", "bolder", "lighter"]);
                const {
                  fontFamily,
                  fontWeight,
                  italicAngle
                } = cssFontInfo;
                if (/^".*"$/.test(fontFamily)) {
                  if (/[^\\]"/.test(fontFamily.slice(1, fontFamily.length - 1))) {
                    (0, _util.warn)(`XFA - FontFamily contains some unescaped ": ${fontFamily}.`);
                    return false;
                  }
                } else if (/^'.*'$/.test(fontFamily)) {
                  if (/[^\\]'/.test(fontFamily.slice(1, fontFamily.length - 1))) {
                    (0, _util.warn)(`XFA - FontFamily contains some unescaped ': ${fontFamily}.`);
                    return false;
                  }
                } else {
                  for (const ident of fontFamily.split(/[ \t]+/)) {
                    if (/^(\d|(-(\d|-)))/.test(ident) || !/^[\w-\\]+$/.test(ident)) {
                      (0, _util.warn)(`XFA - FontFamily contains some invalid <custom-ident>: ${fontFamily}.`);
                      return false;
                    }
                  }
                }
                const weight = fontWeight ? fontWeight.toString() : "";
                cssFontInfo.fontWeight = CSS_FONT_WEIGHT_VALUES.has(weight) ? weight : DEFAULT_CSS_FONT_WEIGHT;
                const angle = parseFloat(italicAngle);
                cssFontInfo.italicAngle = isNaN(angle) || angle < -90 || angle > 90 ? DEFAULT_CSS_FONT_OBLIQUE : italicAngle.toString();
                return true;
              }
              __name(validateCSSFont, "validateCSSFont");
              function recoverJsURL(str) {
                const URL_OPEN_METHODS = ["app.launchURL", "window.open", "xfa.host.gotoURL"];
                const regex = new RegExp("^\\s*(" + URL_OPEN_METHODS.join("|").split(".").join("\\.") + `)\\((?:'|")([^'"]*)(?:'|")(?:,\\s*(\\w+)\\)|\\))`, "i");
                const jsUrl = regex.exec(str);
                if (jsUrl && jsUrl[2]) {
                  const url = jsUrl[2];
                  let newWindow = false;
                  if (jsUrl[3] === "true" && jsUrl[1] === "app.launchURL") {
                    newWindow = true;
                  }
                  return {
                    url,
                    newWindow
                  };
                }
                return null;
              }
              __name(recoverJsURL, "recoverJsURL");
              function numberToString(value) {
                if (Number.isInteger(value)) {
                  return value.toString();
                }
                const roundedValue = Math.round(value * 100);
                if (roundedValue % 100 === 0) {
                  return (roundedValue / 100).toString();
                }
                if (roundedValue % 10 === 0) {
                  return value.toFixed(1);
                }
                return value.toFixed(2);
              }
              __name(numberToString, "numberToString");
              function getNewAnnotationsMap(annotationStorage) {
                if (!annotationStorage) {
                  return null;
                }
                const newAnnotationsByPage = /* @__PURE__ */ new Map();
                for (const [key, value] of annotationStorage) {
                  if (!key.startsWith(_util.AnnotationEditorPrefix)) {
                    continue;
                  }
                  let annotations = newAnnotationsByPage.get(value.pageIndex);
                  if (!annotations) {
                    annotations = [];
                    newAnnotationsByPage.set(value.pageIndex, annotations);
                  }
                  annotations.push(value);
                }
                return newAnnotationsByPage.size > 0 ? newAnnotationsByPage : null;
              }
              __name(getNewAnnotationsMap, "getNewAnnotationsMap");
            },
            /* 132 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.BaseStream = void 0;
              var _util = __w_pdfjs_require__2(2);
              const _BaseStream = class _BaseStream {
                constructor() {
                  if (this.constructor === _BaseStream) {
                    (0, _util.unreachable)("Cannot initialize BaseStream.");
                  }
                }
                get length() {
                  (0, _util.unreachable)("Abstract getter `length` accessed");
                }
                get isEmpty() {
                  (0, _util.unreachable)("Abstract getter `isEmpty` accessed");
                }
                get isDataLoaded() {
                  return (0, _util.shadow)(this, "isDataLoaded", true);
                }
                getByte() {
                  (0, _util.unreachable)("Abstract method `getByte` called");
                }
                getBytes(length) {
                  (0, _util.unreachable)("Abstract method `getBytes` called");
                }
                peekByte() {
                  const peekedByte = this.getByte();
                  if (peekedByte !== -1) {
                    this.pos--;
                  }
                  return peekedByte;
                }
                peekBytes(length) {
                  const bytes = this.getBytes(length);
                  this.pos -= bytes.length;
                  return bytes;
                }
                getUint16() {
                  const b0 = this.getByte();
                  const b1 = this.getByte();
                  if (b0 === -1 || b1 === -1) {
                    return -1;
                  }
                  return (b0 << 8) + b1;
                }
                getInt32() {
                  const b0 = this.getByte();
                  const b1 = this.getByte();
                  const b2 = this.getByte();
                  const b3 = this.getByte();
                  return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
                }
                getByteRange(begin, end) {
                  (0, _util.unreachable)("Abstract method `getByteRange` called");
                }
                getString(length) {
                  return (0, _util.bytesToString)(this.getBytes(length));
                }
                skip(n) {
                  this.pos += n || 1;
                }
                reset() {
                  (0, _util.unreachable)("Abstract method `reset` called");
                }
                moveStart() {
                  (0, _util.unreachable)("Abstract method `moveStart` called");
                }
                makeSubStream(start, length) {
                  (0, _util.unreachable)("Abstract method `makeSubStream` called");
                }
                getBaseStreams() {
                  return null;
                }
              };
              __name(_BaseStream, "BaseStream");
              let BaseStream = _BaseStream;
              exports2.BaseStream = BaseStream;
            },
            /* 133 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.NetworkPdfManager = exports2.LocalPdfManager = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _chunked_stream = __w_pdfjs_require__2(134);
              var _core_utils = __w_pdfjs_require__2(131);
              var _document = __w_pdfjs_require__2(136);
              var _stream = __w_pdfjs_require__2(135);
              function parseDocBaseUrl(url) {
                if (url) {
                  const absoluteUrl = (0, _util.createValidAbsoluteUrl)(url);
                  if (absoluteUrl) {
                    return absoluteUrl.href;
                  }
                  (0, _util.warn)(`Invalid absolute docBaseUrl: "${url}".`);
                }
                return null;
              }
              __name(parseDocBaseUrl, "parseDocBaseUrl");
              const _BasePdfManager = class _BasePdfManager {
                constructor() {
                  if (this.constructor === _BasePdfManager) {
                    (0, _util.unreachable)("Cannot initialize BasePdfManager.");
                  }
                }
                get docId() {
                  return this._docId;
                }
                get password() {
                  return this._password;
                }
                get docBaseUrl() {
                  const catalog = this.pdfDocument.catalog;
                  return (0, _util.shadow)(this, "docBaseUrl", catalog.baseUrl || this._docBaseUrl);
                }
                onLoadedStream() {
                  (0, _util.unreachable)("Abstract method `onLoadedStream` called");
                }
                ensureDoc(prop, args) {
                  return this.ensure(this.pdfDocument, prop, args);
                }
                ensureXRef(prop, args) {
                  return this.ensure(this.pdfDocument.xref, prop, args);
                }
                ensureCatalog(prop, args) {
                  return this.ensure(this.pdfDocument.catalog, prop, args);
                }
                getPage(pageIndex) {
                  return this.pdfDocument.getPage(pageIndex);
                }
                fontFallback(id, handler) {
                  return this.pdfDocument.fontFallback(id, handler);
                }
                loadXfaFonts(handler, task) {
                  return this.pdfDocument.loadXfaFonts(handler, task);
                }
                loadXfaImages() {
                  return this.pdfDocument.loadXfaImages();
                }
                serializeXfaData(annotationStorage) {
                  return this.pdfDocument.serializeXfaData(annotationStorage);
                }
                cleanup() {
                  let manuallyTriggered = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  return this.pdfDocument.cleanup(manuallyTriggered);
                }
                async ensure(obj, prop, args) {
                  (0, _util.unreachable)("Abstract method `ensure` called");
                }
                requestRange(begin, end) {
                  (0, _util.unreachable)("Abstract method `requestRange` called");
                }
                requestLoadedStream() {
                  (0, _util.unreachable)("Abstract method `requestLoadedStream` called");
                }
                sendProgressiveData(chunk) {
                  (0, _util.unreachable)("Abstract method `sendProgressiveData` called");
                }
                updatePassword(password) {
                  this._password = password;
                }
                terminate(reason) {
                  (0, _util.unreachable)("Abstract method `terminate` called");
                }
              };
              __name(_BasePdfManager, "BasePdfManager");
              let BasePdfManager = _BasePdfManager;
              const _LocalPdfManager = class _LocalPdfManager extends BasePdfManager {
                constructor(docId, data, password, msgHandler, evaluatorOptions, enableXfa, docBaseUrl) {
                  super();
                  this._docId = docId;
                  this._password = password;
                  this._docBaseUrl = parseDocBaseUrl(docBaseUrl);
                  this.msgHandler = msgHandler;
                  this.evaluatorOptions = evaluatorOptions;
                  this.enableXfa = enableXfa;
                  const stream = new _stream.Stream(data);
                  this.pdfDocument = new _document.PDFDocument(this, stream);
                  this._loadedStreamPromise = Promise.resolve(stream);
                }
                async ensure(obj, prop, args) {
                  const value = obj[prop];
                  if (typeof value === "function") {
                    return value.apply(obj, args);
                  }
                  return value;
                }
                requestRange(begin, end) {
                  return Promise.resolve();
                }
                requestLoadedStream() {
                }
                onLoadedStream() {
                  return this._loadedStreamPromise;
                }
                terminate(reason) {
                }
              };
              __name(_LocalPdfManager, "LocalPdfManager");
              let LocalPdfManager = _LocalPdfManager;
              exports2.LocalPdfManager = LocalPdfManager;
              const _NetworkPdfManager = class _NetworkPdfManager extends BasePdfManager {
                constructor(docId, pdfNetworkStream, args, evaluatorOptions, enableXfa, docBaseUrl) {
                  super();
                  this._docId = docId;
                  this._password = args.password;
                  this._docBaseUrl = parseDocBaseUrl(docBaseUrl);
                  this.msgHandler = args.msgHandler;
                  this.evaluatorOptions = evaluatorOptions;
                  this.enableXfa = enableXfa;
                  this.streamManager = new _chunked_stream.ChunkedStreamManager(pdfNetworkStream, {
                    msgHandler: args.msgHandler,
                    length: args.length,
                    disableAutoFetch: args.disableAutoFetch,
                    rangeChunkSize: args.rangeChunkSize
                  });
                  this.pdfDocument = new _document.PDFDocument(this, this.streamManager.getStream());
                }
                async ensure(obj, prop, args) {
                  try {
                    const value = obj[prop];
                    if (typeof value === "function") {
                      return value.apply(obj, args);
                    }
                    return value;
                  } catch (ex) {
                    if (!(ex instanceof _core_utils.MissingDataException)) {
                      throw ex;
                    }
                    await this.requestRange(ex.begin, ex.end);
                    return this.ensure(obj, prop, args);
                  }
                }
                requestRange(begin, end) {
                  return this.streamManager.requestRange(begin, end);
                }
                requestLoadedStream() {
                  this.streamManager.requestAllChunks();
                }
                sendProgressiveData(chunk) {
                  this.streamManager.onReceiveData({
                    chunk
                  });
                }
                onLoadedStream() {
                  return this.streamManager.onLoadedStream();
                }
                terminate(reason) {
                  this.streamManager.abort(reason);
                }
              };
              __name(_NetworkPdfManager, "NetworkPdfManager");
              let NetworkPdfManager = _NetworkPdfManager;
              exports2.NetworkPdfManager = NetworkPdfManager;
            },
            /* 134 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.ChunkedStreamManager = exports2.ChunkedStream = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _core_utils = __w_pdfjs_require__2(131);
              var _stream = __w_pdfjs_require__2(135);
              const _ChunkedStream = class _ChunkedStream extends _stream.Stream {
                constructor(length, chunkSize, manager) {
                  super(new Uint8Array(length), 0, length, null);
                  this.chunkSize = chunkSize;
                  this._loadedChunks = /* @__PURE__ */ new Set();
                  this.numChunks = Math.ceil(length / chunkSize);
                  this.manager = manager;
                  this.progressiveDataLength = 0;
                  this.lastSuccessfulEnsureByteChunk = -1;
                }
                getMissingChunks() {
                  const chunks = [];
                  for (let chunk = 0, n = this.numChunks; chunk < n; ++chunk) {
                    if (!this._loadedChunks.has(chunk)) {
                      chunks.push(chunk);
                    }
                  }
                  return chunks;
                }
                get numChunksLoaded() {
                  return this._loadedChunks.size;
                }
                get isDataLoaded() {
                  return this.numChunksLoaded === this.numChunks;
                }
                onReceiveData(begin, chunk) {
                  const chunkSize = this.chunkSize;
                  if (begin % chunkSize !== 0) {
                    throw new Error(`Bad begin offset: ${begin}`);
                  }
                  const end = begin + chunk.byteLength;
                  if (end % chunkSize !== 0 && end !== this.bytes.length) {
                    throw new Error(`Bad end offset: ${end}`);
                  }
                  this.bytes.set(new Uint8Array(chunk), begin);
                  const beginChunk = Math.floor(begin / chunkSize);
                  const endChunk = Math.floor((end - 1) / chunkSize) + 1;
                  for (let curChunk = beginChunk; curChunk < endChunk; ++curChunk) {
                    this._loadedChunks.add(curChunk);
                  }
                }
                onReceiveProgressiveData(data) {
                  let position = this.progressiveDataLength;
                  const beginChunk = Math.floor(position / this.chunkSize);
                  this.bytes.set(new Uint8Array(data), position);
                  position += data.byteLength;
                  this.progressiveDataLength = position;
                  const endChunk = position >= this.end ? this.numChunks : Math.floor(position / this.chunkSize);
                  for (let curChunk = beginChunk; curChunk < endChunk; ++curChunk) {
                    this._loadedChunks.add(curChunk);
                  }
                }
                ensureByte(pos) {
                  if (pos < this.progressiveDataLength) {
                    return;
                  }
                  const chunk = Math.floor(pos / this.chunkSize);
                  if (chunk > this.numChunks) {
                    return;
                  }
                  if (chunk === this.lastSuccessfulEnsureByteChunk) {
                    return;
                  }
                  if (!this._loadedChunks.has(chunk)) {
                    throw new _core_utils.MissingDataException(pos, pos + 1);
                  }
                  this.lastSuccessfulEnsureByteChunk = chunk;
                }
                ensureRange(begin, end) {
                  if (begin >= end) {
                    return;
                  }
                  if (end <= this.progressiveDataLength) {
                    return;
                  }
                  const beginChunk = Math.floor(begin / this.chunkSize);
                  if (beginChunk > this.numChunks) {
                    return;
                  }
                  const endChunk = Math.min(Math.floor((end - 1) / this.chunkSize) + 1, this.numChunks);
                  for (let chunk = beginChunk; chunk < endChunk; ++chunk) {
                    if (!this._loadedChunks.has(chunk)) {
                      throw new _core_utils.MissingDataException(begin, end);
                    }
                  }
                }
                nextEmptyChunk(beginChunk) {
                  const numChunks = this.numChunks;
                  for (let i = 0; i < numChunks; ++i) {
                    const chunk = (beginChunk + i) % numChunks;
                    if (!this._loadedChunks.has(chunk)) {
                      return chunk;
                    }
                  }
                  return null;
                }
                hasChunk(chunk) {
                  return this._loadedChunks.has(chunk);
                }
                getByte() {
                  const pos = this.pos;
                  if (pos >= this.end) {
                    return -1;
                  }
                  if (pos >= this.progressiveDataLength) {
                    this.ensureByte(pos);
                  }
                  return this.bytes[this.pos++];
                }
                getBytes(length) {
                  const bytes = this.bytes;
                  const pos = this.pos;
                  const strEnd = this.end;
                  if (!length) {
                    if (strEnd > this.progressiveDataLength) {
                      this.ensureRange(pos, strEnd);
                    }
                    return bytes.subarray(pos, strEnd);
                  }
                  let end = pos + length;
                  if (end > strEnd) {
                    end = strEnd;
                  }
                  if (end > this.progressiveDataLength) {
                    this.ensureRange(pos, end);
                  }
                  this.pos = end;
                  return bytes.subarray(pos, end);
                }
                getByteRange(begin, end) {
                  if (begin < 0) {
                    begin = 0;
                  }
                  if (end > this.end) {
                    end = this.end;
                  }
                  if (end > this.progressiveDataLength) {
                    this.ensureRange(begin, end);
                  }
                  return this.bytes.subarray(begin, end);
                }
                makeSubStream(start, length) {
                  let dict = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                  if (length) {
                    if (start + length > this.progressiveDataLength) {
                      this.ensureRange(start, start + length);
                    }
                  } else {
                    if (start >= this.progressiveDataLength) {
                      this.ensureByte(start);
                    }
                  }
                  function ChunkedStreamSubstream() {
                  }
                  __name(ChunkedStreamSubstream, "ChunkedStreamSubstream");
                  ChunkedStreamSubstream.prototype = Object.create(this);
                  ChunkedStreamSubstream.prototype.getMissingChunks = function() {
                    const chunkSize = this.chunkSize;
                    const beginChunk = Math.floor(this.start / chunkSize);
                    const endChunk = Math.floor((this.end - 1) / chunkSize) + 1;
                    const missingChunks = [];
                    for (let chunk = beginChunk; chunk < endChunk; ++chunk) {
                      if (!this._loadedChunks.has(chunk)) {
                        missingChunks.push(chunk);
                      }
                    }
                    return missingChunks;
                  };
                  Object.defineProperty(ChunkedStreamSubstream.prototype, "isDataLoaded", {
                    get() {
                      if (this.numChunksLoaded === this.numChunks) {
                        return true;
                      }
                      return this.getMissingChunks().length === 0;
                    },
                    configurable: true
                  });
                  const subStream = new ChunkedStreamSubstream();
                  subStream.pos = subStream.start = start;
                  subStream.end = start + length || this.end;
                  subStream.dict = dict;
                  return subStream;
                }
                getBaseStreams() {
                  return [this];
                }
              };
              __name(_ChunkedStream, "ChunkedStream");
              let ChunkedStream = _ChunkedStream;
              exports2.ChunkedStream = ChunkedStream;
              const _ChunkedStreamManager = class _ChunkedStreamManager {
                constructor(pdfNetworkStream, args) {
                  this.length = args.length;
                  this.chunkSize = args.rangeChunkSize;
                  this.stream = new ChunkedStream(this.length, this.chunkSize, this);
                  this.pdfNetworkStream = pdfNetworkStream;
                  this.disableAutoFetch = args.disableAutoFetch;
                  this.msgHandler = args.msgHandler;
                  this.currRequestId = 0;
                  this._chunksNeededByRequest = /* @__PURE__ */ new Map();
                  this._requestsByChunk = /* @__PURE__ */ new Map();
                  this._promisesByRequest = /* @__PURE__ */ new Map();
                  this.progressiveDataLength = 0;
                  this.aborted = false;
                  this._loadedStreamCapability = (0, _util.createPromiseCapability)();
                }
                onLoadedStream() {
                  return this._loadedStreamCapability.promise;
                }
                sendRequest(begin, end) {
                  const rangeReader = this.pdfNetworkStream.getRangeReader(begin, end);
                  if (!rangeReader.isStreamingSupported) {
                    rangeReader.onProgress = this.onProgress.bind(this);
                  }
                  let chunks = [], loaded = 0;
                  return new Promise((resolve, reject) => {
                    const readChunk = /* @__PURE__ */ __name((chunk) => {
                      try {
                        if (!chunk.done) {
                          const data = chunk.value;
                          chunks.push(data);
                          loaded += (0, _util.arrayByteLength)(data);
                          if (rangeReader.isStreamingSupported) {
                            this.onProgress({
                              loaded
                            });
                          }
                          rangeReader.read().then(readChunk, reject);
                          return;
                        }
                        const chunkData = (0, _util.arraysToBytes)(chunks);
                        chunks = null;
                        resolve(chunkData);
                      } catch (e) {
                        reject(e);
                      }
                    }, "readChunk");
                    rangeReader.read().then(readChunk, reject);
                  }).then((data) => {
                    if (this.aborted) {
                      return;
                    }
                    this.onReceiveData({
                      chunk: data,
                      begin
                    });
                  });
                }
                requestAllChunks() {
                  const missingChunks = this.stream.getMissingChunks();
                  this._requestChunks(missingChunks);
                  return this._loadedStreamCapability.promise;
                }
                _requestChunks(chunks) {
                  const requestId = this.currRequestId++;
                  const chunksNeeded = /* @__PURE__ */ new Set();
                  this._chunksNeededByRequest.set(requestId, chunksNeeded);
                  for (const chunk of chunks) {
                    if (!this.stream.hasChunk(chunk)) {
                      chunksNeeded.add(chunk);
                    }
                  }
                  if (chunksNeeded.size === 0) {
                    return Promise.resolve();
                  }
                  const capability = (0, _util.createPromiseCapability)();
                  this._promisesByRequest.set(requestId, capability);
                  const chunksToRequest = [];
                  for (const chunk of chunksNeeded) {
                    let requestIds = this._requestsByChunk.get(chunk);
                    if (!requestIds) {
                      requestIds = [];
                      this._requestsByChunk.set(chunk, requestIds);
                      chunksToRequest.push(chunk);
                    }
                    requestIds.push(requestId);
                  }
                  if (chunksToRequest.length > 0) {
                    const groupedChunksToRequest = this.groupChunks(chunksToRequest);
                    for (const groupedChunk of groupedChunksToRequest) {
                      const begin = groupedChunk.beginChunk * this.chunkSize;
                      const end = Math.min(groupedChunk.endChunk * this.chunkSize, this.length);
                      this.sendRequest(begin, end).catch(capability.reject);
                    }
                  }
                  return capability.promise.catch((reason) => {
                    if (this.aborted) {
                      return;
                    }
                    throw reason;
                  });
                }
                getStream() {
                  return this.stream;
                }
                requestRange(begin, end) {
                  end = Math.min(end, this.length);
                  const beginChunk = this.getBeginChunk(begin);
                  const endChunk = this.getEndChunk(end);
                  const chunks = [];
                  for (let chunk = beginChunk; chunk < endChunk; ++chunk) {
                    chunks.push(chunk);
                  }
                  return this._requestChunks(chunks);
                }
                requestRanges() {
                  let ranges = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
                  const chunksToRequest = [];
                  for (const range of ranges) {
                    const beginChunk = this.getBeginChunk(range.begin);
                    const endChunk = this.getEndChunk(range.end);
                    for (let chunk = beginChunk; chunk < endChunk; ++chunk) {
                      if (!chunksToRequest.includes(chunk)) {
                        chunksToRequest.push(chunk);
                      }
                    }
                  }
                  chunksToRequest.sort(function(a, b) {
                    return a - b;
                  });
                  return this._requestChunks(chunksToRequest);
                }
                groupChunks(chunks) {
                  const groupedChunks = [];
                  let beginChunk = -1;
                  let prevChunk = -1;
                  for (let i = 0, ii = chunks.length; i < ii; ++i) {
                    const chunk = chunks[i];
                    if (beginChunk < 0) {
                      beginChunk = chunk;
                    }
                    if (prevChunk >= 0 && prevChunk + 1 !== chunk) {
                      groupedChunks.push({
                        beginChunk,
                        endChunk: prevChunk + 1
                      });
                      beginChunk = chunk;
                    }
                    if (i + 1 === chunks.length) {
                      groupedChunks.push({
                        beginChunk,
                        endChunk: chunk + 1
                      });
                    }
                    prevChunk = chunk;
                  }
                  return groupedChunks;
                }
                onProgress(args) {
                  this.msgHandler.send("DocProgress", {
                    loaded: this.stream.numChunksLoaded * this.chunkSize + args.loaded,
                    total: this.length
                  });
                }
                onReceiveData(args) {
                  const chunk = args.chunk;
                  const isProgressive = args.begin === void 0;
                  const begin = isProgressive ? this.progressiveDataLength : args.begin;
                  const end = begin + chunk.byteLength;
                  const beginChunk = Math.floor(begin / this.chunkSize);
                  const endChunk = end < this.length ? Math.floor(end / this.chunkSize) : Math.ceil(end / this.chunkSize);
                  if (isProgressive) {
                    this.stream.onReceiveProgressiveData(chunk);
                    this.progressiveDataLength = end;
                  } else {
                    this.stream.onReceiveData(begin, chunk);
                  }
                  if (this.stream.isDataLoaded) {
                    this._loadedStreamCapability.resolve(this.stream);
                  }
                  const loadedRequests = [];
                  for (let curChunk = beginChunk; curChunk < endChunk; ++curChunk) {
                    const requestIds = this._requestsByChunk.get(curChunk);
                    if (!requestIds) {
                      continue;
                    }
                    this._requestsByChunk.delete(curChunk);
                    for (const requestId of requestIds) {
                      const chunksNeeded = this._chunksNeededByRequest.get(requestId);
                      if (chunksNeeded.has(curChunk)) {
                        chunksNeeded.delete(curChunk);
                      }
                      if (chunksNeeded.size > 0) {
                        continue;
                      }
                      loadedRequests.push(requestId);
                    }
                  }
                  if (!this.disableAutoFetch && this._requestsByChunk.size === 0) {
                    let nextEmptyChunk;
                    if (this.stream.numChunksLoaded === 1) {
                      const lastChunk = this.stream.numChunks - 1;
                      if (!this.stream.hasChunk(lastChunk)) {
                        nextEmptyChunk = lastChunk;
                      }
                    } else {
                      nextEmptyChunk = this.stream.nextEmptyChunk(endChunk);
                    }
                    if (Number.isInteger(nextEmptyChunk)) {
                      this._requestChunks([nextEmptyChunk]);
                    }
                  }
                  for (const requestId of loadedRequests) {
                    const capability = this._promisesByRequest.get(requestId);
                    this._promisesByRequest.delete(requestId);
                    capability.resolve();
                  }
                  this.msgHandler.send("DocProgress", {
                    loaded: this.stream.numChunksLoaded * this.chunkSize,
                    total: this.length
                  });
                }
                onError(err) {
                  this._loadedStreamCapability.reject(err);
                }
                getBeginChunk(begin) {
                  return Math.floor(begin / this.chunkSize);
                }
                getEndChunk(end) {
                  return Math.floor((end - 1) / this.chunkSize) + 1;
                }
                abort(reason) {
                  this.aborted = true;
                  if (this.pdfNetworkStream) {
                    this.pdfNetworkStream.cancelAllRequests(reason);
                  }
                  for (const capability of this._promisesByRequest.values()) {
                    capability.reject(reason);
                  }
                }
              };
              __name(_ChunkedStreamManager, "ChunkedStreamManager");
              let ChunkedStreamManager = _ChunkedStreamManager;
              exports2.ChunkedStreamManager = ChunkedStreamManager;
            },
            /* 135 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.StringStream = exports2.Stream = exports2.NullStream = void 0;
              var _base_stream = __w_pdfjs_require__2(132);
              var _util = __w_pdfjs_require__2(2);
              const _Stream = class _Stream extends _base_stream.BaseStream {
                constructor(arrayBuffer, start, length, dict) {
                  super();
                  this.bytes = arrayBuffer instanceof Uint8Array ? arrayBuffer : new Uint8Array(arrayBuffer);
                  this.start = start || 0;
                  this.pos = this.start;
                  this.end = start + length || this.bytes.length;
                  this.dict = dict;
                }
                get length() {
                  return this.end - this.start;
                }
                get isEmpty() {
                  return this.length === 0;
                }
                getByte() {
                  if (this.pos >= this.end) {
                    return -1;
                  }
                  return this.bytes[this.pos++];
                }
                getBytes(length) {
                  const bytes = this.bytes;
                  const pos = this.pos;
                  const strEnd = this.end;
                  if (!length) {
                    return bytes.subarray(pos, strEnd);
                  }
                  let end = pos + length;
                  if (end > strEnd) {
                    end = strEnd;
                  }
                  this.pos = end;
                  return bytes.subarray(pos, end);
                }
                getByteRange(begin, end) {
                  if (begin < 0) {
                    begin = 0;
                  }
                  if (end > this.end) {
                    end = this.end;
                  }
                  return this.bytes.subarray(begin, end);
                }
                reset() {
                  this.pos = this.start;
                }
                moveStart() {
                  this.start = this.pos;
                }
                makeSubStream(start, length) {
                  let dict = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                  return new _Stream(this.bytes.buffer, start, length, dict);
                }
              };
              __name(_Stream, "Stream");
              let Stream = _Stream;
              exports2.Stream = Stream;
              const _StringStream = class _StringStream extends Stream {
                constructor(str) {
                  super((0, _util.stringToBytes)(str));
                }
              };
              __name(_StringStream, "StringStream");
              let StringStream = _StringStream;
              exports2.StringStream = StringStream;
              const _NullStream = class _NullStream extends Stream {
                constructor() {
                  super(new Uint8Array(0));
                }
              };
              __name(_NullStream, "NullStream");
              let NullStream = _NullStream;
              exports2.NullStream = NullStream;
            },
            /* 136 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Page = exports2.PDFDocument = void 0;
              var _annotation = __w_pdfjs_require__2(137);
              var _util = __w_pdfjs_require__2(2);
              var _core_utils = __w_pdfjs_require__2(131);
              var _primitives = __w_pdfjs_require__2(130);
              var _xfa_fonts = __w_pdfjs_require__2(176);
              var _base_stream = __w_pdfjs_require__2(132);
              var _crypto = __w_pdfjs_require__2(192);
              var _catalog = __w_pdfjs_require__2(194);
              var _cleanup_helper = __w_pdfjs_require__2(196);
              var _dataset_reader = __w_pdfjs_require__2(225);
              var _parser = __w_pdfjs_require__2(142);
              var _stream = __w_pdfjs_require__2(135);
              var _object_loader = __w_pdfjs_require__2(200);
              var _operator_list = __w_pdfjs_require__2(187);
              var _evaluator = __w_pdfjs_require__2(140);
              var _decode_stream = __w_pdfjs_require__2(144);
              var _struct_tree = __w_pdfjs_require__2(199);
              var _writer = __w_pdfjs_require__2(190);
              var _factory = __w_pdfjs_require__2(201);
              var _xref = __w_pdfjs_require__2(226);
              const DEFAULT_USER_UNIT = 1;
              const LETTER_SIZE_MEDIABOX = [0, 0, 612, 792];
              const _Page = class _Page {
                constructor(_ref) {
                  let {
                    pdfManager,
                    xref,
                    pageIndex,
                    pageDict,
                    ref,
                    globalIdFactory,
                    fontCache,
                    builtInCMapCache,
                    standardFontDataCache,
                    globalImageCache,
                    nonBlendModesSet,
                    xfaFactory
                  } = _ref;
                  this.pdfManager = pdfManager;
                  this.pageIndex = pageIndex;
                  this.pageDict = pageDict;
                  this.xref = xref;
                  this.ref = ref;
                  this.fontCache = fontCache;
                  this.builtInCMapCache = builtInCMapCache;
                  this.standardFontDataCache = standardFontDataCache;
                  this.globalImageCache = globalImageCache;
                  this.nonBlendModesSet = nonBlendModesSet;
                  this.evaluatorOptions = pdfManager.evaluatorOptions;
                  this.resourcesPromise = null;
                  this.xfaFactory = xfaFactory;
                  const idCounters = {
                    obj: 0
                  };
                  this._localIdFactory = class extends globalIdFactory {
                    static createObjId() {
                      return `p${pageIndex}_${++idCounters.obj}`;
                    }
                    static getPageObjId() {
                      return `page${ref.toString()}`;
                    }
                  };
                }
                _getInheritableProperty(key) {
                  let getArray = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  const value = (0, _core_utils.getInheritableProperty)({
                    dict: this.pageDict,
                    key,
                    getArray,
                    stopWhenFound: false
                  });
                  if (!Array.isArray(value)) {
                    return value;
                  }
                  if (value.length === 1 || !(value[0] instanceof _primitives.Dict)) {
                    return value[0];
                  }
                  return _primitives.Dict.merge({
                    xref: this.xref,
                    dictArray: value
                  });
                }
                get content() {
                  return this.pageDict.getArray("Contents");
                }
                get resources() {
                  const resources = this._getInheritableProperty("Resources");
                  return (0, _util.shadow)(this, "resources", resources instanceof _primitives.Dict ? resources : _primitives.Dict.empty);
                }
                _getBoundingBox(name) {
                  if (this.xfaData) {
                    return this.xfaData.bbox;
                  }
                  const box = this._getInheritableProperty(name, true);
                  if (Array.isArray(box) && box.length === 4) {
                    if (box[2] - box[0] !== 0 && box[3] - box[1] !== 0) {
                      return box;
                    }
                    (0, _util.warn)(`Empty /${name} entry.`);
                  }
                  return null;
                }
                get mediaBox() {
                  return (0, _util.shadow)(this, "mediaBox", this._getBoundingBox("MediaBox") || LETTER_SIZE_MEDIABOX);
                }
                get cropBox() {
                  return (0, _util.shadow)(this, "cropBox", this._getBoundingBox("CropBox") || this.mediaBox);
                }
                get userUnit() {
                  let obj = this.pageDict.get("UserUnit");
                  if (typeof obj !== "number" || obj <= 0) {
                    obj = DEFAULT_USER_UNIT;
                  }
                  return (0, _util.shadow)(this, "userUnit", obj);
                }
                get view() {
                  const {
                    cropBox,
                    mediaBox
                  } = this;
                  let view;
                  if (cropBox === mediaBox || (0, _util.isArrayEqual)(cropBox, mediaBox)) {
                    view = mediaBox;
                  } else {
                    const box = _util.Util.intersect(cropBox, mediaBox);
                    if (box && box[2] - box[0] !== 0 && box[3] - box[1] !== 0) {
                      view = box;
                    } else {
                      (0, _util.warn)("Empty /CropBox and /MediaBox intersection.");
                    }
                  }
                  return (0, _util.shadow)(this, "view", view || mediaBox);
                }
                get rotate() {
                  let rotate = this._getInheritableProperty("Rotate") || 0;
                  if (rotate % 90 !== 0) {
                    rotate = 0;
                  } else if (rotate >= 360) {
                    rotate %= 360;
                  } else if (rotate < 0) {
                    rotate = (rotate % 360 + 360) % 360;
                  }
                  return (0, _util.shadow)(this, "rotate", rotate);
                }
                _onSubStreamError(handler, reason, objId) {
                  if (this.evaluatorOptions.ignoreErrors) {
                    handler.send("UnsupportedFeature", {
                      featureId: _util.UNSUPPORTED_FEATURES.errorContentSubStream
                    });
                    (0, _util.warn)(`getContentStream - ignoring sub-stream (${objId}): "${reason}".`);
                    return;
                  }
                  throw reason;
                }
                getContentStream(handler) {
                  return this.pdfManager.ensure(this, "content").then((content) => {
                    if (content instanceof _base_stream.BaseStream) {
                      return content;
                    }
                    if (Array.isArray(content)) {
                      return new _decode_stream.StreamsSequenceStream(content, this._onSubStreamError.bind(this, handler));
                    }
                    return new _stream.NullStream();
                  });
                }
                get xfaData() {
                  return (0, _util.shadow)(this, "xfaData", this.xfaFactory ? {
                    bbox: this.xfaFactory.getBoundingBox(this.pageIndex)
                  } : null);
                }
                async saveNewAnnotations(handler, task, annotations) {
                  if (this.xfaFactory) {
                    throw new Error("XFA: Cannot save new annotations.");
                  }
                  const partialEvaluator = new _evaluator.PartialEvaluator({
                    xref: this.xref,
                    handler,
                    pageIndex: this.pageIndex,
                    idFactory: this._localIdFactory,
                    fontCache: this.fontCache,
                    builtInCMapCache: this.builtInCMapCache,
                    standardFontDataCache: this.standardFontDataCache,
                    globalImageCache: this.globalImageCache,
                    options: this.evaluatorOptions
                  });
                  const pageDict = this.pageDict;
                  const annotationsArray = this.annotations.slice();
                  const newData = await _annotation.AnnotationFactory.saveNewAnnotations(partialEvaluator, task, annotations);
                  for (const {
                    ref
                  } of newData.annotations) {
                    annotationsArray.push(ref);
                  }
                  const savedDict = pageDict.get("Annots");
                  pageDict.set("Annots", annotationsArray);
                  const buffer = [];
                  let transform = null;
                  if (this.xref.encrypt) {
                    transform = this.xref.encrypt.createCipherTransform(this.ref.num, this.ref.gen);
                  }
                  (0, _writer.writeObject)(this.ref, pageDict, buffer, transform);
                  if (savedDict) {
                    pageDict.set("Annots", savedDict);
                  }
                  const objects = newData.dependencies;
                  objects.push({
                    ref: this.ref,
                    data: buffer.join("")
                  }, ...newData.annotations);
                  return objects;
                }
                save(handler, task, annotationStorage) {
                  const partialEvaluator = new _evaluator.PartialEvaluator({
                    xref: this.xref,
                    handler,
                    pageIndex: this.pageIndex,
                    idFactory: this._localIdFactory,
                    fontCache: this.fontCache,
                    builtInCMapCache: this.builtInCMapCache,
                    standardFontDataCache: this.standardFontDataCache,
                    globalImageCache: this.globalImageCache,
                    options: this.evaluatorOptions
                  });
                  return this._parsedAnnotations.then(function(annotations) {
                    const newRefsPromises = [];
                    for (const annotation of annotations) {
                      if (!annotation.mustBePrinted(annotationStorage)) {
                        continue;
                      }
                      newRefsPromises.push(annotation.save(partialEvaluator, task, annotationStorage).catch(function(reason) {
                        (0, _util.warn)(`save - ignoring annotation data during "${task.name}" task: "${reason}".`);
                        return null;
                      }));
                    }
                    return Promise.all(newRefsPromises).then(function(newRefs) {
                      return newRefs.filter((newRef) => !!newRef);
                    });
                  });
                }
                loadResources(keys) {
                  if (!this.resourcesPromise) {
                    this.resourcesPromise = this.pdfManager.ensure(this, "resources");
                  }
                  return this.resourcesPromise.then(() => {
                    const objectLoader = new _object_loader.ObjectLoader(this.resources, keys, this.xref);
                    return objectLoader.load();
                  });
                }
                getOperatorList(_ref2) {
                  let {
                    handler,
                    sink,
                    task,
                    intent,
                    cacheKey,
                    annotationStorage = null
                  } = _ref2;
                  const contentStreamPromise = this.getContentStream(handler);
                  const resourcesPromise = this.loadResources(["ColorSpace", "ExtGState", "Font", "Pattern", "Properties", "Shading", "XObject"]);
                  const partialEvaluator = new _evaluator.PartialEvaluator({
                    xref: this.xref,
                    handler,
                    pageIndex: this.pageIndex,
                    idFactory: this._localIdFactory,
                    fontCache: this.fontCache,
                    builtInCMapCache: this.builtInCMapCache,
                    standardFontDataCache: this.standardFontDataCache,
                    globalImageCache: this.globalImageCache,
                    options: this.evaluatorOptions
                  });
                  const newAnnotationsByPage = !this.xfaFactory ? (0, _core_utils.getNewAnnotationsMap)(annotationStorage) : null;
                  let newAnnotationsPromise = Promise.resolve(null);
                  if (newAnnotationsByPage) {
                    const newAnnotations = newAnnotationsByPage.get(this.pageIndex);
                    if (newAnnotations) {
                      newAnnotationsPromise = _annotation.AnnotationFactory.printNewAnnotations(partialEvaluator, task, newAnnotations);
                    }
                  }
                  const dataPromises = Promise.all([contentStreamPromise, resourcesPromise]);
                  const pageListPromise = dataPromises.then((_ref3) => {
                    let [contentStream] = _ref3;
                    const opList = new _operator_list.OperatorList(intent, sink);
                    handler.send("StartRenderPage", {
                      transparency: partialEvaluator.hasBlendModes(this.resources, this.nonBlendModesSet),
                      pageIndex: this.pageIndex,
                      cacheKey
                    });
                    return partialEvaluator.getOperatorList({
                      stream: contentStream,
                      task,
                      resources: this.resources,
                      operatorList: opList
                    }).then(function() {
                      return opList;
                    });
                  });
                  return Promise.all([pageListPromise, this._parsedAnnotations, newAnnotationsPromise]).then(function(_ref4) {
                    let [pageOpList, annotations, newAnnotations] = _ref4;
                    if (newAnnotations) {
                      annotations = annotations.concat(newAnnotations);
                    }
                    if (annotations.length === 0 || intent & _util.RenderingIntentFlag.ANNOTATIONS_DISABLE) {
                      pageOpList.flush(true);
                      return {
                        length: pageOpList.totalLength
                      };
                    }
                    const renderForms = !!(intent & _util.RenderingIntentFlag.ANNOTATIONS_FORMS), intentAny = !!(intent & _util.RenderingIntentFlag.ANY), intentDisplay = !!(intent & _util.RenderingIntentFlag.DISPLAY), intentPrint = !!(intent & _util.RenderingIntentFlag.PRINT);
                    const opListPromises = [];
                    for (const annotation of annotations) {
                      if (intentAny || intentDisplay && annotation.mustBeViewed(annotationStorage) || intentPrint && annotation.mustBePrinted(annotationStorage)) {
                        opListPromises.push(annotation.getOperatorList(partialEvaluator, task, intent, renderForms, annotationStorage).catch(function(reason) {
                          (0, _util.warn)(`getOperatorList - ignoring annotation data during "${task.name}" task: "${reason}".`);
                          return null;
                        }));
                      }
                    }
                    return Promise.all(opListPromises).then(function(opLists) {
                      let form = false, canvas = false;
                      for (const {
                        opList,
                        separateForm,
                        separateCanvas
                      } of opLists) {
                        pageOpList.addOpList(opList);
                        if (separateForm) {
                          form = separateForm;
                        }
                        if (separateCanvas) {
                          canvas = separateCanvas;
                        }
                      }
                      pageOpList.flush(true, {
                        form,
                        canvas
                      });
                      return {
                        length: pageOpList.totalLength
                      };
                    });
                  });
                }
                extractTextContent(_ref5) {
                  let {
                    handler,
                    task,
                    includeMarkedContent,
                    sink,
                    combineTextItems
                  } = _ref5;
                  const contentStreamPromise = this.getContentStream(handler);
                  const resourcesPromise = this.loadResources(["ExtGState", "Font", "Properties", "XObject"]);
                  const dataPromises = Promise.all([contentStreamPromise, resourcesPromise]);
                  return dataPromises.then((_ref6) => {
                    let [contentStream] = _ref6;
                    const partialEvaluator = new _evaluator.PartialEvaluator({
                      xref: this.xref,
                      handler,
                      pageIndex: this.pageIndex,
                      idFactory: this._localIdFactory,
                      fontCache: this.fontCache,
                      builtInCMapCache: this.builtInCMapCache,
                      standardFontDataCache: this.standardFontDataCache,
                      globalImageCache: this.globalImageCache,
                      options: this.evaluatorOptions
                    });
                    return partialEvaluator.getTextContent({
                      stream: contentStream,
                      task,
                      resources: this.resources,
                      includeMarkedContent,
                      combineTextItems,
                      sink,
                      viewBox: this.view
                    });
                  });
                }
                async getStructTree() {
                  const structTreeRoot = await this.pdfManager.ensureCatalog("structTreeRoot");
                  if (!structTreeRoot) {
                    return null;
                  }
                  const structTree = await this.pdfManager.ensure(this, "_parseStructTree", [structTreeRoot]);
                  return structTree.serializable;
                }
                _parseStructTree(structTreeRoot) {
                  const tree = new _struct_tree.StructTreePage(structTreeRoot, this.pageDict);
                  tree.parse();
                  return tree;
                }
                async getAnnotationsData(handler, task, intent) {
                  const annotations = await this._parsedAnnotations;
                  if (annotations.length === 0) {
                    return [];
                  }
                  const textContentPromises = [];
                  const annotationsData = [];
                  let partialEvaluator;
                  const intentAny = !!(intent & _util.RenderingIntentFlag.ANY), intentDisplay = !!(intent & _util.RenderingIntentFlag.DISPLAY), intentPrint = !!(intent & _util.RenderingIntentFlag.PRINT);
                  for (const annotation of annotations) {
                    const isVisible = intentAny || intentDisplay && annotation.viewable;
                    if (isVisible || intentPrint && annotation.printable) {
                      annotationsData.push(annotation.data);
                    }
                    if (annotation.hasTextContent && isVisible) {
                      if (!partialEvaluator) {
                        partialEvaluator = new _evaluator.PartialEvaluator({
                          xref: this.xref,
                          handler,
                          pageIndex: this.pageIndex,
                          idFactory: this._localIdFactory,
                          fontCache: this.fontCache,
                          builtInCMapCache: this.builtInCMapCache,
                          standardFontDataCache: this.standardFontDataCache,
                          globalImageCache: this.globalImageCache,
                          options: this.evaluatorOptions
                        });
                      }
                      textContentPromises.push(annotation.extractTextContent(partialEvaluator, task, this.view).catch(function(reason) {
                        (0, _util.warn)(`getAnnotationsData - ignoring textContent during "${task.name}" task: "${reason}".`);
                      }));
                    }
                  }
                  await Promise.all(textContentPromises);
                  return annotationsData;
                }
                get annotations() {
                  const annots = this._getInheritableProperty("Annots");
                  return (0, _util.shadow)(this, "annotations", Array.isArray(annots) ? annots : []);
                }
                get _parsedAnnotations() {
                  const parsedAnnotations = this.pdfManager.ensure(this, "annotations").then(() => {
                    const annotationPromises = [];
                    for (const annotationRef of this.annotations) {
                      annotationPromises.push(_annotation.AnnotationFactory.create(this.xref, annotationRef, this.pdfManager, this._localIdFactory, false).catch(function(reason) {
                        (0, _util.warn)(`_parsedAnnotations: "${reason}".`);
                        return null;
                      }));
                    }
                    return Promise.all(annotationPromises).then(function(annotations) {
                      if (annotations.length === 0) {
                        return annotations;
                      }
                      const sortedAnnotations = [];
                      let popupAnnotations;
                      for (const annotation of annotations) {
                        if (!annotation) {
                          continue;
                        }
                        if (annotation instanceof _annotation.PopupAnnotation) {
                          if (!popupAnnotations) {
                            popupAnnotations = [];
                          }
                          popupAnnotations.push(annotation);
                          continue;
                        }
                        sortedAnnotations.push(annotation);
                      }
                      if (popupAnnotations) {
                        sortedAnnotations.push(...popupAnnotations);
                      }
                      return sortedAnnotations;
                    });
                  });
                  return (0, _util.shadow)(this, "_parsedAnnotations", parsedAnnotations);
                }
                get jsActions() {
                  const actions = (0, _core_utils.collectActions)(this.xref, this.pageDict, _util.PageActionEventType);
                  return (0, _util.shadow)(this, "jsActions", actions);
                }
              };
              __name(_Page, "Page");
              let Page = _Page;
              exports2.Page = Page;
              const PDF_HEADER_SIGNATURE = new Uint8Array([37, 80, 68, 70, 45]);
              const STARTXREF_SIGNATURE = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]);
              const ENDOBJ_SIGNATURE = new Uint8Array([101, 110, 100, 111, 98, 106]);
              const FINGERPRINT_FIRST_BYTES = 1024;
              const EMPTY_FINGERPRINT = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
              const PDF_HEADER_VERSION_REGEXP = /^[1-9]\.\d$/;
              function find(stream, signature) {
                let limit = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1024;
                let backwards = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
                const signatureLength = signature.length;
                const scanBytes = stream.peekBytes(limit);
                const scanLength = scanBytes.length - signatureLength;
                if (scanLength <= 0) {
                  return false;
                }
                if (backwards) {
                  const signatureEnd = signatureLength - 1;
                  let pos = scanBytes.length - 1;
                  while (pos >= signatureEnd) {
                    let j = 0;
                    while (j < signatureLength && scanBytes[pos - j] === signature[signatureEnd - j]) {
                      j++;
                    }
                    if (j >= signatureLength) {
                      stream.pos += pos - signatureEnd;
                      return true;
                    }
                    pos--;
                  }
                } else {
                  let pos = 0;
                  while (pos <= scanLength) {
                    let j = 0;
                    while (j < signatureLength && scanBytes[pos + j] === signature[j]) {
                      j++;
                    }
                    if (j >= signatureLength) {
                      stream.pos += pos;
                      return true;
                    }
                    pos++;
                  }
                }
                return false;
              }
              __name(find, "find");
              const _PDFDocument = class _PDFDocument {
                constructor(pdfManager, stream) {
                  if (stream.length <= 0) {
                    throw new _util.InvalidPDFException("The PDF file is empty, i.e. its size is zero bytes.");
                  }
                  this.pdfManager = pdfManager;
                  this.stream = stream;
                  this.xref = new _xref.XRef(stream, pdfManager);
                  this._pagePromises = /* @__PURE__ */ new Map();
                  this._version = null;
                  const idCounters = {
                    font: 0
                  };
                  this._globalIdFactory = class {
                    static getDocId() {
                      return `g_${pdfManager.docId}`;
                    }
                    static createFontId() {
                      return `f${++idCounters.font}`;
                    }
                    static createObjId() {
                      (0, _util.unreachable)("Abstract method `createObjId` called.");
                    }
                    static getPageObjId() {
                      (0, _util.unreachable)("Abstract method `getPageObjId` called.");
                    }
                  };
                }
                parse(recoveryMode) {
                  this.xref.parse(recoveryMode);
                  this.catalog = new _catalog.Catalog(this.pdfManager, this.xref);
                  if (this.catalog.version) {
                    this._version = this.catalog.version;
                  }
                }
                get linearization() {
                  let linearization = null;
                  try {
                    linearization = _parser.Linearization.create(this.stream);
                  } catch (err) {
                    if (err instanceof _core_utils.MissingDataException) {
                      throw err;
                    }
                    (0, _util.info)(err);
                  }
                  return (0, _util.shadow)(this, "linearization", linearization);
                }
                get startXRef() {
                  const stream = this.stream;
                  let startXRef = 0;
                  if (this.linearization) {
                    stream.reset();
                    if (find(stream, ENDOBJ_SIGNATURE)) {
                      startXRef = stream.pos + 6 - stream.start;
                    }
                  } else {
                    const step = 1024;
                    const startXRefLength = STARTXREF_SIGNATURE.length;
                    let found = false, pos = stream.end;
                    while (!found && pos > 0) {
                      pos -= step - startXRefLength;
                      if (pos < 0) {
                        pos = 0;
                      }
                      stream.pos = pos;
                      found = find(stream, STARTXREF_SIGNATURE, step, true);
                    }
                    if (found) {
                      stream.skip(9);
                      let ch;
                      do {
                        ch = stream.getByte();
                      } while ((0, _core_utils.isWhiteSpace)(ch));
                      let str = "";
                      while (ch >= 32 && ch <= 57) {
                        str += String.fromCharCode(ch);
                        ch = stream.getByte();
                      }
                      startXRef = parseInt(str, 10);
                      if (isNaN(startXRef)) {
                        startXRef = 0;
                      }
                    }
                  }
                  return (0, _util.shadow)(this, "startXRef", startXRef);
                }
                checkHeader() {
                  const stream = this.stream;
                  stream.reset();
                  if (!find(stream, PDF_HEADER_SIGNATURE)) {
                    return;
                  }
                  stream.moveStart();
                  const MAX_PDF_VERSION_LENGTH = 12;
                  let version = "", ch;
                  while ((ch = stream.getByte()) > 32) {
                    if (version.length >= MAX_PDF_VERSION_LENGTH) {
                      break;
                    }
                    version += String.fromCharCode(ch);
                  }
                  if (!this._version) {
                    this._version = version.substring(5);
                  }
                }
                parseStartXRef() {
                  this.xref.setStartXRef(this.startXRef);
                }
                get numPages() {
                  let num = 0;
                  if (this.catalog.hasActualNumPages) {
                    num = this.catalog.numPages;
                  } else if (this.xfaFactory) {
                    num = this.xfaFactory.getNumPages();
                  } else if (this.linearization) {
                    num = this.linearization.numPages;
                  } else {
                    num = this.catalog.numPages;
                  }
                  return (0, _util.shadow)(this, "numPages", num);
                }
                _hasOnlyDocumentSignatures(fields) {
                  let recursionDepth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
                  const RECURSION_LIMIT = 10;
                  if (!Array.isArray(fields)) {
                    return false;
                  }
                  return fields.every((field) => {
                    field = this.xref.fetchIfRef(field);
                    if (!(field instanceof _primitives.Dict)) {
                      return false;
                    }
                    if (field.has("Kids")) {
                      if (++recursionDepth > RECURSION_LIMIT) {
                        (0, _util.warn)("_hasOnlyDocumentSignatures: maximum recursion depth reached");
                        return false;
                      }
                      return this._hasOnlyDocumentSignatures(field.get("Kids"), recursionDepth);
                    }
                    const isSignature = (0, _primitives.isName)(field.get("FT"), "Sig");
                    const rectangle = field.get("Rect");
                    const isInvisible = Array.isArray(rectangle) && rectangle.every((value) => value === 0);
                    return isSignature && isInvisible;
                  });
                }
                get _xfaStreams() {
                  const acroForm = this.catalog.acroForm;
                  if (!acroForm) {
                    return null;
                  }
                  const xfa = acroForm.get("XFA");
                  const entries = {
                    "xdp:xdp": "",
                    template: "",
                    datasets: "",
                    config: "",
                    connectionSet: "",
                    localeSet: "",
                    stylesheet: "",
                    "/xdp:xdp": ""
                  };
                  if (xfa instanceof _base_stream.BaseStream && !xfa.isEmpty) {
                    entries["xdp:xdp"] = xfa;
                    return entries;
                  }
                  if (!Array.isArray(xfa) || xfa.length === 0) {
                    return null;
                  }
                  for (let i = 0, ii = xfa.length; i < ii; i += 2) {
                    let name;
                    if (i === 0) {
                      name = "xdp:xdp";
                    } else if (i === ii - 2) {
                      name = "/xdp:xdp";
                    } else {
                      name = xfa[i];
                    }
                    if (!entries.hasOwnProperty(name)) {
                      continue;
                    }
                    const data = this.xref.fetchIfRef(xfa[i + 1]);
                    if (!(data instanceof _base_stream.BaseStream) || data.isEmpty) {
                      continue;
                    }
                    entries[name] = data;
                  }
                  return entries;
                }
                get xfaDatasets() {
                  const streams = this._xfaStreams;
                  if (!streams) {
                    return (0, _util.shadow)(this, "xfaDatasets", null);
                  }
                  for (const key of ["datasets", "xdp:xdp"]) {
                    const stream = streams[key];
                    if (!stream) {
                      continue;
                    }
                    try {
                      const str = (0, _util.stringToUTF8String)(stream.getString());
                      const data = {
                        [key]: str
                      };
                      return (0, _util.shadow)(this, "xfaDatasets", new _dataset_reader.DatasetReader(data));
                    } catch (_) {
                      (0, _util.warn)("XFA - Invalid utf-8 string.");
                      break;
                    }
                  }
                  return (0, _util.shadow)(this, "xfaDatasets", null);
                }
                get xfaData() {
                  const streams = this._xfaStreams;
                  if (!streams) {
                    return null;
                  }
                  const data = /* @__PURE__ */ Object.create(null);
                  for (const [key, stream] of Object.entries(streams)) {
                    if (!stream) {
                      continue;
                    }
                    try {
                      data[key] = (0, _util.stringToUTF8String)(stream.getString());
                    } catch (_) {
                      (0, _util.warn)("XFA - Invalid utf-8 string.");
                      return null;
                    }
                  }
                  return data;
                }
                get xfaFactory() {
                  let data;
                  if (this.pdfManager.enableXfa && this.catalog.needsRendering && this.formInfo.hasXfa && !this.formInfo.hasAcroForm) {
                    data = this.xfaData;
                  }
                  return (0, _util.shadow)(this, "xfaFactory", data ? new _factory.XFAFactory(data) : null);
                }
                get isPureXfa() {
                  return this.xfaFactory ? this.xfaFactory.isValid() : false;
                }
                get htmlForXfa() {
                  return this.xfaFactory ? this.xfaFactory.getPages() : null;
                }
                async loadXfaImages() {
                  const xfaImagesDict = await this.pdfManager.ensureCatalog("xfaImages");
                  if (!xfaImagesDict) {
                    return;
                  }
                  const keys = xfaImagesDict.getKeys();
                  const objectLoader = new _object_loader.ObjectLoader(xfaImagesDict, keys, this.xref);
                  await objectLoader.load();
                  const xfaImages = /* @__PURE__ */ new Map();
                  for (const key of keys) {
                    const stream = xfaImagesDict.get(key);
                    if (stream instanceof _base_stream.BaseStream) {
                      xfaImages.set(key, stream.getBytes());
                    }
                  }
                  this.xfaFactory.setImages(xfaImages);
                }
                async loadXfaFonts(handler, task) {
                  const acroForm = await this.pdfManager.ensureCatalog("acroForm");
                  if (!acroForm) {
                    return;
                  }
                  const resources = await acroForm.getAsync("DR");
                  if (!(resources instanceof _primitives.Dict)) {
                    return;
                  }
                  const objectLoader = new _object_loader.ObjectLoader(resources, ["Font"], this.xref);
                  await objectLoader.load();
                  const fontRes = resources.get("Font");
                  if (!(fontRes instanceof _primitives.Dict)) {
                    return;
                  }
                  const options = Object.assign(/* @__PURE__ */ Object.create(null), this.pdfManager.evaluatorOptions);
                  options.useSystemFonts = false;
                  const partialEvaluator = new _evaluator.PartialEvaluator({
                    xref: this.xref,
                    handler,
                    pageIndex: -1,
                    idFactory: this._globalIdFactory,
                    fontCache: this.catalog.fontCache,
                    builtInCMapCache: this.catalog.builtInCMapCache,
                    standardFontDataCache: this.catalog.standardFontDataCache,
                    options
                  });
                  const operatorList = new _operator_list.OperatorList();
                  const pdfFonts = [];
                  const initialState = {
                    get font() {
                      return pdfFonts.at(-1);
                    },
                    set font(font) {
                      pdfFonts.push(font);
                    },
                    clone() {
                      return this;
                    }
                  };
                  const fonts = /* @__PURE__ */ new Map();
                  fontRes.forEach((fontName, font) => {
                    fonts.set(fontName, font);
                  });
                  const promises = [];
                  for (const [fontName, font] of fonts) {
                    const descriptor = font.get("FontDescriptor");
                    if (!(descriptor instanceof _primitives.Dict)) {
                      continue;
                    }
                    let fontFamily = descriptor.get("FontFamily");
                    fontFamily = fontFamily.replace(/[ ]+(\d)/g, "$1");
                    const fontWeight = descriptor.get("FontWeight");
                    const italicAngle = -descriptor.get("ItalicAngle");
                    const cssFontInfo = {
                      fontFamily,
                      fontWeight,
                      italicAngle
                    };
                    if (!(0, _core_utils.validateCSSFont)(cssFontInfo)) {
                      continue;
                    }
                    promises.push(partialEvaluator.handleSetFont(resources, [_primitives.Name.get(fontName), 1], null, operatorList, task, initialState, null, cssFontInfo).catch(function(reason) {
                      (0, _util.warn)(`loadXfaFonts: "${reason}".`);
                      return null;
                    }));
                  }
                  await Promise.all(promises);
                  const missingFonts = this.xfaFactory.setFonts(pdfFonts);
                  if (!missingFonts) {
                    return;
                  }
                  options.ignoreErrors = true;
                  promises.length = 0;
                  pdfFonts.length = 0;
                  const reallyMissingFonts = /* @__PURE__ */ new Set();
                  for (const missing of missingFonts) {
                    if (!(0, _xfa_fonts.getXfaFontName)(`${missing}-Regular`)) {
                      reallyMissingFonts.add(missing);
                    }
                  }
                  if (reallyMissingFonts.size) {
                    missingFonts.push("PdfJS-Fallback");
                  }
                  for (const missing of missingFonts) {
                    if (reallyMissingFonts.has(missing)) {
                      continue;
                    }
                    for (const fontInfo of [{
                      name: "Regular",
                      fontWeight: 400,
                      italicAngle: 0
                    }, {
                      name: "Bold",
                      fontWeight: 700,
                      italicAngle: 0
                    }, {
                      name: "Italic",
                      fontWeight: 400,
                      italicAngle: 12
                    }, {
                      name: "BoldItalic",
                      fontWeight: 700,
                      italicAngle: 12
                    }]) {
                      const name = `${missing}-${fontInfo.name}`;
                      const dict = (0, _xfa_fonts.getXfaFontDict)(name);
                      promises.push(partialEvaluator.handleSetFont(resources, [_primitives.Name.get(name), 1], null, operatorList, task, initialState, dict, {
                        fontFamily: missing,
                        fontWeight: fontInfo.fontWeight,
                        italicAngle: fontInfo.italicAngle
                      }).catch(function(reason) {
                        (0, _util.warn)(`loadXfaFonts: "${reason}".`);
                        return null;
                      }));
                    }
                  }
                  await Promise.all(promises);
                  this.xfaFactory.appendFonts(pdfFonts, reallyMissingFonts);
                }
                async serializeXfaData(annotationStorage) {
                  return this.xfaFactory ? this.xfaFactory.serializeData(annotationStorage) : null;
                }
                get formInfo() {
                  const formInfo = {
                    hasFields: false,
                    hasAcroForm: false,
                    hasXfa: false,
                    hasSignatures: false
                  };
                  const acroForm = this.catalog.acroForm;
                  if (!acroForm) {
                    return (0, _util.shadow)(this, "formInfo", formInfo);
                  }
                  try {
                    const fields = acroForm.get("Fields");
                    const hasFields = Array.isArray(fields) && fields.length > 0;
                    formInfo.hasFields = hasFields;
                    const xfa = acroForm.get("XFA");
                    formInfo.hasXfa = Array.isArray(xfa) && xfa.length > 0 || xfa instanceof _base_stream.BaseStream && !xfa.isEmpty;
                    const sigFlags = acroForm.get("SigFlags");
                    const hasSignatures = !!(sigFlags & 1);
                    const hasOnlyDocumentSignatures = hasSignatures && this._hasOnlyDocumentSignatures(fields);
                    formInfo.hasAcroForm = hasFields && !hasOnlyDocumentSignatures;
                    formInfo.hasSignatures = hasSignatures;
                  } catch (ex) {
                    if (ex instanceof _core_utils.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.warn)(`Cannot fetch form information: "${ex}".`);
                  }
                  return (0, _util.shadow)(this, "formInfo", formInfo);
                }
                get documentInfo() {
                  let version = this._version;
                  if (typeof version !== "string" || !PDF_HEADER_VERSION_REGEXP.test(version)) {
                    (0, _util.warn)(`Invalid PDF header version number: ${version}`);
                    version = null;
                  }
                  const docInfo = {
                    PDFFormatVersion: version,
                    Language: this.catalog.lang,
                    EncryptFilterName: this.xref.encrypt ? this.xref.encrypt.filterName : null,
                    IsLinearized: !!this.linearization,
                    IsAcroFormPresent: this.formInfo.hasAcroForm,
                    IsXFAPresent: this.formInfo.hasXfa,
                    IsCollectionPresent: !!this.catalog.collection,
                    IsSignaturesPresent: this.formInfo.hasSignatures
                  };
                  let infoDict;
                  try {
                    infoDict = this.xref.trailer.get("Info");
                  } catch (err) {
                    if (err instanceof _core_utils.MissingDataException) {
                      throw err;
                    }
                    (0, _util.info)("The document information dictionary is invalid.");
                  }
                  if (!(infoDict instanceof _primitives.Dict)) {
                    return (0, _util.shadow)(this, "documentInfo", docInfo);
                  }
                  for (const key of infoDict.getKeys()) {
                    const value = infoDict.get(key);
                    switch (key) {
                      case "Title":
                      case "Author":
                      case "Subject":
                      case "Keywords":
                      case "Creator":
                      case "Producer":
                      case "CreationDate":
                      case "ModDate":
                        if (typeof value === "string") {
                          docInfo[key] = (0, _util.stringToPDFString)(value);
                          continue;
                        }
                        break;
                      case "Trapped":
                        if (value instanceof _primitives.Name) {
                          docInfo[key] = value;
                          continue;
                        }
                        break;
                      default:
                        let customValue;
                        switch (typeof value) {
                          case "string":
                            customValue = (0, _util.stringToPDFString)(value);
                            break;
                          case "number":
                          case "boolean":
                            customValue = value;
                            break;
                          default:
                            if (value instanceof _primitives.Name) {
                              customValue = value;
                            }
                            break;
                        }
                        if (customValue === void 0) {
                          (0, _util.warn)(`Bad value, for custom key "${key}", in Info: ${value}.`);
                          continue;
                        }
                        if (!docInfo.Custom) {
                          docInfo.Custom = /* @__PURE__ */ Object.create(null);
                        }
                        docInfo.Custom[key] = customValue;
                        continue;
                    }
                    (0, _util.warn)(`Bad value, for key "${key}", in Info: ${value}.`);
                  }
                  return (0, _util.shadow)(this, "documentInfo", docInfo);
                }
                get fingerprints() {
                  function validate(data) {
                    return typeof data === "string" && data.length > 0 && data !== EMPTY_FINGERPRINT;
                  }
                  __name(validate, "validate");
                  function hexString(hash) {
                    const buf = [];
                    for (let i = 0, ii = hash.length; i < ii; i++) {
                      const hex = hash[i].toString(16);
                      buf.push(hex.padStart(2, "0"));
                    }
                    return buf.join("");
                  }
                  __name(hexString, "hexString");
                  const idArray = this.xref.trailer.get("ID");
                  let hashOriginal, hashModified;
                  if (Array.isArray(idArray) && validate(idArray[0])) {
                    hashOriginal = (0, _util.stringToBytes)(idArray[0]);
                    if (idArray[1] !== idArray[0] && validate(idArray[1])) {
                      hashModified = (0, _util.stringToBytes)(idArray[1]);
                    }
                  } else {
                    hashOriginal = (0, _crypto.calculateMD5)(this.stream.getByteRange(0, FINGERPRINT_FIRST_BYTES), 0, FINGERPRINT_FIRST_BYTES);
                  }
                  return (0, _util.shadow)(this, "fingerprints", [hexString(hashOriginal), hashModified ? hexString(hashModified) : null]);
                }
                async _getLinearizationPage(pageIndex) {
                  const {
                    catalog,
                    linearization,
                    xref
                  } = this;
                  const ref = _primitives.Ref.get(linearization.objectNumberFirst, 0);
                  try {
                    const obj = await xref.fetchAsync(ref);
                    if (obj instanceof _primitives.Dict) {
                      let type = obj.getRaw("Type");
                      if (type instanceof _primitives.Ref) {
                        type = await xref.fetchAsync(type);
                      }
                      if ((0, _primitives.isName)(type, "Page") || !obj.has("Type") && !obj.has("Kids")) {
                        if (!catalog.pageKidsCountCache.has(ref)) {
                          catalog.pageKidsCountCache.put(ref, 1);
                        }
                        if (!catalog.pageIndexCache.has(ref)) {
                          catalog.pageIndexCache.put(ref, 0);
                        }
                        return [obj, ref];
                      }
                    }
                    throw new _util.FormatError("The Linearization dictionary doesn't point to a valid Page dictionary.");
                  } catch (reason) {
                    (0, _util.warn)(`_getLinearizationPage: "${reason.message}".`);
                    return catalog.getPageDict(pageIndex);
                  }
                }
                getPage(pageIndex) {
                  const cachedPromise = this._pagePromises.get(pageIndex);
                  if (cachedPromise) {
                    return cachedPromise;
                  }
                  const {
                    catalog,
                    linearization,
                    xfaFactory
                  } = this;
                  let promise;
                  if (xfaFactory) {
                    promise = Promise.resolve([_primitives.Dict.empty, null]);
                  } else if (linearization && linearization.pageFirst === pageIndex) {
                    promise = this._getLinearizationPage(pageIndex);
                  } else {
                    promise = catalog.getPageDict(pageIndex);
                  }
                  promise = promise.then((_ref7) => {
                    let [pageDict, ref] = _ref7;
                    return new Page({
                      pdfManager: this.pdfManager,
                      xref: this.xref,
                      pageIndex,
                      pageDict,
                      ref,
                      globalIdFactory: this._globalIdFactory,
                      fontCache: catalog.fontCache,
                      builtInCMapCache: catalog.builtInCMapCache,
                      standardFontDataCache: catalog.standardFontDataCache,
                      globalImageCache: catalog.globalImageCache,
                      nonBlendModesSet: catalog.nonBlendModesSet,
                      xfaFactory
                    });
                  });
                  this._pagePromises.set(pageIndex, promise);
                  return promise;
                }
                async checkFirstPage() {
                  let recoveryMode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  if (recoveryMode) {
                    return;
                  }
                  try {
                    await this.getPage(0);
                  } catch (reason) {
                    if (reason instanceof _core_utils.XRefEntryException) {
                      this._pagePromises.delete(0);
                      await this.cleanup();
                      throw new _core_utils.XRefParseException();
                    }
                  }
                }
                async checkLastPage() {
                  let recoveryMode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  const {
                    catalog,
                    pdfManager
                  } = this;
                  catalog.setActualNumPages();
                  let numPages;
                  try {
                    await Promise.all([pdfManager.ensureDoc("xfaFactory"), pdfManager.ensureDoc("linearization"), pdfManager.ensureCatalog("numPages")]);
                    if (this.xfaFactory) {
                      return;
                    } else if (this.linearization) {
                      numPages = this.linearization.numPages;
                    } else {
                      numPages = catalog.numPages;
                    }
                    if (!Number.isInteger(numPages)) {
                      throw new _util.FormatError("Page count is not an integer.");
                    } else if (numPages <= 1) {
                      return;
                    }
                    await this.getPage(numPages - 1);
                  } catch (reason) {
                    this._pagePromises.delete(numPages - 1);
                    await this.cleanup();
                    if (reason instanceof _core_utils.XRefEntryException && !recoveryMode) {
                      throw new _core_utils.XRefParseException();
                    }
                    (0, _util.warn)(`checkLastPage - invalid /Pages tree /Count: ${numPages}.`);
                    let pagesTree;
                    try {
                      pagesTree = await catalog.getAllPageDicts(recoveryMode);
                    } catch (reasonAll) {
                      if (reasonAll instanceof _core_utils.XRefEntryException && !recoveryMode) {
                        throw new _core_utils.XRefParseException();
                      }
                      catalog.setActualNumPages(1);
                      return;
                    }
                    for (const [pageIndex, [pageDict, ref]] of pagesTree) {
                      let promise;
                      if (pageDict instanceof Error) {
                        promise = Promise.reject(pageDict);
                        promise.catch(() => {
                        });
                      } else {
                        promise = Promise.resolve(new Page({
                          pdfManager,
                          xref: this.xref,
                          pageIndex,
                          pageDict,
                          ref,
                          globalIdFactory: this._globalIdFactory,
                          fontCache: catalog.fontCache,
                          builtInCMapCache: catalog.builtInCMapCache,
                          standardFontDataCache: catalog.standardFontDataCache,
                          globalImageCache: catalog.globalImageCache,
                          nonBlendModesSet: catalog.nonBlendModesSet,
                          xfaFactory: null
                        }));
                      }
                      this._pagePromises.set(pageIndex, promise);
                    }
                    catalog.setActualNumPages(pagesTree.size);
                  }
                }
                fontFallback(id, handler) {
                  return this.catalog.fontFallback(id, handler);
                }
                async cleanup() {
                  let manuallyTriggered = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  return this.catalog ? this.catalog.cleanup(manuallyTriggered) : (0, _cleanup_helper.clearGlobalCaches)();
                }
                _collectFieldObjects(name, fieldRef, promises) {
                  const field = this.xref.fetchIfRef(fieldRef);
                  if (field.has("T")) {
                    const partName = (0, _util.stringToPDFString)(field.get("T"));
                    if (name === "") {
                      name = partName;
                    } else {
                      name = `${name}.${partName}`;
                    }
                  }
                  if (!promises.has(name)) {
                    promises.set(name, []);
                  }
                  promises.get(name).push(_annotation.AnnotationFactory.create(this.xref, fieldRef, this.pdfManager, this._localIdFactory, true).then((annotation) => annotation && annotation.getFieldObject()).catch(function(reason) {
                    (0, _util.warn)(`_collectFieldObjects: "${reason}".`);
                    return null;
                  }));
                  if (field.has("Kids")) {
                    const kids = field.get("Kids");
                    for (const kid of kids) {
                      this._collectFieldObjects(name, kid, promises);
                    }
                  }
                }
                get fieldObjects() {
                  if (!this.formInfo.hasFields) {
                    return (0, _util.shadow)(this, "fieldObjects", Promise.resolve(null));
                  }
                  const allFields = /* @__PURE__ */ Object.create(null);
                  const fieldPromises = /* @__PURE__ */ new Map();
                  for (const fieldRef of this.catalog.acroForm.get("Fields")) {
                    this._collectFieldObjects("", fieldRef, fieldPromises);
                  }
                  const allPromises = [];
                  for (const [name, promises] of fieldPromises) {
                    allPromises.push(Promise.all(promises).then((fields) => {
                      fields = fields.filter((field) => !!field);
                      if (fields.length > 0) {
                        allFields[name] = fields;
                      }
                    }));
                  }
                  return (0, _util.shadow)(this, "fieldObjects", Promise.all(allPromises).then(() => allFields));
                }
                get hasJSActions() {
                  const promise = this.pdfManager.ensureDoc("_parseHasJSActions");
                  return (0, _util.shadow)(this, "hasJSActions", promise);
                }
                async _parseHasJSActions() {
                  const [catalogJsActions, fieldObjects] = await Promise.all([this.pdfManager.ensureCatalog("jsActions"), this.pdfManager.ensureDoc("fieldObjects")]);
                  if (catalogJsActions) {
                    return true;
                  }
                  if (fieldObjects) {
                    return Object.values(fieldObjects).some((fieldObject) => fieldObject.some((object) => object.actions !== null));
                  }
                  return false;
                }
                get calculationOrderIds() {
                  const acroForm = this.catalog.acroForm;
                  if (!acroForm || !acroForm.has("CO")) {
                    return (0, _util.shadow)(this, "calculationOrderIds", null);
                  }
                  const calculationOrder = acroForm.get("CO");
                  if (!Array.isArray(calculationOrder) || calculationOrder.length === 0) {
                    return (0, _util.shadow)(this, "calculationOrderIds", null);
                  }
                  const ids = [];
                  for (const id of calculationOrder) {
                    if (id instanceof _primitives.Ref) {
                      ids.push(id.toString());
                    }
                  }
                  if (ids.length === 0) {
                    return (0, _util.shadow)(this, "calculationOrderIds", null);
                  }
                  return (0, _util.shadow)(this, "calculationOrderIds", ids);
                }
              };
              __name(_PDFDocument, "PDFDocument");
              let PDFDocument = _PDFDocument;
              exports2.PDFDocument = PDFDocument;
            },
            /* 137 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PopupAnnotation = exports2.MarkupAnnotation = exports2.AnnotationFactory = exports2.AnnotationBorderStyle = exports2.Annotation = void 0;
              exports2.getQuadPoints = getQuadPoints;
              var _util = __w_pdfjs_require__2(2);
              var _core_utils = __w_pdfjs_require__2(131);
              var _default_appearance = __w_pdfjs_require__2(138);
              var _primitives = __w_pdfjs_require__2(130);
              var _writer = __w_pdfjs_require__2(190);
              var _base_stream = __w_pdfjs_require__2(132);
              var _bidi = __w_pdfjs_require__2(185);
              var _catalog = __w_pdfjs_require__2(194);
              var _colorspace = __w_pdfjs_require__2(139);
              var _file_spec = __w_pdfjs_require__2(197);
              var _object_loader = __w_pdfjs_require__2(200);
              var _operator_list = __w_pdfjs_require__2(187);
              var _stream = __w_pdfjs_require__2(135);
              var _factory = __w_pdfjs_require__2(201);
              const _AnnotationFactory = class _AnnotationFactory {
                static create(xref, ref, pdfManager, idFactory, collectFields) {
                  return Promise.all([pdfManager.ensureCatalog("acroForm"), pdfManager.ensureCatalog("baseUrl"), pdfManager.ensureDoc("xfaDatasets"), collectFields ? this._getPageIndex(xref, ref, pdfManager) : -1]).then((_ref) => {
                    let [acroForm, baseUrl, xfaDatasets, pageIndex] = _ref;
                    return pdfManager.ensure(this, "_create", [xref, ref, pdfManager, idFactory, acroForm, xfaDatasets, collectFields, pageIndex]);
                  });
                }
                static _create(xref, ref, pdfManager, idFactory, acroForm, xfaDatasets, collectFields) {
                  let pageIndex = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : -1;
                  const dict = xref.fetchIfRef(ref);
                  if (!(dict instanceof _primitives.Dict)) {
                    return void 0;
                  }
                  const id = ref instanceof _primitives.Ref ? ref.toString() : `annot_${idFactory.createObjId()}`;
                  let subtype = dict.get("Subtype");
                  subtype = subtype instanceof _primitives.Name ? subtype.name : null;
                  const parameters = {
                    xref,
                    ref,
                    dict,
                    subtype,
                    id,
                    pdfManager,
                    acroForm: acroForm instanceof _primitives.Dict ? acroForm : _primitives.Dict.empty,
                    xfaDatasets,
                    collectFields,
                    pageIndex
                  };
                  switch (subtype) {
                    case "Link":
                      return new LinkAnnotation(parameters);
                    case "Text":
                      return new TextAnnotation(parameters);
                    case "Widget":
                      let fieldType = (0, _core_utils.getInheritableProperty)({
                        dict,
                        key: "FT"
                      });
                      fieldType = fieldType instanceof _primitives.Name ? fieldType.name : null;
                      switch (fieldType) {
                        case "Tx":
                          return new TextWidgetAnnotation(parameters);
                        case "Btn":
                          return new ButtonWidgetAnnotation(parameters);
                        case "Ch":
                          return new ChoiceWidgetAnnotation(parameters);
                        case "Sig":
                          return new SignatureWidgetAnnotation(parameters);
                      }
                      (0, _util.warn)(`Unimplemented widget field type "${fieldType}", falling back to base field type.`);
                      return new WidgetAnnotation(parameters);
                    case "Popup":
                      return new PopupAnnotation(parameters);
                    case "FreeText":
                      return new FreeTextAnnotation(parameters);
                    case "Line":
                      return new LineAnnotation(parameters);
                    case "Square":
                      return new SquareAnnotation(parameters);
                    case "Circle":
                      return new CircleAnnotation(parameters);
                    case "PolyLine":
                      return new PolylineAnnotation(parameters);
                    case "Polygon":
                      return new PolygonAnnotation(parameters);
                    case "Caret":
                      return new CaretAnnotation(parameters);
                    case "Ink":
                      return new InkAnnotation(parameters);
                    case "Highlight":
                      return new HighlightAnnotation(parameters);
                    case "Underline":
                      return new UnderlineAnnotation(parameters);
                    case "Squiggly":
                      return new SquigglyAnnotation(parameters);
                    case "StrikeOut":
                      return new StrikeOutAnnotation(parameters);
                    case "Stamp":
                      return new StampAnnotation(parameters);
                    case "FileAttachment":
                      return new FileAttachmentAnnotation(parameters);
                    default:
                      if (!collectFields) {
                        if (!subtype) {
                          (0, _util.warn)("Annotation is missing the required /Subtype.");
                        } else {
                          (0, _util.warn)(`Unimplemented annotation type "${subtype}", falling back to base annotation.`);
                        }
                      }
                      return new Annotation(parameters);
                  }
                }
                static async _getPageIndex(xref, ref, pdfManager) {
                  try {
                    const annotDict = await xref.fetchIfRefAsync(ref);
                    if (!(annotDict instanceof _primitives.Dict)) {
                      return -1;
                    }
                    const pageRef = annotDict.getRaw("P");
                    if (!(pageRef instanceof _primitives.Ref)) {
                      return -1;
                    }
                    const pageIndex = await pdfManager.ensureCatalog("getPageIndex", [pageRef]);
                    return pageIndex;
                  } catch (ex) {
                    (0, _util.warn)(`_getPageIndex: "${ex}".`);
                    return -1;
                  }
                }
                static async saveNewAnnotations(evaluator, task, annotations) {
                  const xref = evaluator.xref;
                  let baseFontRef;
                  const dependencies = [];
                  const promises = [];
                  for (const annotation of annotations) {
                    switch (annotation.annotationType) {
                      case _util.AnnotationEditorType.FREETEXT:
                        if (!baseFontRef) {
                          const baseFont = new _primitives.Dict(xref);
                          baseFont.set("BaseFont", _primitives.Name.get("Helvetica"));
                          baseFont.set("Type", _primitives.Name.get("Font"));
                          baseFont.set("Subtype", _primitives.Name.get("Type1"));
                          baseFont.set("Encoding", _primitives.Name.get("WinAnsiEncoding"));
                          const buffer = [];
                          baseFontRef = xref.getNewRef();
                          (0, _writer.writeObject)(baseFontRef, baseFont, buffer, null);
                          dependencies.push({
                            ref: baseFontRef,
                            data: buffer.join("")
                          });
                        }
                        promises.push(FreeTextAnnotation.createNewAnnotation(xref, annotation, dependencies, {
                          evaluator,
                          task,
                          baseFontRef
                        }));
                        break;
                      case _util.AnnotationEditorType.INK:
                        promises.push(InkAnnotation.createNewAnnotation(xref, annotation, dependencies));
                    }
                  }
                  return {
                    annotations: await Promise.all(promises),
                    dependencies
                  };
                }
                static async printNewAnnotations(evaluator, task, annotations) {
                  if (!annotations) {
                    return null;
                  }
                  const xref = evaluator.xref;
                  const promises = [];
                  for (const annotation of annotations) {
                    switch (annotation.annotationType) {
                      case _util.AnnotationEditorType.FREETEXT:
                        promises.push(FreeTextAnnotation.createNewPrintAnnotation(xref, annotation, {
                          evaluator,
                          task
                        }));
                        break;
                      case _util.AnnotationEditorType.INK:
                        promises.push(InkAnnotation.createNewPrintAnnotation(xref, annotation));
                        break;
                    }
                  }
                  return Promise.all(promises);
                }
              };
              __name(_AnnotationFactory, "AnnotationFactory");
              let AnnotationFactory = _AnnotationFactory;
              exports2.AnnotationFactory = AnnotationFactory;
              function getRgbColor(color) {
                let defaultColor = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new Uint8ClampedArray(3);
                if (!Array.isArray(color)) {
                  return defaultColor;
                }
                const rgbColor = defaultColor || new Uint8ClampedArray(3);
                switch (color.length) {
                  case 0:
                    return null;
                  case 1:
                    _colorspace.ColorSpace.singletons.gray.getRgbItem(color, 0, rgbColor, 0);
                    return rgbColor;
                  case 3:
                    _colorspace.ColorSpace.singletons.rgb.getRgbItem(color, 0, rgbColor, 0);
                    return rgbColor;
                  case 4:
                    _colorspace.ColorSpace.singletons.cmyk.getRgbItem(color, 0, rgbColor, 0);
                    return rgbColor;
                  default:
                    return defaultColor;
                }
              }
              __name(getRgbColor, "getRgbColor");
              function getQuadPoints(dict, rect) {
                if (!dict.has("QuadPoints")) {
                  return null;
                }
                const quadPoints = dict.getArray("QuadPoints");
                if (!Array.isArray(quadPoints) || quadPoints.length === 0 || quadPoints.length % 8 > 0) {
                  return null;
                }
                const quadPointsLists = [];
                for (let i = 0, ii = quadPoints.length / 8; i < ii; i++) {
                  quadPointsLists.push([]);
                  for (let j = i * 8, jj = i * 8 + 8; j < jj; j += 2) {
                    const x = quadPoints[j];
                    const y = quadPoints[j + 1];
                    if (rect !== null && (x < rect[0] || x > rect[2] || y < rect[1] || y > rect[3])) {
                      return null;
                    }
                    quadPointsLists[i].push({
                      x,
                      y
                    });
                  }
                }
                return quadPointsLists.map((quadPointsList) => {
                  const [minX, maxX, minY, maxY] = quadPointsList.reduce((_ref2, quadPoint) => {
                    let [mX, MX, mY, MY] = _ref2;
                    return [Math.min(mX, quadPoint.x), Math.max(MX, quadPoint.x), Math.min(mY, quadPoint.y), Math.max(MY, quadPoint.y)];
                  }, [Number.MAX_VALUE, Number.MIN_VALUE, Number.MAX_VALUE, Number.MIN_VALUE]);
                  return [{
                    x: minX,
                    y: maxY
                  }, {
                    x: maxX,
                    y: maxY
                  }, {
                    x: minX,
                    y: minY
                  }, {
                    x: maxX,
                    y: minY
                  }];
                });
              }
              __name(getQuadPoints, "getQuadPoints");
              function getTransformMatrix(rect, bbox, matrix) {
                const [minX, minY, maxX, maxY] = _util.Util.getAxialAlignedBoundingBox(bbox, matrix);
                if (minX === maxX || minY === maxY) {
                  return [1, 0, 0, 1, rect[0], rect[1]];
                }
                const xRatio = (rect[2] - rect[0]) / (maxX - minX);
                const yRatio = (rect[3] - rect[1]) / (maxY - minY);
                return [xRatio, 0, 0, yRatio, rect[0] - minX * xRatio, rect[1] - minY * yRatio];
              }
              __name(getTransformMatrix, "getTransformMatrix");
              const _Annotation = class _Annotation {
                constructor(params) {
                  const dict = params.dict;
                  this.setTitle(dict.get("T"));
                  this.setContents(dict.get("Contents"));
                  this.setModificationDate(dict.get("M"));
                  this.setFlags(dict.get("F"));
                  this.setRectangle(dict.getArray("Rect"));
                  this.setColor(dict.getArray("C"));
                  this.setBorderStyle(dict);
                  this.setAppearance(dict);
                  this.setOptionalContent(dict);
                  const MK = dict.get("MK");
                  this.setBorderAndBackgroundColors(MK);
                  this.setRotation(MK);
                  this._streams = [];
                  if (this.appearance) {
                    this._streams.push(this.appearance);
                  }
                  this.data = {
                    annotationFlags: this.flags,
                    borderStyle: this.borderStyle,
                    color: this.color,
                    backgroundColor: this.backgroundColor,
                    borderColor: this.borderColor,
                    rotation: this.rotation,
                    contentsObj: this._contents,
                    hasAppearance: !!this.appearance,
                    id: params.id,
                    modificationDate: this.modificationDate,
                    rect: this.rectangle,
                    subtype: params.subtype,
                    hasOwnCanvas: false
                  };
                  if (params.collectFields) {
                    const kids = dict.get("Kids");
                    if (Array.isArray(kids)) {
                      const kidIds = [];
                      for (const kid of kids) {
                        if (kid instanceof _primitives.Ref) {
                          kidIds.push(kid.toString());
                        }
                      }
                      if (kidIds.length !== 0) {
                        this.data.kidIds = kidIds;
                      }
                    }
                    this.data.actions = (0, _core_utils.collectActions)(params.xref, dict, _util.AnnotationActionEventType);
                    this.data.fieldName = this._constructFieldName(dict);
                    this.data.pageIndex = params.pageIndex;
                  }
                  this._fallbackFontDict = null;
                }
                _hasFlag(flags, flag) {
                  return !!(flags & flag);
                }
                _isViewable(flags) {
                  return !this._hasFlag(flags, _util.AnnotationFlag.INVISIBLE) && !this._hasFlag(flags, _util.AnnotationFlag.NOVIEW);
                }
                _isPrintable(flags) {
                  return this._hasFlag(flags, _util.AnnotationFlag.PRINT) && !this._hasFlag(flags, _util.AnnotationFlag.INVISIBLE);
                }
                mustBeViewed(annotationStorage) {
                  const storageEntry = annotationStorage && annotationStorage.get(this.data.id);
                  if (storageEntry && storageEntry.hidden !== void 0) {
                    return !storageEntry.hidden;
                  }
                  return this.viewable && !this._hasFlag(this.flags, _util.AnnotationFlag.HIDDEN);
                }
                mustBePrinted(annotationStorage) {
                  const storageEntry = annotationStorage && annotationStorage.get(this.data.id);
                  if (storageEntry && storageEntry.print !== void 0) {
                    return storageEntry.print;
                  }
                  return this.printable;
                }
                get viewable() {
                  if (this.data.quadPoints === null) {
                    return false;
                  }
                  if (this.flags === 0) {
                    return true;
                  }
                  return this._isViewable(this.flags);
                }
                get printable() {
                  if (this.data.quadPoints === null) {
                    return false;
                  }
                  if (this.flags === 0) {
                    return false;
                  }
                  return this._isPrintable(this.flags);
                }
                _parseStringHelper(data) {
                  const str = typeof data === "string" ? (0, _util.stringToPDFString)(data) : "";
                  const dir = str && (0, _bidi.bidi)(str).dir === "rtl" ? "rtl" : "ltr";
                  return {
                    str,
                    dir
                  };
                }
                setTitle(title) {
                  this._title = this._parseStringHelper(title);
                }
                setContents(contents) {
                  this._contents = this._parseStringHelper(contents);
                }
                setModificationDate(modificationDate) {
                  this.modificationDate = typeof modificationDate === "string" ? modificationDate : null;
                }
                setFlags(flags) {
                  this.flags = Number.isInteger(flags) && flags > 0 ? flags : 0;
                }
                hasFlag(flag) {
                  return this._hasFlag(this.flags, flag);
                }
                setRectangle(rectangle) {
                  if (Array.isArray(rectangle) && rectangle.length === 4) {
                    this.rectangle = _util.Util.normalizeRect(rectangle);
                  } else {
                    this.rectangle = [0, 0, 0, 0];
                  }
                }
                setColor(color) {
                  this.color = getRgbColor(color);
                }
                setLineEndings(lineEndings) {
                  this.lineEndings = ["None", "None"];
                  if (Array.isArray(lineEndings) && lineEndings.length === 2) {
                    for (let i = 0; i < 2; i++) {
                      const obj = lineEndings[i];
                      if (obj instanceof _primitives.Name) {
                        switch (obj.name) {
                          case "None":
                            continue;
                          case "Square":
                          case "Circle":
                          case "Diamond":
                          case "OpenArrow":
                          case "ClosedArrow":
                          case "Butt":
                          case "ROpenArrow":
                          case "RClosedArrow":
                          case "Slash":
                            this.lineEndings[i] = obj.name;
                            continue;
                        }
                      }
                      (0, _util.warn)(`Ignoring invalid lineEnding: ${obj}`);
                    }
                  }
                }
                setRotation(mk) {
                  this.rotation = 0;
                  if (mk instanceof _primitives.Dict) {
                    let angle = mk.get("R") || 0;
                    if (Number.isInteger(angle) && angle !== 0) {
                      angle %= 360;
                      if (angle < 0) {
                        angle += 360;
                      }
                      if (angle % 90 === 0) {
                        this.rotation = angle;
                      }
                    }
                  }
                }
                setBorderAndBackgroundColors(mk) {
                  if (mk instanceof _primitives.Dict) {
                    this.borderColor = getRgbColor(mk.getArray("BC"), null);
                    this.backgroundColor = getRgbColor(mk.getArray("BG"), null);
                  } else {
                    this.borderColor = this.backgroundColor = null;
                  }
                }
                setBorderStyle(borderStyle) {
                  this.borderStyle = new AnnotationBorderStyle();
                  if (!(borderStyle instanceof _primitives.Dict)) {
                    return;
                  }
                  if (borderStyle.has("BS")) {
                    const dict = borderStyle.get("BS");
                    const dictType = dict.get("Type");
                    if (!dictType || (0, _primitives.isName)(dictType, "Border")) {
                      this.borderStyle.setWidth(dict.get("W"), this.rectangle);
                      this.borderStyle.setStyle(dict.get("S"));
                      this.borderStyle.setDashArray(dict.getArray("D"));
                    }
                  } else if (borderStyle.has("Border")) {
                    const array = borderStyle.getArray("Border");
                    if (Array.isArray(array) && array.length >= 3) {
                      this.borderStyle.setHorizontalCornerRadius(array[0]);
                      this.borderStyle.setVerticalCornerRadius(array[1]);
                      this.borderStyle.setWidth(array[2], this.rectangle);
                      if (array.length === 4) {
                        this.borderStyle.setDashArray(array[3], true);
                      }
                    }
                  } else {
                    this.borderStyle.setWidth(0);
                  }
                }
                setAppearance(dict) {
                  this.appearance = null;
                  const appearanceStates = dict.get("AP");
                  if (!(appearanceStates instanceof _primitives.Dict)) {
                    return;
                  }
                  const normalAppearanceState = appearanceStates.get("N");
                  if (normalAppearanceState instanceof _base_stream.BaseStream) {
                    this.appearance = normalAppearanceState;
                    return;
                  }
                  if (!(normalAppearanceState instanceof _primitives.Dict)) {
                    return;
                  }
                  const as = dict.get("AS");
                  if (!(as instanceof _primitives.Name) || !normalAppearanceState.has(as.name)) {
                    return;
                  }
                  this.appearance = normalAppearanceState.get(as.name);
                }
                setOptionalContent(dict) {
                  this.oc = null;
                  const oc = dict.get("OC");
                  if (oc instanceof _primitives.Name) {
                    (0, _util.warn)("setOptionalContent: Support for /Name-entry is not implemented.");
                  } else if (oc instanceof _primitives.Dict) {
                    this.oc = oc;
                  }
                }
                loadResources(keys, appearance) {
                  return appearance.dict.getAsync("Resources").then((resources) => {
                    if (!resources) {
                      return void 0;
                    }
                    const objectLoader = new _object_loader.ObjectLoader(resources, keys, resources.xref);
                    return objectLoader.load().then(function() {
                      return resources;
                    });
                  });
                }
                async getOperatorList(evaluator, task, intent, renderForms, annotationStorage) {
                  const data = this.data;
                  let appearance = this.appearance;
                  const isUsingOwnCanvas = !!(this.data.hasOwnCanvas && intent & _util.RenderingIntentFlag.DISPLAY);
                  if (!appearance) {
                    if (!isUsingOwnCanvas) {
                      return {
                        opList: new _operator_list.OperatorList(),
                        separateForm: false,
                        separateCanvas: false
                      };
                    }
                    appearance = new _stream.StringStream("");
                    appearance.dict = new _primitives.Dict();
                  }
                  const appearanceDict = appearance.dict;
                  const resources = await this.loadResources(["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"], appearance);
                  const bbox = appearanceDict.getArray("BBox") || [0, 0, 1, 1];
                  const matrix = appearanceDict.getArray("Matrix") || [1, 0, 0, 1, 0, 0];
                  const transform = getTransformMatrix(data.rect, bbox, matrix);
                  const opList = new _operator_list.OperatorList();
                  let optionalContent;
                  if (this.oc) {
                    optionalContent = await evaluator.parseMarkedContentProps(this.oc, null);
                  }
                  if (optionalContent !== void 0) {
                    opList.addOp(_util.OPS.beginMarkedContentProps, ["OC", optionalContent]);
                  }
                  opList.addOp(_util.OPS.beginAnnotation, [data.id, data.rect, transform, matrix, isUsingOwnCanvas]);
                  await evaluator.getOperatorList({
                    stream: appearance,
                    task,
                    resources,
                    operatorList: opList,
                    fallbackFontDict: this._fallbackFontDict
                  });
                  opList.addOp(_util.OPS.endAnnotation, []);
                  if (optionalContent !== void 0) {
                    opList.addOp(_util.OPS.endMarkedContent, []);
                  }
                  this.reset();
                  return {
                    opList,
                    separateForm: false,
                    separateCanvas: isUsingOwnCanvas
                  };
                }
                async save(evaluator, task, annotationStorage) {
                  return null;
                }
                get hasTextContent() {
                  return false;
                }
                async extractTextContent(evaluator, task, viewBox) {
                  if (!this.appearance) {
                    return;
                  }
                  const resources = await this.loadResources(["ExtGState", "Font", "Properties", "XObject"], this.appearance);
                  const text = [];
                  const buffer = [];
                  const sink = {
                    desiredSize: Math.Infinity,
                    ready: true,
                    enqueue(chunk, size) {
                      for (const item of chunk.items) {
                        buffer.push(item.str);
                        if (item.hasEOL) {
                          text.push(buffer.join(""));
                          buffer.length = 0;
                        }
                      }
                    }
                  };
                  await evaluator.getTextContent({
                    stream: this.appearance,
                    task,
                    resources,
                    includeMarkedContent: true,
                    combineTextItems: true,
                    sink,
                    viewBox
                  });
                  this.reset();
                  if (buffer.length) {
                    text.push(buffer.join(""));
                  }
                  if (text.length > 0) {
                    this.data.textContent = text;
                  }
                }
                getFieldObject() {
                  if (this.data.kidIds) {
                    return {
                      id: this.data.id,
                      actions: this.data.actions,
                      name: this.data.fieldName,
                      strokeColor: this.data.borderColor,
                      fillColor: this.data.backgroundColor,
                      type: "",
                      kidIds: this.data.kidIds,
                      page: this.data.pageIndex,
                      rotation: this.rotation
                    };
                  }
                  return null;
                }
                reset() {
                  for (const stream of this._streams) {
                    stream.reset();
                  }
                }
                _constructFieldName(dict) {
                  if (!dict.has("T") && !dict.has("Parent")) {
                    (0, _util.warn)("Unknown field name, falling back to empty field name.");
                    return "";
                  }
                  if (!dict.has("Parent")) {
                    return (0, _util.stringToPDFString)(dict.get("T"));
                  }
                  const fieldName = [];
                  if (dict.has("T")) {
                    fieldName.unshift((0, _util.stringToPDFString)(dict.get("T")));
                  }
                  let loopDict = dict;
                  const visited = new _primitives.RefSet();
                  if (dict.objId) {
                    visited.put(dict.objId);
                  }
                  while (loopDict.has("Parent")) {
                    loopDict = loopDict.get("Parent");
                    if (!(loopDict instanceof _primitives.Dict) || loopDict.objId && visited.has(loopDict.objId)) {
                      break;
                    }
                    if (loopDict.objId) {
                      visited.put(loopDict.objId);
                    }
                    if (loopDict.has("T")) {
                      fieldName.unshift((0, _util.stringToPDFString)(loopDict.get("T")));
                    }
                  }
                  return fieldName.join(".");
                }
              };
              __name(_Annotation, "Annotation");
              let Annotation = _Annotation;
              exports2.Annotation = Annotation;
              const _AnnotationBorderStyle = class _AnnotationBorderStyle {
                constructor() {
                  this.width = 1;
                  this.style = _util.AnnotationBorderStyleType.SOLID;
                  this.dashArray = [3];
                  this.horizontalCornerRadius = 0;
                  this.verticalCornerRadius = 0;
                }
                setWidth(width) {
                  let rect = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0, 0];
                  if (width instanceof _primitives.Name) {
                    this.width = 0;
                    return;
                  }
                  if (typeof width === "number") {
                    if (width > 0) {
                      const maxWidth = (rect[2] - rect[0]) / 2;
                      const maxHeight = (rect[3] - rect[1]) / 2;
                      if (maxWidth > 0 && maxHeight > 0 && (width > maxWidth || width > maxHeight)) {
                        (0, _util.warn)(`AnnotationBorderStyle.setWidth - ignoring width: ${width}`);
                        width = 1;
                      }
                    }
                    this.width = width;
                  }
                }
                setStyle(style) {
                  if (!(style instanceof _primitives.Name)) {
                    return;
                  }
                  switch (style.name) {
                    case "S":
                      this.style = _util.AnnotationBorderStyleType.SOLID;
                      break;
                    case "D":
                      this.style = _util.AnnotationBorderStyleType.DASHED;
                      break;
                    case "B":
                      this.style = _util.AnnotationBorderStyleType.BEVELED;
                      break;
                    case "I":
                      this.style = _util.AnnotationBorderStyleType.INSET;
                      break;
                    case "U":
                      this.style = _util.AnnotationBorderStyleType.UNDERLINE;
                      break;
                  }
                }
                setDashArray(dashArray) {
                  let forceStyle = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  if (Array.isArray(dashArray) && dashArray.length > 0) {
                    let isValid = true;
                    let allZeros = true;
                    for (const element of dashArray) {
                      const validNumber = +element >= 0;
                      if (!validNumber) {
                        isValid = false;
                        break;
                      } else if (element > 0) {
                        allZeros = false;
                      }
                    }
                    if (isValid && !allZeros) {
                      this.dashArray = dashArray;
                      if (forceStyle) {
                        this.setStyle(_primitives.Name.get("D"));
                      }
                    } else {
                      this.width = 0;
                    }
                  } else if (dashArray) {
                    this.width = 0;
                  }
                }
                setHorizontalCornerRadius(radius) {
                  if (Number.isInteger(radius)) {
                    this.horizontalCornerRadius = radius;
                  }
                }
                setVerticalCornerRadius(radius) {
                  if (Number.isInteger(radius)) {
                    this.verticalCornerRadius = radius;
                  }
                }
              };
              __name(_AnnotationBorderStyle, "AnnotationBorderStyle");
              let AnnotationBorderStyle = _AnnotationBorderStyle;
              exports2.AnnotationBorderStyle = AnnotationBorderStyle;
              const _MarkupAnnotation = class _MarkupAnnotation extends Annotation {
                constructor(parameters) {
                  super(parameters);
                  const dict = parameters.dict;
                  if (dict.has("IRT")) {
                    const rawIRT = dict.getRaw("IRT");
                    this.data.inReplyTo = rawIRT instanceof _primitives.Ref ? rawIRT.toString() : null;
                    const rt = dict.get("RT");
                    this.data.replyType = rt instanceof _primitives.Name ? rt.name : _util.AnnotationReplyType.REPLY;
                  }
                  if (this.data.replyType === _util.AnnotationReplyType.GROUP) {
                    const parent = dict.get("IRT");
                    this.setTitle(parent.get("T"));
                    this.data.titleObj = this._title;
                    this.setContents(parent.get("Contents"));
                    this.data.contentsObj = this._contents;
                    if (!parent.has("CreationDate")) {
                      this.data.creationDate = null;
                    } else {
                      this.setCreationDate(parent.get("CreationDate"));
                      this.data.creationDate = this.creationDate;
                    }
                    if (!parent.has("M")) {
                      this.data.modificationDate = null;
                    } else {
                      this.setModificationDate(parent.get("M"));
                      this.data.modificationDate = this.modificationDate;
                    }
                    this.data.hasPopup = parent.has("Popup");
                    if (!parent.has("C")) {
                      this.data.color = null;
                    } else {
                      this.setColor(parent.getArray("C"));
                      this.data.color = this.color;
                    }
                  } else {
                    this.data.titleObj = this._title;
                    this.setCreationDate(dict.get("CreationDate"));
                    this.data.creationDate = this.creationDate;
                    this.data.hasPopup = dict.has("Popup");
                    if (!dict.has("C")) {
                      this.data.color = null;
                    }
                  }
                  if (dict.has("RC")) {
                    this.data.richText = _factory.XFAFactory.getRichTextAsHtml(dict.get("RC"));
                  }
                }
                setCreationDate(creationDate) {
                  this.creationDate = typeof creationDate === "string" ? creationDate : null;
                }
                _setDefaultAppearance(_ref3) {
                  let {
                    xref,
                    extra,
                    strokeColor,
                    fillColor,
                    blendMode,
                    strokeAlpha,
                    fillAlpha,
                    pointsCallback
                  } = _ref3;
                  let minX = Number.MAX_VALUE;
                  let minY = Number.MAX_VALUE;
                  let maxX = Number.MIN_VALUE;
                  let maxY = Number.MIN_VALUE;
                  const buffer = ["q"];
                  if (extra) {
                    buffer.push(extra);
                  }
                  if (strokeColor) {
                    buffer.push(`${strokeColor[0]} ${strokeColor[1]} ${strokeColor[2]} RG`);
                  }
                  if (fillColor) {
                    buffer.push(`${fillColor[0]} ${fillColor[1]} ${fillColor[2]} rg`);
                  }
                  let pointsArray = this.data.quadPoints;
                  if (!pointsArray) {
                    pointsArray = [[{
                      x: this.rectangle[0],
                      y: this.rectangle[3]
                    }, {
                      x: this.rectangle[2],
                      y: this.rectangle[3]
                    }, {
                      x: this.rectangle[0],
                      y: this.rectangle[1]
                    }, {
                      x: this.rectangle[2],
                      y: this.rectangle[1]
                    }]];
                  }
                  for (const points of pointsArray) {
                    const [mX, MX, mY, MY] = pointsCallback(buffer, points);
                    minX = Math.min(minX, mX);
                    maxX = Math.max(maxX, MX);
                    minY = Math.min(minY, mY);
                    maxY = Math.max(maxY, MY);
                  }
                  buffer.push("Q");
                  const formDict = new _primitives.Dict(xref);
                  const appearanceStreamDict = new _primitives.Dict(xref);
                  appearanceStreamDict.set("Subtype", _primitives.Name.get("Form"));
                  const appearanceStream = new _stream.StringStream(buffer.join(" "));
                  appearanceStream.dict = appearanceStreamDict;
                  formDict.set("Fm0", appearanceStream);
                  const gsDict = new _primitives.Dict(xref);
                  if (blendMode) {
                    gsDict.set("BM", _primitives.Name.get(blendMode));
                  }
                  if (typeof strokeAlpha === "number") {
                    gsDict.set("CA", strokeAlpha);
                  }
                  if (typeof fillAlpha === "number") {
                    gsDict.set("ca", fillAlpha);
                  }
                  const stateDict = new _primitives.Dict(xref);
                  stateDict.set("GS0", gsDict);
                  const resources = new _primitives.Dict(xref);
                  resources.set("ExtGState", stateDict);
                  resources.set("XObject", formDict);
                  const appearanceDict = new _primitives.Dict(xref);
                  appearanceDict.set("Resources", resources);
                  const bbox = this.data.rect = [minX, minY, maxX, maxY];
                  appearanceDict.set("BBox", bbox);
                  this.appearance = new _stream.StringStream("/GS0 gs /Fm0 Do");
                  this.appearance.dict = appearanceDict;
                  this._streams.push(this.appearance, appearanceStream);
                }
                static async createNewAnnotation(xref, annotation, dependencies, params) {
                  const annotationRef = xref.getNewRef();
                  const apRef = xref.getNewRef();
                  const annotationDict = this.createNewDict(annotation, xref, {
                    apRef
                  });
                  const ap = await this.createNewAppearanceStream(annotation, xref, params);
                  const buffer = [];
                  let transform = xref.encrypt ? xref.encrypt.createCipherTransform(apRef.num, apRef.gen) : null;
                  (0, _writer.writeObject)(apRef, ap, buffer, transform);
                  dependencies.push({
                    ref: apRef,
                    data: buffer.join("")
                  });
                  buffer.length = 0;
                  transform = xref.encrypt ? xref.encrypt.createCipherTransform(annotationRef.num, annotationRef.gen) : null;
                  (0, _writer.writeObject)(annotationRef, annotationDict, buffer, transform);
                  return {
                    ref: annotationRef,
                    data: buffer.join("")
                  };
                }
                static async createNewPrintAnnotation(xref, annotation, params) {
                  const ap = await this.createNewAppearanceStream(annotation, xref, params);
                  const annotationDict = this.createNewDict(annotation, xref, {
                    ap
                  });
                  return new this.prototype.constructor({
                    dict: annotationDict,
                    xref
                  });
                }
              };
              __name(_MarkupAnnotation, "MarkupAnnotation");
              let MarkupAnnotation = _MarkupAnnotation;
              exports2.MarkupAnnotation = MarkupAnnotation;
              const _WidgetAnnotation = class _WidgetAnnotation extends Annotation {
                constructor(params) {
                  super(params);
                  const dict = params.dict;
                  const data = this.data;
                  this.ref = params.ref;
                  data.annotationType = _util.AnnotationType.WIDGET;
                  if (data.fieldName === void 0) {
                    data.fieldName = this._constructFieldName(dict);
                  }
                  if (data.actions === void 0) {
                    data.actions = (0, _core_utils.collectActions)(params.xref, dict, _util.AnnotationActionEventType);
                  }
                  let fieldValue = (0, _core_utils.getInheritableProperty)({
                    dict,
                    key: "V",
                    getArray: true
                  });
                  data.fieldValue = this._decodeFormValue(fieldValue);
                  const defaultFieldValue = (0, _core_utils.getInheritableProperty)({
                    dict,
                    key: "DV",
                    getArray: true
                  });
                  data.defaultFieldValue = this._decodeFormValue(defaultFieldValue);
                  if (fieldValue === void 0 && params.xfaDatasets) {
                    const path = this._title.str;
                    if (path) {
                      this._hasValueFromXFA = true;
                      data.fieldValue = fieldValue = params.xfaDatasets.getValue(path);
                    }
                  }
                  if (fieldValue === void 0 && data.defaultFieldValue !== null) {
                    data.fieldValue = data.defaultFieldValue;
                  }
                  data.alternativeText = (0, _util.stringToPDFString)(dict.get("TU") || "");
                  const defaultAppearance = (0, _core_utils.getInheritableProperty)({
                    dict,
                    key: "DA"
                  }) || params.acroForm.get("DA");
                  this._defaultAppearance = typeof defaultAppearance === "string" ? defaultAppearance : "";
                  data.defaultAppearanceData = (0, _default_appearance.parseDefaultAppearance)(this._defaultAppearance);
                  const fieldType = (0, _core_utils.getInheritableProperty)({
                    dict,
                    key: "FT"
                  });
                  data.fieldType = fieldType instanceof _primitives.Name ? fieldType.name : null;
                  const localResources = (0, _core_utils.getInheritableProperty)({
                    dict,
                    key: "DR"
                  });
                  const acroFormResources = params.acroForm.get("DR");
                  const appearanceResources = this.appearance && this.appearance.dict.get("Resources");
                  this._fieldResources = {
                    localResources,
                    acroFormResources,
                    appearanceResources,
                    mergedResources: _primitives.Dict.merge({
                      xref: params.xref,
                      dictArray: [localResources, appearanceResources, acroFormResources],
                      mergeSubDicts: true
                    })
                  };
                  data.fieldFlags = (0, _core_utils.getInheritableProperty)({
                    dict,
                    key: "Ff"
                  });
                  if (!Number.isInteger(data.fieldFlags) || data.fieldFlags < 0) {
                    data.fieldFlags = 0;
                  }
                  data.readOnly = this.hasFieldFlag(_util.AnnotationFieldFlag.READONLY);
                  data.required = this.hasFieldFlag(_util.AnnotationFieldFlag.REQUIRED);
                  data.hidden = this._hasFlag(data.annotationFlags, _util.AnnotationFlag.HIDDEN);
                }
                _decodeFormValue(formValue) {
                  if (Array.isArray(formValue)) {
                    return formValue.filter((item) => typeof item === "string").map((item) => (0, _util.stringToPDFString)(item));
                  } else if (formValue instanceof _primitives.Name) {
                    return (0, _util.stringToPDFString)(formValue.name);
                  } else if (typeof formValue === "string") {
                    return (0, _util.stringToPDFString)(formValue);
                  }
                  return null;
                }
                hasFieldFlag(flag) {
                  return !!(this.data.fieldFlags & flag);
                }
                static _getRotationMatrix(rotation, width, height) {
                  switch (rotation) {
                    case 90:
                      return [0, 1, -1, 0, width, 0];
                    case 180:
                      return [-1, 0, 0, -1, width, height];
                    case 270:
                      return [0, -1, 1, 0, 0, height];
                    default:
                      throw new Error("Invalid rotation");
                  }
                }
                getRotationMatrix(annotationStorage) {
                  const storageEntry = annotationStorage ? annotationStorage.get(this.data.id) : void 0;
                  let rotation = storageEntry && storageEntry.rotation;
                  if (rotation === void 0) {
                    rotation = this.rotation;
                  }
                  if (rotation === 0) {
                    return _util.IDENTITY_MATRIX;
                  }
                  const width = this.data.rect[2] - this.data.rect[0];
                  const height = this.data.rect[3] - this.data.rect[1];
                  return _WidgetAnnotation._getRotationMatrix(rotation, width, height);
                }
                getBorderAndBackgroundAppearances(annotationStorage) {
                  const storageEntry = annotationStorage ? annotationStorage.get(this.data.id) : void 0;
                  let rotation = storageEntry && storageEntry.rotation;
                  if (rotation === void 0) {
                    rotation = this.rotation;
                  }
                  if (!this.backgroundColor && !this.borderColor) {
                    return "";
                  }
                  const width = this.data.rect[2] - this.data.rect[0];
                  const height = this.data.rect[3] - this.data.rect[1];
                  const rect = rotation === 0 || rotation === 180 ? `0 0 ${width} ${height} re` : `0 0 ${height} ${width} re`;
                  let str = "";
                  if (this.backgroundColor) {
                    str = `${(0, _default_appearance.getPdfColor)(this.backgroundColor, true)} ${rect} f `;
                  }
                  if (this.borderColor) {
                    const borderWidth = this.borderStyle.width || 1;
                    str += `${borderWidth} w ${(0, _default_appearance.getPdfColor)(this.borderColor, false)} ${rect} S `;
                  }
                  return str;
                }
                async getOperatorList(evaluator, task, intent, renderForms, annotationStorage) {
                  if (renderForms && !(this instanceof SignatureWidgetAnnotation)) {
                    return {
                      opList: new _operator_list.OperatorList(),
                      separateForm: true,
                      separateCanvas: false
                    };
                  }
                  if (!this._hasText) {
                    return super.getOperatorList(evaluator, task, intent, renderForms, annotationStorage);
                  }
                  const content = await this._getAppearance(evaluator, task, annotationStorage);
                  if (this.appearance && content === null) {
                    return super.getOperatorList(evaluator, task, intent, renderForms, annotationStorage);
                  }
                  const opList = new _operator_list.OperatorList();
                  if (!this._defaultAppearance || content === null) {
                    return {
                      opList,
                      separateForm: false,
                      separateCanvas: false
                    };
                  }
                  const matrix = [1, 0, 0, 1, 0, 0];
                  const bbox = [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]];
                  const transform = getTransformMatrix(this.data.rect, bbox, matrix);
                  let optionalContent;
                  if (this.oc) {
                    optionalContent = await evaluator.parseMarkedContentProps(this.oc, null);
                  }
                  if (optionalContent !== void 0) {
                    opList.addOp(_util.OPS.beginMarkedContentProps, ["OC", optionalContent]);
                  }
                  opList.addOp(_util.OPS.beginAnnotation, [this.data.id, this.data.rect, transform, this.getRotationMatrix(annotationStorage), false]);
                  const stream = new _stream.StringStream(content);
                  await evaluator.getOperatorList({
                    stream,
                    task,
                    resources: this._fieldResources.mergedResources,
                    operatorList: opList
                  });
                  opList.addOp(_util.OPS.endAnnotation, []);
                  if (optionalContent !== void 0) {
                    opList.addOp(_util.OPS.endMarkedContent, []);
                  }
                  return {
                    opList,
                    separateForm: false,
                    separateCanvas: false
                  };
                }
                _getMKDict(rotation) {
                  const mk = new _primitives.Dict(null);
                  if (rotation) {
                    mk.set("R", rotation);
                  }
                  if (this.borderColor) {
                    mk.set("BC", Array.from(this.borderColor).map((c) => c / 255));
                  }
                  if (this.backgroundColor) {
                    mk.set("BG", Array.from(this.backgroundColor).map((c) => c / 255));
                  }
                  return mk.size > 0 ? mk : null;
                }
                async save(evaluator, task, annotationStorage) {
                  const storageEntry = annotationStorage ? annotationStorage.get(this.data.id) : void 0;
                  let value = storageEntry && storageEntry.value;
                  let rotation = storageEntry && storageEntry.rotation;
                  if (value === this.data.fieldValue || value === void 0) {
                    if (!this._hasValueFromXFA && rotation === void 0) {
                      return null;
                    }
                    value = value || this.data.fieldValue;
                  }
                  if (rotation === void 0 && !this._hasValueFromXFA && Array.isArray(value) && Array.isArray(this.data.fieldValue) && value.length === this.data.fieldValue.length && value.every((x, i) => x === this.data.fieldValue[i])) {
                    return null;
                  }
                  if (rotation === void 0) {
                    rotation = this.rotation;
                  }
                  let appearance = await this._getAppearance(evaluator, task, annotationStorage);
                  if (appearance === null) {
                    return null;
                  }
                  const {
                    xref
                  } = evaluator;
                  const dict = xref.fetchIfRef(this.ref);
                  if (!(dict instanceof _primitives.Dict)) {
                    return null;
                  }
                  const bbox = [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]];
                  const xfa = {
                    path: (0, _util.stringToPDFString)(dict.get("T") || ""),
                    value
                  };
                  const newRef = xref.getNewRef();
                  const AP = new _primitives.Dict(xref);
                  AP.set("N", newRef);
                  const encrypt = xref.encrypt;
                  let originalTransform = null;
                  let newTransform = null;
                  if (encrypt) {
                    originalTransform = encrypt.createCipherTransform(this.ref.num, this.ref.gen);
                    newTransform = encrypt.createCipherTransform(newRef.num, newRef.gen);
                    appearance = newTransform.encryptString(appearance);
                  }
                  const encoder = /* @__PURE__ */ __name((val) => (0, _util.isAscii)(val) ? val : (0, _util.stringToUTF16BEString)(val), "encoder");
                  dict.set("V", Array.isArray(value) ? value.map(encoder) : encoder(value));
                  dict.set("AP", AP);
                  dict.set("M", `D:${(0, _util.getModificationDate)()}`);
                  const maybeMK = this._getMKDict(rotation);
                  if (maybeMK) {
                    dict.set("MK", maybeMK);
                  }
                  const appearanceDict = new _primitives.Dict(xref);
                  appearanceDict.set("Length", appearance.length);
                  appearanceDict.set("Subtype", _primitives.Name.get("Form"));
                  appearanceDict.set("Resources", this._getSaveFieldResources(xref));
                  appearanceDict.set("BBox", bbox);
                  const rotationMatrix = this.getRotationMatrix(annotationStorage);
                  if (rotationMatrix !== _util.IDENTITY_MATRIX) {
                    appearanceDict.set("Matrix", rotationMatrix);
                  }
                  const bufferOriginal = [`${this.ref.num} ${this.ref.gen} obj
`];
                  (0, _writer.writeDict)(dict, bufferOriginal, originalTransform);
                  bufferOriginal.push("\nendobj\n");
                  const bufferNew = [`${newRef.num} ${newRef.gen} obj
`];
                  (0, _writer.writeDict)(appearanceDict, bufferNew, newTransform);
                  bufferNew.push(" stream\n", appearance, "\nendstream\nendobj\n");
                  return [{
                    ref: this.ref,
                    data: bufferOriginal.join(""),
                    xfa
                  }, {
                    ref: newRef,
                    data: bufferNew.join(""),
                    xfa: null
                  }];
                }
                async _getAppearance(evaluator, task, annotationStorage) {
                  const isPassword = this.hasFieldFlag(_util.AnnotationFieldFlag.PASSWORD);
                  if (isPassword) {
                    return null;
                  }
                  const storageEntry = annotationStorage ? annotationStorage.get(this.data.id) : void 0;
                  let value, rotation;
                  if (storageEntry) {
                    value = storageEntry.formattedValue || storageEntry.value;
                    rotation = storageEntry.rotation;
                  }
                  if (rotation === void 0 && value === void 0) {
                    if (!this._hasValueFromXFA || this.appearance) {
                      return null;
                    }
                  }
                  if (value === void 0) {
                    value = this.data.fieldValue;
                    if (!value) {
                      return "";
                    }
                  }
                  if (Array.isArray(value) && value.length === 1) {
                    value = value[0];
                  }
                  (0, _util.assert)(typeof value === "string", "Expected `value` to be a string.");
                  value = value.trim();
                  if (value === "") {
                    return "";
                  }
                  if (rotation === void 0) {
                    rotation = this.rotation;
                  }
                  let lineCount = -1;
                  if (this.data.multiLine) {
                    lineCount = value.split(/\r\n|\r|\n/).length;
                  }
                  const defaultPadding = 2;
                  const hPadding = defaultPadding;
                  let totalHeight = this.data.rect[3] - this.data.rect[1];
                  let totalWidth = this.data.rect[2] - this.data.rect[0];
                  if (rotation === 90 || rotation === 270) {
                    [totalWidth, totalHeight] = [totalHeight, totalWidth];
                  }
                  if (!this._defaultAppearance) {
                    this.data.defaultAppearanceData = (0, _default_appearance.parseDefaultAppearance)(this._defaultAppearance = "/Helvetica 0 Tf 0 g");
                  }
                  const font = await _WidgetAnnotation._getFontData(evaluator, task, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
                  const [defaultAppearance, fontSize] = this._computeFontSize(totalHeight - defaultPadding, totalWidth - 2 * hPadding, value, font, lineCount);
                  let descent = font.descent;
                  if (isNaN(descent)) {
                    descent = 0;
                  }
                  const defaultVPadding = Math.min(Math.floor((totalHeight - fontSize) / 2), defaultPadding);
                  const vPadding = defaultVPadding + Math.abs(descent) * fontSize;
                  const alignment = this.data.textAlignment;
                  if (this.data.multiLine) {
                    return this._getMultilineAppearance(defaultAppearance, value, font, fontSize, totalWidth, totalHeight, alignment, hPadding, vPadding, annotationStorage);
                  }
                  const encodedString = font.encodeString(value).join("");
                  if (this.data.comb) {
                    return this._getCombAppearance(defaultAppearance, font, encodedString, totalWidth, hPadding, vPadding, annotationStorage);
                  }
                  const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
                  if (alignment === 0 || alignment > 2) {
                    return `/Tx BMC q ${colors}BT ` + defaultAppearance + ` 1 0 0 1 ${hPadding} ${vPadding} Tm (${(0, _util.escapeString)(encodedString)}) Tj ET Q EMC`;
                  }
                  const renderedText = this._renderText(encodedString, font, fontSize, totalWidth, alignment, hPadding, vPadding);
                  return `/Tx BMC q ${colors}BT ` + defaultAppearance + ` 1 0 0 1 0 0 Tm ${renderedText} ET Q EMC`;
                }
                static async _getFontData(evaluator, task, appearanceData, resources) {
                  const operatorList = new _operator_list.OperatorList();
                  const initialState = {
                    font: null,
                    clone() {
                      return this;
                    }
                  };
                  const {
                    fontName,
                    fontSize
                  } = appearanceData;
                  await evaluator.handleSetFont(resources, [fontName && _primitives.Name.get(fontName), fontSize], null, operatorList, task, initialState, null);
                  return initialState.font;
                }
                _getTextWidth(text, font) {
                  return font.charsToGlyphs(text).reduce((width, glyph) => width + glyph.width, 0) / 1e3;
                }
                _computeFontSize(height, width, text, font, lineCount) {
                  let {
                    fontSize
                  } = this.data.defaultAppearanceData;
                  if (!fontSize) {
                    const roundWithTwoDigits = /* @__PURE__ */ __name((x) => Math.floor(x * 100) / 100, "roundWithTwoDigits");
                    if (lineCount === -1) {
                      const textWidth = this._getTextWidth(text, font);
                      fontSize = roundWithTwoDigits(Math.min(height / _util.LINE_FACTOR, width / textWidth));
                    } else {
                      const lines = text.split(/\r\n?|\n/);
                      const cachedLines = [];
                      for (const line of lines) {
                        const encoded = font.encodeString(line).join("");
                        const glyphs = font.charsToGlyphs(encoded);
                        const positions = font.getCharPositions(encoded);
                        cachedLines.push({
                          line: encoded,
                          glyphs,
                          positions
                        });
                      }
                      const isTooBig = /* @__PURE__ */ __name((fsize) => {
                        let totalHeight = 0;
                        for (const cache of cachedLines) {
                          const chunks = this._splitLine(null, font, fsize, width, cache);
                          totalHeight += chunks.length * fsize;
                          if (totalHeight > height) {
                            return true;
                          }
                        }
                        return false;
                      }, "isTooBig");
                      fontSize = 12;
                      let lineHeight = fontSize * _util.LINE_FACTOR;
                      let numberOfLines = Math.round(height / lineHeight);
                      numberOfLines = Math.max(numberOfLines, lineCount);
                      while (true) {
                        lineHeight = height / numberOfLines;
                        fontSize = roundWithTwoDigits(lineHeight / _util.LINE_FACTOR);
                        if (isTooBig(fontSize)) {
                          numberOfLines++;
                          continue;
                        }
                        break;
                      }
                    }
                    const {
                      fontName,
                      fontColor
                    } = this.data.defaultAppearanceData;
                    this._defaultAppearance = (0, _default_appearance.createDefaultAppearance)({
                      fontSize,
                      fontName,
                      fontColor
                    });
                  }
                  return [this._defaultAppearance, fontSize];
                }
                _renderText(text, font, fontSize, totalWidth, alignment, hPadding, vPadding) {
                  let shift;
                  if (alignment === 1) {
                    const width = this._getTextWidth(text, font) * fontSize;
                    shift = (totalWidth - width) / 2;
                  } else if (alignment === 2) {
                    const width = this._getTextWidth(text, font) * fontSize;
                    shift = totalWidth - width - hPadding;
                  } else {
                    shift = hPadding;
                  }
                  shift = (0, _core_utils.numberToString)(shift);
                  vPadding = (0, _core_utils.numberToString)(vPadding);
                  return `${shift} ${vPadding} Td (${(0, _util.escapeString)(text)}) Tj`;
                }
                _getSaveFieldResources(xref) {
                  const {
                    localResources,
                    appearanceResources,
                    acroFormResources
                  } = this._fieldResources;
                  const fontName = this.data.defaultAppearanceData && this.data.defaultAppearanceData.fontName;
                  if (!fontName) {
                    return localResources || _primitives.Dict.empty;
                  }
                  for (const resources of [localResources, appearanceResources]) {
                    if (resources instanceof _primitives.Dict) {
                      const localFont = resources.get("Font");
                      if (localFont instanceof _primitives.Dict && localFont.has(fontName)) {
                        return resources;
                      }
                    }
                  }
                  if (acroFormResources instanceof _primitives.Dict) {
                    const acroFormFont = acroFormResources.get("Font");
                    if (acroFormFont instanceof _primitives.Dict && acroFormFont.has(fontName)) {
                      const subFontDict = new _primitives.Dict(xref);
                      subFontDict.set(fontName, acroFormFont.getRaw(fontName));
                      const subResourcesDict = new _primitives.Dict(xref);
                      subResourcesDict.set("Font", subFontDict);
                      return _primitives.Dict.merge({
                        xref,
                        dictArray: [subResourcesDict, localResources],
                        mergeSubDicts: true
                      });
                    }
                  }
                  return localResources || _primitives.Dict.empty;
                }
                getFieldObject() {
                  return null;
                }
              };
              __name(_WidgetAnnotation, "WidgetAnnotation");
              let WidgetAnnotation = _WidgetAnnotation;
              const _TextWidgetAnnotation = class _TextWidgetAnnotation extends WidgetAnnotation {
                constructor(params) {
                  super(params);
                  this._hasText = true;
                  const dict = params.dict;
                  if (typeof this.data.fieldValue !== "string") {
                    this.data.fieldValue = "";
                  }
                  let alignment = (0, _core_utils.getInheritableProperty)({
                    dict,
                    key: "Q"
                  });
                  if (!Number.isInteger(alignment) || alignment < 0 || alignment > 2) {
                    alignment = null;
                  }
                  this.data.textAlignment = alignment;
                  let maximumLength = (0, _core_utils.getInheritableProperty)({
                    dict,
                    key: "MaxLen"
                  });
                  if (!Number.isInteger(maximumLength) || maximumLength < 0) {
                    maximumLength = 0;
                  }
                  this.data.maxLen = maximumLength;
                  this.data.multiLine = this.hasFieldFlag(_util.AnnotationFieldFlag.MULTILINE);
                  this.data.comb = this.hasFieldFlag(_util.AnnotationFieldFlag.COMB) && !this.hasFieldFlag(_util.AnnotationFieldFlag.MULTILINE) && !this.hasFieldFlag(_util.AnnotationFieldFlag.PASSWORD) && !this.hasFieldFlag(_util.AnnotationFieldFlag.FILESELECT) && this.data.maxLen !== 0;
                  this.data.doNotScroll = this.hasFieldFlag(_util.AnnotationFieldFlag.DONOTSCROLL);
                }
                _getCombAppearance(defaultAppearance, font, text, width, hPadding, vPadding, annotationStorage) {
                  const combWidth = (0, _core_utils.numberToString)(width / this.data.maxLen);
                  const buf = [];
                  const positions = font.getCharPositions(text);
                  for (const [start, end] of positions) {
                    buf.push(`(${(0, _util.escapeString)(text.substring(start, end))}) Tj`);
                  }
                  const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
                  const renderedComb = buf.join(` ${combWidth} 0 Td `);
                  return `/Tx BMC q ${colors}BT ` + defaultAppearance + ` 1 0 0 1 ${hPadding} ${vPadding} Tm ${renderedComb} ET Q EMC`;
                }
                _getMultilineAppearance(defaultAppearance, text, font, fontSize, width, height, alignment, hPadding, vPadding, annotationStorage) {
                  const lines = text.split(/\r\n?|\n/);
                  const buf = [];
                  const totalWidth = width - 2 * hPadding;
                  for (const line of lines) {
                    const chunks = this._splitLine(line, font, fontSize, totalWidth);
                    for (const chunk of chunks) {
                      const padding = buf.length === 0 ? hPadding : 0;
                      buf.push(this._renderText(chunk, font, fontSize, width, alignment, padding, -fontSize));
                    }
                  }
                  const renderedText = buf.join("\n");
                  const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
                  return `/Tx BMC q ${colors}BT ` + defaultAppearance + ` 1 0 0 1 0 ${height} Tm ${renderedText} ET Q EMC`;
                }
                _splitLine(line, font, fontSize, width) {
                  let cache = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
                  line = cache.line || font.encodeString(line).join("");
                  const glyphs = cache.glyphs || font.charsToGlyphs(line);
                  if (glyphs.length <= 1) {
                    return [line];
                  }
                  const positions = cache.positions || font.getCharPositions(line);
                  const scale = fontSize / 1e3;
                  const chunks = [];
                  let lastSpacePosInStringStart = -1, lastSpacePosInStringEnd = -1, lastSpacePos = -1, startChunk = 0, currentWidth = 0;
                  for (let i = 0, ii = glyphs.length; i < ii; i++) {
                    const [start, end] = positions[i];
                    const glyph = glyphs[i];
                    const glyphWidth = glyph.width * scale;
                    if (glyph.unicode === " ") {
                      if (currentWidth + glyphWidth > width) {
                        chunks.push(line.substring(startChunk, start));
                        startChunk = start;
                        currentWidth = glyphWidth;
                        lastSpacePosInStringStart = -1;
                        lastSpacePos = -1;
                      } else {
                        currentWidth += glyphWidth;
                        lastSpacePosInStringStart = start;
                        lastSpacePosInStringEnd = end;
                        lastSpacePos = i;
                      }
                    } else {
                      if (currentWidth + glyphWidth > width) {
                        if (lastSpacePosInStringStart !== -1) {
                          chunks.push(line.substring(startChunk, lastSpacePosInStringEnd));
                          startChunk = lastSpacePosInStringEnd;
                          i = lastSpacePos + 1;
                          lastSpacePosInStringStart = -1;
                          currentWidth = 0;
                        } else {
                          chunks.push(line.substring(startChunk, start));
                          startChunk = start;
                          currentWidth = glyphWidth;
                        }
                      } else {
                        currentWidth += glyphWidth;
                      }
                    }
                  }
                  if (startChunk < line.length) {
                    chunks.push(line.substring(startChunk, line.length));
                  }
                  return chunks;
                }
                getFieldObject() {
                  return {
                    id: this.data.id,
                    value: this.data.fieldValue,
                    defaultValue: this.data.defaultFieldValue || "",
                    multiline: this.data.multiLine,
                    password: this.hasFieldFlag(_util.AnnotationFieldFlag.PASSWORD),
                    charLimit: this.data.maxLen,
                    comb: this.data.comb,
                    editable: !this.data.readOnly,
                    hidden: this.data.hidden,
                    name: this.data.fieldName,
                    rect: this.data.rect,
                    actions: this.data.actions,
                    page: this.data.pageIndex,
                    strokeColor: this.data.borderColor,
                    fillColor: this.data.backgroundColor,
                    rotation: this.rotation,
                    type: "text"
                  };
                }
              };
              __name(_TextWidgetAnnotation, "TextWidgetAnnotation");
              let TextWidgetAnnotation = _TextWidgetAnnotation;
              const _ButtonWidgetAnnotation = class _ButtonWidgetAnnotation extends WidgetAnnotation {
                constructor(params) {
                  super(params);
                  this.checkedAppearance = null;
                  this.uncheckedAppearance = null;
                  this.data.checkBox = !this.hasFieldFlag(_util.AnnotationFieldFlag.RADIO) && !this.hasFieldFlag(_util.AnnotationFieldFlag.PUSHBUTTON);
                  this.data.radioButton = this.hasFieldFlag(_util.AnnotationFieldFlag.RADIO) && !this.hasFieldFlag(_util.AnnotationFieldFlag.PUSHBUTTON);
                  this.data.pushButton = this.hasFieldFlag(_util.AnnotationFieldFlag.PUSHBUTTON);
                  this.data.isTooltipOnly = false;
                  if (this.data.checkBox) {
                    this._processCheckBox(params);
                  } else if (this.data.radioButton) {
                    this._processRadioButton(params);
                  } else if (this.data.pushButton) {
                    this.data.hasOwnCanvas = true;
                    this._processPushButton(params);
                  } else {
                    (0, _util.warn)("Invalid field flags for button widget annotation");
                  }
                }
                async getOperatorList(evaluator, task, intent, renderForms, annotationStorage) {
                  if (this.data.pushButton) {
                    return super.getOperatorList(evaluator, task, intent, false, annotationStorage);
                  }
                  let value = null;
                  let rotation = null;
                  if (annotationStorage) {
                    const storageEntry = annotationStorage.get(this.data.id);
                    value = storageEntry ? storageEntry.value : null;
                    rotation = storageEntry ? storageEntry.rotation : null;
                  }
                  if (value === null && this.appearance) {
                    return super.getOperatorList(evaluator, task, intent, renderForms, annotationStorage);
                  }
                  if (value === null || value === void 0) {
                    if (this.data.checkBox) {
                      value = this.data.fieldValue === this.data.exportValue;
                    } else {
                      value = this.data.fieldValue === this.data.buttonValue;
                    }
                  }
                  const appearance = value ? this.checkedAppearance : this.uncheckedAppearance;
                  if (appearance) {
                    const savedAppearance = this.appearance;
                    const savedMatrix = appearance.dict.getArray("Matrix") || _util.IDENTITY_MATRIX;
                    if (rotation) {
                      appearance.dict.set("Matrix", this.getRotationMatrix(annotationStorage));
                    }
                    this.appearance = appearance;
                    const operatorList = super.getOperatorList(evaluator, task, intent, renderForms, annotationStorage);
                    this.appearance = savedAppearance;
                    appearance.dict.set("Matrix", savedMatrix);
                    return operatorList;
                  }
                  return {
                    opList: new _operator_list.OperatorList(),
                    separateForm: false,
                    separateCanvas: false
                  };
                }
                async save(evaluator, task, annotationStorage) {
                  if (this.data.checkBox) {
                    return this._saveCheckbox(evaluator, task, annotationStorage);
                  }
                  if (this.data.radioButton) {
                    return this._saveRadioButton(evaluator, task, annotationStorage);
                  }
                  return null;
                }
                async _saveCheckbox(evaluator, task, annotationStorage) {
                  if (!annotationStorage) {
                    return null;
                  }
                  const storageEntry = annotationStorage.get(this.data.id);
                  let rotation = storageEntry && storageEntry.rotation;
                  let value = storageEntry && storageEntry.value;
                  if (rotation === void 0) {
                    if (value === void 0) {
                      return null;
                    }
                    const defaultValue = this.data.fieldValue === this.data.exportValue;
                    if (defaultValue === value) {
                      return null;
                    }
                  }
                  const dict = evaluator.xref.fetchIfRef(this.ref);
                  if (!(dict instanceof _primitives.Dict)) {
                    return null;
                  }
                  if (rotation === void 0) {
                    rotation = this.rotation;
                  }
                  if (value === void 0) {
                    value = this.data.fieldValue === this.data.exportValue;
                  }
                  const xfa = {
                    path: (0, _util.stringToPDFString)(dict.get("T") || ""),
                    value: value ? this.data.exportValue : ""
                  };
                  const name = _primitives.Name.get(value ? this.data.exportValue : "Off");
                  dict.set("V", name);
                  dict.set("AS", name);
                  dict.set("M", `D:${(0, _util.getModificationDate)()}`);
                  const maybeMK = this._getMKDict(rotation);
                  if (maybeMK) {
                    dict.set("MK", maybeMK);
                  }
                  const encrypt = evaluator.xref.encrypt;
                  let originalTransform = null;
                  if (encrypt) {
                    originalTransform = encrypt.createCipherTransform(this.ref.num, this.ref.gen);
                  }
                  const buffer = [`${this.ref.num} ${this.ref.gen} obj
`];
                  (0, _writer.writeDict)(dict, buffer, originalTransform);
                  buffer.push("\nendobj\n");
                  return [{
                    ref: this.ref,
                    data: buffer.join(""),
                    xfa
                  }];
                }
                async _saveRadioButton(evaluator, task, annotationStorage) {
                  if (!annotationStorage) {
                    return null;
                  }
                  const storageEntry = annotationStorage.get(this.data.id);
                  let rotation = storageEntry && storageEntry.rotation;
                  let value = storageEntry && storageEntry.value;
                  if (rotation === void 0) {
                    if (value === void 0) {
                      return null;
                    }
                    const defaultValue = this.data.fieldValue === this.data.buttonValue;
                    if (defaultValue === value) {
                      return null;
                    }
                  }
                  const dict = evaluator.xref.fetchIfRef(this.ref);
                  if (!(dict instanceof _primitives.Dict)) {
                    return null;
                  }
                  if (value === void 0) {
                    value = this.data.fieldValue === this.data.buttonValue;
                  }
                  if (rotation === void 0) {
                    rotation = this.rotation;
                  }
                  const xfa = {
                    path: (0, _util.stringToPDFString)(dict.get("T") || ""),
                    value: value ? this.data.buttonValue : ""
                  };
                  const name = _primitives.Name.get(value ? this.data.buttonValue : "Off");
                  let parentBuffer = null;
                  const encrypt = evaluator.xref.encrypt;
                  if (value) {
                    if (this.parent instanceof _primitives.Ref) {
                      const parent = evaluator.xref.fetch(this.parent);
                      let parentTransform = null;
                      if (encrypt) {
                        parentTransform = encrypt.createCipherTransform(this.parent.num, this.parent.gen);
                      }
                      parent.set("V", name);
                      parentBuffer = [`${this.parent.num} ${this.parent.gen} obj
`];
                      (0, _writer.writeDict)(parent, parentBuffer, parentTransform);
                      parentBuffer.push("\nendobj\n");
                    } else if (this.parent instanceof _primitives.Dict) {
                      this.parent.set("V", name);
                    }
                  }
                  dict.set("AS", name);
                  dict.set("M", `D:${(0, _util.getModificationDate)()}`);
                  const maybeMK = this._getMKDict(rotation);
                  if (maybeMK) {
                    dict.set("MK", maybeMK);
                  }
                  let originalTransform = null;
                  if (encrypt) {
                    originalTransform = encrypt.createCipherTransform(this.ref.num, this.ref.gen);
                  }
                  const buffer = [`${this.ref.num} ${this.ref.gen} obj
`];
                  (0, _writer.writeDict)(dict, buffer, originalTransform);
                  buffer.push("\nendobj\n");
                  const newRefs = [{
                    ref: this.ref,
                    data: buffer.join(""),
                    xfa
                  }];
                  if (parentBuffer !== null) {
                    newRefs.push({
                      ref: this.parent,
                      data: parentBuffer.join(""),
                      xfa: null
                    });
                  }
                  return newRefs;
                }
                _getDefaultCheckedAppearance(params, type) {
                  const width = this.data.rect[2] - this.data.rect[0];
                  const height = this.data.rect[3] - this.data.rect[1];
                  const bbox = [0, 0, width, height];
                  const FONT_RATIO = 0.8;
                  const fontSize = Math.min(width, height) * FONT_RATIO;
                  let metrics, char;
                  if (type === "check") {
                    metrics = {
                      width: 0.755 * fontSize,
                      height: 0.705 * fontSize
                    };
                    char = "3";
                  } else if (type === "disc") {
                    metrics = {
                      width: 0.791 * fontSize,
                      height: 0.705 * fontSize
                    };
                    char = "l";
                  } else {
                    (0, _util.unreachable)(`_getDefaultCheckedAppearance - unsupported type: ${type}`);
                  }
                  const xShift = (0, _core_utils.numberToString)((width - metrics.width) / 2);
                  const yShift = (0, _core_utils.numberToString)((height - metrics.height) / 2);
                  const appearance = `q BT /PdfJsZaDb ${fontSize} Tf 0 g ${xShift} ${yShift} Td (${char}) Tj ET Q`;
                  const appearanceStreamDict = new _primitives.Dict(params.xref);
                  appearanceStreamDict.set("FormType", 1);
                  appearanceStreamDict.set("Subtype", _primitives.Name.get("Form"));
                  appearanceStreamDict.set("Type", _primitives.Name.get("XObject"));
                  appearanceStreamDict.set("BBox", bbox);
                  appearanceStreamDict.set("Matrix", [1, 0, 0, 1, 0, 0]);
                  appearanceStreamDict.set("Length", appearance.length);
                  const resources = new _primitives.Dict(params.xref);
                  const font = new _primitives.Dict(params.xref);
                  font.set("PdfJsZaDb", this.fallbackFontDict);
                  resources.set("Font", font);
                  appearanceStreamDict.set("Resources", resources);
                  this.checkedAppearance = new _stream.StringStream(appearance);
                  this.checkedAppearance.dict = appearanceStreamDict;
                  this._streams.push(this.checkedAppearance);
                }
                _processCheckBox(params) {
                  const customAppearance = params.dict.get("AP");
                  if (!(customAppearance instanceof _primitives.Dict)) {
                    return;
                  }
                  const normalAppearance = customAppearance.get("N");
                  if (!(normalAppearance instanceof _primitives.Dict)) {
                    return;
                  }
                  const asValue = this._decodeFormValue(params.dict.get("AS"));
                  if (typeof asValue === "string") {
                    this.data.fieldValue = asValue;
                  }
                  const yes = this.data.fieldValue !== null && this.data.fieldValue !== "Off" ? this.data.fieldValue : "Yes";
                  const exportValues = normalAppearance.getKeys();
                  if (exportValues.length === 0) {
                    exportValues.push("Off", yes);
                  } else if (exportValues.length === 1) {
                    if (exportValues[0] === "Off") {
                      exportValues.push(yes);
                    } else {
                      exportValues.unshift("Off");
                    }
                  } else if (exportValues.includes(yes)) {
                    exportValues.length = 0;
                    exportValues.push("Off", yes);
                  } else {
                    const otherYes = exportValues.find((v) => v !== "Off");
                    exportValues.length = 0;
                    exportValues.push("Off", otherYes);
                  }
                  if (!exportValues.includes(this.data.fieldValue)) {
                    this.data.fieldValue = "Off";
                  }
                  this.data.exportValue = exportValues[1];
                  this.checkedAppearance = normalAppearance.get(this.data.exportValue) || null;
                  this.uncheckedAppearance = normalAppearance.get("Off") || null;
                  if (this.checkedAppearance) {
                    this._streams.push(this.checkedAppearance);
                  } else {
                    this._getDefaultCheckedAppearance(params, "check");
                  }
                  if (this.uncheckedAppearance) {
                    this._streams.push(this.uncheckedAppearance);
                  }
                  this._fallbackFontDict = this.fallbackFontDict;
                }
                _processRadioButton(params) {
                  this.data.fieldValue = this.data.buttonValue = null;
                  const fieldParent = params.dict.get("Parent");
                  if (fieldParent instanceof _primitives.Dict) {
                    this.parent = params.dict.getRaw("Parent");
                    const fieldParentValue = fieldParent.get("V");
                    if (fieldParentValue instanceof _primitives.Name) {
                      this.data.fieldValue = this._decodeFormValue(fieldParentValue);
                    }
                  }
                  const appearanceStates = params.dict.get("AP");
                  if (!(appearanceStates instanceof _primitives.Dict)) {
                    return;
                  }
                  const normalAppearance = appearanceStates.get("N");
                  if (!(normalAppearance instanceof _primitives.Dict)) {
                    return;
                  }
                  for (const key of normalAppearance.getKeys()) {
                    if (key !== "Off") {
                      this.data.buttonValue = this._decodeFormValue(key);
                      break;
                    }
                  }
                  this.checkedAppearance = normalAppearance.get(this.data.buttonValue) || null;
                  this.uncheckedAppearance = normalAppearance.get("Off") || null;
                  if (this.checkedAppearance) {
                    this._streams.push(this.checkedAppearance);
                  } else {
                    this._getDefaultCheckedAppearance(params, "disc");
                  }
                  if (this.uncheckedAppearance) {
                    this._streams.push(this.uncheckedAppearance);
                  }
                  this._fallbackFontDict = this.fallbackFontDict;
                }
                _processPushButton(params) {
                  if (!params.dict.has("A") && !params.dict.has("AA") && !this.data.alternativeText) {
                    (0, _util.warn)("Push buttons without action dictionaries are not supported");
                    return;
                  }
                  this.data.isTooltipOnly = !params.dict.has("A") && !params.dict.has("AA");
                  _catalog.Catalog.parseDestDictionary({
                    destDict: params.dict,
                    resultObj: this.data,
                    docBaseUrl: params.pdfManager.docBaseUrl
                  });
                }
                getFieldObject() {
                  let type = "button";
                  let exportValues;
                  if (this.data.checkBox) {
                    type = "checkbox";
                    exportValues = this.data.exportValue;
                  } else if (this.data.radioButton) {
                    type = "radiobutton";
                    exportValues = this.data.buttonValue;
                  }
                  return {
                    id: this.data.id,
                    value: this.data.fieldValue || "Off",
                    defaultValue: this.data.defaultFieldValue,
                    exportValues,
                    editable: !this.data.readOnly,
                    name: this.data.fieldName,
                    rect: this.data.rect,
                    hidden: this.data.hidden,
                    actions: this.data.actions,
                    page: this.data.pageIndex,
                    strokeColor: this.data.borderColor,
                    fillColor: this.data.backgroundColor,
                    rotation: this.rotation,
                    type
                  };
                }
                get fallbackFontDict() {
                  const dict = new _primitives.Dict();
                  dict.set("BaseFont", _primitives.Name.get("ZapfDingbats"));
                  dict.set("Type", _primitives.Name.get("FallbackType"));
                  dict.set("Subtype", _primitives.Name.get("FallbackType"));
                  dict.set("Encoding", _primitives.Name.get("ZapfDingbatsEncoding"));
                  return (0, _util.shadow)(this, "fallbackFontDict", dict);
                }
              };
              __name(_ButtonWidgetAnnotation, "ButtonWidgetAnnotation");
              let ButtonWidgetAnnotation = _ButtonWidgetAnnotation;
              const _ChoiceWidgetAnnotation = class _ChoiceWidgetAnnotation extends WidgetAnnotation {
                constructor(params) {
                  super(params);
                  this.data.options = [];
                  const options = (0, _core_utils.getInheritableProperty)({
                    dict: params.dict,
                    key: "Opt"
                  });
                  if (Array.isArray(options)) {
                    const xref = params.xref;
                    for (let i = 0, ii = options.length; i < ii; i++) {
                      const option = xref.fetchIfRef(options[i]);
                      const isOptionArray = Array.isArray(option);
                      this.data.options[i] = {
                        exportValue: this._decodeFormValue(isOptionArray ? xref.fetchIfRef(option[0]) : option),
                        displayValue: this._decodeFormValue(isOptionArray ? xref.fetchIfRef(option[1]) : option)
                      };
                    }
                  }
                  if (typeof this.data.fieldValue === "string") {
                    this.data.fieldValue = [this.data.fieldValue];
                  } else if (!this.data.fieldValue) {
                    this.data.fieldValue = [];
                  }
                  this.data.combo = this.hasFieldFlag(_util.AnnotationFieldFlag.COMBO);
                  this.data.multiSelect = this.hasFieldFlag(_util.AnnotationFieldFlag.MULTISELECT);
                  this._hasText = true;
                }
                getFieldObject() {
                  const type = this.data.combo ? "combobox" : "listbox";
                  const value = this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
                  return {
                    id: this.data.id,
                    value,
                    defaultValue: this.data.defaultFieldValue,
                    editable: !this.data.readOnly,
                    name: this.data.fieldName,
                    rect: this.data.rect,
                    numItems: this.data.fieldValue.length,
                    multipleSelection: this.data.multiSelect,
                    hidden: this.data.hidden,
                    actions: this.data.actions,
                    items: this.data.options,
                    page: this.data.pageIndex,
                    strokeColor: this.data.borderColor,
                    fillColor: this.data.backgroundColor,
                    rotation: this.rotation,
                    type
                  };
                }
                async _getAppearance(evaluator, task, annotationStorage) {
                  if (this.data.combo) {
                    return super._getAppearance(evaluator, task, annotationStorage);
                  }
                  if (!annotationStorage) {
                    return null;
                  }
                  const storageEntry = annotationStorage.get(this.data.id);
                  if (!storageEntry) {
                    return null;
                  }
                  const rotation = storageEntry.rotation;
                  let exportedValue = storageEntry.value;
                  if (rotation === void 0 && exportedValue === void 0) {
                    return null;
                  }
                  if (exportedValue === void 0) {
                    exportedValue = this.data.fieldValue;
                  } else if (!Array.isArray(exportedValue)) {
                    exportedValue = [exportedValue];
                  }
                  const defaultPadding = 2;
                  const hPadding = defaultPadding;
                  let totalHeight = this.data.rect[3] - this.data.rect[1];
                  let totalWidth = this.data.rect[2] - this.data.rect[0];
                  if (rotation === 90 || rotation === 270) {
                    [totalWidth, totalHeight] = [totalHeight, totalWidth];
                  }
                  const lineCount = this.data.options.length;
                  const valueIndices = [];
                  for (let i = 0; i < lineCount; i++) {
                    const {
                      exportValue
                    } = this.data.options[i];
                    if (exportedValue.includes(exportValue)) {
                      valueIndices.push(i);
                    }
                  }
                  if (!this._defaultAppearance) {
                    this.data.defaultAppearanceData = (0, _default_appearance.parseDefaultAppearance)(this._defaultAppearance = "/Helvetica 0 Tf 0 g");
                  }
                  const font = await WidgetAnnotation._getFontData(evaluator, task, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
                  let defaultAppearance;
                  let {
                    fontSize
                  } = this.data.defaultAppearanceData;
                  if (!fontSize) {
                    const lineHeight2 = (totalHeight - defaultPadding) / lineCount;
                    let lineWidth = -1;
                    let value;
                    for (const {
                      displayValue
                    } of this.data.options) {
                      const width = this._getTextWidth(displayValue, font);
                      if (width > lineWidth) {
                        lineWidth = width;
                        value = displayValue;
                      }
                    }
                    [defaultAppearance, fontSize] = this._computeFontSize(lineHeight2, totalWidth - 2 * hPadding, value, font, -1);
                  } else {
                    defaultAppearance = this._defaultAppearance;
                  }
                  const lineHeight = fontSize * _util.LINE_FACTOR;
                  const vPadding = (lineHeight - fontSize) / 2;
                  const numberOfVisibleLines = Math.floor(totalHeight / lineHeight);
                  let firstIndex;
                  if (valueIndices.length === 1) {
                    const valuePosition = valueIndices[0];
                    const indexInPage = valuePosition % numberOfVisibleLines;
                    firstIndex = valuePosition - indexInPage;
                  } else {
                    firstIndex = valueIndices.length ? valueIndices[0] : 0;
                  }
                  const end = Math.min(firstIndex + numberOfVisibleLines + 1, lineCount);
                  const buf = ["/Tx BMC q", `1 1 ${totalWidth} ${totalHeight} re W n`];
                  if (valueIndices.length) {
                    buf.push("0.600006 0.756866 0.854904 rg");
                    for (const index of valueIndices) {
                      if (firstIndex <= index && index < end) {
                        buf.push(`1 ${totalHeight - (index - firstIndex + 1) * lineHeight} ${totalWidth} ${lineHeight} re f`);
                      }
                    }
                  }
                  buf.push("BT", defaultAppearance, `1 0 0 1 0 ${totalHeight} Tm`);
                  for (let i = firstIndex; i < end; i++) {
                    const {
                      displayValue
                    } = this.data.options[i];
                    const hpadding = i === firstIndex ? hPadding : 0;
                    const vpadding = i === firstIndex ? vPadding : 0;
                    buf.push(this._renderText(displayValue, font, fontSize, totalWidth, 0, hpadding, -lineHeight + vpadding));
                  }
                  buf.push("ET Q EMC");
                  return buf.join("\n");
                }
              };
              __name(_ChoiceWidgetAnnotation, "ChoiceWidgetAnnotation");
              let ChoiceWidgetAnnotation = _ChoiceWidgetAnnotation;
              const _SignatureWidgetAnnotation = class _SignatureWidgetAnnotation extends WidgetAnnotation {
                constructor(params) {
                  super(params);
                  this.data.fieldValue = null;
                }
                getFieldObject() {
                  return {
                    id: this.data.id,
                    value: null,
                    page: this.data.pageIndex,
                    type: "signature"
                  };
                }
              };
              __name(_SignatureWidgetAnnotation, "SignatureWidgetAnnotation");
              let SignatureWidgetAnnotation = _SignatureWidgetAnnotation;
              const _TextAnnotation = class _TextAnnotation extends MarkupAnnotation {
                constructor(parameters) {
                  const DEFAULT_ICON_SIZE = 22;
                  super(parameters);
                  const dict = parameters.dict;
                  this.data.annotationType = _util.AnnotationType.TEXT;
                  if (this.data.hasAppearance) {
                    this.data.name = "NoIcon";
                  } else {
                    this.data.rect[1] = this.data.rect[3] - DEFAULT_ICON_SIZE;
                    this.data.rect[2] = this.data.rect[0] + DEFAULT_ICON_SIZE;
                    this.data.name = dict.has("Name") ? dict.get("Name").name : "Note";
                  }
                  if (dict.has("State")) {
                    this.data.state = dict.get("State") || null;
                    this.data.stateModel = dict.get("StateModel") || null;
                  } else {
                    this.data.state = null;
                    this.data.stateModel = null;
                  }
                }
              };
              __name(_TextAnnotation, "TextAnnotation");
              let TextAnnotation = _TextAnnotation;
              const _LinkAnnotation = class _LinkAnnotation extends Annotation {
                constructor(params) {
                  super(params);
                  this.data.annotationType = _util.AnnotationType.LINK;
                  const quadPoints = getQuadPoints(params.dict, this.rectangle);
                  if (quadPoints) {
                    this.data.quadPoints = quadPoints;
                  }
                  this.data.borderColor = this.data.borderColor || this.data.color;
                  _catalog.Catalog.parseDestDictionary({
                    destDict: params.dict,
                    resultObj: this.data,
                    docBaseUrl: params.pdfManager.docBaseUrl
                  });
                }
              };
              __name(_LinkAnnotation, "LinkAnnotation");
              let LinkAnnotation = _LinkAnnotation;
              const _PopupAnnotation = class _PopupAnnotation extends Annotation {
                constructor(parameters) {
                  super(parameters);
                  this.data.annotationType = _util.AnnotationType.POPUP;
                  let parentItem = parameters.dict.get("Parent");
                  if (!parentItem) {
                    (0, _util.warn)("Popup annotation has a missing or invalid parent annotation.");
                    return;
                  }
                  const parentSubtype = parentItem.get("Subtype");
                  this.data.parentType = parentSubtype instanceof _primitives.Name ? parentSubtype.name : null;
                  const rawParent = parameters.dict.getRaw("Parent");
                  this.data.parentId = rawParent instanceof _primitives.Ref ? rawParent.toString() : null;
                  const parentRect = parentItem.getArray("Rect");
                  if (Array.isArray(parentRect) && parentRect.length === 4) {
                    this.data.parentRect = _util.Util.normalizeRect(parentRect);
                  } else {
                    this.data.parentRect = [0, 0, 0, 0];
                  }
                  const rt = parentItem.get("RT");
                  if ((0, _primitives.isName)(rt, _util.AnnotationReplyType.GROUP)) {
                    parentItem = parentItem.get("IRT");
                  }
                  if (!parentItem.has("M")) {
                    this.data.modificationDate = null;
                  } else {
                    this.setModificationDate(parentItem.get("M"));
                    this.data.modificationDate = this.modificationDate;
                  }
                  if (!parentItem.has("C")) {
                    this.data.color = null;
                  } else {
                    this.setColor(parentItem.getArray("C"));
                    this.data.color = this.color;
                  }
                  if (!this.viewable) {
                    const parentFlags = parentItem.get("F");
                    if (this._isViewable(parentFlags)) {
                      this.setFlags(parentFlags);
                    }
                  }
                  this.setTitle(parentItem.get("T"));
                  this.data.titleObj = this._title;
                  this.setContents(parentItem.get("Contents"));
                  this.data.contentsObj = this._contents;
                  if (parentItem.has("RC")) {
                    this.data.richText = _factory.XFAFactory.getRichTextAsHtml(parentItem.get("RC"));
                  }
                }
              };
              __name(_PopupAnnotation, "PopupAnnotation");
              let PopupAnnotation = _PopupAnnotation;
              exports2.PopupAnnotation = PopupAnnotation;
              const _FreeTextAnnotation = class _FreeTextAnnotation extends MarkupAnnotation {
                constructor(parameters) {
                  super(parameters);
                  this.data.annotationType = _util.AnnotationType.FREETEXT;
                }
                get hasTextContent() {
                  return !!this.appearance;
                }
                static createNewDict(annotation, xref, _ref4) {
                  let {
                    apRef,
                    ap
                  } = _ref4;
                  const {
                    color,
                    fontSize,
                    rect,
                    rotation,
                    user,
                    value
                  } = annotation;
                  const freetext = new _primitives.Dict(xref);
                  freetext.set("Type", _primitives.Name.get("Annot"));
                  freetext.set("Subtype", _primitives.Name.get("FreeText"));
                  freetext.set("CreationDate", `D:${(0, _util.getModificationDate)()}`);
                  freetext.set("Rect", rect);
                  const da = `/Helv ${fontSize} Tf ${(0, _default_appearance.getPdfColor)(color, true)}`;
                  freetext.set("DA", da);
                  freetext.set("Contents", value);
                  freetext.set("F", 4);
                  freetext.set("Border", [0, 0, 0]);
                  freetext.set("Rotate", rotation);
                  if (user) {
                    freetext.set("T", (0, _util.stringToUTF8String)(user));
                  }
                  const n = new _primitives.Dict(xref);
                  freetext.set("AP", n);
                  if (apRef) {
                    n.set("N", apRef);
                  } else {
                    n.set("N", ap);
                  }
                  return freetext;
                }
                static async createNewAppearanceStream(annotation, xref, params) {
                  const {
                    baseFontRef,
                    evaluator,
                    task
                  } = params;
                  const {
                    color,
                    fontSize,
                    rect,
                    rotation,
                    value
                  } = annotation;
                  const resources = new _primitives.Dict(xref);
                  const font = new _primitives.Dict(xref);
                  if (baseFontRef) {
                    font.set("Helv", baseFontRef);
                  } else {
                    const baseFont = new _primitives.Dict(xref);
                    baseFont.set("BaseFont", _primitives.Name.get("Helvetica"));
                    baseFont.set("Type", _primitives.Name.get("Font"));
                    baseFont.set("Subtype", _primitives.Name.get("Type1"));
                    baseFont.set("Encoding", _primitives.Name.get("WinAnsiEncoding"));
                    font.set("Helv", baseFont);
                  }
                  resources.set("Font", font);
                  const helv = await WidgetAnnotation._getFontData(evaluator, task, {
                    fontName: "Helvetica",
                    fontSize
                  }, resources);
                  const [x1, y1, x2, y2] = rect;
                  let w = x2 - x1;
                  let h = y2 - y1;
                  if (rotation % 180 !== 0) {
                    [w, h] = [h, w];
                  }
                  const lines = value.split("\n");
                  const scale = fontSize / 1e3;
                  let totalWidth = -Infinity;
                  const encodedLines = [];
                  for (let line of lines) {
                    line = helv.encodeString(line).join("");
                    encodedLines.push(line);
                    let lineWidth = 0;
                    const glyphs = helv.charsToGlyphs(line);
                    for (const glyph of glyphs) {
                      lineWidth += glyph.width * scale;
                    }
                    totalWidth = Math.max(totalWidth, lineWidth);
                  }
                  let hscale = 1;
                  if (totalWidth > w) {
                    hscale = w / totalWidth;
                  }
                  let vscale = 1;
                  const lineHeight = _util.LINE_FACTOR * fontSize;
                  const lineDescent = _util.LINE_DESCENT_FACTOR * fontSize;
                  const totalHeight = lineHeight * lines.length;
                  if (totalHeight > h) {
                    vscale = h / totalHeight;
                  }
                  const fscale = Math.min(hscale, vscale);
                  const newFontSize = fontSize * fscale;
                  const buffer = ["q", `0 0 ${(0, _core_utils.numberToString)(w)} ${(0, _core_utils.numberToString)(h)} re W n`, `BT`, `1 0 0 1 0 ${(0, _core_utils.numberToString)(h + lineDescent)} Tm 0 Tc ${(0, _default_appearance.getPdfColor)(color, true)}`, `/Helv ${(0, _core_utils.numberToString)(newFontSize)} Tf`];
                  const vShift = (0, _core_utils.numberToString)(lineHeight);
                  for (const line of encodedLines) {
                    buffer.push(`0 -${vShift} Td (${(0, _util.escapeString)(line)}) Tj`);
                  }
                  buffer.push("ET", "Q");
                  const appearance = buffer.join("\n");
                  const appearanceStreamDict = new _primitives.Dict(xref);
                  appearanceStreamDict.set("FormType", 1);
                  appearanceStreamDict.set("Subtype", _primitives.Name.get("Form"));
                  appearanceStreamDict.set("Type", _primitives.Name.get("XObject"));
                  appearanceStreamDict.set("BBox", [0, 0, w, h]);
                  appearanceStreamDict.set("Length", appearance.length);
                  appearanceStreamDict.set("Resources", resources);
                  if (rotation) {
                    const matrix = WidgetAnnotation._getRotationMatrix(rotation, w, h);
                    appearanceStreamDict.set("Matrix", matrix);
                  }
                  const ap = new _stream.StringStream(appearance);
                  ap.dict = appearanceStreamDict;
                  return ap;
                }
              };
              __name(_FreeTextAnnotation, "FreeTextAnnotation");
              let FreeTextAnnotation = _FreeTextAnnotation;
              const _LineAnnotation = class _LineAnnotation extends MarkupAnnotation {
                constructor(parameters) {
                  super(parameters);
                  const {
                    dict
                  } = parameters;
                  this.data.annotationType = _util.AnnotationType.LINE;
                  const lineCoordinates = dict.getArray("L");
                  this.data.lineCoordinates = _util.Util.normalizeRect(lineCoordinates);
                  this.setLineEndings(dict.getArray("LE"));
                  this.data.lineEndings = this.lineEndings;
                  if (!this.appearance) {
                    const strokeColor = this.color ? Array.from(this.color).map((c) => c / 255) : [0, 0, 0];
                    const strokeAlpha = dict.get("CA");
                    let fillColor = null, interiorColor = dict.getArray("IC");
                    if (interiorColor) {
                      interiorColor = getRgbColor(interiorColor, null);
                      fillColor = interiorColor ? Array.from(interiorColor).map((c) => c / 255) : null;
                    }
                    const fillAlpha = fillColor ? strokeAlpha : null;
                    const borderWidth = this.borderStyle.width || 1, borderAdjust = 2 * borderWidth;
                    const bbox = [this.data.lineCoordinates[0] - borderAdjust, this.data.lineCoordinates[1] - borderAdjust, this.data.lineCoordinates[2] + borderAdjust, this.data.lineCoordinates[3] + borderAdjust];
                    if (!_util.Util.intersect(this.rectangle, bbox)) {
                      this.rectangle = bbox;
                    }
                    this._setDefaultAppearance({
                      xref: parameters.xref,
                      extra: `${borderWidth} w`,
                      strokeColor,
                      fillColor,
                      strokeAlpha,
                      fillAlpha,
                      pointsCallback: (buffer, points) => {
                        buffer.push(`${lineCoordinates[0]} ${lineCoordinates[1]} m`, `${lineCoordinates[2]} ${lineCoordinates[3]} l`, "S");
                        return [points[0].x - borderWidth, points[1].x + borderWidth, points[3].y - borderWidth, points[1].y + borderWidth];
                      }
                    });
                  }
                }
              };
              __name(_LineAnnotation, "LineAnnotation");
              let LineAnnotation = _LineAnnotation;
              const _SquareAnnotation = class _SquareAnnotation extends MarkupAnnotation {
                constructor(parameters) {
                  super(parameters);
                  this.data.annotationType = _util.AnnotationType.SQUARE;
                  if (!this.appearance) {
                    const strokeColor = this.color ? Array.from(this.color).map((c) => c / 255) : [0, 0, 0];
                    const strokeAlpha = parameters.dict.get("CA");
                    let fillColor = null, interiorColor = parameters.dict.getArray("IC");
                    if (interiorColor) {
                      interiorColor = getRgbColor(interiorColor, null);
                      fillColor = interiorColor ? Array.from(interiorColor).map((c) => c / 255) : null;
                    }
                    const fillAlpha = fillColor ? strokeAlpha : null;
                    if (this.borderStyle.width === 0 && !fillColor) {
                      return;
                    }
                    this._setDefaultAppearance({
                      xref: parameters.xref,
                      extra: `${this.borderStyle.width} w`,
                      strokeColor,
                      fillColor,
                      strokeAlpha,
                      fillAlpha,
                      pointsCallback: (buffer, points) => {
                        const x = points[2].x + this.borderStyle.width / 2;
                        const y = points[2].y + this.borderStyle.width / 2;
                        const width = points[3].x - points[2].x - this.borderStyle.width;
                        const height = points[1].y - points[3].y - this.borderStyle.width;
                        buffer.push(`${x} ${y} ${width} ${height} re`);
                        if (fillColor) {
                          buffer.push("B");
                        } else {
                          buffer.push("S");
                        }
                        return [points[0].x, points[1].x, points[3].y, points[1].y];
                      }
                    });
                  }
                }
              };
              __name(_SquareAnnotation, "SquareAnnotation");
              let SquareAnnotation = _SquareAnnotation;
              const _CircleAnnotation = class _CircleAnnotation extends MarkupAnnotation {
                constructor(parameters) {
                  super(parameters);
                  this.data.annotationType = _util.AnnotationType.CIRCLE;
                  if (!this.appearance) {
                    const strokeColor = this.color ? Array.from(this.color).map((c) => c / 255) : [0, 0, 0];
                    const strokeAlpha = parameters.dict.get("CA");
                    let fillColor = null;
                    let interiorColor = parameters.dict.getArray("IC");
                    if (interiorColor) {
                      interiorColor = getRgbColor(interiorColor, null);
                      fillColor = interiorColor ? Array.from(interiorColor).map((c) => c / 255) : null;
                    }
                    const fillAlpha = fillColor ? strokeAlpha : null;
                    if (this.borderStyle.width === 0 && !fillColor) {
                      return;
                    }
                    const controlPointsDistance = 4 / 3 * Math.tan(Math.PI / (2 * 4));
                    this._setDefaultAppearance({
                      xref: parameters.xref,
                      extra: `${this.borderStyle.width} w`,
                      strokeColor,
                      fillColor,
                      strokeAlpha,
                      fillAlpha,
                      pointsCallback: (buffer, points) => {
                        const x0 = points[0].x + this.borderStyle.width / 2;
                        const y0 = points[0].y - this.borderStyle.width / 2;
                        const x1 = points[3].x - this.borderStyle.width / 2;
                        const y1 = points[3].y + this.borderStyle.width / 2;
                        const xMid = x0 + (x1 - x0) / 2;
                        const yMid = y0 + (y1 - y0) / 2;
                        const xOffset = (x1 - x0) / 2 * controlPointsDistance;
                        const yOffset = (y1 - y0) / 2 * controlPointsDistance;
                        buffer.push(`${xMid} ${y1} m`, `${xMid + xOffset} ${y1} ${x1} ${yMid + yOffset} ${x1} ${yMid} c`, `${x1} ${yMid - yOffset} ${xMid + xOffset} ${y0} ${xMid} ${y0} c`, `${xMid - xOffset} ${y0} ${x0} ${yMid - yOffset} ${x0} ${yMid} c`, `${x0} ${yMid + yOffset} ${xMid - xOffset} ${y1} ${xMid} ${y1} c`, "h");
                        if (fillColor) {
                          buffer.push("B");
                        } else {
                          buffer.push("S");
                        }
                        return [points[0].x, points[1].x, points[3].y, points[1].y];
                      }
                    });
                  }
                }
              };
              __name(_CircleAnnotation, "CircleAnnotation");
              let CircleAnnotation = _CircleAnnotation;
              const _PolylineAnnotation = class _PolylineAnnotation extends MarkupAnnotation {
                constructor(parameters) {
                  super(parameters);
                  const {
                    dict
                  } = parameters;
                  this.data.annotationType = _util.AnnotationType.POLYLINE;
                  this.data.vertices = [];
                  if (!(this instanceof PolygonAnnotation)) {
                    this.setLineEndings(dict.getArray("LE"));
                    this.data.lineEndings = this.lineEndings;
                  }
                  const rawVertices = dict.getArray("Vertices");
                  if (!Array.isArray(rawVertices)) {
                    return;
                  }
                  for (let i = 0, ii = rawVertices.length; i < ii; i += 2) {
                    this.data.vertices.push({
                      x: rawVertices[i],
                      y: rawVertices[i + 1]
                    });
                  }
                  if (!this.appearance) {
                    const strokeColor = this.color ? Array.from(this.color).map((c) => c / 255) : [0, 0, 0];
                    const strokeAlpha = dict.get("CA");
                    const borderWidth = this.borderStyle.width || 1, borderAdjust = 2 * borderWidth;
                    const bbox = [Infinity, Infinity, -Infinity, -Infinity];
                    for (const vertex of this.data.vertices) {
                      bbox[0] = Math.min(bbox[0], vertex.x - borderAdjust);
                      bbox[1] = Math.min(bbox[1], vertex.y - borderAdjust);
                      bbox[2] = Math.max(bbox[2], vertex.x + borderAdjust);
                      bbox[3] = Math.max(bbox[3], vertex.y + borderAdjust);
                    }
                    if (!_util.Util.intersect(this.rectangle, bbox)) {
                      this.rectangle = bbox;
                    }
                    this._setDefaultAppearance({
                      xref: parameters.xref,
                      extra: `${borderWidth} w`,
                      strokeColor,
                      strokeAlpha,
                      pointsCallback: (buffer, points) => {
                        const vertices = this.data.vertices;
                        for (let i = 0, ii = vertices.length; i < ii; i++) {
                          buffer.push(`${vertices[i].x} ${vertices[i].y} ${i === 0 ? "m" : "l"}`);
                        }
                        buffer.push("S");
                        return [points[0].x, points[1].x, points[3].y, points[1].y];
                      }
                    });
                  }
                }
              };
              __name(_PolylineAnnotation, "PolylineAnnotation");
              let PolylineAnnotation = _PolylineAnnotation;
              const _PolygonAnnotation = class _PolygonAnnotation extends PolylineAnnotation {
                constructor(parameters) {
                  super(parameters);
                  this.data.annotationType = _util.AnnotationType.POLYGON;
                }
              };
              __name(_PolygonAnnotation, "PolygonAnnotation");
              let PolygonAnnotation = _PolygonAnnotation;
              const _CaretAnnotation = class _CaretAnnotation extends MarkupAnnotation {
                constructor(parameters) {
                  super(parameters);
                  this.data.annotationType = _util.AnnotationType.CARET;
                }
              };
              __name(_CaretAnnotation, "CaretAnnotation");
              let CaretAnnotation = _CaretAnnotation;
              const _InkAnnotation = class _InkAnnotation extends MarkupAnnotation {
                constructor(parameters) {
                  super(parameters);
                  this.data.annotationType = _util.AnnotationType.INK;
                  this.data.inkLists = [];
                  const rawInkLists = parameters.dict.getArray("InkList");
                  if (!Array.isArray(rawInkLists)) {
                    return;
                  }
                  const xref = parameters.xref;
                  for (let i = 0, ii = rawInkLists.length; i < ii; ++i) {
                    this.data.inkLists.push([]);
                    for (let j = 0, jj = rawInkLists[i].length; j < jj; j += 2) {
                      this.data.inkLists[i].push({
                        x: xref.fetchIfRef(rawInkLists[i][j]),
                        y: xref.fetchIfRef(rawInkLists[i][j + 1])
                      });
                    }
                  }
                  if (!this.appearance) {
                    const strokeColor = this.color ? Array.from(this.color).map((c) => c / 255) : [0, 0, 0];
                    const strokeAlpha = parameters.dict.get("CA");
                    const borderWidth = this.borderStyle.width || 1, borderAdjust = 2 * borderWidth;
                    const bbox = [Infinity, Infinity, -Infinity, -Infinity];
                    for (const inkLists of this.data.inkLists) {
                      for (const vertex of inkLists) {
                        bbox[0] = Math.min(bbox[0], vertex.x - borderAdjust);
                        bbox[1] = Math.min(bbox[1], vertex.y - borderAdjust);
                        bbox[2] = Math.max(bbox[2], vertex.x + borderAdjust);
                        bbox[3] = Math.max(bbox[3], vertex.y + borderAdjust);
                      }
                    }
                    if (!_util.Util.intersect(this.rectangle, bbox)) {
                      this.rectangle = bbox;
                    }
                    this._setDefaultAppearance({
                      xref: parameters.xref,
                      extra: `${borderWidth} w`,
                      strokeColor,
                      strokeAlpha,
                      pointsCallback: (buffer, points) => {
                        for (const inkList of this.data.inkLists) {
                          for (let i = 0, ii = inkList.length; i < ii; i++) {
                            buffer.push(`${inkList[i].x} ${inkList[i].y} ${i === 0 ? "m" : "l"}`);
                          }
                          buffer.push("S");
                        }
                        return [points[0].x, points[1].x, points[3].y, points[1].y];
                      }
                    });
                  }
                }
                static createNewDict(annotation, xref, _ref5) {
                  let {
                    apRef,
                    ap
                  } = _ref5;
                  const {
                    paths,
                    rect,
                    rotation
                  } = annotation;
                  const ink = new _primitives.Dict(xref);
                  ink.set("Type", _primitives.Name.get("Annot"));
                  ink.set("Subtype", _primitives.Name.get("Ink"));
                  ink.set("CreationDate", `D:${(0, _util.getModificationDate)()}`);
                  ink.set("Rect", rect);
                  ink.set("InkList", paths.map((p) => p.points));
                  ink.set("F", 4);
                  ink.set("Border", [0, 0, 0]);
                  ink.set("Rotate", rotation);
                  const n = new _primitives.Dict(xref);
                  ink.set("AP", n);
                  if (apRef) {
                    n.set("N", apRef);
                  } else {
                    n.set("N", ap);
                  }
                  return ink;
                }
                static async createNewAppearanceStream(annotation, xref, params) {
                  const {
                    color,
                    rect,
                    rotation,
                    paths,
                    thickness,
                    opacity
                  } = annotation;
                  const [x1, y1, x2, y2] = rect;
                  let w = x2 - x1;
                  let h = y2 - y1;
                  if (rotation % 180 !== 0) {
                    [w, h] = [h, w];
                  }
                  const appearanceBuffer = [`${thickness} w 1 J 1 j`, `${(0, _default_appearance.getPdfColor)(color, false)}`];
                  if (opacity !== 1) {
                    appearanceBuffer.push("/R0 gs");
                  }
                  const buffer = [];
                  for (const {
                    bezier
                  } of paths) {
                    buffer.length = 0;
                    buffer.push(`${(0, _core_utils.numberToString)(bezier[0])} ${(0, _core_utils.numberToString)(bezier[1])} m`);
                    for (let i = 2, ii = bezier.length; i < ii; i += 6) {
                      const curve = bezier.slice(i, i + 6).map(_core_utils.numberToString).join(" ");
                      buffer.push(`${curve} c`);
                    }
                    buffer.push("S");
                    appearanceBuffer.push(buffer.join("\n"));
                  }
                  const appearance = appearanceBuffer.join("\n");
                  const appearanceStreamDict = new _primitives.Dict(xref);
                  appearanceStreamDict.set("FormType", 1);
                  appearanceStreamDict.set("Subtype", _primitives.Name.get("Form"));
                  appearanceStreamDict.set("Type", _primitives.Name.get("XObject"));
                  appearanceStreamDict.set("BBox", [0, 0, w, h]);
                  appearanceStreamDict.set("Length", appearance.length);
                  if (rotation) {
                    const matrix = WidgetAnnotation._getRotationMatrix(rotation, w, h);
                    appearanceStreamDict.set("Matrix", matrix);
                  }
                  if (opacity !== 1) {
                    const resources = new _primitives.Dict(xref);
                    const extGState = new _primitives.Dict(xref);
                    const r0 = new _primitives.Dict(xref);
                    r0.set("CA", opacity);
                    r0.set("Type", _primitives.Name.get("ExtGState"));
                    extGState.set("R0", r0);
                    resources.set("ExtGState", extGState);
                    appearanceStreamDict.set("Resources", resources);
                  }
                  const ap = new _stream.StringStream(appearance);
                  ap.dict = appearanceStreamDict;
                  return ap;
                }
              };
              __name(_InkAnnotation, "InkAnnotation");
              let InkAnnotation = _InkAnnotation;
              const _HighlightAnnotation = class _HighlightAnnotation extends MarkupAnnotation {
                constructor(parameters) {
                  super(parameters);
                  this.data.annotationType = _util.AnnotationType.HIGHLIGHT;
                  const quadPoints = this.data.quadPoints = getQuadPoints(parameters.dict, null);
                  if (quadPoints) {
                    const resources = this.appearance && this.appearance.dict.get("Resources");
                    if (!this.appearance || !(resources && resources.has("ExtGState"))) {
                      if (this.appearance) {
                        (0, _util.warn)("HighlightAnnotation - ignoring built-in appearance stream.");
                      }
                      const fillColor = this.color ? Array.from(this.color).map((c) => c / 255) : [1, 1, 0];
                      const fillAlpha = parameters.dict.get("CA");
                      this._setDefaultAppearance({
                        xref: parameters.xref,
                        fillColor,
                        blendMode: "Multiply",
                        fillAlpha,
                        pointsCallback: (buffer, points) => {
                          buffer.push(`${points[0].x} ${points[0].y} m`, `${points[1].x} ${points[1].y} l`, `${points[3].x} ${points[3].y} l`, `${points[2].x} ${points[2].y} l`, "f");
                          return [points[0].x, points[1].x, points[3].y, points[1].y];
                        }
                      });
                    }
                  } else {
                    this.data.hasPopup = false;
                  }
                }
              };
              __name(_HighlightAnnotation, "HighlightAnnotation");
              let HighlightAnnotation = _HighlightAnnotation;
              const _UnderlineAnnotation = class _UnderlineAnnotation extends MarkupAnnotation {
                constructor(parameters) {
                  super(parameters);
                  this.data.annotationType = _util.AnnotationType.UNDERLINE;
                  const quadPoints = this.data.quadPoints = getQuadPoints(parameters.dict, null);
                  if (quadPoints) {
                    if (!this.appearance) {
                      const strokeColor = this.color ? Array.from(this.color).map((c) => c / 255) : [0, 0, 0];
                      const strokeAlpha = parameters.dict.get("CA");
                      this._setDefaultAppearance({
                        xref: parameters.xref,
                        extra: "[] 0 d 1 w",
                        strokeColor,
                        strokeAlpha,
                        pointsCallback: (buffer, points) => {
                          buffer.push(`${points[2].x} ${points[2].y} m`, `${points[3].x} ${points[3].y} l`, "S");
                          return [points[0].x, points[1].x, points[3].y, points[1].y];
                        }
                      });
                    }
                  } else {
                    this.data.hasPopup = false;
                  }
                }
              };
              __name(_UnderlineAnnotation, "UnderlineAnnotation");
              let UnderlineAnnotation = _UnderlineAnnotation;
              const _SquigglyAnnotation = class _SquigglyAnnotation extends MarkupAnnotation {
                constructor(parameters) {
                  super(parameters);
                  this.data.annotationType = _util.AnnotationType.SQUIGGLY;
                  const quadPoints = this.data.quadPoints = getQuadPoints(parameters.dict, null);
                  if (quadPoints) {
                    if (!this.appearance) {
                      const strokeColor = this.color ? Array.from(this.color).map((c) => c / 255) : [0, 0, 0];
                      const strokeAlpha = parameters.dict.get("CA");
                      this._setDefaultAppearance({
                        xref: parameters.xref,
                        extra: "[] 0 d 1 w",
                        strokeColor,
                        strokeAlpha,
                        pointsCallback: (buffer, points) => {
                          const dy = (points[0].y - points[2].y) / 6;
                          let shift = dy;
                          let x = points[2].x;
                          const y = points[2].y;
                          const xEnd = points[3].x;
                          buffer.push(`${x} ${y + shift} m`);
                          do {
                            x += 2;
                            shift = shift === 0 ? dy : 0;
                            buffer.push(`${x} ${y + shift} l`);
                          } while (x < xEnd);
                          buffer.push("S");
                          return [points[2].x, xEnd, y - 2 * dy, y + 2 * dy];
                        }
                      });
                    }
                  } else {
                    this.data.hasPopup = false;
                  }
                }
              };
              __name(_SquigglyAnnotation, "SquigglyAnnotation");
              let SquigglyAnnotation = _SquigglyAnnotation;
              const _StrikeOutAnnotation = class _StrikeOutAnnotation extends MarkupAnnotation {
                constructor(parameters) {
                  super(parameters);
                  this.data.annotationType = _util.AnnotationType.STRIKEOUT;
                  const quadPoints = this.data.quadPoints = getQuadPoints(parameters.dict, null);
                  if (quadPoints) {
                    if (!this.appearance) {
                      const strokeColor = this.color ? Array.from(this.color).map((c) => c / 255) : [0, 0, 0];
                      const strokeAlpha = parameters.dict.get("CA");
                      this._setDefaultAppearance({
                        xref: parameters.xref,
                        extra: "[] 0 d 1 w",
                        strokeColor,
                        strokeAlpha,
                        pointsCallback: (buffer, points) => {
                          buffer.push(`${(points[0].x + points[2].x) / 2} ${(points[0].y + points[2].y) / 2} m`, `${(points[1].x + points[3].x) / 2} ${(points[1].y + points[3].y) / 2} l`, "S");
                          return [points[0].x, points[1].x, points[3].y, points[1].y];
                        }
                      });
                    }
                  } else {
                    this.data.hasPopup = false;
                  }
                }
              };
              __name(_StrikeOutAnnotation, "StrikeOutAnnotation");
              let StrikeOutAnnotation = _StrikeOutAnnotation;
              const _StampAnnotation = class _StampAnnotation extends MarkupAnnotation {
                constructor(parameters) {
                  super(parameters);
                  this.data.annotationType = _util.AnnotationType.STAMP;
                }
              };
              __name(_StampAnnotation, "StampAnnotation");
              let StampAnnotation = _StampAnnotation;
              const _FileAttachmentAnnotation = class _FileAttachmentAnnotation extends MarkupAnnotation {
                constructor(parameters) {
                  super(parameters);
                  const file = new _file_spec.FileSpec(parameters.dict.get("FS"), parameters.xref);
                  this.data.annotationType = _util.AnnotationType.FILEATTACHMENT;
                  this.data.file = file.serializable;
                }
              };
              __name(_FileAttachmentAnnotation, "FileAttachmentAnnotation");
              let FileAttachmentAnnotation = _FileAttachmentAnnotation;
            },
            /* 138 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.createDefaultAppearance = createDefaultAppearance;
              exports2.getPdfColor = getPdfColor;
              exports2.parseDefaultAppearance = parseDefaultAppearance;
              var _core_utils = __w_pdfjs_require__2(131);
              var _util = __w_pdfjs_require__2(2);
              var _colorspace = __w_pdfjs_require__2(139);
              var _evaluator = __w_pdfjs_require__2(140);
              var _primitives = __w_pdfjs_require__2(130);
              var _stream = __w_pdfjs_require__2(135);
              const _DefaultAppearanceEvaluator = class _DefaultAppearanceEvaluator extends _evaluator.EvaluatorPreprocessor {
                constructor(str) {
                  super(new _stream.StringStream(str));
                }
                parse() {
                  const operation = {
                    fn: 0,
                    args: []
                  };
                  const result = {
                    fontSize: 0,
                    fontName: "",
                    fontColor: new Uint8ClampedArray(3)
                  };
                  try {
                    while (true) {
                      operation.args.length = 0;
                      if (!this.read(operation)) {
                        break;
                      }
                      if (this.savedStatesDepth !== 0) {
                        continue;
                      }
                      const {
                        fn,
                        args
                      } = operation;
                      switch (fn | 0) {
                        case _util.OPS.setFont:
                          const [fontName, fontSize] = args;
                          if (fontName instanceof _primitives.Name) {
                            result.fontName = fontName.name;
                          }
                          if (typeof fontSize === "number" && fontSize > 0) {
                            result.fontSize = fontSize;
                          }
                          break;
                        case _util.OPS.setFillRGBColor:
                          _colorspace.ColorSpace.singletons.rgb.getRgbItem(args, 0, result.fontColor, 0);
                          break;
                        case _util.OPS.setFillGray:
                          _colorspace.ColorSpace.singletons.gray.getRgbItem(args, 0, result.fontColor, 0);
                          break;
                        case _util.OPS.setFillColorSpace:
                          _colorspace.ColorSpace.singletons.cmyk.getRgbItem(args, 0, result.fontColor, 0);
                          break;
                      }
                    }
                  } catch (reason) {
                    (0, _util.warn)(`parseDefaultAppearance - ignoring errors: "${reason}".`);
                  }
                  return result;
                }
              };
              __name(_DefaultAppearanceEvaluator, "DefaultAppearanceEvaluator");
              let DefaultAppearanceEvaluator = _DefaultAppearanceEvaluator;
              function parseDefaultAppearance(str) {
                return new DefaultAppearanceEvaluator(str).parse();
              }
              __name(parseDefaultAppearance, "parseDefaultAppearance");
              function getPdfColor(color, isFill) {
                if (color[0] === color[1] && color[1] === color[2]) {
                  const gray = color[0] / 255;
                  return `${(0, _core_utils.numberToString)(gray)} ${isFill ? "g" : "G"}`;
                }
                return Array.from(color).map((c) => (0, _core_utils.numberToString)(c / 255)).join(" ") + ` ${isFill ? "rg" : "RG"}`;
              }
              __name(getPdfColor, "getPdfColor");
              function createDefaultAppearance(_ref) {
                let {
                  fontSize,
                  fontName,
                  fontColor
                } = _ref;
                return `/${(0, _core_utils.escapePDFName)(fontName)} ${fontSize} Tf ${getPdfColor(fontColor, true)}`;
              }
              __name(createDefaultAppearance, "createDefaultAppearance");
            },
            /* 139 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.ColorSpace = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _primitives = __w_pdfjs_require__2(130);
              var _base_stream = __w_pdfjs_require__2(132);
              var _core_utils = __w_pdfjs_require__2(131);
              function resizeRgbImage(src, dest, w1, h1, w2, h2, alpha01) {
                const COMPONENTS = 3;
                alpha01 = alpha01 !== 1 ? 0 : alpha01;
                const xRatio = w1 / w2;
                const yRatio = h1 / h2;
                let newIndex = 0, oldIndex;
                const xScaled = new Uint16Array(w2);
                const w1Scanline = w1 * COMPONENTS;
                for (let i = 0; i < w2; i++) {
                  xScaled[i] = Math.floor(i * xRatio) * COMPONENTS;
                }
                for (let i = 0; i < h2; i++) {
                  const py = Math.floor(i * yRatio) * w1Scanline;
                  for (let j = 0; j < w2; j++) {
                    oldIndex = py + xScaled[j];
                    dest[newIndex++] = src[oldIndex++];
                    dest[newIndex++] = src[oldIndex++];
                    dest[newIndex++] = src[oldIndex++];
                    newIndex += alpha01;
                  }
                }
              }
              __name(resizeRgbImage, "resizeRgbImage");
              const _ColorSpace = class _ColorSpace {
                constructor(name, numComps) {
                  if (this.constructor === _ColorSpace) {
                    (0, _util.unreachable)("Cannot initialize ColorSpace.");
                  }
                  this.name = name;
                  this.numComps = numComps;
                }
                getRgb(src, srcOffset) {
                  const rgb = new Uint8ClampedArray(3);
                  this.getRgbItem(src, srcOffset, rgb, 0);
                  return rgb;
                }
                getRgbItem(src, srcOffset, dest, destOffset) {
                  (0, _util.unreachable)("Should not call ColorSpace.getRgbItem");
                }
                getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  (0, _util.unreachable)("Should not call ColorSpace.getRgbBuffer");
                }
                getOutputLength(inputLength, alpha01) {
                  (0, _util.unreachable)("Should not call ColorSpace.getOutputLength");
                }
                isPassthrough(bits) {
                  return false;
                }
                isDefaultDecode(decodeMap, bpc) {
                  return _ColorSpace.isDefaultDecode(decodeMap, this.numComps);
                }
                fillRgb(dest, originalWidth, originalHeight, width, height, actualHeight, bpc, comps, alpha01) {
                  const count = originalWidth * originalHeight;
                  let rgbBuf = null;
                  const numComponentColors = 1 << bpc;
                  const needsResizing = originalHeight !== height || originalWidth !== width;
                  if (this.isPassthrough(bpc)) {
                    rgbBuf = comps;
                  } else if (this.numComps === 1 && count > numComponentColors && this.name !== "DeviceGray" && this.name !== "DeviceRGB") {
                    const allColors = bpc <= 8 ? new Uint8Array(numComponentColors) : new Uint16Array(numComponentColors);
                    for (let i = 0; i < numComponentColors; i++) {
                      allColors[i] = i;
                    }
                    const colorMap = new Uint8ClampedArray(numComponentColors * 3);
                    this.getRgbBuffer(allColors, 0, numComponentColors, colorMap, 0, bpc, 0);
                    if (!needsResizing) {
                      let destPos = 0;
                      for (let i = 0; i < count; ++i) {
                        const key = comps[i] * 3;
                        dest[destPos++] = colorMap[key];
                        dest[destPos++] = colorMap[key + 1];
                        dest[destPos++] = colorMap[key + 2];
                        destPos += alpha01;
                      }
                    } else {
                      rgbBuf = new Uint8Array(count * 3);
                      let rgbPos = 0;
                      for (let i = 0; i < count; ++i) {
                        const key = comps[i] * 3;
                        rgbBuf[rgbPos++] = colorMap[key];
                        rgbBuf[rgbPos++] = colorMap[key + 1];
                        rgbBuf[rgbPos++] = colorMap[key + 2];
                      }
                    }
                  } else {
                    if (!needsResizing) {
                      this.getRgbBuffer(comps, 0, width * actualHeight, dest, 0, bpc, alpha01);
                    } else {
                      rgbBuf = new Uint8ClampedArray(count * 3);
                      this.getRgbBuffer(comps, 0, count, rgbBuf, 0, bpc, 0);
                    }
                  }
                  if (rgbBuf) {
                    if (needsResizing) {
                      resizeRgbImage(rgbBuf, dest, originalWidth, originalHeight, width, height, alpha01);
                    } else {
                      let destPos = 0, rgbPos = 0;
                      for (let i = 0, ii = width * actualHeight; i < ii; i++) {
                        dest[destPos++] = rgbBuf[rgbPos++];
                        dest[destPos++] = rgbBuf[rgbPos++];
                        dest[destPos++] = rgbBuf[rgbPos++];
                        destPos += alpha01;
                      }
                    }
                  }
                }
                get usesZeroToOneRange() {
                  return (0, _util.shadow)(this, "usesZeroToOneRange", true);
                }
                static _cache(cacheKey, xref, localColorSpaceCache, parsedColorSpace) {
                  if (!localColorSpaceCache) {
                    throw new Error('ColorSpace._cache - expected "localColorSpaceCache" argument.');
                  }
                  if (!parsedColorSpace) {
                    throw new Error('ColorSpace._cache - expected "parsedColorSpace" argument.');
                  }
                  let csName, csRef;
                  if (cacheKey instanceof _primitives.Ref) {
                    csRef = cacheKey;
                    cacheKey = xref.fetch(cacheKey);
                  }
                  if (cacheKey instanceof _primitives.Name) {
                    csName = cacheKey.name;
                  }
                  if (csName || csRef) {
                    localColorSpaceCache.set(csName, csRef, parsedColorSpace);
                  }
                }
                static getCached(cacheKey, xref, localColorSpaceCache) {
                  if (!localColorSpaceCache) {
                    throw new Error('ColorSpace.getCached - expected "localColorSpaceCache" argument.');
                  }
                  if (cacheKey instanceof _primitives.Ref) {
                    const localColorSpace = localColorSpaceCache.getByRef(cacheKey);
                    if (localColorSpace) {
                      return localColorSpace;
                    }
                    try {
                      cacheKey = xref.fetch(cacheKey);
                    } catch (ex) {
                      if (ex instanceof _core_utils.MissingDataException) {
                        throw ex;
                      }
                    }
                  }
                  if (cacheKey instanceof _primitives.Name) {
                    const localColorSpace = localColorSpaceCache.getByName(cacheKey.name);
                    if (localColorSpace) {
                      return localColorSpace;
                    }
                  }
                  return null;
                }
                static async parseAsync(_ref) {
                  let {
                    cs,
                    xref,
                    resources = null,
                    pdfFunctionFactory,
                    localColorSpaceCache
                  } = _ref;
                  const parsedColorSpace = this._parse(cs, xref, resources, pdfFunctionFactory);
                  this._cache(cs, xref, localColorSpaceCache, parsedColorSpace);
                  return parsedColorSpace;
                }
                static parse(_ref2) {
                  let {
                    cs,
                    xref,
                    resources = null,
                    pdfFunctionFactory,
                    localColorSpaceCache
                  } = _ref2;
                  const cachedColorSpace = this.getCached(cs, xref, localColorSpaceCache);
                  if (cachedColorSpace) {
                    return cachedColorSpace;
                  }
                  const parsedColorSpace = this._parse(cs, xref, resources, pdfFunctionFactory);
                  this._cache(cs, xref, localColorSpaceCache, parsedColorSpace);
                  return parsedColorSpace;
                }
                static _parse(cs, xref) {
                  let resources = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                  let pdfFunctionFactory = arguments.length > 3 ? arguments[3] : void 0;
                  cs = xref.fetchIfRef(cs);
                  if (cs instanceof _primitives.Name) {
                    switch (cs.name) {
                      case "G":
                      case "DeviceGray":
                        return this.singletons.gray;
                      case "RGB":
                      case "DeviceRGB":
                        return this.singletons.rgb;
                      case "CMYK":
                      case "DeviceCMYK":
                        return this.singletons.cmyk;
                      case "Pattern":
                        return new PatternCS(null);
                      default:
                        if (resources instanceof _primitives.Dict) {
                          const colorSpaces = resources.get("ColorSpace");
                          if (colorSpaces instanceof _primitives.Dict) {
                            const resourcesCS = colorSpaces.get(cs.name);
                            if (resourcesCS) {
                              if (resourcesCS instanceof _primitives.Name) {
                                return this._parse(resourcesCS, xref, resources, pdfFunctionFactory);
                              }
                              cs = resourcesCS;
                              break;
                            }
                          }
                        }
                        throw new _util.FormatError(`Unrecognized ColorSpace: ${cs.name}`);
                    }
                  }
                  if (Array.isArray(cs)) {
                    const mode = xref.fetchIfRef(cs[0]).name;
                    let params, numComps, baseCS, whitePoint, blackPoint, gamma;
                    switch (mode) {
                      case "G":
                      case "DeviceGray":
                        return this.singletons.gray;
                      case "RGB":
                      case "DeviceRGB":
                        return this.singletons.rgb;
                      case "CMYK":
                      case "DeviceCMYK":
                        return this.singletons.cmyk;
                      case "CalGray":
                        params = xref.fetchIfRef(cs[1]);
                        whitePoint = params.getArray("WhitePoint");
                        blackPoint = params.getArray("BlackPoint");
                        gamma = params.get("Gamma");
                        return new CalGrayCS(whitePoint, blackPoint, gamma);
                      case "CalRGB":
                        params = xref.fetchIfRef(cs[1]);
                        whitePoint = params.getArray("WhitePoint");
                        blackPoint = params.getArray("BlackPoint");
                        gamma = params.getArray("Gamma");
                        const matrix = params.getArray("Matrix");
                        return new CalRGBCS(whitePoint, blackPoint, gamma, matrix);
                      case "ICCBased":
                        const stream = xref.fetchIfRef(cs[1]);
                        const dict = stream.dict;
                        numComps = dict.get("N");
                        const alt = dict.get("Alternate");
                        if (alt) {
                          const altCS = this._parse(alt, xref, resources, pdfFunctionFactory);
                          if (altCS.numComps === numComps) {
                            return altCS;
                          }
                          (0, _util.warn)("ICCBased color space: Ignoring incorrect /Alternate entry.");
                        }
                        if (numComps === 1) {
                          return this.singletons.gray;
                        } else if (numComps === 3) {
                          return this.singletons.rgb;
                        } else if (numComps === 4) {
                          return this.singletons.cmyk;
                        }
                        break;
                      case "Pattern":
                        baseCS = cs[1] || null;
                        if (baseCS) {
                          baseCS = this._parse(baseCS, xref, resources, pdfFunctionFactory);
                        }
                        return new PatternCS(baseCS);
                      case "I":
                      case "Indexed":
                        baseCS = this._parse(cs[1], xref, resources, pdfFunctionFactory);
                        const hiVal = xref.fetchIfRef(cs[2]) + 1;
                        const lookup = xref.fetchIfRef(cs[3]);
                        return new IndexedCS(baseCS, hiVal, lookup);
                      case "Separation":
                      case "DeviceN":
                        const name = xref.fetchIfRef(cs[1]);
                        numComps = Array.isArray(name) ? name.length : 1;
                        baseCS = this._parse(cs[2], xref, resources, pdfFunctionFactory);
                        const tintFn = pdfFunctionFactory.create(cs[3]);
                        return new AlternateCS(numComps, baseCS, tintFn);
                      case "Lab":
                        params = xref.fetchIfRef(cs[1]);
                        whitePoint = params.getArray("WhitePoint");
                        blackPoint = params.getArray("BlackPoint");
                        const range = params.getArray("Range");
                        return new LabCS(whitePoint, blackPoint, range);
                      default:
                        throw new _util.FormatError(`Unimplemented ColorSpace object: ${mode}`);
                    }
                  }
                  throw new _util.FormatError(`Unrecognized ColorSpace object: ${cs}`);
                }
                static isDefaultDecode(decode, numComps) {
                  if (!Array.isArray(decode)) {
                    return true;
                  }
                  if (numComps * 2 !== decode.length) {
                    (0, _util.warn)("The decode map is not the correct length");
                    return true;
                  }
                  for (let i = 0, ii = decode.length; i < ii; i += 2) {
                    if (decode[i] !== 0 || decode[i + 1] !== 1) {
                      return false;
                    }
                  }
                  return true;
                }
                static get singletons() {
                  return (0, _util.shadow)(this, "singletons", {
                    get gray() {
                      return (0, _util.shadow)(this, "gray", new DeviceGrayCS());
                    },
                    get rgb() {
                      return (0, _util.shadow)(this, "rgb", new DeviceRgbCS());
                    },
                    get cmyk() {
                      return (0, _util.shadow)(this, "cmyk", new DeviceCmykCS());
                    }
                  });
                }
              };
              __name(_ColorSpace, "ColorSpace");
              let ColorSpace = _ColorSpace;
              exports2.ColorSpace = ColorSpace;
              const _AlternateCS = class _AlternateCS extends ColorSpace {
                constructor(numComps, base, tintFn) {
                  super("Alternate", numComps);
                  this.base = base;
                  this.tintFn = tintFn;
                  this.tmpBuf = new Float32Array(base.numComps);
                }
                getRgbItem(src, srcOffset, dest, destOffset) {
                  const tmpBuf = this.tmpBuf;
                  this.tintFn(src, srcOffset, tmpBuf, 0);
                  this.base.getRgbItem(tmpBuf, 0, dest, destOffset);
                }
                getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  const tintFn = this.tintFn;
                  const base = this.base;
                  const scale = 1 / ((1 << bits) - 1);
                  const baseNumComps = base.numComps;
                  const usesZeroToOneRange = base.usesZeroToOneRange;
                  const isPassthrough = (base.isPassthrough(8) || !usesZeroToOneRange) && alpha01 === 0;
                  let pos = isPassthrough ? destOffset : 0;
                  const baseBuf = isPassthrough ? dest : new Uint8ClampedArray(baseNumComps * count);
                  const numComps = this.numComps;
                  const scaled = new Float32Array(numComps);
                  const tinted = new Float32Array(baseNumComps);
                  let i, j;
                  for (i = 0; i < count; i++) {
                    for (j = 0; j < numComps; j++) {
                      scaled[j] = src[srcOffset++] * scale;
                    }
                    tintFn(scaled, 0, tinted, 0);
                    if (usesZeroToOneRange) {
                      for (j = 0; j < baseNumComps; j++) {
                        baseBuf[pos++] = tinted[j] * 255;
                      }
                    } else {
                      base.getRgbItem(tinted, 0, baseBuf, pos);
                      pos += baseNumComps;
                    }
                  }
                  if (!isPassthrough) {
                    base.getRgbBuffer(baseBuf, 0, count, dest, destOffset, 8, alpha01);
                  }
                }
                getOutputLength(inputLength, alpha01) {
                  return this.base.getOutputLength(inputLength * this.base.numComps / this.numComps, alpha01);
                }
              };
              __name(_AlternateCS, "AlternateCS");
              let AlternateCS = _AlternateCS;
              const _PatternCS = class _PatternCS extends ColorSpace {
                constructor(baseCS) {
                  super("Pattern", null);
                  this.base = baseCS;
                }
                isDefaultDecode(decodeMap, bpc) {
                  (0, _util.unreachable)("Should not call PatternCS.isDefaultDecode");
                }
              };
              __name(_PatternCS, "PatternCS");
              let PatternCS = _PatternCS;
              const _IndexedCS = class _IndexedCS extends ColorSpace {
                constructor(base, highVal, lookup) {
                  super("Indexed", 1);
                  this.base = base;
                  this.highVal = highVal;
                  const length = base.numComps * highVal;
                  this.lookup = new Uint8Array(length);
                  if (lookup instanceof _base_stream.BaseStream) {
                    const bytes = lookup.getBytes(length);
                    this.lookup.set(bytes);
                  } else if (typeof lookup === "string") {
                    for (let i = 0; i < length; ++i) {
                      this.lookup[i] = lookup.charCodeAt(i) & 255;
                    }
                  } else {
                    throw new _util.FormatError(`IndexedCS - unrecognized lookup table: ${lookup}`);
                  }
                }
                getRgbItem(src, srcOffset, dest, destOffset) {
                  const numComps = this.base.numComps;
                  const start = src[srcOffset] * numComps;
                  this.base.getRgbBuffer(this.lookup, start, 1, dest, destOffset, 8, 0);
                }
                getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  const base = this.base;
                  const numComps = base.numComps;
                  const outputDelta = base.getOutputLength(numComps, alpha01);
                  const lookup = this.lookup;
                  for (let i = 0; i < count; ++i) {
                    const lookupPos = src[srcOffset++] * numComps;
                    base.getRgbBuffer(lookup, lookupPos, 1, dest, destOffset, 8, alpha01);
                    destOffset += outputDelta;
                  }
                }
                getOutputLength(inputLength, alpha01) {
                  return this.base.getOutputLength(inputLength * this.base.numComps, alpha01);
                }
                isDefaultDecode(decodeMap, bpc) {
                  if (!Array.isArray(decodeMap)) {
                    return true;
                  }
                  if (decodeMap.length !== 2) {
                    (0, _util.warn)("Decode map length is not correct");
                    return true;
                  }
                  if (!Number.isInteger(bpc) || bpc < 1) {
                    (0, _util.warn)("Bits per component is not correct");
                    return true;
                  }
                  return decodeMap[0] === 0 && decodeMap[1] === (1 << bpc) - 1;
                }
              };
              __name(_IndexedCS, "IndexedCS");
              let IndexedCS = _IndexedCS;
              const _DeviceGrayCS = class _DeviceGrayCS extends ColorSpace {
                constructor() {
                  super("DeviceGray", 1);
                }
                getRgbItem(src, srcOffset, dest, destOffset) {
                  const c = src[srcOffset] * 255;
                  dest[destOffset] = dest[destOffset + 1] = dest[destOffset + 2] = c;
                }
                getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  const scale = 255 / ((1 << bits) - 1);
                  let j = srcOffset, q = destOffset;
                  for (let i = 0; i < count; ++i) {
                    const c = scale * src[j++];
                    dest[q++] = c;
                    dest[q++] = c;
                    dest[q++] = c;
                    q += alpha01;
                  }
                }
                getOutputLength(inputLength, alpha01) {
                  return inputLength * (3 + alpha01);
                }
              };
              __name(_DeviceGrayCS, "DeviceGrayCS");
              let DeviceGrayCS = _DeviceGrayCS;
              const _DeviceRgbCS = class _DeviceRgbCS extends ColorSpace {
                constructor() {
                  super("DeviceRGB", 3);
                }
                getRgbItem(src, srcOffset, dest, destOffset) {
                  dest[destOffset] = src[srcOffset] * 255;
                  dest[destOffset + 1] = src[srcOffset + 1] * 255;
                  dest[destOffset + 2] = src[srcOffset + 2] * 255;
                }
                getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  if (bits === 8 && alpha01 === 0) {
                    dest.set(src.subarray(srcOffset, srcOffset + count * 3), destOffset);
                    return;
                  }
                  const scale = 255 / ((1 << bits) - 1);
                  let j = srcOffset, q = destOffset;
                  for (let i = 0; i < count; ++i) {
                    dest[q++] = scale * src[j++];
                    dest[q++] = scale * src[j++];
                    dest[q++] = scale * src[j++];
                    q += alpha01;
                  }
                }
                getOutputLength(inputLength, alpha01) {
                  return inputLength * (3 + alpha01) / 3 | 0;
                }
                isPassthrough(bits) {
                  return bits === 8;
                }
              };
              __name(_DeviceRgbCS, "DeviceRgbCS");
              let DeviceRgbCS = _DeviceRgbCS;
              const DeviceCmykCS = (/* @__PURE__ */ __name(function DeviceCmykCSClosure() {
                function convertToRgb(src, srcOffset, srcScale, dest, destOffset) {
                  const c = src[srcOffset] * srcScale;
                  const m = src[srcOffset + 1] * srcScale;
                  const y = src[srcOffset + 2] * srcScale;
                  const k = src[srcOffset + 3] * srcScale;
                  dest[destOffset] = 255 + c * (-4.387332384609988 * c + 54.48615194189176 * m + 18.82290502165302 * y + 212.25662451639585 * k + -285.2331026137004) + m * (1.7149763477362134 * m - 5.6096736904047315 * y + -17.873870861415444 * k - 5.497006427196366) + y * (-2.5217340131683033 * y - 21.248923337353073 * k + 17.5119270841813) + k * (-21.86122147463605 * k - 189.48180835922747);
                  dest[destOffset + 1] = 255 + c * (8.841041422036149 * c + 60.118027045597366 * m + 6.871425592049007 * y + 31.159100130055922 * k + -79.2970844816548) + m * (-15.310361306967817 * m + 17.575251261109482 * y + 131.35250912493976 * k - 190.9453302588951) + y * (4.444339102852739 * y + 9.8632861493405 * k - 24.86741582555878) + k * (-20.737325471181034 * k - 187.80453709719578);
                  dest[destOffset + 2] = 255 + c * (0.8842522430003296 * c + 8.078677503112928 * m + 30.89978309703729 * y - 0.23883238689178934 * k + -14.183576799673286) + m * (10.49593273432072 * m + 63.02378494754052 * y + 50.606957656360734 * k - 112.23884253719248) + y * (0.03296041114873217 * y + 115.60384449646641 * k + -193.58209356861505) + k * (-22.33816807309886 * k - 180.12613974708367);
                }
                __name(convertToRgb, "convertToRgb");
                const _DeviceCmykCS = class _DeviceCmykCS extends ColorSpace {
                  constructor() {
                    super("DeviceCMYK", 4);
                  }
                  getRgbItem(src, srcOffset, dest, destOffset) {
                    convertToRgb(src, srcOffset, 1, dest, destOffset);
                  }
                  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                    const scale = 1 / ((1 << bits) - 1);
                    for (let i = 0; i < count; i++) {
                      convertToRgb(src, srcOffset, scale, dest, destOffset);
                      srcOffset += 4;
                      destOffset += 3 + alpha01;
                    }
                  }
                  getOutputLength(inputLength, alpha01) {
                    return inputLength / 4 * (3 + alpha01) | 0;
                  }
                };
                __name(_DeviceCmykCS, "DeviceCmykCS");
                let DeviceCmykCS2 = _DeviceCmykCS;
                return DeviceCmykCS2;
              }, "DeviceCmykCSClosure"))();
              const CalGrayCS = (/* @__PURE__ */ __name(function CalGrayCSClosure() {
                function convertToRgb(cs, src, srcOffset, dest, destOffset, scale) {
                  const A = src[srcOffset] * scale;
                  const AG = A ** cs.G;
                  const L = cs.YW * AG;
                  const val = Math.max(295.8 * L ** 0.3333333333333333 - 40.8, 0);
                  dest[destOffset] = val;
                  dest[destOffset + 1] = val;
                  dest[destOffset + 2] = val;
                }
                __name(convertToRgb, "convertToRgb");
                const _CalGrayCS = class _CalGrayCS extends ColorSpace {
                  constructor(whitePoint, blackPoint, gamma) {
                    super("CalGray", 1);
                    if (!whitePoint) {
                      throw new _util.FormatError("WhitePoint missing - required for color space CalGray");
                    }
                    blackPoint = blackPoint || [0, 0, 0];
                    gamma = gamma || 1;
                    this.XW = whitePoint[0];
                    this.YW = whitePoint[1];
                    this.ZW = whitePoint[2];
                    this.XB = blackPoint[0];
                    this.YB = blackPoint[1];
                    this.ZB = blackPoint[2];
                    this.G = gamma;
                    if (this.XW < 0 || this.ZW < 0 || this.YW !== 1) {
                      throw new _util.FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
                    }
                    if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
                      (0, _util.info)(`Invalid BlackPoint for ${this.name}, falling back to default.`);
                      this.XB = this.YB = this.ZB = 0;
                    }
                    if (this.XB !== 0 || this.YB !== 0 || this.ZB !== 0) {
                      (0, _util.warn)(`${this.name}, BlackPoint: XB: ${this.XB}, YB: ${this.YB}, ZB: ${this.ZB}, only default values are supported.`);
                    }
                    if (this.G < 1) {
                      (0, _util.info)(`Invalid Gamma: ${this.G} for ${this.name}, falling back to default.`);
                      this.G = 1;
                    }
                  }
                  getRgbItem(src, srcOffset, dest, destOffset) {
                    convertToRgb(this, src, srcOffset, dest, destOffset, 1);
                  }
                  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                    const scale = 1 / ((1 << bits) - 1);
                    for (let i = 0; i < count; ++i) {
                      convertToRgb(this, src, srcOffset, dest, destOffset, scale);
                      srcOffset += 1;
                      destOffset += 3 + alpha01;
                    }
                  }
                  getOutputLength(inputLength, alpha01) {
                    return inputLength * (3 + alpha01);
                  }
                };
                __name(_CalGrayCS, "CalGrayCS");
                let CalGrayCS2 = _CalGrayCS;
                return CalGrayCS2;
              }, "CalGrayCSClosure"))();
              const CalRGBCS = (/* @__PURE__ */ __name(function CalRGBCSClosure() {
                const BRADFORD_SCALE_MATRIX = new Float32Array([0.8951, 0.2664, -0.1614, -0.7502, 1.7135, 0.0367, 0.0389, -0.0685, 1.0296]);
                const BRADFORD_SCALE_INVERSE_MATRIX = new Float32Array([0.9869929, -0.1470543, 0.1599627, 0.4323053, 0.5183603, 0.0492912, -85287e-7, 0.0400428, 0.9684867]);
                const SRGB_D65_XYZ_TO_RGB_MATRIX = new Float32Array([3.2404542, -1.5371385, -0.4985314, -0.969266, 1.8760108, 0.041556, 0.0556434, -0.2040259, 1.0572252]);
                const FLAT_WHITEPOINT_MATRIX = new Float32Array([1, 1, 1]);
                const tempNormalizeMatrix = new Float32Array(3);
                const tempConvertMatrix1 = new Float32Array(3);
                const tempConvertMatrix2 = new Float32Array(3);
                const DECODE_L_CONSTANT = ((8 + 16) / 116) ** 3 / 8;
                function matrixProduct(a, b, result) {
                  result[0] = a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
                  result[1] = a[3] * b[0] + a[4] * b[1] + a[5] * b[2];
                  result[2] = a[6] * b[0] + a[7] * b[1] + a[8] * b[2];
                }
                __name(matrixProduct, "matrixProduct");
                function convertToFlat(sourceWhitePoint, LMS, result) {
                  result[0] = LMS[0] * 1 / sourceWhitePoint[0];
                  result[1] = LMS[1] * 1 / sourceWhitePoint[1];
                  result[2] = LMS[2] * 1 / sourceWhitePoint[2];
                }
                __name(convertToFlat, "convertToFlat");
                function convertToD65(sourceWhitePoint, LMS, result) {
                  const D65X = 0.95047;
                  const D65Y = 1;
                  const D65Z = 1.08883;
                  result[0] = LMS[0] * D65X / sourceWhitePoint[0];
                  result[1] = LMS[1] * D65Y / sourceWhitePoint[1];
                  result[2] = LMS[2] * D65Z / sourceWhitePoint[2];
                }
                __name(convertToD65, "convertToD65");
                function sRGBTransferFunction(color) {
                  if (color <= 31308e-7) {
                    return adjustToRange(0, 1, 12.92 * color);
                  }
                  if (color >= 0.99554525) {
                    return 1;
                  }
                  return adjustToRange(0, 1, (1 + 0.055) * color ** (1 / 2.4) - 0.055);
                }
                __name(sRGBTransferFunction, "sRGBTransferFunction");
                function adjustToRange(min, max, value) {
                  return Math.max(min, Math.min(max, value));
                }
                __name(adjustToRange, "adjustToRange");
                function decodeL(L) {
                  if (L < 0) {
                    return -decodeL(-L);
                  }
                  if (L > 8) {
                    return ((L + 16) / 116) ** 3;
                  }
                  return L * DECODE_L_CONSTANT;
                }
                __name(decodeL, "decodeL");
                function compensateBlackPoint(sourceBlackPoint, XYZ_Flat, result) {
                  if (sourceBlackPoint[0] === 0 && sourceBlackPoint[1] === 0 && sourceBlackPoint[2] === 0) {
                    result[0] = XYZ_Flat[0];
                    result[1] = XYZ_Flat[1];
                    result[2] = XYZ_Flat[2];
                    return;
                  }
                  const zeroDecodeL = decodeL(0);
                  const X_DST = zeroDecodeL;
                  const X_SRC = decodeL(sourceBlackPoint[0]);
                  const Y_DST = zeroDecodeL;
                  const Y_SRC = decodeL(sourceBlackPoint[1]);
                  const Z_DST = zeroDecodeL;
                  const Z_SRC = decodeL(sourceBlackPoint[2]);
                  const X_Scale = (1 - X_DST) / (1 - X_SRC);
                  const X_Offset = 1 - X_Scale;
                  const Y_Scale = (1 - Y_DST) / (1 - Y_SRC);
                  const Y_Offset = 1 - Y_Scale;
                  const Z_Scale = (1 - Z_DST) / (1 - Z_SRC);
                  const Z_Offset = 1 - Z_Scale;
                  result[0] = XYZ_Flat[0] * X_Scale + X_Offset;
                  result[1] = XYZ_Flat[1] * Y_Scale + Y_Offset;
                  result[2] = XYZ_Flat[2] * Z_Scale + Z_Offset;
                }
                __name(compensateBlackPoint, "compensateBlackPoint");
                function normalizeWhitePointToFlat(sourceWhitePoint, XYZ_In, result) {
                  if (sourceWhitePoint[0] === 1 && sourceWhitePoint[2] === 1) {
                    result[0] = XYZ_In[0];
                    result[1] = XYZ_In[1];
                    result[2] = XYZ_In[2];
                    return;
                  }
                  const LMS = result;
                  matrixProduct(BRADFORD_SCALE_MATRIX, XYZ_In, LMS);
                  const LMS_Flat = tempNormalizeMatrix;
                  convertToFlat(sourceWhitePoint, LMS, LMS_Flat);
                  matrixProduct(BRADFORD_SCALE_INVERSE_MATRIX, LMS_Flat, result);
                }
                __name(normalizeWhitePointToFlat, "normalizeWhitePointToFlat");
                function normalizeWhitePointToD65(sourceWhitePoint, XYZ_In, result) {
                  const LMS = result;
                  matrixProduct(BRADFORD_SCALE_MATRIX, XYZ_In, LMS);
                  const LMS_D65 = tempNormalizeMatrix;
                  convertToD65(sourceWhitePoint, LMS, LMS_D65);
                  matrixProduct(BRADFORD_SCALE_INVERSE_MATRIX, LMS_D65, result);
                }
                __name(normalizeWhitePointToD65, "normalizeWhitePointToD65");
                function convertToRgb(cs, src, srcOffset, dest, destOffset, scale) {
                  const A = adjustToRange(0, 1, src[srcOffset] * scale);
                  const B = adjustToRange(0, 1, src[srcOffset + 1] * scale);
                  const C = adjustToRange(0, 1, src[srcOffset + 2] * scale);
                  const AGR = A === 1 ? 1 : A ** cs.GR;
                  const BGG = B === 1 ? 1 : B ** cs.GG;
                  const CGB = C === 1 ? 1 : C ** cs.GB;
                  const X = cs.MXA * AGR + cs.MXB * BGG + cs.MXC * CGB;
                  const Y = cs.MYA * AGR + cs.MYB * BGG + cs.MYC * CGB;
                  const Z = cs.MZA * AGR + cs.MZB * BGG + cs.MZC * CGB;
                  const XYZ = tempConvertMatrix1;
                  XYZ[0] = X;
                  XYZ[1] = Y;
                  XYZ[2] = Z;
                  const XYZ_Flat = tempConvertMatrix2;
                  normalizeWhitePointToFlat(cs.whitePoint, XYZ, XYZ_Flat);
                  const XYZ_Black = tempConvertMatrix1;
                  compensateBlackPoint(cs.blackPoint, XYZ_Flat, XYZ_Black);
                  const XYZ_D65 = tempConvertMatrix2;
                  normalizeWhitePointToD65(FLAT_WHITEPOINT_MATRIX, XYZ_Black, XYZ_D65);
                  const SRGB = tempConvertMatrix1;
                  matrixProduct(SRGB_D65_XYZ_TO_RGB_MATRIX, XYZ_D65, SRGB);
                  dest[destOffset] = sRGBTransferFunction(SRGB[0]) * 255;
                  dest[destOffset + 1] = sRGBTransferFunction(SRGB[1]) * 255;
                  dest[destOffset + 2] = sRGBTransferFunction(SRGB[2]) * 255;
                }
                __name(convertToRgb, "convertToRgb");
                const _CalRGBCS = class _CalRGBCS extends ColorSpace {
                  constructor(whitePoint, blackPoint, gamma, matrix) {
                    super("CalRGB", 3);
                    if (!whitePoint) {
                      throw new _util.FormatError("WhitePoint missing - required for color space CalRGB");
                    }
                    blackPoint = blackPoint || new Float32Array(3);
                    gamma = gamma || new Float32Array([1, 1, 1]);
                    matrix = matrix || new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
                    const XW = whitePoint[0];
                    const YW = whitePoint[1];
                    const ZW = whitePoint[2];
                    this.whitePoint = whitePoint;
                    const XB = blackPoint[0];
                    const YB = blackPoint[1];
                    const ZB = blackPoint[2];
                    this.blackPoint = blackPoint;
                    this.GR = gamma[0];
                    this.GG = gamma[1];
                    this.GB = gamma[2];
                    this.MXA = matrix[0];
                    this.MYA = matrix[1];
                    this.MZA = matrix[2];
                    this.MXB = matrix[3];
                    this.MYB = matrix[4];
                    this.MZB = matrix[5];
                    this.MXC = matrix[6];
                    this.MYC = matrix[7];
                    this.MZC = matrix[8];
                    if (XW < 0 || ZW < 0 || YW !== 1) {
                      throw new _util.FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
                    }
                    if (XB < 0 || YB < 0 || ZB < 0) {
                      (0, _util.info)(`Invalid BlackPoint for ${this.name} [${XB}, ${YB}, ${ZB}], falling back to default.`);
                      this.blackPoint = new Float32Array(3);
                    }
                    if (this.GR < 0 || this.GG < 0 || this.GB < 0) {
                      (0, _util.info)(`Invalid Gamma [${this.GR}, ${this.GG}, ${this.GB}] for ${this.name}, falling back to default.`);
                      this.GR = this.GG = this.GB = 1;
                    }
                  }
                  getRgbItem(src, srcOffset, dest, destOffset) {
                    convertToRgb(this, src, srcOffset, dest, destOffset, 1);
                  }
                  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                    const scale = 1 / ((1 << bits) - 1);
                    for (let i = 0; i < count; ++i) {
                      convertToRgb(this, src, srcOffset, dest, destOffset, scale);
                      srcOffset += 3;
                      destOffset += 3 + alpha01;
                    }
                  }
                  getOutputLength(inputLength, alpha01) {
                    return inputLength * (3 + alpha01) / 3 | 0;
                  }
                };
                __name(_CalRGBCS, "CalRGBCS");
                let CalRGBCS2 = _CalRGBCS;
                return CalRGBCS2;
              }, "CalRGBCSClosure"))();
              const LabCS = (/* @__PURE__ */ __name(function LabCSClosure() {
                function fn_g(x) {
                  let result;
                  if (x >= 6 / 29) {
                    result = x ** 3;
                  } else {
                    result = 108 / 841 * (x - 4 / 29);
                  }
                  return result;
                }
                __name(fn_g, "fn_g");
                function decode(value, high1, low2, high2) {
                  return low2 + value * (high2 - low2) / high1;
                }
                __name(decode, "decode");
                function convertToRgb(cs, src, srcOffset, maxVal, dest, destOffset) {
                  let Ls = src[srcOffset];
                  let as = src[srcOffset + 1];
                  let bs = src[srcOffset + 2];
                  if (maxVal !== false) {
                    Ls = decode(Ls, maxVal, 0, 100);
                    as = decode(as, maxVal, cs.amin, cs.amax);
                    bs = decode(bs, maxVal, cs.bmin, cs.bmax);
                  }
                  if (as > cs.amax) {
                    as = cs.amax;
                  } else if (as < cs.amin) {
                    as = cs.amin;
                  }
                  if (bs > cs.bmax) {
                    bs = cs.bmax;
                  } else if (bs < cs.bmin) {
                    bs = cs.bmin;
                  }
                  const M = (Ls + 16) / 116;
                  const L = M + as / 500;
                  const N = M - bs / 200;
                  const X = cs.XW * fn_g(L);
                  const Y = cs.YW * fn_g(M);
                  const Z = cs.ZW * fn_g(N);
                  let r, g, b;
                  if (cs.ZW < 1) {
                    r = X * 3.1339 + Y * -1.617 + Z * -0.4906;
                    g = X * -0.9785 + Y * 1.916 + Z * 0.0333;
                    b = X * 0.072 + Y * -0.229 + Z * 1.4057;
                  } else {
                    r = X * 3.2406 + Y * -1.5372 + Z * -0.4986;
                    g = X * -0.9689 + Y * 1.8758 + Z * 0.0415;
                    b = X * 0.0557 + Y * -0.204 + Z * 1.057;
                  }
                  dest[destOffset] = Math.sqrt(r) * 255;
                  dest[destOffset + 1] = Math.sqrt(g) * 255;
                  dest[destOffset + 2] = Math.sqrt(b) * 255;
                }
                __name(convertToRgb, "convertToRgb");
                const _LabCS = class _LabCS extends ColorSpace {
                  constructor(whitePoint, blackPoint, range) {
                    super("Lab", 3);
                    if (!whitePoint) {
                      throw new _util.FormatError("WhitePoint missing - required for color space Lab");
                    }
                    blackPoint = blackPoint || [0, 0, 0];
                    range = range || [-100, 100, -100, 100];
                    this.XW = whitePoint[0];
                    this.YW = whitePoint[1];
                    this.ZW = whitePoint[2];
                    this.amin = range[0];
                    this.amax = range[1];
                    this.bmin = range[2];
                    this.bmax = range[3];
                    this.XB = blackPoint[0];
                    this.YB = blackPoint[1];
                    this.ZB = blackPoint[2];
                    if (this.XW < 0 || this.ZW < 0 || this.YW !== 1) {
                      throw new _util.FormatError("Invalid WhitePoint components, no fallback available");
                    }
                    if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
                      (0, _util.info)("Invalid BlackPoint, falling back to default");
                      this.XB = this.YB = this.ZB = 0;
                    }
                    if (this.amin > this.amax || this.bmin > this.bmax) {
                      (0, _util.info)("Invalid Range, falling back to defaults");
                      this.amin = -100;
                      this.amax = 100;
                      this.bmin = -100;
                      this.bmax = 100;
                    }
                  }
                  getRgbItem(src, srcOffset, dest, destOffset) {
                    convertToRgb(this, src, srcOffset, false, dest, destOffset);
                  }
                  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                    const maxVal = (1 << bits) - 1;
                    for (let i = 0; i < count; i++) {
                      convertToRgb(this, src, srcOffset, maxVal, dest, destOffset);
                      srcOffset += 3;
                      destOffset += 3 + alpha01;
                    }
                  }
                  getOutputLength(inputLength, alpha01) {
                    return inputLength * (3 + alpha01) / 3 | 0;
                  }
                  isDefaultDecode(decodeMap, bpc) {
                    return true;
                  }
                  get usesZeroToOneRange() {
                    return (0, _util.shadow)(this, "usesZeroToOneRange", false);
                  }
                };
                __name(_LabCS, "LabCS");
                let LabCS2 = _LabCS;
                return LabCS2;
              }, "LabCSClosure"))();
            },
            /* 140 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PartialEvaluator = exports2.EvaluatorPreprocessor = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _cmap = __w_pdfjs_require__2(141);
              var _primitives = __w_pdfjs_require__2(130);
              var _fonts = __w_pdfjs_require__2(159);
              var _fonts_utils = __w_pdfjs_require__2(163);
              var _encodings = __w_pdfjs_require__2(162);
              var _standard_fonts = __w_pdfjs_require__2(166);
              var _unicode = __w_pdfjs_require__2(165);
              var _pattern = __w_pdfjs_require__2(175);
              var _xfa_fonts = __w_pdfjs_require__2(176);
              var _to_unicode_map = __w_pdfjs_require__2(167);
              var _function = __w_pdfjs_require__2(182);
              var _parser = __w_pdfjs_require__2(142);
              var _image_utils = __w_pdfjs_require__2(184);
              var _stream = __w_pdfjs_require__2(135);
              var _base_stream = __w_pdfjs_require__2(132);
              var _bidi = __w_pdfjs_require__2(185);
              var _colorspace = __w_pdfjs_require__2(139);
              var _decode_stream = __w_pdfjs_require__2(144);
              var _glyphlist = __w_pdfjs_require__2(164);
              var _core_utils = __w_pdfjs_require__2(131);
              var _metrics = __w_pdfjs_require__2(170);
              var _murmurhash = __w_pdfjs_require__2(186);
              var _operator_list = __w_pdfjs_require__2(187);
              var _image = __w_pdfjs_require__2(188);
              const DefaultPartialEvaluatorOptions = Object.freeze({
                maxImageSize: -1,
                disableFontFace: false,
                ignoreErrors: false,
                isEvalSupported: true,
                fontExtraProperties: false,
                useSystemFonts: true,
                cMapUrl: null,
                standardFontDataUrl: null
              });
              const PatternType = {
                TILING: 1,
                SHADING: 2
              };
              const TEXT_CHUNK_BATCH_SIZE = 10;
              const deferred = Promise.resolve();
              function normalizeBlendMode(value) {
                let parsingArray = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                if (Array.isArray(value)) {
                  for (let i = 0, ii = value.length; i < ii; i++) {
                    const maybeBM = normalizeBlendMode(value[i], true);
                    if (maybeBM) {
                      return maybeBM;
                    }
                  }
                  (0, _util.warn)(`Unsupported blend mode Array: ${value}`);
                  return "source-over";
                }
                if (!(value instanceof _primitives.Name)) {
                  if (parsingArray) {
                    return null;
                  }
                  return "source-over";
                }
                switch (value.name) {
                  case "Normal":
                  case "Compatible":
                    return "source-over";
                  case "Multiply":
                    return "multiply";
                  case "Screen":
                    return "screen";
                  case "Overlay":
                    return "overlay";
                  case "Darken":
                    return "darken";
                  case "Lighten":
                    return "lighten";
                  case "ColorDodge":
                    return "color-dodge";
                  case "ColorBurn":
                    return "color-burn";
                  case "HardLight":
                    return "hard-light";
                  case "SoftLight":
                    return "soft-light";
                  case "Difference":
                    return "difference";
                  case "Exclusion":
                    return "exclusion";
                  case "Hue":
                    return "hue";
                  case "Saturation":
                    return "saturation";
                  case "Color":
                    return "color";
                  case "Luminosity":
                    return "luminosity";
                }
                if (parsingArray) {
                  return null;
                }
                (0, _util.warn)(`Unsupported blend mode: ${value.name}`);
                return "source-over";
              }
              __name(normalizeBlendMode, "normalizeBlendMode");
              function incrementCachedImageMaskCount(data) {
                if (data.fn === _util.OPS.paintImageMaskXObject && data.args[0] && data.args[0].count > 0) {
                  data.args[0].count++;
                }
              }
              __name(incrementCachedImageMaskCount, "incrementCachedImageMaskCount");
              const _TimeSlotManager = class _TimeSlotManager {
                static get TIME_SLOT_DURATION_MS() {
                  return (0, _util.shadow)(this, "TIME_SLOT_DURATION_MS", 20);
                }
                static get CHECK_TIME_EVERY() {
                  return (0, _util.shadow)(this, "CHECK_TIME_EVERY", 100);
                }
                constructor() {
                  this.reset();
                }
                check() {
                  if (++this.checked < _TimeSlotManager.CHECK_TIME_EVERY) {
                    return false;
                  }
                  this.checked = 0;
                  return this.endTime <= Date.now();
                }
                reset() {
                  this.endTime = Date.now() + _TimeSlotManager.TIME_SLOT_DURATION_MS;
                  this.checked = 0;
                }
              };
              __name(_TimeSlotManager, "TimeSlotManager");
              let TimeSlotManager = _TimeSlotManager;
              const _PartialEvaluator = class _PartialEvaluator {
                constructor(_ref) {
                  let {
                    xref,
                    handler,
                    pageIndex,
                    idFactory,
                    fontCache,
                    builtInCMapCache,
                    standardFontDataCache,
                    globalImageCache,
                    options = null
                  } = _ref;
                  this.xref = xref;
                  this.handler = handler;
                  this.pageIndex = pageIndex;
                  this.idFactory = idFactory;
                  this.fontCache = fontCache;
                  this.builtInCMapCache = builtInCMapCache;
                  this.standardFontDataCache = standardFontDataCache;
                  this.globalImageCache = globalImageCache;
                  this.options = options || DefaultPartialEvaluatorOptions;
                  this.parsingType3Font = false;
                  this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);
                }
                get _pdfFunctionFactory() {
                  const pdfFunctionFactory = new _function.PDFFunctionFactory({
                    xref: this.xref,
                    isEvalSupported: this.options.isEvalSupported
                  });
                  return (0, _util.shadow)(this, "_pdfFunctionFactory", pdfFunctionFactory);
                }
                clone() {
                  let newOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                  const newEvaluator = Object.create(this);
                  newEvaluator.options = Object.assign(/* @__PURE__ */ Object.create(null), this.options, newOptions);
                  return newEvaluator;
                }
                hasBlendModes(resources, nonBlendModesSet) {
                  if (!(resources instanceof _primitives.Dict)) {
                    return false;
                  }
                  if (resources.objId && nonBlendModesSet.has(resources.objId)) {
                    return false;
                  }
                  const processed = new _primitives.RefSet(nonBlendModesSet);
                  if (resources.objId) {
                    processed.put(resources.objId);
                  }
                  const nodes = [resources], xref = this.xref;
                  while (nodes.length) {
                    const node = nodes.shift();
                    const graphicStates = node.get("ExtGState");
                    if (graphicStates instanceof _primitives.Dict) {
                      for (let graphicState of graphicStates.getRawValues()) {
                        if (graphicState instanceof _primitives.Ref) {
                          if (processed.has(graphicState)) {
                            continue;
                          }
                          try {
                            graphicState = xref.fetch(graphicState);
                          } catch (ex) {
                            processed.put(graphicState);
                            (0, _util.info)(`hasBlendModes - ignoring ExtGState: "${ex}".`);
                            continue;
                          }
                        }
                        if (!(graphicState instanceof _primitives.Dict)) {
                          continue;
                        }
                        if (graphicState.objId) {
                          processed.put(graphicState.objId);
                        }
                        const bm = graphicState.get("BM");
                        if (bm instanceof _primitives.Name) {
                          if (bm.name !== "Normal") {
                            return true;
                          }
                          continue;
                        }
                        if (bm !== void 0 && Array.isArray(bm)) {
                          for (const element of bm) {
                            if (element instanceof _primitives.Name && element.name !== "Normal") {
                              return true;
                            }
                          }
                        }
                      }
                    }
                    const xObjects = node.get("XObject");
                    if (!(xObjects instanceof _primitives.Dict)) {
                      continue;
                    }
                    for (let xObject of xObjects.getRawValues()) {
                      if (xObject instanceof _primitives.Ref) {
                        if (processed.has(xObject)) {
                          continue;
                        }
                        try {
                          xObject = xref.fetch(xObject);
                        } catch (ex) {
                          processed.put(xObject);
                          (0, _util.info)(`hasBlendModes - ignoring XObject: "${ex}".`);
                          continue;
                        }
                      }
                      if (!(xObject instanceof _base_stream.BaseStream)) {
                        continue;
                      }
                      if (xObject.dict.objId) {
                        processed.put(xObject.dict.objId);
                      }
                      const xResources = xObject.dict.get("Resources");
                      if (!(xResources instanceof _primitives.Dict)) {
                        continue;
                      }
                      if (xResources.objId && processed.has(xResources.objId)) {
                        continue;
                      }
                      nodes.push(xResources);
                      if (xResources.objId) {
                        processed.put(xResources.objId);
                      }
                    }
                  }
                  for (const ref of processed) {
                    nonBlendModesSet.put(ref);
                  }
                  return false;
                }
                async fetchBuiltInCMap(name) {
                  const cachedData = this.builtInCMapCache.get(name);
                  if (cachedData) {
                    return cachedData;
                  }
                  let data;
                  if (this.options.cMapUrl !== null) {
                    const url = `${this.options.cMapUrl}${name}.bcmap`;
                    const response = await fetch(url);
                    if (!response.ok) {
                      throw new Error(`fetchBuiltInCMap: failed to fetch file "${url}" with "${response.statusText}".`);
                    }
                    data = {
                      cMapData: new Uint8Array(await response.arrayBuffer()),
                      compressionType: _util.CMapCompressionType.BINARY
                    };
                  } else {
                    data = await this.handler.sendWithPromise("FetchBuiltInCMap", {
                      name
                    });
                  }
                  if (data.compressionType !== _util.CMapCompressionType.NONE) {
                    this.builtInCMapCache.set(name, data);
                  }
                  return data;
                }
                async fetchStandardFontData(name) {
                  const cachedData = this.standardFontDataCache.get(name);
                  if (cachedData) {
                    return new _stream.Stream(cachedData);
                  }
                  if (this.options.useSystemFonts && name !== "Symbol" && name !== "ZapfDingbats") {
                    return null;
                  }
                  const standardFontNameToFileName = (0, _standard_fonts.getFontNameToFileMap)(), filename = standardFontNameToFileName[name];
                  let data;
                  if (this.options.standardFontDataUrl !== null) {
                    const url = `${this.options.standardFontDataUrl}${filename}`;
                    const response = await fetch(url);
                    if (!response.ok) {
                      (0, _util.warn)(`fetchStandardFontData: failed to fetch file "${url}" with "${response.statusText}".`);
                    } else {
                      data = await response.arrayBuffer();
                    }
                  } else {
                    try {
                      data = await this.handler.sendWithPromise("FetchStandardFontData", {
                        filename
                      });
                    } catch (e) {
                      (0, _util.warn)(`fetchStandardFontData: failed to fetch file "${filename}" with "${e}".`);
                    }
                  }
                  if (!data) {
                    return null;
                  }
                  this.standardFontDataCache.set(name, data);
                  return new _stream.Stream(data);
                }
                async buildFormXObject(resources, xobj, smask, operatorList, task, initialState, localColorSpaceCache) {
                  const dict = xobj.dict;
                  const matrix = dict.getArray("Matrix");
                  let bbox = dict.getArray("BBox");
                  if (Array.isArray(bbox) && bbox.length === 4) {
                    bbox = _util.Util.normalizeRect(bbox);
                  } else {
                    bbox = null;
                  }
                  let optionalContent, groupOptions;
                  if (dict.has("OC")) {
                    optionalContent = await this.parseMarkedContentProps(dict.get("OC"), resources);
                  }
                  if (optionalContent !== void 0) {
                    operatorList.addOp(_util.OPS.beginMarkedContentProps, ["OC", optionalContent]);
                  }
                  const group = dict.get("Group");
                  if (group) {
                    groupOptions = {
                      matrix,
                      bbox,
                      smask,
                      isolated: false,
                      knockout: false
                    };
                    const groupSubtype = group.get("S");
                    let colorSpace = null;
                    if ((0, _primitives.isName)(groupSubtype, "Transparency")) {
                      groupOptions.isolated = group.get("I") || false;
                      groupOptions.knockout = group.get("K") || false;
                      if (group.has("CS")) {
                        const cs = group.getRaw("CS");
                        const cachedColorSpace = _colorspace.ColorSpace.getCached(cs, this.xref, localColorSpaceCache);
                        if (cachedColorSpace) {
                          colorSpace = cachedColorSpace;
                        } else {
                          colorSpace = await this.parseColorSpace({
                            cs,
                            resources,
                            localColorSpaceCache
                          });
                        }
                      }
                    }
                    if (smask && smask.backdrop) {
                      colorSpace = colorSpace || _colorspace.ColorSpace.singletons.rgb;
                      smask.backdrop = colorSpace.getRgb(smask.backdrop, 0);
                    }
                    operatorList.addOp(_util.OPS.beginGroup, [groupOptions]);
                  }
                  const args = group ? [matrix, null] : [matrix, bbox];
                  operatorList.addOp(_util.OPS.paintFormXObjectBegin, args);
                  return this.getOperatorList({
                    stream: xobj,
                    task,
                    resources: dict.get("Resources") || resources,
                    operatorList,
                    initialState
                  }).then(function() {
                    operatorList.addOp(_util.OPS.paintFormXObjectEnd, []);
                    if (group) {
                      operatorList.addOp(_util.OPS.endGroup, [groupOptions]);
                    }
                    if (optionalContent !== void 0) {
                      operatorList.addOp(_util.OPS.endMarkedContent, []);
                    }
                  });
                }
                _sendImgData(objId, imgData) {
                  let cacheGlobally = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                  const transfers = imgData ? [imgData.bitmap || imgData.data.buffer] : null;
                  if (this.parsingType3Font || cacheGlobally) {
                    return this.handler.send("commonobj", [objId, "Image", imgData], transfers);
                  }
                  return this.handler.send("obj", [objId, this.pageIndex, "Image", imgData], transfers);
                }
                async buildPaintImageXObject(_ref2) {
                  let {
                    resources,
                    image,
                    isInline = false,
                    operatorList,
                    cacheKey,
                    localImageCache,
                    localColorSpaceCache
                  } = _ref2;
                  const dict = image.dict;
                  const imageRef = dict.objId;
                  const w = dict.get("W", "Width");
                  const h = dict.get("H", "Height");
                  if (!(w && typeof w === "number") || !(h && typeof h === "number")) {
                    (0, _util.warn)("Image dimensions are missing, or not numbers.");
                    return;
                  }
                  const maxImageSize = this.options.maxImageSize;
                  if (maxImageSize !== -1 && w * h > maxImageSize) {
                    const msg = "Image exceeded maximum allowed size and was removed.";
                    if (this.options.ignoreErrors) {
                      (0, _util.warn)(msg);
                      return;
                    }
                    throw new Error(msg);
                  }
                  let optionalContent;
                  if (dict.has("OC")) {
                    optionalContent = await this.parseMarkedContentProps(dict.get("OC"), resources);
                  }
                  const imageMask = dict.get("IM", "ImageMask") || false;
                  let imgData, args;
                  if (imageMask) {
                    const interpolate = dict.get("I", "Interpolate");
                    const bitStrideLength = w + 7 >> 3;
                    const imgArray = image.getBytes(bitStrideLength * h);
                    const decode = dict.getArray("D", "Decode");
                    if (this.parsingType3Font) {
                      imgData = _image.PDFImage.createRawMask({
                        imgArray,
                        width: w,
                        height: h,
                        imageIsFromDecodeStream: image instanceof _decode_stream.DecodeStream,
                        inverseDecode: !!decode && decode[0] > 0,
                        interpolate
                      });
                      imgData.cached = !!cacheKey;
                      args = [imgData];
                      operatorList.addImageOps(_util.OPS.paintImageMaskXObject, args, optionalContent);
                      if (cacheKey) {
                        localImageCache.set(cacheKey, imageRef, {
                          fn: _util.OPS.paintImageMaskXObject,
                          args,
                          optionalContent
                        });
                      }
                      return;
                    }
                    imgData = _image.PDFImage.createMask({
                      imgArray,
                      width: w,
                      height: h,
                      imageIsFromDecodeStream: image instanceof _decode_stream.DecodeStream,
                      inverseDecode: !!decode && decode[0] > 0,
                      interpolate
                    });
                    if (imgData.isSingleOpaquePixel) {
                      operatorList.addImageOps(_util.OPS.paintSolidColorImageMask, [], optionalContent);
                      if (cacheKey) {
                        localImageCache.set(cacheKey, imageRef, {
                          fn: _util.OPS.paintSolidColorImageMask,
                          args: [],
                          optionalContent
                        });
                      }
                      return;
                    }
                    const objId2 = `mask_${this.idFactory.createObjId()}`;
                    operatorList.addDependency(objId2);
                    this._sendImgData(objId2, imgData);
                    args = [{
                      data: objId2,
                      width: imgData.width,
                      height: imgData.height,
                      interpolate: imgData.interpolate,
                      count: 1
                    }];
                    operatorList.addImageOps(_util.OPS.paintImageMaskXObject, args, optionalContent);
                    if (cacheKey) {
                      localImageCache.set(cacheKey, imageRef, {
                        fn: _util.OPS.paintImageMaskXObject,
                        args,
                        optionalContent
                      });
                    }
                    return;
                  }
                  const softMask = dict.get("SM", "SMask") || false;
                  const mask = dict.get("Mask") || false;
                  const SMALL_IMAGE_DIMENSIONS = 200;
                  if (isInline && !softMask && !mask && w + h < SMALL_IMAGE_DIMENSIONS) {
                    const imageObj = new _image.PDFImage({
                      xref: this.xref,
                      res: resources,
                      image,
                      isInline,
                      pdfFunctionFactory: this._pdfFunctionFactory,
                      localColorSpaceCache
                    });
                    imgData = imageObj.createImageData(true);
                    operatorList.addImageOps(_util.OPS.paintInlineImageXObject, [imgData], optionalContent);
                    return;
                  }
                  let objId = `img_${this.idFactory.createObjId()}`, cacheGlobally = false;
                  if (this.parsingType3Font) {
                    objId = `${this.idFactory.getDocId()}_type3_${objId}`;
                  } else if (imageRef) {
                    cacheGlobally = this.globalImageCache.shouldCache(imageRef, this.pageIndex);
                    if (cacheGlobally) {
                      objId = `${this.idFactory.getDocId()}_${objId}`;
                    }
                  }
                  operatorList.addDependency(objId);
                  args = [objId, w, h];
                  _image.PDFImage.buildImage({
                    xref: this.xref,
                    res: resources,
                    image,
                    isInline,
                    pdfFunctionFactory: this._pdfFunctionFactory,
                    localColorSpaceCache
                  }).then((imageObj) => {
                    imgData = imageObj.createImageData(false);
                    if (cacheKey && imageRef && cacheGlobally) {
                      this.globalImageCache.addByteSize(imageRef, imgData.data.length);
                    }
                    return this._sendImgData(objId, imgData, cacheGlobally);
                  }).catch((reason) => {
                    (0, _util.warn)(`Unable to decode image "${objId}": "${reason}".`);
                    return this._sendImgData(objId, null, cacheGlobally);
                  });
                  operatorList.addImageOps(_util.OPS.paintImageXObject, args, optionalContent);
                  if (cacheKey) {
                    localImageCache.set(cacheKey, imageRef, {
                      fn: _util.OPS.paintImageXObject,
                      args,
                      optionalContent
                    });
                    if (imageRef) {
                      (0, _util.assert)(!isInline, "Cannot cache an inline image globally.");
                      this.globalImageCache.addPageIndex(imageRef, this.pageIndex);
                      if (cacheGlobally) {
                        this.globalImageCache.setData(imageRef, {
                          objId,
                          fn: _util.OPS.paintImageXObject,
                          args,
                          optionalContent,
                          byteSize: 0
                        });
                      }
                    }
                  }
                }
                handleSMask(smask, resources, operatorList, task, stateManager, localColorSpaceCache) {
                  const smaskContent = smask.get("G");
                  const smaskOptions = {
                    subtype: smask.get("S").name,
                    backdrop: smask.get("BC")
                  };
                  const transferObj = smask.get("TR");
                  if ((0, _function.isPDFFunction)(transferObj)) {
                    const transferFn = this._pdfFunctionFactory.create(transferObj);
                    const transferMap = new Uint8Array(256);
                    const tmp = new Float32Array(1);
                    for (let i = 0; i < 256; i++) {
                      tmp[0] = i / 255;
                      transferFn(tmp, 0, tmp, 0);
                      transferMap[i] = tmp[0] * 255 | 0;
                    }
                    smaskOptions.transferMap = transferMap;
                  }
                  return this.buildFormXObject(resources, smaskContent, smaskOptions, operatorList, task, stateManager.state.clone(), localColorSpaceCache);
                }
                handleTransferFunction(tr) {
                  let transferArray;
                  if (Array.isArray(tr)) {
                    transferArray = tr;
                  } else if ((0, _function.isPDFFunction)(tr)) {
                    transferArray = [tr];
                  } else {
                    return null;
                  }
                  const transferMaps = [];
                  let numFns = 0, numEffectfulFns = 0;
                  for (const entry of transferArray) {
                    const transferObj = this.xref.fetchIfRef(entry);
                    numFns++;
                    if ((0, _primitives.isName)(transferObj, "Identity")) {
                      transferMaps.push(null);
                      continue;
                    } else if (!(0, _function.isPDFFunction)(transferObj)) {
                      return null;
                    }
                    const transferFn = this._pdfFunctionFactory.create(transferObj);
                    const transferMap = new Uint8Array(256), tmp = new Float32Array(1);
                    for (let j = 0; j < 256; j++) {
                      tmp[0] = j / 255;
                      transferFn(tmp, 0, tmp, 0);
                      transferMap[j] = tmp[0] * 255 | 0;
                    }
                    transferMaps.push(transferMap);
                    numEffectfulFns++;
                  }
                  if (!(numFns === 1 || numFns === 4)) {
                    return null;
                  }
                  if (numEffectfulFns === 0) {
                    return null;
                  }
                  return transferMaps;
                }
                handleTilingType(fn, color, resources, pattern, patternDict, operatorList, task, localTilingPatternCache) {
                  const tilingOpList = new _operator_list.OperatorList();
                  const patternResources = _primitives.Dict.merge({
                    xref: this.xref,
                    dictArray: [patternDict.get("Resources"), resources]
                  });
                  return this.getOperatorList({
                    stream: pattern,
                    task,
                    resources: patternResources,
                    operatorList: tilingOpList
                  }).then(function() {
                    const operatorListIR = tilingOpList.getIR();
                    const tilingPatternIR = (0, _pattern.getTilingPatternIR)(operatorListIR, patternDict, color);
                    operatorList.addDependencies(tilingOpList.dependencies);
                    operatorList.addOp(fn, tilingPatternIR);
                    if (patternDict.objId) {
                      localTilingPatternCache.set(null, patternDict.objId, {
                        operatorListIR,
                        dict: patternDict
                      });
                    }
                  }).catch((reason) => {
                    if (reason instanceof _util.AbortException) {
                      return;
                    }
                    if (this.options.ignoreErrors) {
                      this.handler.send("UnsupportedFeature", {
                        featureId: _util.UNSUPPORTED_FEATURES.errorTilingPattern
                      });
                      (0, _util.warn)(`handleTilingType - ignoring pattern: "${reason}".`);
                      return;
                    }
                    throw reason;
                  });
                }
                handleSetFont(resources, fontArgs, fontRef, operatorList, task, state) {
                  let fallbackFontDict = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null;
                  let cssFontInfo = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : null;
                  const fontName = fontArgs && fontArgs[0] instanceof _primitives.Name ? fontArgs[0].name : null;
                  return this.loadFont(fontName, fontRef, resources, fallbackFontDict, cssFontInfo).then((translated) => {
                    if (!translated.font.isType3Font) {
                      return translated;
                    }
                    return translated.loadType3Data(this, resources, task).then(function() {
                      operatorList.addDependencies(translated.type3Dependencies);
                      return translated;
                    }).catch((reason) => {
                      this.handler.send("UnsupportedFeature", {
                        featureId: _util.UNSUPPORTED_FEATURES.errorFontLoadType3
                      });
                      return new TranslatedFont({
                        loadedName: "g_font_error",
                        font: new _fonts.ErrorFont(`Type3 font load error: ${reason}`),
                        dict: translated.font,
                        evaluatorOptions: this.options
                      });
                    });
                  }).then((translated) => {
                    state.font = translated.font;
                    translated.send(this.handler);
                    return translated.loadedName;
                  });
                }
                handleText(chars, state) {
                  const font = state.font;
                  const glyphs = font.charsToGlyphs(chars);
                  if (font.data) {
                    const isAddToPathSet = !!(state.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);
                    if (isAddToPathSet || state.fillColorSpace.name === "Pattern" || font.disableFontFace || this.options.disableFontFace) {
                      _PartialEvaluator.buildFontPaths(font, glyphs, this.handler, this.options);
                    }
                  }
                  return glyphs;
                }
                ensureStateFont(state) {
                  if (state.font) {
                    return;
                  }
                  const reason = new _util.FormatError("Missing setFont (Tf) operator before text rendering operator.");
                  if (this.options.ignoreErrors) {
                    this.handler.send("UnsupportedFeature", {
                      featureId: _util.UNSUPPORTED_FEATURES.errorFontState
                    });
                    (0, _util.warn)(`ensureStateFont: "${reason}".`);
                    return;
                  }
                  throw reason;
                }
                async setGState(_ref3) {
                  let {
                    resources,
                    gState,
                    operatorList,
                    cacheKey,
                    task,
                    stateManager,
                    localGStateCache,
                    localColorSpaceCache
                  } = _ref3;
                  const gStateRef = gState.objId;
                  let isSimpleGState = true;
                  const gStateObj = [];
                  const gStateKeys = gState.getKeys();
                  let promise = Promise.resolve();
                  for (let i = 0, ii = gStateKeys.length; i < ii; i++) {
                    const key = gStateKeys[i];
                    const value = gState.get(key);
                    switch (key) {
                      case "Type":
                        break;
                      case "LW":
                      case "LC":
                      case "LJ":
                      case "ML":
                      case "D":
                      case "RI":
                      case "FL":
                      case "CA":
                      case "ca":
                        gStateObj.push([key, value]);
                        break;
                      case "Font":
                        isSimpleGState = false;
                        promise = promise.then(() => {
                          return this.handleSetFont(resources, null, value[0], operatorList, task, stateManager.state).then(function(loadedName) {
                            operatorList.addDependency(loadedName);
                            gStateObj.push([key, [loadedName, value[1]]]);
                          });
                        });
                        break;
                      case "BM":
                        gStateObj.push([key, normalizeBlendMode(value)]);
                        break;
                      case "SMask":
                        if ((0, _primitives.isName)(value, "None")) {
                          gStateObj.push([key, false]);
                          break;
                        }
                        if (value instanceof _primitives.Dict) {
                          isSimpleGState = false;
                          promise = promise.then(() => {
                            return this.handleSMask(value, resources, operatorList, task, stateManager, localColorSpaceCache);
                          });
                          gStateObj.push([key, true]);
                        } else {
                          (0, _util.warn)("Unsupported SMask type");
                        }
                        break;
                      case "TR":
                        const transferMaps = this.handleTransferFunction(value);
                        gStateObj.push([key, transferMaps]);
                        break;
                      case "OP":
                      case "op":
                      case "OPM":
                      case "BG":
                      case "BG2":
                      case "UCR":
                      case "UCR2":
                      case "TR2":
                      case "HT":
                      case "SM":
                      case "SA":
                      case "AIS":
                      case "TK":
                        (0, _util.info)("graphic state operator " + key);
                        break;
                      default:
                        (0, _util.info)("Unknown graphic state operator " + key);
                        break;
                    }
                  }
                  return promise.then(function() {
                    if (gStateObj.length > 0) {
                      operatorList.addOp(_util.OPS.setGState, [gStateObj]);
                    }
                    if (isSimpleGState) {
                      localGStateCache.set(cacheKey, gStateRef, gStateObj);
                    }
                  });
                }
                loadFont(fontName, font, resources) {
                  let fallbackFontDict = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
                  let cssFontInfo = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
                  const errorFont = /* @__PURE__ */ __name(async () => {
                    return new TranslatedFont({
                      loadedName: "g_font_error",
                      font: new _fonts.ErrorFont(`Font "${fontName}" is not available.`),
                      dict: font,
                      evaluatorOptions: this.options
                    });
                  }, "errorFont");
                  const xref = this.xref;
                  let fontRef;
                  if (font) {
                    if (font instanceof _primitives.Ref) {
                      fontRef = font;
                    }
                  } else {
                    const fontRes = resources.get("Font");
                    if (fontRes) {
                      fontRef = fontRes.getRaw(fontName);
                    }
                  }
                  if (!fontRef) {
                    const partialMsg = `Font "${fontName || font && font.toString()}" is not available`;
                    if (!this.options.ignoreErrors && !this.parsingType3Font) {
                      (0, _util.warn)(`${partialMsg}.`);
                      return errorFont();
                    }
                    this.handler.send("UnsupportedFeature", {
                      featureId: _util.UNSUPPORTED_FEATURES.errorFontMissing
                    });
                    (0, _util.warn)(`${partialMsg} -- attempting to fallback to a default font.`);
                    if (fallbackFontDict) {
                      fontRef = fallbackFontDict;
                    } else {
                      fontRef = _PartialEvaluator.fallbackFontDict;
                    }
                  }
                  if (this.parsingType3Font && this.type3FontRefs.has(fontRef)) {
                    return errorFont();
                  }
                  if (this.fontCache.has(fontRef)) {
                    return this.fontCache.get(fontRef);
                  }
                  font = xref.fetchIfRef(fontRef);
                  if (!(font instanceof _primitives.Dict)) {
                    return errorFont();
                  }
                  if (font.cacheKey && this.fontCache.has(font.cacheKey)) {
                    return this.fontCache.get(font.cacheKey);
                  }
                  const fontCapability = (0, _util.createPromiseCapability)();
                  let preEvaluatedFont;
                  try {
                    preEvaluatedFont = this.preEvaluateFont(font);
                    preEvaluatedFont.cssFontInfo = cssFontInfo;
                  } catch (reason) {
                    (0, _util.warn)(`loadFont - preEvaluateFont failed: "${reason}".`);
                    return errorFont();
                  }
                  const {
                    descriptor,
                    hash
                  } = preEvaluatedFont;
                  const fontRefIsRef = fontRef instanceof _primitives.Ref;
                  let fontID;
                  if (fontRefIsRef) {
                    fontID = `f${fontRef.toString()}`;
                  }
                  if (hash && descriptor instanceof _primitives.Dict) {
                    if (!descriptor.fontAliases) {
                      descriptor.fontAliases = /* @__PURE__ */ Object.create(null);
                    }
                    const fontAliases = descriptor.fontAliases;
                    if (fontAliases[hash]) {
                      const aliasFontRef = fontAliases[hash].aliasRef;
                      if (fontRefIsRef && aliasFontRef && this.fontCache.has(aliasFontRef)) {
                        this.fontCache.putAlias(fontRef, aliasFontRef);
                        return this.fontCache.get(fontRef);
                      }
                    } else {
                      fontAliases[hash] = {
                        fontID: this.idFactory.createFontId()
                      };
                    }
                    if (fontRefIsRef) {
                      fontAliases[hash].aliasRef = fontRef;
                    }
                    fontID = fontAliases[hash].fontID;
                  }
                  if (fontRefIsRef) {
                    this.fontCache.put(fontRef, fontCapability.promise);
                  } else {
                    if (!fontID) {
                      fontID = this.idFactory.createFontId();
                    }
                    font.cacheKey = `cacheKey_${fontID}`;
                    this.fontCache.put(font.cacheKey, fontCapability.promise);
                  }
                  (0, _util.assert)(fontID && fontID.startsWith("f"), 'The "fontID" must be (correctly) defined.');
                  font.loadedName = `${this.idFactory.getDocId()}_${fontID}`;
                  this.translateFont(preEvaluatedFont).then((translatedFont) => {
                    if (translatedFont.fontType !== void 0) {
                      xref.stats.addFontType(translatedFont.fontType);
                    }
                    fontCapability.resolve(new TranslatedFont({
                      loadedName: font.loadedName,
                      font: translatedFont,
                      dict: font,
                      evaluatorOptions: this.options
                    }));
                  }).catch((reason) => {
                    this.handler.send("UnsupportedFeature", {
                      featureId: _util.UNSUPPORTED_FEATURES.errorFontTranslate
                    });
                    (0, _util.warn)(`loadFont - translateFont failed: "${reason}".`);
                    try {
                      const fontFile3 = descriptor && descriptor.get("FontFile3");
                      const subtype = fontFile3 && fontFile3.get("Subtype");
                      const fontType = (0, _fonts_utils.getFontType)(preEvaluatedFont.type, subtype && subtype.name);
                      if (fontType !== void 0) {
                        xref.stats.addFontType(fontType);
                      }
                    } catch (ex) {
                    }
                    fontCapability.resolve(new TranslatedFont({
                      loadedName: font.loadedName,
                      font: new _fonts.ErrorFont(reason instanceof Error ? reason.message : reason),
                      dict: font,
                      evaluatorOptions: this.options
                    }));
                  });
                  return fontCapability.promise;
                }
                buildPath(operatorList, fn, args) {
                  let parsingText = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
                  const lastIndex = operatorList.length - 1;
                  if (!args) {
                    args = [];
                  }
                  let minMax;
                  if (lastIndex < 0 || operatorList.fnArray[lastIndex] !== _util.OPS.constructPath) {
                    if (parsingText) {
                      (0, _util.warn)(`Encountered path operator "${fn}" inside of a text object.`);
                      operatorList.addOp(_util.OPS.save, null);
                    }
                    minMax = [Infinity, -Infinity, Infinity, -Infinity];
                    operatorList.addOp(_util.OPS.constructPath, [[fn], args, minMax]);
                    if (parsingText) {
                      operatorList.addOp(_util.OPS.restore, null);
                    }
                  } else {
                    const opArgs = operatorList.argsArray[lastIndex];
                    opArgs[0].push(fn);
                    Array.prototype.push.apply(opArgs[1], args);
                    minMax = opArgs[2];
                  }
                  switch (fn) {
                    case _util.OPS.rectangle:
                      minMax[0] = Math.min(minMax[0], args[0], args[0] + args[2]);
                      minMax[1] = Math.max(minMax[1], args[0], args[0] + args[2]);
                      minMax[2] = Math.min(minMax[2], args[1], args[1] + args[3]);
                      minMax[3] = Math.max(minMax[3], args[1], args[1] + args[3]);
                      break;
                    case _util.OPS.moveTo:
                    case _util.OPS.lineTo:
                      minMax[0] = Math.min(minMax[0], args[0]);
                      minMax[1] = Math.max(minMax[1], args[0]);
                      minMax[2] = Math.min(minMax[2], args[1]);
                      minMax[3] = Math.max(minMax[3], args[1]);
                      break;
                  }
                }
                parseColorSpace(_ref4) {
                  let {
                    cs,
                    resources,
                    localColorSpaceCache
                  } = _ref4;
                  return _colorspace.ColorSpace.parseAsync({
                    cs,
                    xref: this.xref,
                    resources,
                    pdfFunctionFactory: this._pdfFunctionFactory,
                    localColorSpaceCache
                  }).catch((reason) => {
                    if (reason instanceof _util.AbortException) {
                      return null;
                    }
                    if (this.options.ignoreErrors) {
                      this.handler.send("UnsupportedFeature", {
                        featureId: _util.UNSUPPORTED_FEATURES.errorColorSpace
                      });
                      (0, _util.warn)(`parseColorSpace - ignoring ColorSpace: "${reason}".`);
                      return null;
                    }
                    throw reason;
                  });
                }
                parseShading(_ref5) {
                  let {
                    shading,
                    resources,
                    localColorSpaceCache,
                    localShadingPatternCache
                  } = _ref5;
                  let id = localShadingPatternCache.get(shading);
                  if (!id) {
                    var shadingFill = _pattern.Pattern.parseShading(shading, this.xref, resources, this.handler, this._pdfFunctionFactory, localColorSpaceCache);
                    const patternIR = shadingFill.getIR();
                    id = `pattern_${this.idFactory.createObjId()}`;
                    localShadingPatternCache.set(shading, id);
                    this.handler.send("obj", [id, this.pageIndex, "Pattern", patternIR]);
                  }
                  return id;
                }
                handleColorN(operatorList, fn, args, cs, patterns, resources, task, localColorSpaceCache, localTilingPatternCache, localShadingPatternCache) {
                  const patternName = args.pop();
                  if (patternName instanceof _primitives.Name) {
                    const rawPattern = patterns.getRaw(patternName.name);
                    const localTilingPattern = rawPattern instanceof _primitives.Ref && localTilingPatternCache.getByRef(rawPattern);
                    if (localTilingPattern) {
                      try {
                        const color = cs.base ? cs.base.getRgb(args, 0) : null;
                        const tilingPatternIR = (0, _pattern.getTilingPatternIR)(localTilingPattern.operatorListIR, localTilingPattern.dict, color);
                        operatorList.addOp(fn, tilingPatternIR);
                        return void 0;
                      } catch (ex) {
                      }
                    }
                    const pattern = this.xref.fetchIfRef(rawPattern);
                    if (pattern) {
                      const dict = pattern instanceof _base_stream.BaseStream ? pattern.dict : pattern;
                      const typeNum = dict.get("PatternType");
                      if (typeNum === PatternType.TILING) {
                        const color = cs.base ? cs.base.getRgb(args, 0) : null;
                        return this.handleTilingType(fn, color, resources, pattern, dict, operatorList, task, localTilingPatternCache);
                      } else if (typeNum === PatternType.SHADING) {
                        const shading = dict.get("Shading");
                        const matrix = dict.getArray("Matrix");
                        const objId = this.parseShading({
                          shading,
                          resources,
                          localColorSpaceCache,
                          localShadingPatternCache
                        });
                        operatorList.addOp(fn, ["Shading", objId, matrix]);
                        return void 0;
                      }
                      throw new _util.FormatError(`Unknown PatternType: ${typeNum}`);
                    }
                  }
                  throw new _util.FormatError(`Unknown PatternName: ${patternName}`);
                }
                _parseVisibilityExpression(array, nestingCounter, currentResult) {
                  const MAX_NESTING = 10;
                  if (++nestingCounter > MAX_NESTING) {
                    (0, _util.warn)("Visibility expression is too deeply nested");
                    return;
                  }
                  const length = array.length;
                  const operator = this.xref.fetchIfRef(array[0]);
                  if (length < 2 || !(operator instanceof _primitives.Name)) {
                    (0, _util.warn)("Invalid visibility expression");
                    return;
                  }
                  switch (operator.name) {
                    case "And":
                    case "Or":
                    case "Not":
                      currentResult.push(operator.name);
                      break;
                    default:
                      (0, _util.warn)(`Invalid operator ${operator.name} in visibility expression`);
                      return;
                  }
                  for (let i = 1; i < length; i++) {
                    const raw = array[i];
                    const object = this.xref.fetchIfRef(raw);
                    if (Array.isArray(object)) {
                      const nestedResult = [];
                      currentResult.push(nestedResult);
                      this._parseVisibilityExpression(object, nestingCounter, nestedResult);
                    } else if (raw instanceof _primitives.Ref) {
                      currentResult.push(raw.toString());
                    }
                  }
                }
                async parseMarkedContentProps(contentProperties, resources) {
                  let optionalContent;
                  if (contentProperties instanceof _primitives.Name) {
                    const properties = resources.get("Properties");
                    optionalContent = properties.get(contentProperties.name);
                  } else if (contentProperties instanceof _primitives.Dict) {
                    optionalContent = contentProperties;
                  } else {
                    throw new _util.FormatError("Optional content properties malformed.");
                  }
                  const optionalContentType = optionalContent.get("Type").name;
                  if (optionalContentType === "OCG") {
                    return {
                      type: optionalContentType,
                      id: optionalContent.objId
                    };
                  } else if (optionalContentType === "OCMD") {
                    const expression = optionalContent.get("VE");
                    if (Array.isArray(expression)) {
                      const result = [];
                      this._parseVisibilityExpression(expression, 0, result);
                      if (result.length > 0) {
                        return {
                          type: "OCMD",
                          expression: result
                        };
                      }
                    }
                    const optionalContentGroups = optionalContent.get("OCGs");
                    if (Array.isArray(optionalContentGroups) || optionalContentGroups instanceof _primitives.Dict) {
                      const groupIds = [];
                      if (Array.isArray(optionalContentGroups)) {
                        for (const ocg of optionalContentGroups) {
                          groupIds.push(ocg.toString());
                        }
                      } else {
                        groupIds.push(optionalContentGroups.objId);
                      }
                      return {
                        type: optionalContentType,
                        ids: groupIds,
                        policy: optionalContent.get("P") instanceof _primitives.Name ? optionalContent.get("P").name : null,
                        expression: null
                      };
                    } else if (optionalContentGroups instanceof _primitives.Ref) {
                      return {
                        type: optionalContentType,
                        id: optionalContentGroups.toString()
                      };
                    }
                  }
                  return null;
                }
                getOperatorList(_ref6) {
                  let {
                    stream,
                    task,
                    resources,
                    operatorList,
                    initialState = null,
                    fallbackFontDict = null
                  } = _ref6;
                  resources = resources || _primitives.Dict.empty;
                  initialState = initialState || new EvalState();
                  if (!operatorList) {
                    throw new Error('getOperatorList: missing "operatorList" parameter');
                  }
                  const self2 = this;
                  const xref = this.xref;
                  let parsingText = false;
                  const localImageCache = new _image_utils.LocalImageCache();
                  const localColorSpaceCache = new _image_utils.LocalColorSpaceCache();
                  const localGStateCache = new _image_utils.LocalGStateCache();
                  const localTilingPatternCache = new _image_utils.LocalTilingPatternCache();
                  const localShadingPatternCache = /* @__PURE__ */ new Map();
                  const xobjs = resources.get("XObject") || _primitives.Dict.empty;
                  const patterns = resources.get("Pattern") || _primitives.Dict.empty;
                  const stateManager = new StateManager(initialState);
                  const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
                  const timeSlotManager = new TimeSlotManager();
                  function closePendingRestoreOPS(argument) {
                    for (let i = 0, ii = preprocessor.savedStatesDepth; i < ii; i++) {
                      operatorList.addOp(_util.OPS.restore, []);
                    }
                  }
                  __name(closePendingRestoreOPS, "closePendingRestoreOPS");
                  return new Promise(/* @__PURE__ */ __name(function promiseBody(resolve, reject) {
                    const next = /* @__PURE__ */ __name(function(promise) {
                      Promise.all([promise, operatorList.ready]).then(function() {
                        try {
                          promiseBody(resolve, reject);
                        } catch (ex) {
                          reject(ex);
                        }
                      }, reject);
                    }, "next");
                    task.ensureNotTerminated();
                    timeSlotManager.reset();
                    const operation = {};
                    let stop, i, ii, cs, name, isValidName;
                    while (!(stop = timeSlotManager.check())) {
                      operation.args = null;
                      if (!preprocessor.read(operation)) {
                        break;
                      }
                      let args = operation.args;
                      let fn = operation.fn;
                      switch (fn | 0) {
                        case _util.OPS.paintXObject:
                          isValidName = args[0] instanceof _primitives.Name;
                          name = args[0].name;
                          if (isValidName) {
                            const localImage = localImageCache.getByName(name);
                            if (localImage) {
                              operatorList.addImageOps(localImage.fn, localImage.args, localImage.optionalContent);
                              incrementCachedImageMaskCount(localImage);
                              args = null;
                              continue;
                            }
                          }
                          next(new Promise(function(resolveXObject, rejectXObject) {
                            if (!isValidName) {
                              throw new _util.FormatError("XObject must be referred to by name.");
                            }
                            let xobj = xobjs.getRaw(name);
                            if (xobj instanceof _primitives.Ref) {
                              const localImage = localImageCache.getByRef(xobj);
                              if (localImage) {
                                operatorList.addImageOps(localImage.fn, localImage.args, localImage.optionalContent);
                                incrementCachedImageMaskCount(localImage);
                                resolveXObject();
                                return;
                              }
                              const globalImage = self2.globalImageCache.getData(xobj, self2.pageIndex);
                              if (globalImage) {
                                operatorList.addDependency(globalImage.objId);
                                operatorList.addImageOps(globalImage.fn, globalImage.args, globalImage.optionalContent);
                                resolveXObject();
                                return;
                              }
                              xobj = xref.fetch(xobj);
                            }
                            if (!(xobj instanceof _base_stream.BaseStream)) {
                              throw new _util.FormatError("XObject should be a stream");
                            }
                            const type = xobj.dict.get("Subtype");
                            if (!(type instanceof _primitives.Name)) {
                              throw new _util.FormatError("XObject should have a Name subtype");
                            }
                            if (type.name === "Form") {
                              stateManager.save();
                              self2.buildFormXObject(resources, xobj, null, operatorList, task, stateManager.state.clone(), localColorSpaceCache).then(function() {
                                stateManager.restore();
                                resolveXObject();
                              }, rejectXObject);
                              return;
                            } else if (type.name === "Image") {
                              self2.buildPaintImageXObject({
                                resources,
                                image: xobj,
                                operatorList,
                                cacheKey: name,
                                localImageCache,
                                localColorSpaceCache
                              }).then(resolveXObject, rejectXObject);
                              return;
                            } else if (type.name === "PS") {
                              (0, _util.info)("Ignored XObject subtype PS");
                            } else {
                              throw new _util.FormatError(`Unhandled XObject subtype ${type.name}`);
                            }
                            resolveXObject();
                          }).catch(function(reason) {
                            if (reason instanceof _util.AbortException) {
                              return;
                            }
                            if (self2.options.ignoreErrors) {
                              self2.handler.send("UnsupportedFeature", {
                                featureId: _util.UNSUPPORTED_FEATURES.errorXObject
                              });
                              (0, _util.warn)(`getOperatorList - ignoring XObject: "${reason}".`);
                              return;
                            }
                            throw reason;
                          }));
                          return;
                        case _util.OPS.setFont:
                          var fontSize = args[1];
                          next(self2.handleSetFont(resources, args, null, operatorList, task, stateManager.state, fallbackFontDict).then(function(loadedName) {
                            operatorList.addDependency(loadedName);
                            operatorList.addOp(_util.OPS.setFont, [loadedName, fontSize]);
                          }));
                          return;
                        case _util.OPS.beginText:
                          parsingText = true;
                          break;
                        case _util.OPS.endText:
                          parsingText = false;
                          break;
                        case _util.OPS.endInlineImage:
                          var cacheKey = args[0].cacheKey;
                          if (cacheKey) {
                            const localImage = localImageCache.getByName(cacheKey);
                            if (localImage) {
                              operatorList.addImageOps(localImage.fn, localImage.args, localImage.optionalContent);
                              incrementCachedImageMaskCount(localImage);
                              args = null;
                              continue;
                            }
                          }
                          next(self2.buildPaintImageXObject({
                            resources,
                            image: args[0],
                            isInline: true,
                            operatorList,
                            cacheKey,
                            localImageCache,
                            localColorSpaceCache
                          }));
                          return;
                        case _util.OPS.showText:
                          if (!stateManager.state.font) {
                            self2.ensureStateFont(stateManager.state);
                            continue;
                          }
                          args[0] = self2.handleText(args[0], stateManager.state);
                          break;
                        case _util.OPS.showSpacedText:
                          if (!stateManager.state.font) {
                            self2.ensureStateFont(stateManager.state);
                            continue;
                          }
                          var arr = args[0];
                          var combinedGlyphs = [];
                          var arrLength = arr.length;
                          var state = stateManager.state;
                          for (i = 0; i < arrLength; ++i) {
                            const arrItem = arr[i];
                            if (typeof arrItem === "string") {
                              Array.prototype.push.apply(combinedGlyphs, self2.handleText(arrItem, state));
                            } else if (typeof arrItem === "number") {
                              combinedGlyphs.push(arrItem);
                            }
                          }
                          args[0] = combinedGlyphs;
                          fn = _util.OPS.showText;
                          break;
                        case _util.OPS.nextLineShowText:
                          if (!stateManager.state.font) {
                            self2.ensureStateFont(stateManager.state);
                            continue;
                          }
                          operatorList.addOp(_util.OPS.nextLine);
                          args[0] = self2.handleText(args[0], stateManager.state);
                          fn = _util.OPS.showText;
                          break;
                        case _util.OPS.nextLineSetSpacingShowText:
                          if (!stateManager.state.font) {
                            self2.ensureStateFont(stateManager.state);
                            continue;
                          }
                          operatorList.addOp(_util.OPS.nextLine);
                          operatorList.addOp(_util.OPS.setWordSpacing, [args.shift()]);
                          operatorList.addOp(_util.OPS.setCharSpacing, [args.shift()]);
                          args[0] = self2.handleText(args[0], stateManager.state);
                          fn = _util.OPS.showText;
                          break;
                        case _util.OPS.setTextRenderingMode:
                          stateManager.state.textRenderingMode = args[0];
                          break;
                        case _util.OPS.setFillColorSpace: {
                          const cachedColorSpace = _colorspace.ColorSpace.getCached(args[0], xref, localColorSpaceCache);
                          if (cachedColorSpace) {
                            stateManager.state.fillColorSpace = cachedColorSpace;
                            continue;
                          }
                          next(self2.parseColorSpace({
                            cs: args[0],
                            resources,
                            localColorSpaceCache
                          }).then(function(colorSpace) {
                            if (colorSpace) {
                              stateManager.state.fillColorSpace = colorSpace;
                            }
                          }));
                          return;
                        }
                        case _util.OPS.setStrokeColorSpace: {
                          const cachedColorSpace = _colorspace.ColorSpace.getCached(args[0], xref, localColorSpaceCache);
                          if (cachedColorSpace) {
                            stateManager.state.strokeColorSpace = cachedColorSpace;
                            continue;
                          }
                          next(self2.parseColorSpace({
                            cs: args[0],
                            resources,
                            localColorSpaceCache
                          }).then(function(colorSpace) {
                            if (colorSpace) {
                              stateManager.state.strokeColorSpace = colorSpace;
                            }
                          }));
                          return;
                        }
                        case _util.OPS.setFillColor:
                          cs = stateManager.state.fillColorSpace;
                          args = cs.getRgb(args, 0);
                          fn = _util.OPS.setFillRGBColor;
                          break;
                        case _util.OPS.setStrokeColor:
                          cs = stateManager.state.strokeColorSpace;
                          args = cs.getRgb(args, 0);
                          fn = _util.OPS.setStrokeRGBColor;
                          break;
                        case _util.OPS.setFillGray:
                          stateManager.state.fillColorSpace = _colorspace.ColorSpace.singletons.gray;
                          args = _colorspace.ColorSpace.singletons.gray.getRgb(args, 0);
                          fn = _util.OPS.setFillRGBColor;
                          break;
                        case _util.OPS.setStrokeGray:
                          stateManager.state.strokeColorSpace = _colorspace.ColorSpace.singletons.gray;
                          args = _colorspace.ColorSpace.singletons.gray.getRgb(args, 0);
                          fn = _util.OPS.setStrokeRGBColor;
                          break;
                        case _util.OPS.setFillCMYKColor:
                          stateManager.state.fillColorSpace = _colorspace.ColorSpace.singletons.cmyk;
                          args = _colorspace.ColorSpace.singletons.cmyk.getRgb(args, 0);
                          fn = _util.OPS.setFillRGBColor;
                          break;
                        case _util.OPS.setStrokeCMYKColor:
                          stateManager.state.strokeColorSpace = _colorspace.ColorSpace.singletons.cmyk;
                          args = _colorspace.ColorSpace.singletons.cmyk.getRgb(args, 0);
                          fn = _util.OPS.setStrokeRGBColor;
                          break;
                        case _util.OPS.setFillRGBColor:
                          stateManager.state.fillColorSpace = _colorspace.ColorSpace.singletons.rgb;
                          args = _colorspace.ColorSpace.singletons.rgb.getRgb(args, 0);
                          break;
                        case _util.OPS.setStrokeRGBColor:
                          stateManager.state.strokeColorSpace = _colorspace.ColorSpace.singletons.rgb;
                          args = _colorspace.ColorSpace.singletons.rgb.getRgb(args, 0);
                          break;
                        case _util.OPS.setFillColorN:
                          cs = stateManager.state.fillColorSpace;
                          if (cs.name === "Pattern") {
                            next(self2.handleColorN(operatorList, _util.OPS.setFillColorN, args, cs, patterns, resources, task, localColorSpaceCache, localTilingPatternCache, localShadingPatternCache));
                            return;
                          }
                          args = cs.getRgb(args, 0);
                          fn = _util.OPS.setFillRGBColor;
                          break;
                        case _util.OPS.setStrokeColorN:
                          cs = stateManager.state.strokeColorSpace;
                          if (cs.name === "Pattern") {
                            next(self2.handleColorN(operatorList, _util.OPS.setStrokeColorN, args, cs, patterns, resources, task, localColorSpaceCache, localTilingPatternCache, localShadingPatternCache));
                            return;
                          }
                          args = cs.getRgb(args, 0);
                          fn = _util.OPS.setStrokeRGBColor;
                          break;
                        case _util.OPS.shadingFill:
                          var shadingRes = resources.get("Shading");
                          if (!shadingRes) {
                            throw new _util.FormatError("No shading resource found");
                          }
                          var shading = shadingRes.get(args[0].name);
                          if (!shading) {
                            throw new _util.FormatError("No shading object found");
                          }
                          const patternId = self2.parseShading({
                            shading,
                            resources,
                            localColorSpaceCache,
                            localShadingPatternCache
                          });
                          args = [patternId];
                          fn = _util.OPS.shadingFill;
                          break;
                        case _util.OPS.setGState:
                          isValidName = args[0] instanceof _primitives.Name;
                          name = args[0].name;
                          if (isValidName) {
                            const localGStateObj = localGStateCache.getByName(name);
                            if (localGStateObj) {
                              if (localGStateObj.length > 0) {
                                operatorList.addOp(_util.OPS.setGState, [localGStateObj]);
                              }
                              args = null;
                              continue;
                            }
                          }
                          next(new Promise(function(resolveGState, rejectGState) {
                            if (!isValidName) {
                              throw new _util.FormatError("GState must be referred to by name.");
                            }
                            const extGState = resources.get("ExtGState");
                            if (!(extGState instanceof _primitives.Dict)) {
                              throw new _util.FormatError("ExtGState should be a dictionary.");
                            }
                            const gState = extGState.get(name);
                            if (!(gState instanceof _primitives.Dict)) {
                              throw new _util.FormatError("GState should be a dictionary.");
                            }
                            self2.setGState({
                              resources,
                              gState,
                              operatorList,
                              cacheKey: name,
                              task,
                              stateManager,
                              localGStateCache,
                              localColorSpaceCache
                            }).then(resolveGState, rejectGState);
                          }).catch(function(reason) {
                            if (reason instanceof _util.AbortException) {
                              return;
                            }
                            if (self2.options.ignoreErrors) {
                              self2.handler.send("UnsupportedFeature", {
                                featureId: _util.UNSUPPORTED_FEATURES.errorExtGState
                              });
                              (0, _util.warn)(`getOperatorList - ignoring ExtGState: "${reason}".`);
                              return;
                            }
                            throw reason;
                          }));
                          return;
                        case _util.OPS.moveTo:
                        case _util.OPS.lineTo:
                        case _util.OPS.curveTo:
                        case _util.OPS.curveTo2:
                        case _util.OPS.curveTo3:
                        case _util.OPS.closePath:
                        case _util.OPS.rectangle:
                          self2.buildPath(operatorList, fn, args, parsingText);
                          continue;
                        case _util.OPS.markPoint:
                        case _util.OPS.markPointProps:
                        case _util.OPS.beginCompat:
                        case _util.OPS.endCompat:
                          continue;
                        case _util.OPS.beginMarkedContentProps:
                          if (!(args[0] instanceof _primitives.Name)) {
                            (0, _util.warn)(`Expected name for beginMarkedContentProps arg0=${args[0]}`);
                            continue;
                          }
                          if (args[0].name === "OC") {
                            next(self2.parseMarkedContentProps(args[1], resources).then((data) => {
                              operatorList.addOp(_util.OPS.beginMarkedContentProps, ["OC", data]);
                            }).catch((reason) => {
                              if (reason instanceof _util.AbortException) {
                                return;
                              }
                              if (self2.options.ignoreErrors) {
                                self2.handler.send("UnsupportedFeature", {
                                  featureId: _util.UNSUPPORTED_FEATURES.errorMarkedContent
                                });
                                (0, _util.warn)(`getOperatorList - ignoring beginMarkedContentProps: "${reason}".`);
                                return;
                              }
                              throw reason;
                            }));
                            return;
                          }
                          args = [args[0].name, args[1] instanceof _primitives.Dict ? args[1].get("MCID") : null];
                          break;
                        case _util.OPS.beginMarkedContent:
                        case _util.OPS.endMarkedContent:
                        default:
                          if (args !== null) {
                            for (i = 0, ii = args.length; i < ii; i++) {
                              if (args[i] instanceof _primitives.Dict) {
                                break;
                              }
                            }
                            if (i < ii) {
                              (0, _util.warn)("getOperatorList - ignoring operator: " + fn);
                              continue;
                            }
                          }
                      }
                      operatorList.addOp(fn, args);
                    }
                    if (stop) {
                      next(deferred);
                      return;
                    }
                    closePendingRestoreOPS();
                    resolve();
                  }, "promiseBody")).catch((reason) => {
                    if (reason instanceof _util.AbortException) {
                      return;
                    }
                    if (this.options.ignoreErrors) {
                      this.handler.send("UnsupportedFeature", {
                        featureId: _util.UNSUPPORTED_FEATURES.errorOperatorList
                      });
                      (0, _util.warn)(`getOperatorList - ignoring errors during "${task.name}" task: "${reason}".`);
                      closePendingRestoreOPS();
                      return;
                    }
                    throw reason;
                  });
                }
                getTextContent(_ref7) {
                  let {
                    stream,
                    task,
                    resources,
                    stateManager = null,
                    combineTextItems = false,
                    includeMarkedContent = false,
                    sink,
                    seenStyles = /* @__PURE__ */ new Set(),
                    viewBox
                  } = _ref7;
                  resources = resources || _primitives.Dict.empty;
                  stateManager = stateManager || new StateManager(new TextState());
                  const NormalizedUnicodes = (0, _unicode.getNormalizedUnicodes)();
                  const textContent = {
                    items: [],
                    styles: /* @__PURE__ */ Object.create(null)
                  };
                  const textContentItem = {
                    initialized: false,
                    str: [],
                    totalWidth: 0,
                    totalHeight: 0,
                    width: 0,
                    height: 0,
                    vertical: false,
                    prevTransform: null,
                    textAdvanceScale: 0,
                    spaceInFlowMin: 0,
                    spaceInFlowMax: 0,
                    trackingSpaceMin: Infinity,
                    negativeSpaceMax: -Infinity,
                    notASpace: -Infinity,
                    transform: null,
                    fontName: null,
                    hasEOL: false
                  };
                  const twoLastChars = [" ", " "];
                  let twoLastCharsPos = 0;
                  function saveLastChar(char) {
                    const nextPos = (twoLastCharsPos + 1) % 2;
                    const ret = twoLastChars[twoLastCharsPos] !== " " && twoLastChars[nextPos] === " ";
                    twoLastChars[twoLastCharsPos] = char;
                    twoLastCharsPos = nextPos;
                    return ret;
                  }
                  __name(saveLastChar, "saveLastChar");
                  function resetLastChars() {
                    twoLastChars[0] = twoLastChars[1] = " ";
                    twoLastCharsPos = 0;
                  }
                  __name(resetLastChars, "resetLastChars");
                  const TRACKING_SPACE_FACTOR = 0.1;
                  const NOT_A_SPACE_FACTOR = 0.03;
                  const NEGATIVE_SPACE_FACTOR = -0.2;
                  const SPACE_IN_FLOW_MIN_FACTOR = 0.1;
                  const SPACE_IN_FLOW_MAX_FACTOR = 0.6;
                  const self2 = this;
                  const xref = this.xref;
                  const showSpacedTextBuffer = [];
                  let xobjs = null;
                  const emptyXObjectCache = new _image_utils.LocalImageCache();
                  const emptyGStateCache = new _image_utils.LocalGStateCache();
                  const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
                  let textState;
                  function getCurrentTextTransform() {
                    const font = textState.font;
                    const tsm = [textState.fontSize * textState.textHScale, 0, 0, textState.fontSize, 0, textState.textRise];
                    if (font.isType3Font && (textState.fontSize <= 1 || font.isCharBBox) && !(0, _util.isArrayEqual)(textState.fontMatrix, _util.FONT_IDENTITY_MATRIX)) {
                      const glyphHeight = font.bbox[3] - font.bbox[1];
                      if (glyphHeight > 0) {
                        tsm[3] *= glyphHeight * textState.fontMatrix[3];
                      }
                    }
                    return _util.Util.transform(textState.ctm, _util.Util.transform(textState.textMatrix, tsm));
                  }
                  __name(getCurrentTextTransform, "getCurrentTextTransform");
                  function ensureTextContentItem() {
                    if (textContentItem.initialized) {
                      return textContentItem;
                    }
                    const font = textState.font, loadedName = font.loadedName;
                    if (!seenStyles.has(loadedName)) {
                      seenStyles.add(loadedName);
                      textContent.styles[loadedName] = {
                        fontFamily: font.fallbackName,
                        ascent: font.ascent,
                        descent: font.descent,
                        vertical: font.vertical
                      };
                    }
                    textContentItem.fontName = loadedName;
                    const trm = textContentItem.transform = getCurrentTextTransform();
                    if (!font.vertical) {
                      textContentItem.width = textContentItem.totalWidth = 0;
                      textContentItem.height = textContentItem.totalHeight = Math.hypot(trm[2], trm[3]);
                      textContentItem.vertical = false;
                    } else {
                      textContentItem.width = textContentItem.totalWidth = Math.hypot(trm[0], trm[1]);
                      textContentItem.height = textContentItem.totalHeight = 0;
                      textContentItem.vertical = true;
                    }
                    const scaleLineX = Math.hypot(textState.textLineMatrix[0], textState.textLineMatrix[1]);
                    const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]);
                    textContentItem.textAdvanceScale = scaleCtmX * scaleLineX;
                    textContentItem.trackingSpaceMin = textState.fontSize * TRACKING_SPACE_FACTOR;
                    textContentItem.notASpace = textState.fontSize * NOT_A_SPACE_FACTOR;
                    textContentItem.negativeSpaceMax = textState.fontSize * NEGATIVE_SPACE_FACTOR;
                    textContentItem.spaceInFlowMin = textState.fontSize * SPACE_IN_FLOW_MIN_FACTOR;
                    textContentItem.spaceInFlowMax = textState.fontSize * SPACE_IN_FLOW_MAX_FACTOR;
                    textContentItem.hasEOL = false;
                    textContentItem.initialized = true;
                    return textContentItem;
                  }
                  __name(ensureTextContentItem, "ensureTextContentItem");
                  function updateAdvanceScale() {
                    if (!textContentItem.initialized) {
                      return;
                    }
                    const scaleLineX = Math.hypot(textState.textLineMatrix[0], textState.textLineMatrix[1]);
                    const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]);
                    const scaleFactor = scaleCtmX * scaleLineX;
                    if (scaleFactor === textContentItem.textAdvanceScale) {
                      return;
                    }
                    if (!textContentItem.vertical) {
                      textContentItem.totalWidth += textContentItem.width * textContentItem.textAdvanceScale;
                      textContentItem.width = 0;
                    } else {
                      textContentItem.totalHeight += textContentItem.height * textContentItem.textAdvanceScale;
                      textContentItem.height = 0;
                    }
                    textContentItem.textAdvanceScale = scaleFactor;
                  }
                  __name(updateAdvanceScale, "updateAdvanceScale");
                  function runBidiTransform(textChunk) {
                    const text = textChunk.str.join("");
                    const bidiResult = (0, _bidi.bidi)(text, -1, textChunk.vertical);
                    return {
                      str: bidiResult.str,
                      dir: bidiResult.dir,
                      width: Math.abs(textChunk.totalWidth),
                      height: Math.abs(textChunk.totalHeight),
                      transform: textChunk.transform,
                      fontName: textChunk.fontName,
                      hasEOL: textChunk.hasEOL
                    };
                  }
                  __name(runBidiTransform, "runBidiTransform");
                  function handleSetFont(fontName, fontRef) {
                    return self2.loadFont(fontName, fontRef, resources).then(function(translated) {
                      if (!translated.font.isType3Font) {
                        return translated;
                      }
                      return translated.loadType3Data(self2, resources, task).catch(function() {
                      }).then(function() {
                        return translated;
                      });
                    }).then(function(translated) {
                      textState.font = translated.font;
                      textState.fontMatrix = translated.font.fontMatrix || _util.FONT_IDENTITY_MATRIX;
                    });
                  }
                  __name(handleSetFont, "handleSetFont");
                  function applyInverseRotation(x, y, matrix) {
                    const scale = Math.hypot(matrix[0], matrix[1]);
                    return [(matrix[0] * x + matrix[1] * y) / scale, (matrix[2] * x + matrix[3] * y) / scale];
                  }
                  __name(applyInverseRotation, "applyInverseRotation");
                  function compareWithLastPosition() {
                    const currentTransform = getCurrentTextTransform();
                    let posX = currentTransform[4];
                    let posY = currentTransform[5];
                    const shiftedX = posX - viewBox[0];
                    const shiftedY = posY - viewBox[1];
                    if (shiftedX < 0 || shiftedX > viewBox[2] || shiftedY < 0 || shiftedY > viewBox[3]) {
                      return false;
                    }
                    if (!combineTextItems || !textState.font || !textContentItem.prevTransform) {
                      return true;
                    }
                    let lastPosX = textContentItem.prevTransform[4];
                    let lastPosY = textContentItem.prevTransform[5];
                    if (lastPosX === posX && lastPosY === posY) {
                      return true;
                    }
                    let rotate = -1;
                    if (currentTransform[0] && currentTransform[1] === 0 && currentTransform[2] === 0) {
                      rotate = currentTransform[0] > 0 ? 0 : 180;
                    } else if (currentTransform[1] && currentTransform[0] === 0 && currentTransform[3] === 0) {
                      rotate = currentTransform[1] > 0 ? 90 : 270;
                    }
                    switch (rotate) {
                      case 0:
                        break;
                      case 90:
                        [posX, posY] = [posY, posX];
                        [lastPosX, lastPosY] = [lastPosY, lastPosX];
                        break;
                      case 180:
                        [posX, posY, lastPosX, lastPosY] = [-posX, -posY, -lastPosX, -lastPosY];
                        break;
                      case 270:
                        [posX, posY] = [-posY, -posX];
                        [lastPosX, lastPosY] = [-lastPosY, -lastPosX];
                        break;
                      default:
                        [posX, posY] = applyInverseRotation(posX, posY, currentTransform);
                        [lastPosX, lastPosY] = applyInverseRotation(lastPosX, lastPosY, textContentItem.prevTransform);
                    }
                    if (textState.font.vertical) {
                      const advanceY2 = (lastPosY - posY) / textContentItem.textAdvanceScale;
                      const advanceX2 = posX - lastPosX;
                      const textOrientation2 = Math.sign(textContentItem.height);
                      if (advanceY2 < textOrientation2 * textContentItem.negativeSpaceMax) {
                        if (Math.abs(advanceX2) > 0.5 * textContentItem.width) {
                          appendEOL();
                          return true;
                        }
                        resetLastChars();
                        flushTextContentItem();
                        return true;
                      }
                      if (Math.abs(advanceX2) > textContentItem.width) {
                        appendEOL();
                        return true;
                      }
                      if (advanceY2 <= textOrientation2 * textContentItem.notASpace) {
                        resetLastChars();
                      }
                      if (advanceY2 <= textOrientation2 * textContentItem.trackingSpaceMin) {
                        textContentItem.height += advanceY2;
                      } else if (!addFakeSpaces(advanceY2, textContentItem.prevTransform, textOrientation2)) {
                        if (textContentItem.str.length === 0) {
                          resetLastChars();
                          textContent.items.push({
                            str: " ",
                            dir: "ltr",
                            width: 0,
                            height: Math.abs(advanceY2),
                            transform: textContentItem.prevTransform,
                            fontName: textContentItem.fontName,
                            hasEOL: false
                          });
                        } else {
                          textContentItem.height += advanceY2;
                        }
                      }
                      return true;
                    }
                    const advanceX = (posX - lastPosX) / textContentItem.textAdvanceScale;
                    const advanceY = posY - lastPosY;
                    const textOrientation = Math.sign(textContentItem.width);
                    if (advanceX < textOrientation * textContentItem.negativeSpaceMax) {
                      if (Math.abs(advanceY) > 0.5 * textContentItem.height) {
                        appendEOL();
                        return true;
                      }
                      resetLastChars();
                      flushTextContentItem();
                      return true;
                    }
                    if (Math.abs(advanceY) > textContentItem.height) {
                      appendEOL();
                      return true;
                    }
                    if (advanceX <= textOrientation * textContentItem.notASpace) {
                      resetLastChars();
                    }
                    if (advanceX <= textOrientation * textContentItem.trackingSpaceMin) {
                      textContentItem.width += advanceX;
                    } else if (!addFakeSpaces(advanceX, textContentItem.prevTransform, textOrientation)) {
                      if (textContentItem.str.length === 0) {
                        resetLastChars();
                        textContent.items.push({
                          str: " ",
                          dir: "ltr",
                          width: Math.abs(advanceX),
                          height: 0,
                          transform: textContentItem.prevTransform,
                          fontName: textContentItem.fontName,
                          hasEOL: false
                        });
                      } else {
                        textContentItem.width += advanceX;
                      }
                    }
                    return true;
                  }
                  __name(compareWithLastPosition, "compareWithLastPosition");
                  function buildTextContentItem(_ref8) {
                    let {
                      chars,
                      extraSpacing
                    } = _ref8;
                    const font = textState.font;
                    if (!chars) {
                      const charSpacing = textState.charSpacing + extraSpacing;
                      if (charSpacing) {
                        if (!font.vertical) {
                          textState.translateTextMatrix(charSpacing * textState.textHScale, 0);
                        } else {
                          textState.translateTextMatrix(0, -charSpacing);
                        }
                      }
                      return;
                    }
                    const glyphs = font.charsToGlyphs(chars);
                    const scale = textState.fontMatrix[0] * textState.fontSize;
                    for (let i = 0, ii = glyphs.length; i < ii; i++) {
                      const glyph = glyphs[i];
                      if (glyph.isInvisibleFormatMark) {
                        continue;
                      }
                      let charSpacing = textState.charSpacing + (i + 1 === ii ? extraSpacing : 0);
                      let glyphWidth = glyph.width;
                      if (font.vertical) {
                        glyphWidth = glyph.vmetric ? glyph.vmetric[0] : -glyphWidth;
                      }
                      let scaledDim = glyphWidth * scale;
                      if (glyph.isWhitespace) {
                        if (!font.vertical) {
                          charSpacing += scaledDim + textState.wordSpacing;
                          textState.translateTextMatrix(charSpacing * textState.textHScale, 0);
                        } else {
                          charSpacing += -scaledDim + textState.wordSpacing;
                          textState.translateTextMatrix(0, -charSpacing);
                        }
                        saveLastChar(" ");
                        continue;
                      }
                      if (!compareWithLastPosition()) {
                        continue;
                      }
                      const textChunk = ensureTextContentItem();
                      if (glyph.isZeroWidthDiacritic) {
                        scaledDim = 0;
                      }
                      if (!font.vertical) {
                        scaledDim *= textState.textHScale;
                        textState.translateTextMatrix(scaledDim, 0);
                        textChunk.width += scaledDim;
                      } else {
                        textState.translateTextMatrix(0, scaledDim);
                        scaledDim = Math.abs(scaledDim);
                        textChunk.height += scaledDim;
                      }
                      if (scaledDim) {
                        textChunk.prevTransform = getCurrentTextTransform();
                      }
                      let glyphUnicode = glyph.unicode;
                      glyphUnicode = NormalizedUnicodes[glyphUnicode] || glyphUnicode;
                      glyphUnicode = (0, _unicode.reverseIfRtl)(glyphUnicode);
                      if (saveLastChar(glyphUnicode)) {
                        textChunk.str.push(" ");
                      }
                      textChunk.str.push(glyphUnicode);
                      if (charSpacing) {
                        if (!font.vertical) {
                          textState.translateTextMatrix(charSpacing * textState.textHScale, 0);
                        } else {
                          textState.translateTextMatrix(0, -charSpacing);
                        }
                      }
                    }
                  }
                  __name(buildTextContentItem, "buildTextContentItem");
                  function appendEOL() {
                    resetLastChars();
                    if (textContentItem.initialized) {
                      textContentItem.hasEOL = true;
                      flushTextContentItem();
                    } else {
                      textContent.items.push({
                        str: "",
                        dir: "ltr",
                        width: 0,
                        height: 0,
                        transform: getCurrentTextTransform(),
                        fontName: textState.font.loadedName,
                        hasEOL: true
                      });
                    }
                  }
                  __name(appendEOL, "appendEOL");
                  function addFakeSpaces(width, transf, textOrientation) {
                    if (textOrientation * textContentItem.spaceInFlowMin <= width && width <= textOrientation * textContentItem.spaceInFlowMax) {
                      if (textContentItem.initialized) {
                        resetLastChars();
                        textContentItem.str.push(" ");
                      }
                      return false;
                    }
                    const fontName = textContentItem.fontName;
                    let height = 0;
                    if (textContentItem.vertical) {
                      height = width;
                      width = 0;
                    }
                    flushTextContentItem();
                    resetLastChars();
                    textContent.items.push({
                      str: " ",
                      dir: "ltr",
                      width: Math.abs(width),
                      height: Math.abs(height),
                      transform: transf || getCurrentTextTransform(),
                      fontName,
                      hasEOL: false
                    });
                    return true;
                  }
                  __name(addFakeSpaces, "addFakeSpaces");
                  function flushTextContentItem() {
                    if (!textContentItem.initialized || !textContentItem.str) {
                      return;
                    }
                    if (!textContentItem.vertical) {
                      textContentItem.totalWidth += textContentItem.width * textContentItem.textAdvanceScale;
                    } else {
                      textContentItem.totalHeight += textContentItem.height * textContentItem.textAdvanceScale;
                    }
                    textContent.items.push(runBidiTransform(textContentItem));
                    textContentItem.initialized = false;
                    textContentItem.str.length = 0;
                  }
                  __name(flushTextContentItem, "flushTextContentItem");
                  function enqueueChunk() {
                    let batch = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                    const length = textContent.items.length;
                    if (length === 0) {
                      return;
                    }
                    if (batch && length < TEXT_CHUNK_BATCH_SIZE) {
                      return;
                    }
                    sink.enqueue(textContent, length);
                    textContent.items = [];
                    textContent.styles = /* @__PURE__ */ Object.create(null);
                  }
                  __name(enqueueChunk, "enqueueChunk");
                  const timeSlotManager = new TimeSlotManager();
                  return new Promise(/* @__PURE__ */ __name(function promiseBody(resolve, reject) {
                    const next = /* @__PURE__ */ __name(function(promise) {
                      enqueueChunk(true);
                      Promise.all([promise, sink.ready]).then(function() {
                        try {
                          promiseBody(resolve, reject);
                        } catch (ex) {
                          reject(ex);
                        }
                      }, reject);
                    }, "next");
                    task.ensureNotTerminated();
                    timeSlotManager.reset();
                    const operation = {};
                    let stop, args = [];
                    while (!(stop = timeSlotManager.check())) {
                      args.length = 0;
                      operation.args = args;
                      if (!preprocessor.read(operation)) {
                        break;
                      }
                      textState = stateManager.state;
                      const fn = operation.fn;
                      args = operation.args;
                      switch (fn | 0) {
                        case _util.OPS.setFont:
                          var fontNameArg = args[0].name, fontSizeArg = args[1];
                          if (textState.font && fontNameArg === textState.fontName && fontSizeArg === textState.fontSize) {
                            break;
                          }
                          flushTextContentItem();
                          textState.fontName = fontNameArg;
                          textState.fontSize = fontSizeArg;
                          next(handleSetFont(fontNameArg, null));
                          return;
                        case _util.OPS.setTextRise:
                          textState.textRise = args[0];
                          break;
                        case _util.OPS.setHScale:
                          textState.textHScale = args[0] / 100;
                          break;
                        case _util.OPS.setLeading:
                          textState.leading = args[0];
                          break;
                        case _util.OPS.moveText:
                          textState.translateTextLineMatrix(args[0], args[1]);
                          textState.textMatrix = textState.textLineMatrix.slice();
                          break;
                        case _util.OPS.setLeadingMoveText:
                          textState.leading = -args[1];
                          textState.translateTextLineMatrix(args[0], args[1]);
                          textState.textMatrix = textState.textLineMatrix.slice();
                          break;
                        case _util.OPS.nextLine:
                          textState.carriageReturn();
                          break;
                        case _util.OPS.setTextMatrix:
                          textState.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
                          textState.setTextLineMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
                          updateAdvanceScale();
                          break;
                        case _util.OPS.setCharSpacing:
                          textState.charSpacing = args[0];
                          break;
                        case _util.OPS.setWordSpacing:
                          textState.wordSpacing = args[0];
                          break;
                        case _util.OPS.beginText:
                          textState.textMatrix = _util.IDENTITY_MATRIX.slice();
                          textState.textLineMatrix = _util.IDENTITY_MATRIX.slice();
                          break;
                        case _util.OPS.showSpacedText:
                          if (!stateManager.state.font) {
                            self2.ensureStateFont(stateManager.state);
                            continue;
                          }
                          const spaceFactor = (textState.font.vertical ? 1 : -1) * textState.fontSize / 1e3;
                          const elements = args[0];
                          for (let i = 0, ii = elements.length; i < ii - 1; i++) {
                            const item2 = elements[i];
                            if (typeof item2 === "string") {
                              showSpacedTextBuffer.push(item2);
                            } else if (typeof item2 === "number" && item2 !== 0) {
                              const str = showSpacedTextBuffer.join("");
                              showSpacedTextBuffer.length = 0;
                              buildTextContentItem({
                                chars: str,
                                extraSpacing: item2 * spaceFactor
                              });
                            }
                          }
                          const item = elements.at(-1);
                          if (typeof item === "string") {
                            showSpacedTextBuffer.push(item);
                          }
                          if (showSpacedTextBuffer.length > 0) {
                            const str = showSpacedTextBuffer.join("");
                            showSpacedTextBuffer.length = 0;
                            buildTextContentItem({
                              chars: str,
                              extraSpacing: 0
                            });
                          }
                          break;
                        case _util.OPS.showText:
                          if (!stateManager.state.font) {
                            self2.ensureStateFont(stateManager.state);
                            continue;
                          }
                          buildTextContentItem({
                            chars: args[0],
                            extraSpacing: 0
                          });
                          break;
                        case _util.OPS.nextLineShowText:
                          if (!stateManager.state.font) {
                            self2.ensureStateFont(stateManager.state);
                            continue;
                          }
                          textState.carriageReturn();
                          buildTextContentItem({
                            chars: args[0],
                            extraSpacing: 0
                          });
                          break;
                        case _util.OPS.nextLineSetSpacingShowText:
                          if (!stateManager.state.font) {
                            self2.ensureStateFont(stateManager.state);
                            continue;
                          }
                          textState.wordSpacing = args[0];
                          textState.charSpacing = args[1];
                          textState.carriageReturn();
                          buildTextContentItem({
                            chars: args[2],
                            extraSpacing: 0
                          });
                          break;
                        case _util.OPS.paintXObject:
                          flushTextContentItem();
                          if (!xobjs) {
                            xobjs = resources.get("XObject") || _primitives.Dict.empty;
                          }
                          var isValidName = args[0] instanceof _primitives.Name;
                          var name = args[0].name;
                          if (isValidName && emptyXObjectCache.getByName(name)) {
                            break;
                          }
                          next(new Promise(function(resolveXObject, rejectXObject) {
                            if (!isValidName) {
                              throw new _util.FormatError("XObject must be referred to by name.");
                            }
                            let xobj = xobjs.getRaw(name);
                            if (xobj instanceof _primitives.Ref) {
                              if (emptyXObjectCache.getByRef(xobj)) {
                                resolveXObject();
                                return;
                              }
                              const globalImage = self2.globalImageCache.getData(xobj, self2.pageIndex);
                              if (globalImage) {
                                resolveXObject();
                                return;
                              }
                              xobj = xref.fetch(xobj);
                            }
                            if (!(xobj instanceof _base_stream.BaseStream)) {
                              throw new _util.FormatError("XObject should be a stream");
                            }
                            const type = xobj.dict.get("Subtype");
                            if (!(type instanceof _primitives.Name)) {
                              throw new _util.FormatError("XObject should have a Name subtype");
                            }
                            if (type.name !== "Form") {
                              emptyXObjectCache.set(name, xobj.dict.objId, true);
                              resolveXObject();
                              return;
                            }
                            const currentState = stateManager.state.clone();
                            const xObjStateManager = new StateManager(currentState);
                            const matrix = xobj.dict.getArray("Matrix");
                            if (Array.isArray(matrix) && matrix.length === 6) {
                              xObjStateManager.transform(matrix);
                            }
                            enqueueChunk();
                            const sinkWrapper = {
                              enqueueInvoked: false,
                              enqueue(chunk, size) {
                                this.enqueueInvoked = true;
                                sink.enqueue(chunk, size);
                              },
                              get desiredSize() {
                                return sink.desiredSize;
                              },
                              get ready() {
                                return sink.ready;
                              }
                            };
                            self2.getTextContent({
                              stream: xobj,
                              task,
                              resources: xobj.dict.get("Resources") || resources,
                              stateManager: xObjStateManager,
                              combineTextItems,
                              includeMarkedContent,
                              sink: sinkWrapper,
                              seenStyles,
                              viewBox
                            }).then(function() {
                              if (!sinkWrapper.enqueueInvoked) {
                                emptyXObjectCache.set(name, xobj.dict.objId, true);
                              }
                              resolveXObject();
                            }, rejectXObject);
                          }).catch(function(reason) {
                            if (reason instanceof _util.AbortException) {
                              return;
                            }
                            if (self2.options.ignoreErrors) {
                              (0, _util.warn)(`getTextContent - ignoring XObject: "${reason}".`);
                              return;
                            }
                            throw reason;
                          }));
                          return;
                        case _util.OPS.setGState:
                          isValidName = args[0] instanceof _primitives.Name;
                          name = args[0].name;
                          if (isValidName && emptyGStateCache.getByName(name)) {
                            break;
                          }
                          next(new Promise(function(resolveGState, rejectGState) {
                            if (!isValidName) {
                              throw new _util.FormatError("GState must be referred to by name.");
                            }
                            const extGState = resources.get("ExtGState");
                            if (!(extGState instanceof _primitives.Dict)) {
                              throw new _util.FormatError("ExtGState should be a dictionary.");
                            }
                            const gState = extGState.get(name);
                            if (!(gState instanceof _primitives.Dict)) {
                              throw new _util.FormatError("GState should be a dictionary.");
                            }
                            const gStateFont = gState.get("Font");
                            if (!gStateFont) {
                              emptyGStateCache.set(name, gState.objId, true);
                              resolveGState();
                              return;
                            }
                            flushTextContentItem();
                            textState.fontName = null;
                            textState.fontSize = gStateFont[1];
                            handleSetFont(null, gStateFont[0]).then(resolveGState, rejectGState);
                          }).catch(function(reason) {
                            if (reason instanceof _util.AbortException) {
                              return;
                            }
                            if (self2.options.ignoreErrors) {
                              (0, _util.warn)(`getTextContent - ignoring ExtGState: "${reason}".`);
                              return;
                            }
                            throw reason;
                          }));
                          return;
                        case _util.OPS.beginMarkedContent:
                          flushTextContentItem();
                          if (includeMarkedContent) {
                            textContent.items.push({
                              type: "beginMarkedContent",
                              tag: args[0] instanceof _primitives.Name ? args[0].name : null
                            });
                          }
                          break;
                        case _util.OPS.beginMarkedContentProps:
                          flushTextContentItem();
                          if (includeMarkedContent) {
                            let mcid = null;
                            if (args[1] instanceof _primitives.Dict) {
                              mcid = args[1].get("MCID");
                            }
                            textContent.items.push({
                              type: "beginMarkedContentProps",
                              id: Number.isInteger(mcid) ? `${self2.idFactory.getPageObjId()}_mcid${mcid}` : null,
                              tag: args[0] instanceof _primitives.Name ? args[0].name : null
                            });
                          }
                          break;
                        case _util.OPS.endMarkedContent:
                          flushTextContentItem();
                          if (includeMarkedContent) {
                            textContent.items.push({
                              type: "endMarkedContent"
                            });
                          }
                          break;
                      }
                      if (textContent.items.length >= sink.desiredSize) {
                        stop = true;
                        break;
                      }
                    }
                    if (stop) {
                      next(deferred);
                      return;
                    }
                    flushTextContentItem();
                    enqueueChunk();
                    resolve();
                  }, "promiseBody")).catch((reason) => {
                    if (reason instanceof _util.AbortException) {
                      return;
                    }
                    if (this.options.ignoreErrors) {
                      (0, _util.warn)(`getTextContent - ignoring errors during "${task.name}" task: "${reason}".`);
                      flushTextContentItem();
                      enqueueChunk();
                      return;
                    }
                    throw reason;
                  });
                }
                extractDataStructures(dict, baseDict, properties) {
                  const xref = this.xref;
                  let cidToGidBytes;
                  const toUnicodePromise = this.readToUnicode(properties.toUnicode || dict.get("ToUnicode") || baseDict.get("ToUnicode"));
                  if (properties.composite) {
                    const cidSystemInfo = dict.get("CIDSystemInfo");
                    if (cidSystemInfo instanceof _primitives.Dict) {
                      properties.cidSystemInfo = {
                        registry: (0, _util.stringToPDFString)(cidSystemInfo.get("Registry")),
                        ordering: (0, _util.stringToPDFString)(cidSystemInfo.get("Ordering")),
                        supplement: cidSystemInfo.get("Supplement")
                      };
                    }
                    try {
                      const cidToGidMap = dict.get("CIDToGIDMap");
                      if (cidToGidMap instanceof _base_stream.BaseStream) {
                        cidToGidBytes = cidToGidMap.getBytes();
                      }
                    } catch (ex) {
                      if (!this.options.ignoreErrors) {
                        throw ex;
                      }
                      (0, _util.warn)(`extractDataStructures - ignoring CIDToGIDMap data: "${ex}".`);
                    }
                  }
                  const differences = [];
                  let baseEncodingName = null;
                  let encoding;
                  if (dict.has("Encoding")) {
                    encoding = dict.get("Encoding");
                    if (encoding instanceof _primitives.Dict) {
                      baseEncodingName = encoding.get("BaseEncoding");
                      baseEncodingName = baseEncodingName instanceof _primitives.Name ? baseEncodingName.name : null;
                      if (encoding.has("Differences")) {
                        const diffEncoding = encoding.get("Differences");
                        let index = 0;
                        for (let j = 0, jj = diffEncoding.length; j < jj; j++) {
                          const data = xref.fetchIfRef(diffEncoding[j]);
                          if (typeof data === "number") {
                            index = data;
                          } else if (data instanceof _primitives.Name) {
                            differences[index++] = data.name;
                          } else {
                            throw new _util.FormatError(`Invalid entry in 'Differences' array: ${data}`);
                          }
                        }
                      }
                    } else if (encoding instanceof _primitives.Name) {
                      baseEncodingName = encoding.name;
                    } else {
                      const msg = "Encoding is not a Name nor a Dict";
                      if (!this.options.ignoreErrors) {
                        throw new _util.FormatError(msg);
                      }
                      (0, _util.warn)(msg);
                    }
                    if (baseEncodingName !== "MacRomanEncoding" && baseEncodingName !== "MacExpertEncoding" && baseEncodingName !== "WinAnsiEncoding") {
                      baseEncodingName = null;
                    }
                  }
                  if (baseEncodingName) {
                    properties.defaultEncoding = (0, _encodings.getEncoding)(baseEncodingName);
                  } else {
                    const isSymbolicFont = !!(properties.flags & _fonts_utils.FontFlags.Symbolic);
                    const isNonsymbolicFont = !!(properties.flags & _fonts_utils.FontFlags.Nonsymbolic);
                    encoding = _encodings.StandardEncoding;
                    if (properties.type === "TrueType" && !isNonsymbolicFont) {
                      encoding = _encodings.WinAnsiEncoding;
                    }
                    if (isSymbolicFont) {
                      encoding = _encodings.MacRomanEncoding;
                      if (!properties.file || properties.isInternalFont) {
                        if (/Symbol/i.test(properties.name)) {
                          encoding = _encodings.SymbolSetEncoding;
                        } else if (/Dingbats|Wingdings/i.test(properties.name)) {
                          encoding = _encodings.ZapfDingbatsEncoding;
                        }
                      }
                    }
                    properties.defaultEncoding = encoding;
                  }
                  properties.differences = differences;
                  properties.baseEncodingName = baseEncodingName;
                  properties.hasEncoding = !!baseEncodingName || differences.length > 0;
                  properties.dict = dict;
                  return toUnicodePromise.then((readToUnicode) => {
                    properties.toUnicode = readToUnicode;
                    return this.buildToUnicode(properties);
                  }).then((builtToUnicode) => {
                    properties.toUnicode = builtToUnicode;
                    if (cidToGidBytes) {
                      properties.cidToGidMap = this.readCidToGidMap(cidToGidBytes, builtToUnicode);
                    }
                    return properties;
                  });
                }
                _simpleFontToUnicode(properties) {
                  let forceGlyphs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  (0, _util.assert)(!properties.composite, "Must be a simple font.");
                  const toUnicode = [];
                  const encoding = properties.defaultEncoding.slice();
                  const baseEncodingName = properties.baseEncodingName;
                  const differences = properties.differences;
                  for (const charcode in differences) {
                    const glyphName = differences[charcode];
                    if (glyphName === ".notdef") {
                      continue;
                    }
                    encoding[charcode] = glyphName;
                  }
                  const glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
                  for (const charcode in encoding) {
                    let glyphName = encoding[charcode];
                    if (glyphName === "") {
                      continue;
                    } else if (glyphsUnicodeMap[glyphName] === void 0) {
                      let code = 0;
                      switch (glyphName[0]) {
                        case "G":
                          if (glyphName.length === 3) {
                            code = parseInt(glyphName.substring(1), 16);
                          }
                          break;
                        case "g":
                          if (glyphName.length === 5) {
                            code = parseInt(glyphName.substring(1), 16);
                          }
                          break;
                        case "C":
                        case "c":
                          if (glyphName.length >= 3 && glyphName.length <= 4) {
                            const codeStr = glyphName.substring(1);
                            if (forceGlyphs) {
                              code = parseInt(codeStr, 16);
                              break;
                            }
                            code = +codeStr;
                            if (Number.isNaN(code) && Number.isInteger(parseInt(codeStr, 16))) {
                              return this._simpleFontToUnicode(properties, true);
                            }
                          }
                          break;
                        default:
                          const unicode = (0, _unicode.getUnicodeForGlyph)(glyphName, glyphsUnicodeMap);
                          if (unicode !== -1) {
                            code = unicode;
                          }
                      }
                      if (code > 0 && code <= 1114111 && Number.isInteger(code)) {
                        if (baseEncodingName && code === +charcode) {
                          const baseEncoding = (0, _encodings.getEncoding)(baseEncodingName);
                          if (baseEncoding && (glyphName = baseEncoding[charcode])) {
                            toUnicode[charcode] = String.fromCharCode(glyphsUnicodeMap[glyphName]);
                            continue;
                          }
                        }
                        toUnicode[charcode] = String.fromCodePoint(code);
                      }
                      continue;
                    }
                    toUnicode[charcode] = String.fromCharCode(glyphsUnicodeMap[glyphName]);
                  }
                  return toUnicode;
                }
                async buildToUnicode(properties) {
                  properties.hasIncludedToUnicodeMap = !!properties.toUnicode && properties.toUnicode.length > 0;
                  if (properties.hasIncludedToUnicodeMap) {
                    if (!properties.composite && properties.hasEncoding) {
                      properties.fallbackToUnicode = this._simpleFontToUnicode(properties);
                    }
                    return properties.toUnicode;
                  }
                  if (!properties.composite) {
                    return new _to_unicode_map.ToUnicodeMap(this._simpleFontToUnicode(properties));
                  }
                  if (properties.composite && (properties.cMap.builtInCMap && !(properties.cMap instanceof _cmap.IdentityCMap) || properties.cidSystemInfo.registry === "Adobe" && (properties.cidSystemInfo.ordering === "GB1" || properties.cidSystemInfo.ordering === "CNS1" || properties.cidSystemInfo.ordering === "Japan1" || properties.cidSystemInfo.ordering === "Korea1"))) {
                    const {
                      registry,
                      ordering
                    } = properties.cidSystemInfo;
                    const ucs2CMapName = _primitives.Name.get(`${registry}-${ordering}-UCS2`);
                    const ucs2CMap = await _cmap.CMapFactory.create({
                      encoding: ucs2CMapName,
                      fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                      useCMap: null
                    });
                    const toUnicode = [];
                    properties.cMap.forEach(function(charcode, cid) {
                      if (cid > 65535) {
                        throw new _util.FormatError("Max size of CID is 65,535");
                      }
                      const ucs2 = ucs2CMap.lookup(cid);
                      if (ucs2) {
                        toUnicode[charcode] = String.fromCharCode((ucs2.charCodeAt(0) << 8) + ucs2.charCodeAt(1));
                      }
                    });
                    return new _to_unicode_map.ToUnicodeMap(toUnicode);
                  }
                  return new _to_unicode_map.IdentityToUnicodeMap(properties.firstChar, properties.lastChar);
                }
                readToUnicode(cmapObj) {
                  if (!cmapObj) {
                    return Promise.resolve(null);
                  }
                  if (cmapObj instanceof _primitives.Name) {
                    return _cmap.CMapFactory.create({
                      encoding: cmapObj,
                      fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                      useCMap: null
                    }).then(function(cmap) {
                      if (cmap instanceof _cmap.IdentityCMap) {
                        return new _to_unicode_map.IdentityToUnicodeMap(0, 65535);
                      }
                      return new _to_unicode_map.ToUnicodeMap(cmap.getMap());
                    });
                  } else if (cmapObj instanceof _base_stream.BaseStream) {
                    return _cmap.CMapFactory.create({
                      encoding: cmapObj,
                      fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                      useCMap: null
                    }).then(function(cmap) {
                      if (cmap instanceof _cmap.IdentityCMap) {
                        return new _to_unicode_map.IdentityToUnicodeMap(0, 65535);
                      }
                      const map = new Array(cmap.length);
                      cmap.forEach(function(charCode, token) {
                        if (typeof token === "number") {
                          map[charCode] = String.fromCodePoint(token);
                          return;
                        }
                        const str = [];
                        for (let k = 0; k < token.length; k += 2) {
                          const w1 = token.charCodeAt(k) << 8 | token.charCodeAt(k + 1);
                          if ((w1 & 63488) !== 55296) {
                            str.push(w1);
                            continue;
                          }
                          k += 2;
                          const w2 = token.charCodeAt(k) << 8 | token.charCodeAt(k + 1);
                          str.push(((w1 & 1023) << 10) + (w2 & 1023) + 65536);
                        }
                        map[charCode] = String.fromCodePoint(...str);
                      });
                      return new _to_unicode_map.ToUnicodeMap(map);
                    }, (reason) => {
                      if (reason instanceof _util.AbortException) {
                        return null;
                      }
                      if (this.options.ignoreErrors) {
                        this.handler.send("UnsupportedFeature", {
                          featureId: _util.UNSUPPORTED_FEATURES.errorFontToUnicode
                        });
                        (0, _util.warn)(`readToUnicode - ignoring ToUnicode data: "${reason}".`);
                        return null;
                      }
                      throw reason;
                    });
                  }
                  return Promise.resolve(null);
                }
                readCidToGidMap(glyphsData, toUnicode) {
                  const result = [];
                  for (let j = 0, jj = glyphsData.length; j < jj; j++) {
                    const glyphID = glyphsData[j++] << 8 | glyphsData[j];
                    const code = j >> 1;
                    if (glyphID === 0 && !toUnicode.has(code)) {
                      continue;
                    }
                    result[code] = glyphID;
                  }
                  return result;
                }
                extractWidths(dict, descriptor, properties) {
                  const xref = this.xref;
                  let glyphsWidths = [];
                  let defaultWidth = 0;
                  const glyphsVMetrics = [];
                  let defaultVMetrics;
                  let i, ii, j, jj, start, code, widths;
                  if (properties.composite) {
                    defaultWidth = dict.has("DW") ? dict.get("DW") : 1e3;
                    widths = dict.get("W");
                    if (widths) {
                      for (i = 0, ii = widths.length; i < ii; i++) {
                        start = xref.fetchIfRef(widths[i++]);
                        code = xref.fetchIfRef(widths[i]);
                        if (Array.isArray(code)) {
                          for (j = 0, jj = code.length; j < jj; j++) {
                            glyphsWidths[start++] = xref.fetchIfRef(code[j]);
                          }
                        } else {
                          const width = xref.fetchIfRef(widths[++i]);
                          for (j = start; j <= code; j++) {
                            glyphsWidths[j] = width;
                          }
                        }
                      }
                    }
                    if (properties.vertical) {
                      let vmetrics = dict.getArray("DW2") || [880, -1e3];
                      defaultVMetrics = [vmetrics[1], defaultWidth * 0.5, vmetrics[0]];
                      vmetrics = dict.get("W2");
                      if (vmetrics) {
                        for (i = 0, ii = vmetrics.length; i < ii; i++) {
                          start = xref.fetchIfRef(vmetrics[i++]);
                          code = xref.fetchIfRef(vmetrics[i]);
                          if (Array.isArray(code)) {
                            for (j = 0, jj = code.length; j < jj; j++) {
                              glyphsVMetrics[start++] = [xref.fetchIfRef(code[j++]), xref.fetchIfRef(code[j++]), xref.fetchIfRef(code[j])];
                            }
                          } else {
                            const vmetric = [xref.fetchIfRef(vmetrics[++i]), xref.fetchIfRef(vmetrics[++i]), xref.fetchIfRef(vmetrics[++i])];
                            for (j = start; j <= code; j++) {
                              glyphsVMetrics[j] = vmetric;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    const firstChar = properties.firstChar;
                    widths = dict.get("Widths");
                    if (widths) {
                      j = firstChar;
                      for (i = 0, ii = widths.length; i < ii; i++) {
                        glyphsWidths[j++] = xref.fetchIfRef(widths[i]);
                      }
                      defaultWidth = parseFloat(descriptor.get("MissingWidth")) || 0;
                    } else {
                      const baseFontName = dict.get("BaseFont");
                      if (baseFontName instanceof _primitives.Name) {
                        const metrics = this.getBaseFontMetrics(baseFontName.name);
                        glyphsWidths = this.buildCharCodeToWidth(metrics.widths, properties);
                        defaultWidth = metrics.defaultWidth;
                      }
                    }
                  }
                  let isMonospace = true;
                  let firstWidth = defaultWidth;
                  for (const glyph in glyphsWidths) {
                    const glyphWidth = glyphsWidths[glyph];
                    if (!glyphWidth) {
                      continue;
                    }
                    if (!firstWidth) {
                      firstWidth = glyphWidth;
                      continue;
                    }
                    if (firstWidth !== glyphWidth) {
                      isMonospace = false;
                      break;
                    }
                  }
                  if (isMonospace) {
                    properties.flags |= _fonts_utils.FontFlags.FixedPitch;
                  }
                  properties.defaultWidth = defaultWidth;
                  properties.widths = glyphsWidths;
                  properties.defaultVMetrics = defaultVMetrics;
                  properties.vmetrics = glyphsVMetrics;
                }
                isSerifFont(baseFontName) {
                  const fontNameWoStyle = baseFontName.split("-")[0];
                  return fontNameWoStyle in (0, _standard_fonts.getSerifFonts)() || fontNameWoStyle.search(/serif/gi) !== -1;
                }
                getBaseFontMetrics(name) {
                  let defaultWidth = 0;
                  let widths = /* @__PURE__ */ Object.create(null);
                  let monospace = false;
                  const stdFontMap = (0, _standard_fonts.getStdFontMap)();
                  let lookupName = stdFontMap[name] || name;
                  const Metrics = (0, _metrics.getMetrics)();
                  if (!(lookupName in Metrics)) {
                    if (this.isSerifFont(name)) {
                      lookupName = "Times-Roman";
                    } else {
                      lookupName = "Helvetica";
                    }
                  }
                  const glyphWidths = Metrics[lookupName];
                  if (typeof glyphWidths === "number") {
                    defaultWidth = glyphWidths;
                    monospace = true;
                  } else {
                    widths = glyphWidths();
                  }
                  return {
                    defaultWidth,
                    monospace,
                    widths
                  };
                }
                buildCharCodeToWidth(widthsByGlyphName, properties) {
                  const widths = /* @__PURE__ */ Object.create(null);
                  const differences = properties.differences;
                  const encoding = properties.defaultEncoding;
                  for (let charCode = 0; charCode < 256; charCode++) {
                    if (charCode in differences && widthsByGlyphName[differences[charCode]]) {
                      widths[charCode] = widthsByGlyphName[differences[charCode]];
                      continue;
                    }
                    if (charCode in encoding && widthsByGlyphName[encoding[charCode]]) {
                      widths[charCode] = widthsByGlyphName[encoding[charCode]];
                      continue;
                    }
                  }
                  return widths;
                }
                preEvaluateFont(dict) {
                  const baseDict = dict;
                  let type = dict.get("Subtype");
                  if (!(type instanceof _primitives.Name)) {
                    throw new _util.FormatError("invalid font Subtype");
                  }
                  let composite = false;
                  let hash, toUnicode;
                  if (type.name === "Type0") {
                    const df = dict.get("DescendantFonts");
                    if (!df) {
                      throw new _util.FormatError("Descendant fonts are not specified");
                    }
                    dict = Array.isArray(df) ? this.xref.fetchIfRef(df[0]) : df;
                    if (!(dict instanceof _primitives.Dict)) {
                      throw new _util.FormatError("Descendant font is not a dictionary.");
                    }
                    type = dict.get("Subtype");
                    if (!(type instanceof _primitives.Name)) {
                      throw new _util.FormatError("invalid font Subtype");
                    }
                    composite = true;
                  }
                  const firstChar = dict.get("FirstChar") || 0, lastChar = dict.get("LastChar") || (composite ? 65535 : 255);
                  const descriptor = dict.get("FontDescriptor");
                  if (descriptor) {
                    hash = new _murmurhash.MurmurHash3_64();
                    const encoding = baseDict.getRaw("Encoding");
                    if (encoding instanceof _primitives.Name) {
                      hash.update(encoding.name);
                    } else if (encoding instanceof _primitives.Ref) {
                      hash.update(encoding.toString());
                    } else if (encoding instanceof _primitives.Dict) {
                      for (const entry of encoding.getRawValues()) {
                        if (entry instanceof _primitives.Name) {
                          hash.update(entry.name);
                        } else if (entry instanceof _primitives.Ref) {
                          hash.update(entry.toString());
                        } else if (Array.isArray(entry)) {
                          const diffLength = entry.length, diffBuf = new Array(diffLength);
                          for (let j = 0; j < diffLength; j++) {
                            const diffEntry = entry[j];
                            if (diffEntry instanceof _primitives.Name) {
                              diffBuf[j] = diffEntry.name;
                            } else if (typeof diffEntry === "number" || diffEntry instanceof _primitives.Ref) {
                              diffBuf[j] = diffEntry.toString();
                            }
                          }
                          hash.update(diffBuf.join());
                        }
                      }
                    }
                    hash.update(`${firstChar}-${lastChar}`);
                    toUnicode = dict.get("ToUnicode") || baseDict.get("ToUnicode");
                    if (toUnicode instanceof _base_stream.BaseStream) {
                      const stream = toUnicode.str || toUnicode;
                      const uint8array = stream.buffer ? new Uint8Array(stream.buffer.buffer, 0, stream.bufferLength) : new Uint8Array(stream.bytes.buffer, stream.start, stream.end - stream.start);
                      hash.update(uint8array);
                    } else if (toUnicode instanceof _primitives.Name) {
                      hash.update(toUnicode.name);
                    }
                    const widths = dict.get("Widths") || baseDict.get("Widths");
                    if (Array.isArray(widths)) {
                      const widthsBuf = [];
                      for (const entry of widths) {
                        if (typeof entry === "number" || entry instanceof _primitives.Ref) {
                          widthsBuf.push(entry.toString());
                        }
                      }
                      hash.update(widthsBuf.join());
                    }
                    if (composite) {
                      hash.update("compositeFont");
                      const compositeWidths = dict.get("W") || baseDict.get("W");
                      if (Array.isArray(compositeWidths)) {
                        const widthsBuf = [];
                        for (const entry of compositeWidths) {
                          if (typeof entry === "number" || entry instanceof _primitives.Ref) {
                            widthsBuf.push(entry.toString());
                          } else if (Array.isArray(entry)) {
                            const subWidthsBuf = [];
                            for (const element of entry) {
                              if (typeof element === "number" || element instanceof _primitives.Ref) {
                                subWidthsBuf.push(element.toString());
                              }
                            }
                            widthsBuf.push(`[${subWidthsBuf.join()}]`);
                          }
                        }
                        hash.update(widthsBuf.join());
                      }
                      const cidToGidMap = dict.getRaw("CIDToGIDMap") || baseDict.getRaw("CIDToGIDMap");
                      if (cidToGidMap instanceof _primitives.Name) {
                        hash.update(cidToGidMap.name);
                      } else if (cidToGidMap instanceof _primitives.Ref) {
                        hash.update(cidToGidMap.toString());
                      } else if (cidToGidMap instanceof _base_stream.BaseStream) {
                        hash.update(cidToGidMap.peekBytes());
                      }
                    }
                  }
                  return {
                    descriptor,
                    dict,
                    baseDict,
                    composite,
                    type: type.name,
                    firstChar,
                    lastChar,
                    toUnicode,
                    hash: hash ? hash.hexdigest() : ""
                  };
                }
                async translateFont(_ref9) {
                  let {
                    descriptor,
                    dict,
                    baseDict,
                    composite,
                    type,
                    firstChar,
                    lastChar,
                    toUnicode,
                    cssFontInfo
                  } = _ref9;
                  const isType3Font = type === "Type3";
                  let properties;
                  if (!descriptor) {
                    if (isType3Font) {
                      descriptor = new _primitives.Dict(null);
                      descriptor.set("FontName", _primitives.Name.get(type));
                      descriptor.set("FontBBox", dict.getArray("FontBBox") || [0, 0, 0, 0]);
                    } else {
                      let baseFontName = dict.get("BaseFont");
                      if (!(baseFontName instanceof _primitives.Name)) {
                        throw new _util.FormatError("Base font is not specified");
                      }
                      baseFontName = baseFontName.name.replace(/[,_]/g, "-");
                      const metrics = this.getBaseFontMetrics(baseFontName);
                      const fontNameWoStyle = baseFontName.split("-")[0];
                      const flags = (this.isSerifFont(fontNameWoStyle) ? _fonts_utils.FontFlags.Serif : 0) | (metrics.monospace ? _fonts_utils.FontFlags.FixedPitch : 0) | ((0, _standard_fonts.getSymbolsFonts)()[fontNameWoStyle] ? _fonts_utils.FontFlags.Symbolic : _fonts_utils.FontFlags.Nonsymbolic);
                      properties = {
                        type,
                        name: baseFontName,
                        loadedName: baseDict.loadedName,
                        widths: metrics.widths,
                        defaultWidth: metrics.defaultWidth,
                        isSimulatedFlags: true,
                        flags,
                        firstChar,
                        lastChar,
                        toUnicode,
                        xHeight: 0,
                        capHeight: 0,
                        italicAngle: 0,
                        isType3Font
                      };
                      const widths = dict.get("Widths");
                      const standardFontName = (0, _standard_fonts.getStandardFontName)(baseFontName);
                      let file = null;
                      if (standardFontName) {
                        properties.isStandardFont = true;
                        file = await this.fetchStandardFontData(standardFontName);
                        properties.isInternalFont = !!file;
                      }
                      return this.extractDataStructures(dict, dict, properties).then((newProperties) => {
                        if (widths) {
                          const glyphWidths = [];
                          let j = firstChar;
                          for (let i = 0, ii = widths.length; i < ii; i++) {
                            glyphWidths[j++] = this.xref.fetchIfRef(widths[i]);
                          }
                          newProperties.widths = glyphWidths;
                        } else {
                          newProperties.widths = this.buildCharCodeToWidth(metrics.widths, newProperties);
                        }
                        return new _fonts.Font(baseFontName, file, newProperties);
                      });
                    }
                  }
                  let fontName = descriptor.get("FontName");
                  let baseFont = dict.get("BaseFont");
                  if (typeof fontName === "string") {
                    fontName = _primitives.Name.get(fontName);
                  }
                  if (typeof baseFont === "string") {
                    baseFont = _primitives.Name.get(baseFont);
                  }
                  if (!isType3Font) {
                    const fontNameStr = fontName && fontName.name;
                    const baseFontStr = baseFont && baseFont.name;
                    if (fontNameStr !== baseFontStr) {
                      (0, _util.info)(`The FontDescriptor's FontName is "${fontNameStr}" but should be the same as the Font's BaseFont "${baseFontStr}".`);
                      if (fontNameStr && baseFontStr && baseFontStr.startsWith(fontNameStr)) {
                        fontName = baseFont;
                      }
                    }
                  }
                  fontName = fontName || baseFont;
                  if (!(fontName instanceof _primitives.Name)) {
                    throw new _util.FormatError("invalid font name");
                  }
                  let fontFile, subtype, length1, length2, length3;
                  try {
                    fontFile = descriptor.get("FontFile", "FontFile2", "FontFile3");
                  } catch (ex) {
                    if (!this.options.ignoreErrors) {
                      throw ex;
                    }
                    (0, _util.warn)(`translateFont - fetching "${fontName.name}" font file: "${ex}".`);
                    fontFile = new _stream.NullStream();
                  }
                  let isStandardFont = false;
                  let isInternalFont = false;
                  let glyphScaleFactors = null;
                  if (fontFile) {
                    if (fontFile.dict) {
                      const subtypeEntry = fontFile.dict.get("Subtype");
                      if (subtypeEntry instanceof _primitives.Name) {
                        subtype = subtypeEntry.name;
                      }
                      length1 = fontFile.dict.get("Length1");
                      length2 = fontFile.dict.get("Length2");
                      length3 = fontFile.dict.get("Length3");
                    }
                  } else if (cssFontInfo) {
                    const standardFontName = (0, _xfa_fonts.getXfaFontName)(fontName.name);
                    if (standardFontName) {
                      cssFontInfo.fontFamily = `${cssFontInfo.fontFamily}-PdfJS-XFA`;
                      cssFontInfo.metrics = standardFontName.metrics || null;
                      glyphScaleFactors = standardFontName.factors || null;
                      fontFile = await this.fetchStandardFontData(standardFontName.name);
                      isInternalFont = !!fontFile;
                      baseDict = dict = (0, _xfa_fonts.getXfaFontDict)(fontName.name);
                      composite = true;
                    }
                  } else if (!isType3Font) {
                    const standardFontName = (0, _standard_fonts.getStandardFontName)(fontName.name);
                    if (standardFontName) {
                      isStandardFont = true;
                      fontFile = await this.fetchStandardFontData(standardFontName);
                      isInternalFont = !!fontFile;
                    }
                  }
                  properties = {
                    type,
                    name: fontName.name,
                    subtype,
                    file: fontFile,
                    length1,
                    length2,
                    length3,
                    isStandardFont,
                    isInternalFont,
                    loadedName: baseDict.loadedName,
                    composite,
                    fixedPitch: false,
                    fontMatrix: dict.getArray("FontMatrix") || _util.FONT_IDENTITY_MATRIX,
                    firstChar,
                    lastChar,
                    toUnicode,
                    bbox: descriptor.getArray("FontBBox") || dict.getArray("FontBBox"),
                    ascent: descriptor.get("Ascent"),
                    descent: descriptor.get("Descent"),
                    xHeight: descriptor.get("XHeight") || 0,
                    capHeight: descriptor.get("CapHeight") || 0,
                    flags: descriptor.get("Flags"),
                    italicAngle: descriptor.get("ItalicAngle") || 0,
                    isType3Font,
                    cssFontInfo,
                    scaleFactors: glyphScaleFactors
                  };
                  if (composite) {
                    const cidEncoding = baseDict.get("Encoding");
                    if (cidEncoding instanceof _primitives.Name) {
                      properties.cidEncoding = cidEncoding.name;
                    }
                    const cMap = await _cmap.CMapFactory.create({
                      encoding: cidEncoding,
                      fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                      useCMap: null
                    });
                    properties.cMap = cMap;
                    properties.vertical = properties.cMap.vertical;
                  }
                  return this.extractDataStructures(dict, baseDict, properties).then((newProperties) => {
                    this.extractWidths(dict, descriptor, newProperties);
                    return new _fonts.Font(fontName.name, fontFile, newProperties);
                  });
                }
                static buildFontPaths(font, glyphs, handler, evaluatorOptions) {
                  function buildPath(fontChar) {
                    const glyphName = `${font.loadedName}_path_${fontChar}`;
                    try {
                      if (font.renderer.hasBuiltPath(fontChar)) {
                        return;
                      }
                      handler.send("commonobj", [glyphName, "FontPath", font.renderer.getPathJs(fontChar)]);
                    } catch (reason) {
                      if (evaluatorOptions.ignoreErrors) {
                        handler.send("UnsupportedFeature", {
                          featureId: _util.UNSUPPORTED_FEATURES.errorFontBuildPath
                        });
                        (0, _util.warn)(`buildFontPaths - ignoring ${glyphName} glyph: "${reason}".`);
                        return;
                      }
                      throw reason;
                    }
                  }
                  __name(buildPath, "buildPath");
                  for (const glyph of glyphs) {
                    buildPath(glyph.fontChar);
                    const accent = glyph.accent;
                    if (accent && accent.fontChar) {
                      buildPath(accent.fontChar);
                    }
                  }
                }
                static get fallbackFontDict() {
                  const dict = new _primitives.Dict();
                  dict.set("BaseFont", _primitives.Name.get("PDFJS-FallbackFont"));
                  dict.set("Type", _primitives.Name.get("FallbackType"));
                  dict.set("Subtype", _primitives.Name.get("FallbackType"));
                  dict.set("Encoding", _primitives.Name.get("WinAnsiEncoding"));
                  return (0, _util.shadow)(this, "fallbackFontDict", dict);
                }
              };
              __name(_PartialEvaluator, "PartialEvaluator");
              let PartialEvaluator = _PartialEvaluator;
              exports2.PartialEvaluator = PartialEvaluator;
              const _TranslatedFont = class _TranslatedFont {
                constructor(_ref10) {
                  let {
                    loadedName,
                    font,
                    dict,
                    evaluatorOptions
                  } = _ref10;
                  this.loadedName = loadedName;
                  this.font = font;
                  this.dict = dict;
                  this._evaluatorOptions = evaluatorOptions || DefaultPartialEvaluatorOptions;
                  this.type3Loaded = null;
                  this.type3Dependencies = font.isType3Font ? /* @__PURE__ */ new Set() : null;
                  this.sent = false;
                }
                send(handler) {
                  if (this.sent) {
                    return;
                  }
                  this.sent = true;
                  handler.send("commonobj", [this.loadedName, "Font", this.font.exportData(this._evaluatorOptions.fontExtraProperties)]);
                }
                fallback(handler) {
                  if (!this.font.data) {
                    return;
                  }
                  this.font.disableFontFace = true;
                  PartialEvaluator.buildFontPaths(this.font, this.font.glyphCacheValues, handler, this._evaluatorOptions);
                }
                loadType3Data(evaluator, resources, task) {
                  if (this.type3Loaded) {
                    return this.type3Loaded;
                  }
                  if (!this.font.isType3Font) {
                    throw new Error("Must be a Type3 font.");
                  }
                  const type3Evaluator = evaluator.clone({
                    ignoreErrors: false
                  });
                  type3Evaluator.parsingType3Font = true;
                  const type3FontRefs = new _primitives.RefSet(evaluator.type3FontRefs);
                  if (this.dict.objId && !type3FontRefs.has(this.dict.objId)) {
                    type3FontRefs.put(this.dict.objId);
                  }
                  type3Evaluator.type3FontRefs = type3FontRefs;
                  const translatedFont = this.font, type3Dependencies = this.type3Dependencies;
                  let loadCharProcsPromise = Promise.resolve();
                  const charProcs = this.dict.get("CharProcs");
                  const fontResources = this.dict.get("Resources") || resources;
                  const charProcOperatorList = /* @__PURE__ */ Object.create(null);
                  const fontBBox = _util.Util.normalizeRect(translatedFont.bbox || [0, 0, 0, 0]), width = fontBBox[2] - fontBBox[0], height = fontBBox[3] - fontBBox[1];
                  const fontBBoxSize = Math.hypot(width, height);
                  for (const key of charProcs.getKeys()) {
                    loadCharProcsPromise = loadCharProcsPromise.then(() => {
                      const glyphStream = charProcs.get(key);
                      const operatorList = new _operator_list.OperatorList();
                      return type3Evaluator.getOperatorList({
                        stream: glyphStream,
                        task,
                        resources: fontResources,
                        operatorList
                      }).then(() => {
                        if (operatorList.fnArray[0] === _util.OPS.setCharWidthAndBounds) {
                          this._removeType3ColorOperators(operatorList, fontBBoxSize);
                        }
                        charProcOperatorList[key] = operatorList.getIR();
                        for (const dependency of operatorList.dependencies) {
                          type3Dependencies.add(dependency);
                        }
                      }).catch(function(reason) {
                        (0, _util.warn)(`Type3 font resource "${key}" is not available.`);
                        const dummyOperatorList = new _operator_list.OperatorList();
                        charProcOperatorList[key] = dummyOperatorList.getIR();
                      });
                    });
                  }
                  this.type3Loaded = loadCharProcsPromise.then(() => {
                    translatedFont.charProcOperatorList = charProcOperatorList;
                    if (this._bbox) {
                      translatedFont.isCharBBox = true;
                      translatedFont.bbox = this._bbox;
                    }
                  });
                  return this.type3Loaded;
                }
                _removeType3ColorOperators(operatorList) {
                  let fontBBoxSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : NaN;
                  const charBBox = _util.Util.normalizeRect(operatorList.argsArray[0].slice(2)), width = charBBox[2] - charBBox[0], height = charBBox[3] - charBBox[1];
                  const charBBoxSize = Math.hypot(width, height);
                  if (width === 0 || height === 0) {
                    operatorList.fnArray.splice(0, 1);
                    operatorList.argsArray.splice(0, 1);
                  } else if (fontBBoxSize === 0 || Math.round(charBBoxSize / fontBBoxSize) >= 10) {
                    if (!this._bbox) {
                      this._bbox = [Infinity, Infinity, -Infinity, -Infinity];
                    }
                    this._bbox[0] = Math.min(this._bbox[0], charBBox[0]);
                    this._bbox[1] = Math.min(this._bbox[1], charBBox[1]);
                    this._bbox[2] = Math.max(this._bbox[2], charBBox[2]);
                    this._bbox[3] = Math.max(this._bbox[3], charBBox[3]);
                  }
                  let i = 0, ii = operatorList.length;
                  while (i < ii) {
                    switch (operatorList.fnArray[i]) {
                      case _util.OPS.setCharWidthAndBounds:
                        break;
                      case _util.OPS.setStrokeColorSpace:
                      case _util.OPS.setFillColorSpace:
                      case _util.OPS.setStrokeColor:
                      case _util.OPS.setStrokeColorN:
                      case _util.OPS.setFillColor:
                      case _util.OPS.setFillColorN:
                      case _util.OPS.setStrokeGray:
                      case _util.OPS.setFillGray:
                      case _util.OPS.setStrokeRGBColor:
                      case _util.OPS.setFillRGBColor:
                      case _util.OPS.setStrokeCMYKColor:
                      case _util.OPS.setFillCMYKColor:
                      case _util.OPS.shadingFill:
                      case _util.OPS.setRenderingIntent:
                        operatorList.fnArray.splice(i, 1);
                        operatorList.argsArray.splice(i, 1);
                        ii--;
                        continue;
                      case _util.OPS.setGState:
                        const [gStateObj] = operatorList.argsArray[i];
                        let j = 0, jj = gStateObj.length;
                        while (j < jj) {
                          const [gStateKey] = gStateObj[j];
                          switch (gStateKey) {
                            case "TR":
                            case "TR2":
                            case "HT":
                            case "BG":
                            case "BG2":
                            case "UCR":
                            case "UCR2":
                              gStateObj.splice(j, 1);
                              jj--;
                              continue;
                          }
                          j++;
                        }
                        break;
                    }
                    i++;
                  }
                }
              };
              __name(_TranslatedFont, "TranslatedFont");
              let TranslatedFont = _TranslatedFont;
              const _StateManager = class _StateManager {
                constructor() {
                  let initialState = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new EvalState();
                  this.state = initialState;
                  this.stateStack = [];
                }
                save() {
                  const old = this.state;
                  this.stateStack.push(this.state);
                  this.state = old.clone();
                }
                restore() {
                  const prev = this.stateStack.pop();
                  if (prev) {
                    this.state = prev;
                  }
                }
                transform(args) {
                  this.state.ctm = _util.Util.transform(this.state.ctm, args);
                }
              };
              __name(_StateManager, "StateManager");
              let StateManager = _StateManager;
              const _TextState = class _TextState {
                constructor() {
                  this.ctm = new Float32Array(_util.IDENTITY_MATRIX);
                  this.fontName = null;
                  this.fontSize = 0;
                  this.font = null;
                  this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
                  this.textMatrix = _util.IDENTITY_MATRIX.slice();
                  this.textLineMatrix = _util.IDENTITY_MATRIX.slice();
                  this.charSpacing = 0;
                  this.wordSpacing = 0;
                  this.leading = 0;
                  this.textHScale = 1;
                  this.textRise = 0;
                }
                setTextMatrix(a, b, c, d, e, f) {
                  const m = this.textMatrix;
                  m[0] = a;
                  m[1] = b;
                  m[2] = c;
                  m[3] = d;
                  m[4] = e;
                  m[5] = f;
                }
                setTextLineMatrix(a, b, c, d, e, f) {
                  const m = this.textLineMatrix;
                  m[0] = a;
                  m[1] = b;
                  m[2] = c;
                  m[3] = d;
                  m[4] = e;
                  m[5] = f;
                }
                translateTextMatrix(x, y) {
                  const m = this.textMatrix;
                  m[4] = m[0] * x + m[2] * y + m[4];
                  m[5] = m[1] * x + m[3] * y + m[5];
                }
                translateTextLineMatrix(x, y) {
                  const m = this.textLineMatrix;
                  m[4] = m[0] * x + m[2] * y + m[4];
                  m[5] = m[1] * x + m[3] * y + m[5];
                }
                carriageReturn() {
                  this.translateTextLineMatrix(0, -this.leading);
                  this.textMatrix = this.textLineMatrix.slice();
                }
                clone() {
                  const clone = Object.create(this);
                  clone.textMatrix = this.textMatrix.slice();
                  clone.textLineMatrix = this.textLineMatrix.slice();
                  clone.fontMatrix = this.fontMatrix.slice();
                  return clone;
                }
              };
              __name(_TextState, "TextState");
              let TextState = _TextState;
              const _EvalState = class _EvalState {
                constructor() {
                  this.ctm = new Float32Array(_util.IDENTITY_MATRIX);
                  this.font = null;
                  this.textRenderingMode = _util.TextRenderingMode.FILL;
                  this.fillColorSpace = _colorspace.ColorSpace.singletons.gray;
                  this.strokeColorSpace = _colorspace.ColorSpace.singletons.gray;
                }
                clone() {
                  return Object.create(this);
                }
              };
              __name(_EvalState, "EvalState");
              let EvalState = _EvalState;
              const _EvaluatorPreprocessor = class _EvaluatorPreprocessor {
                static get opMap() {
                  const getOPMap = (0, _core_utils.getLookupTableFactory)(function(t) {
                    t.w = {
                      id: _util.OPS.setLineWidth,
                      numArgs: 1,
                      variableArgs: false
                    };
                    t.J = {
                      id: _util.OPS.setLineCap,
                      numArgs: 1,
                      variableArgs: false
                    };
                    t.j = {
                      id: _util.OPS.setLineJoin,
                      numArgs: 1,
                      variableArgs: false
                    };
                    t.M = {
                      id: _util.OPS.setMiterLimit,
                      numArgs: 1,
                      variableArgs: false
                    };
                    t.d = {
                      id: _util.OPS.setDash,
                      numArgs: 2,
                      variableArgs: false
                    };
                    t.ri = {
                      id: _util.OPS.setRenderingIntent,
                      numArgs: 1,
                      variableArgs: false
                    };
                    t.i = {
                      id: _util.OPS.setFlatness,
                      numArgs: 1,
                      variableArgs: false
                    };
                    t.gs = {
                      id: _util.OPS.setGState,
                      numArgs: 1,
                      variableArgs: false
                    };
                    t.q = {
                      id: _util.OPS.save,
                      numArgs: 0,
                      variableArgs: false
                    };
                    t.Q = {
                      id: _util.OPS.restore,
                      numArgs: 0,
                      variableArgs: false
                    };
                    t.cm = {
                      id: _util.OPS.transform,
                      numArgs: 6,
                      variableArgs: false
                    };
                    t.m = {
                      id: _util.OPS.moveTo,
                      numArgs: 2,
                      variableArgs: false
                    };
                    t.l = {
                      id: _util.OPS.lineTo,
                      numArgs: 2,
                      variableArgs: false
                    };
                    t.c = {
                      id: _util.OPS.curveTo,
                      numArgs: 6,
                      variableArgs: false
                    };
                    t.v = {
                      id: _util.OPS.curveTo2,
                      numArgs: 4,
                      variableArgs: false
                    };
                    t.y = {
                      id: _util.OPS.curveTo3,
                      numArgs: 4,
                      variableArgs: false
                    };
                    t.h = {
                      id: _util.OPS.closePath,
                      numArgs: 0,
                      variableArgs: false
                    };
                    t.re = {
                      id: _util.OPS.rectangle,
                      numArgs: 4,
                      variableArgs: false
                    };
                    t.S = {
                      id: _util.OPS.stroke,
                      numArgs: 0,
                      variableArgs: false
                    };
                    t.s = {
                      id: _util.OPS.closeStroke,
                      numArgs: 0,
                      variableArgs: false
                    };
                    t.f = {
                      id: _util.OPS.fill,
                      numArgs: 0,
                      variableArgs: false
                    };
                    t.F = {
                      id: _util.OPS.fill,
                      numArgs: 0,
                      variableArgs: false
                    };
                    t["f*"] = {
                      id: _util.OPS.eoFill,
                      numArgs: 0,
                      variableArgs: false
                    };
                    t.B = {
                      id: _util.OPS.fillStroke,
                      numArgs: 0,
                      variableArgs: false
                    };
                    t["B*"] = {
                      id: _util.OPS.eoFillStroke,
                      numArgs: 0,
                      variableArgs: false
                    };
                    t.b = {
                      id: _util.OPS.closeFillStroke,
                      numArgs: 0,
                      variableArgs: false
                    };
                    t["b*"] = {
                      id: _util.OPS.closeEOFillStroke,
                      numArgs: 0,
                      variableArgs: false
                    };
                    t.n = {
                      id: _util.OPS.endPath,
                      numArgs: 0,
                      variableArgs: false
                    };
                    t.W = {
                      id: _util.OPS.clip,
                      numArgs: 0,
                      variableArgs: false
                    };
                    t["W*"] = {
                      id: _util.OPS.eoClip,
                      numArgs: 0,
                      variableArgs: false
                    };
                    t.BT = {
                      id: _util.OPS.beginText,
                      numArgs: 0,
                      variableArgs: false
                    };
                    t.ET = {
                      id: _util.OPS.endText,
                      numArgs: 0,
                      variableArgs: false
                    };
                    t.Tc = {
                      id: _util.OPS.setCharSpacing,
                      numArgs: 1,
                      variableArgs: false
                    };
                    t.Tw = {
                      id: _util.OPS.setWordSpacing,
                      numArgs: 1,
                      variableArgs: false
                    };
                    t.Tz = {
                      id: _util.OPS.setHScale,
                      numArgs: 1,
                      variableArgs: false
                    };
                    t.TL = {
                      id: _util.OPS.setLeading,
                      numArgs: 1,
                      variableArgs: false
                    };
                    t.Tf = {
                      id: _util.OPS.setFont,
                      numArgs: 2,
                      variableArgs: false
                    };
                    t.Tr = {
                      id: _util.OPS.setTextRenderingMode,
                      numArgs: 1,
                      variableArgs: false
                    };
                    t.Ts = {
                      id: _util.OPS.setTextRise,
                      numArgs: 1,
                      variableArgs: false
                    };
                    t.Td = {
                      id: _util.OPS.moveText,
                      numArgs: 2,
                      variableArgs: false
                    };
                    t.TD = {
                      id: _util.OPS.setLeadingMoveText,
                      numArgs: 2,
                      variableArgs: false
                    };
                    t.Tm = {
                      id: _util.OPS.setTextMatrix,
                      numArgs: 6,
                      variableArgs: false
                    };
                    t["T*"] = {
                      id: _util.OPS.nextLine,
                      numArgs: 0,
                      variableArgs: false
                    };
                    t.Tj = {
                      id: _util.OPS.showText,
                      numArgs: 1,
                      variableArgs: false
                    };
                    t.TJ = {
                      id: _util.OPS.showSpacedText,
                      numArgs: 1,
                      variableArgs: false
                    };
                    t["'"] = {
                      id: _util.OPS.nextLineShowText,
                      numArgs: 1,
                      variableArgs: false
                    };
                    t['"'] = {
                      id: _util.OPS.nextLineSetSpacingShowText,
                      numArgs: 3,
                      variableArgs: false
                    };
                    t.d0 = {
                      id: _util.OPS.setCharWidth,
                      numArgs: 2,
                      variableArgs: false
                    };
                    t.d1 = {
                      id: _util.OPS.setCharWidthAndBounds,
                      numArgs: 6,
                      variableArgs: false
                    };
                    t.CS = {
                      id: _util.OPS.setStrokeColorSpace,
                      numArgs: 1,
                      variableArgs: false
                    };
                    t.cs = {
                      id: _util.OPS.setFillColorSpace,
                      numArgs: 1,
                      variableArgs: false
                    };
                    t.SC = {
                      id: _util.OPS.setStrokeColor,
                      numArgs: 4,
                      variableArgs: true
                    };
                    t.SCN = {
                      id: _util.OPS.setStrokeColorN,
                      numArgs: 33,
                      variableArgs: true
                    };
                    t.sc = {
                      id: _util.OPS.setFillColor,
                      numArgs: 4,
                      variableArgs: true
                    };
                    t.scn = {
                      id: _util.OPS.setFillColorN,
                      numArgs: 33,
                      variableArgs: true
                    };
                    t.G = {
                      id: _util.OPS.setStrokeGray,
                      numArgs: 1,
                      variableArgs: false
                    };
                    t.g = {
                      id: _util.OPS.setFillGray,
                      numArgs: 1,
                      variableArgs: false
                    };
                    t.RG = {
                      id: _util.OPS.setStrokeRGBColor,
                      numArgs: 3,
                      variableArgs: false
                    };
                    t.rg = {
                      id: _util.OPS.setFillRGBColor,
                      numArgs: 3,
                      variableArgs: false
                    };
                    t.K = {
                      id: _util.OPS.setStrokeCMYKColor,
                      numArgs: 4,
                      variableArgs: false
                    };
                    t.k = {
                      id: _util.OPS.setFillCMYKColor,
                      numArgs: 4,
                      variableArgs: false
                    };
                    t.sh = {
                      id: _util.OPS.shadingFill,
                      numArgs: 1,
                      variableArgs: false
                    };
                    t.BI = {
                      id: _util.OPS.beginInlineImage,
                      numArgs: 0,
                      variableArgs: false
                    };
                    t.ID = {
                      id: _util.OPS.beginImageData,
                      numArgs: 0,
                      variableArgs: false
                    };
                    t.EI = {
                      id: _util.OPS.endInlineImage,
                      numArgs: 1,
                      variableArgs: false
                    };
                    t.Do = {
                      id: _util.OPS.paintXObject,
                      numArgs: 1,
                      variableArgs: false
                    };
                    t.MP = {
                      id: _util.OPS.markPoint,
                      numArgs: 1,
                      variableArgs: false
                    };
                    t.DP = {
                      id: _util.OPS.markPointProps,
                      numArgs: 2,
                      variableArgs: false
                    };
                    t.BMC = {
                      id: _util.OPS.beginMarkedContent,
                      numArgs: 1,
                      variableArgs: false
                    };
                    t.BDC = {
                      id: _util.OPS.beginMarkedContentProps,
                      numArgs: 2,
                      variableArgs: false
                    };
                    t.EMC = {
                      id: _util.OPS.endMarkedContent,
                      numArgs: 0,
                      variableArgs: false
                    };
                    t.BX = {
                      id: _util.OPS.beginCompat,
                      numArgs: 0,
                      variableArgs: false
                    };
                    t.EX = {
                      id: _util.OPS.endCompat,
                      numArgs: 0,
                      variableArgs: false
                    };
                    t.BM = null;
                    t.BD = null;
                    t.true = null;
                    t.fa = null;
                    t.fal = null;
                    t.fals = null;
                    t.false = null;
                    t.nu = null;
                    t.nul = null;
                    t.null = null;
                  });
                  return (0, _util.shadow)(this, "opMap", getOPMap());
                }
                static get MAX_INVALID_PATH_OPS() {
                  return (0, _util.shadow)(this, "MAX_INVALID_PATH_OPS", 10);
                }
                constructor(stream, xref) {
                  let stateManager = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new StateManager();
                  this.parser = new _parser.Parser({
                    lexer: new _parser.Lexer(stream, _EvaluatorPreprocessor.opMap),
                    xref
                  });
                  this.stateManager = stateManager;
                  this.nonProcessedArgs = [];
                  this._isPathOp = false;
                  this._numInvalidPathOPS = 0;
                }
                get savedStatesDepth() {
                  return this.stateManager.stateStack.length;
                }
                read(operation) {
                  let args = operation.args;
                  while (true) {
                    const obj = this.parser.getObj();
                    if (obj instanceof _primitives.Cmd) {
                      const cmd = obj.cmd;
                      const opSpec = _EvaluatorPreprocessor.opMap[cmd];
                      if (!opSpec) {
                        (0, _util.warn)(`Unknown command "${cmd}".`);
                        continue;
                      }
                      const fn = opSpec.id;
                      const numArgs = opSpec.numArgs;
                      let argsLength = args !== null ? args.length : 0;
                      if (!this._isPathOp) {
                        this._numInvalidPathOPS = 0;
                      }
                      this._isPathOp = fn >= _util.OPS.moveTo && fn <= _util.OPS.endPath;
                      if (!opSpec.variableArgs) {
                        if (argsLength !== numArgs) {
                          const nonProcessedArgs = this.nonProcessedArgs;
                          while (argsLength > numArgs) {
                            nonProcessedArgs.push(args.shift());
                            argsLength--;
                          }
                          while (argsLength < numArgs && nonProcessedArgs.length !== 0) {
                            if (args === null) {
                              args = [];
                            }
                            args.unshift(nonProcessedArgs.pop());
                            argsLength++;
                          }
                        }
                        if (argsLength < numArgs) {
                          const partialMsg = `command ${cmd}: expected ${numArgs} args, but received ${argsLength} args.`;
                          if (this._isPathOp && ++this._numInvalidPathOPS > _EvaluatorPreprocessor.MAX_INVALID_PATH_OPS) {
                            throw new _util.FormatError(`Invalid ${partialMsg}`);
                          }
                          (0, _util.warn)(`Skipping ${partialMsg}`);
                          if (args !== null) {
                            args.length = 0;
                          }
                          continue;
                        }
                      } else if (argsLength > numArgs) {
                        (0, _util.info)(`Command ${cmd}: expected [0, ${numArgs}] args, but received ${argsLength} args.`);
                      }
                      this.preprocessCommand(fn, args);
                      operation.fn = fn;
                      operation.args = args;
                      return true;
                    }
                    if (obj === _primitives.EOF) {
                      return false;
                    }
                    if (obj !== null) {
                      if (args === null) {
                        args = [];
                      }
                      args.push(obj);
                      if (args.length > 33) {
                        throw new _util.FormatError("Too many arguments");
                      }
                    }
                  }
                }
                preprocessCommand(fn, args) {
                  switch (fn | 0) {
                    case _util.OPS.save:
                      this.stateManager.save();
                      break;
                    case _util.OPS.restore:
                      this.stateManager.restore();
                      break;
                    case _util.OPS.transform:
                      this.stateManager.transform(args);
                      break;
                  }
                }
              };
              __name(_EvaluatorPreprocessor, "EvaluatorPreprocessor");
              let EvaluatorPreprocessor = _EvaluatorPreprocessor;
              exports2.EvaluatorPreprocessor = EvaluatorPreprocessor;
            },
            /* 141 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.IdentityCMap = exports2.CMapFactory = exports2.CMap = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _primitives = __w_pdfjs_require__2(130);
              var _base_stream = __w_pdfjs_require__2(132);
              var _parser = __w_pdfjs_require__2(142);
              var _core_utils = __w_pdfjs_require__2(131);
              var _stream = __w_pdfjs_require__2(135);
              const BUILT_IN_CMAPS = ["Adobe-GB1-UCS2", "Adobe-CNS1-UCS2", "Adobe-Japan1-UCS2", "Adobe-Korea1-UCS2", "78-EUC-H", "78-EUC-V", "78-H", "78-RKSJ-H", "78-RKSJ-V", "78-V", "78ms-RKSJ-H", "78ms-RKSJ-V", "83pv-RKSJ-H", "90ms-RKSJ-H", "90ms-RKSJ-V", "90msp-RKSJ-H", "90msp-RKSJ-V", "90pv-RKSJ-H", "90pv-RKSJ-V", "Add-H", "Add-RKSJ-H", "Add-RKSJ-V", "Add-V", "Adobe-CNS1-0", "Adobe-CNS1-1", "Adobe-CNS1-2", "Adobe-CNS1-3", "Adobe-CNS1-4", "Adobe-CNS1-5", "Adobe-CNS1-6", "Adobe-GB1-0", "Adobe-GB1-1", "Adobe-GB1-2", "Adobe-GB1-3", "Adobe-GB1-4", "Adobe-GB1-5", "Adobe-Japan1-0", "Adobe-Japan1-1", "Adobe-Japan1-2", "Adobe-Japan1-3", "Adobe-Japan1-4", "Adobe-Japan1-5", "Adobe-Japan1-6", "Adobe-Korea1-0", "Adobe-Korea1-1", "Adobe-Korea1-2", "B5-H", "B5-V", "B5pc-H", "B5pc-V", "CNS-EUC-H", "CNS-EUC-V", "CNS1-H", "CNS1-V", "CNS2-H", "CNS2-V", "ETHK-B5-H", "ETHK-B5-V", "ETen-B5-H", "ETen-B5-V", "ETenms-B5-H", "ETenms-B5-V", "EUC-H", "EUC-V", "Ext-H", "Ext-RKSJ-H", "Ext-RKSJ-V", "Ext-V", "GB-EUC-H", "GB-EUC-V", "GB-H", "GB-V", "GBK-EUC-H", "GBK-EUC-V", "GBK2K-H", "GBK2K-V", "GBKp-EUC-H", "GBKp-EUC-V", "GBT-EUC-H", "GBT-EUC-V", "GBT-H", "GBT-V", "GBTpc-EUC-H", "GBTpc-EUC-V", "GBpc-EUC-H", "GBpc-EUC-V", "H", "HKdla-B5-H", "HKdla-B5-V", "HKdlb-B5-H", "HKdlb-B5-V", "HKgccs-B5-H", "HKgccs-B5-V", "HKm314-B5-H", "HKm314-B5-V", "HKm471-B5-H", "HKm471-B5-V", "HKscs-B5-H", "HKscs-B5-V", "Hankaku", "Hiragana", "KSC-EUC-H", "KSC-EUC-V", "KSC-H", "KSC-Johab-H", "KSC-Johab-V", "KSC-V", "KSCms-UHC-H", "KSCms-UHC-HW-H", "KSCms-UHC-HW-V", "KSCms-UHC-V", "KSCpc-EUC-H", "KSCpc-EUC-V", "Katakana", "NWP-H", "NWP-V", "RKSJ-H", "RKSJ-V", "Roman", "UniCNS-UCS2-H", "UniCNS-UCS2-V", "UniCNS-UTF16-H", "UniCNS-UTF16-V", "UniCNS-UTF32-H", "UniCNS-UTF32-V", "UniCNS-UTF8-H", "UniCNS-UTF8-V", "UniGB-UCS2-H", "UniGB-UCS2-V", "UniGB-UTF16-H", "UniGB-UTF16-V", "UniGB-UTF32-H", "UniGB-UTF32-V", "UniGB-UTF8-H", "UniGB-UTF8-V", "UniJIS-UCS2-H", "UniJIS-UCS2-HW-H", "UniJIS-UCS2-HW-V", "UniJIS-UCS2-V", "UniJIS-UTF16-H", "UniJIS-UTF16-V", "UniJIS-UTF32-H", "UniJIS-UTF32-V", "UniJIS-UTF8-H", "UniJIS-UTF8-V", "UniJIS2004-UTF16-H", "UniJIS2004-UTF16-V", "UniJIS2004-UTF32-H", "UniJIS2004-UTF32-V", "UniJIS2004-UTF8-H", "UniJIS2004-UTF8-V", "UniJISPro-UCS2-HW-V", "UniJISPro-UCS2-V", "UniJISPro-UTF8-V", "UniJISX0213-UTF32-H", "UniJISX0213-UTF32-V", "UniJISX02132004-UTF32-H", "UniJISX02132004-UTF32-V", "UniKS-UCS2-H", "UniKS-UCS2-V", "UniKS-UTF16-H", "UniKS-UTF16-V", "UniKS-UTF32-H", "UniKS-UTF32-V", "UniKS-UTF8-H", "UniKS-UTF8-V", "V", "WP-Symbol"];
              const MAX_MAP_RANGE = 2 ** 24 - 1;
              const _CMap = class _CMap {
                constructor() {
                  let builtInCMap = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  this.codespaceRanges = [[], [], [], []];
                  this.numCodespaceRanges = 0;
                  this._map = [];
                  this.name = "";
                  this.vertical = false;
                  this.useCMap = null;
                  this.builtInCMap = builtInCMap;
                }
                addCodespaceRange(n, low, high) {
                  this.codespaceRanges[n - 1].push(low, high);
                  this.numCodespaceRanges++;
                }
                mapCidRange(low, high, dstLow) {
                  if (high - low > MAX_MAP_RANGE) {
                    throw new Error("mapCidRange - ignoring data above MAX_MAP_RANGE.");
                  }
                  while (low <= high) {
                    this._map[low++] = dstLow++;
                  }
                }
                mapBfRange(low, high, dstLow) {
                  if (high - low > MAX_MAP_RANGE) {
                    throw new Error("mapBfRange - ignoring data above MAX_MAP_RANGE.");
                  }
                  const lastByte = dstLow.length - 1;
                  while (low <= high) {
                    this._map[low++] = dstLow;
                    const nextCharCode = dstLow.charCodeAt(lastByte) + 1;
                    if (nextCharCode > 255) {
                      dstLow = dstLow.substring(0, lastByte - 1) + String.fromCharCode(dstLow.charCodeAt(lastByte - 1) + 1) + "\0";
                      continue;
                    }
                    dstLow = dstLow.substring(0, lastByte) + String.fromCharCode(nextCharCode);
                  }
                }
                mapBfRangeToArray(low, high, array) {
                  if (high - low > MAX_MAP_RANGE) {
                    throw new Error("mapBfRangeToArray - ignoring data above MAX_MAP_RANGE.");
                  }
                  const ii = array.length;
                  let i = 0;
                  while (low <= high && i < ii) {
                    this._map[low] = array[i++];
                    ++low;
                  }
                }
                mapOne(src, dst) {
                  this._map[src] = dst;
                }
                lookup(code) {
                  return this._map[code];
                }
                contains(code) {
                  return this._map[code] !== void 0;
                }
                forEach(callback) {
                  const map = this._map;
                  const length = map.length;
                  if (length <= 65536) {
                    for (let i = 0; i < length; i++) {
                      if (map[i] !== void 0) {
                        callback(i, map[i]);
                      }
                    }
                  } else {
                    for (const i in map) {
                      callback(i, map[i]);
                    }
                  }
                }
                charCodeOf(value) {
                  const map = this._map;
                  if (map.length <= 65536) {
                    return map.indexOf(value);
                  }
                  for (const charCode in map) {
                    if (map[charCode] === value) {
                      return charCode | 0;
                    }
                  }
                  return -1;
                }
                getMap() {
                  return this._map;
                }
                readCharCode(str, offset, out) {
                  let c = 0;
                  const codespaceRanges = this.codespaceRanges;
                  for (let n = 0, nn = codespaceRanges.length; n < nn; n++) {
                    c = (c << 8 | str.charCodeAt(offset + n)) >>> 0;
                    const codespaceRange = codespaceRanges[n];
                    for (let k = 0, kk = codespaceRange.length; k < kk; ) {
                      const low = codespaceRange[k++];
                      const high = codespaceRange[k++];
                      if (c >= low && c <= high) {
                        out.charcode = c;
                        out.length = n + 1;
                        return;
                      }
                    }
                  }
                  out.charcode = 0;
                  out.length = 1;
                }
                getCharCodeLength(charCode) {
                  const codespaceRanges = this.codespaceRanges;
                  for (let n = 0, nn = codespaceRanges.length; n < nn; n++) {
                    const codespaceRange = codespaceRanges[n];
                    for (let k = 0, kk = codespaceRange.length; k < kk; ) {
                      const low = codespaceRange[k++];
                      const high = codespaceRange[k++];
                      if (charCode >= low && charCode <= high) {
                        return n + 1;
                      }
                    }
                  }
                  return 1;
                }
                get length() {
                  return this._map.length;
                }
                get isIdentityCMap() {
                  if (!(this.name === "Identity-H" || this.name === "Identity-V")) {
                    return false;
                  }
                  if (this._map.length !== 65536) {
                    return false;
                  }
                  for (let i = 0; i < 65536; i++) {
                    if (this._map[i] !== i) {
                      return false;
                    }
                  }
                  return true;
                }
              };
              __name(_CMap, "CMap");
              let CMap = _CMap;
              exports2.CMap = CMap;
              const _IdentityCMap = class _IdentityCMap extends CMap {
                constructor(vertical, n) {
                  super();
                  this.vertical = vertical;
                  this.addCodespaceRange(n, 0, 65535);
                }
                mapCidRange(low, high, dstLow) {
                  (0, _util.unreachable)("should not call mapCidRange");
                }
                mapBfRange(low, high, dstLow) {
                  (0, _util.unreachable)("should not call mapBfRange");
                }
                mapBfRangeToArray(low, high, array) {
                  (0, _util.unreachable)("should not call mapBfRangeToArray");
                }
                mapOne(src, dst) {
                  (0, _util.unreachable)("should not call mapCidOne");
                }
                lookup(code) {
                  return Number.isInteger(code) && code <= 65535 ? code : void 0;
                }
                contains(code) {
                  return Number.isInteger(code) && code <= 65535;
                }
                forEach(callback) {
                  for (let i = 0; i <= 65535; i++) {
                    callback(i, i);
                  }
                }
                charCodeOf(value) {
                  return Number.isInteger(value) && value <= 65535 ? value : -1;
                }
                getMap() {
                  const map = new Array(65536);
                  for (let i = 0; i <= 65535; i++) {
                    map[i] = i;
                  }
                  return map;
                }
                get length() {
                  return 65536;
                }
                get isIdentityCMap() {
                  (0, _util.unreachable)("should not access .isIdentityCMap");
                }
              };
              __name(_IdentityCMap, "IdentityCMap");
              let IdentityCMap = _IdentityCMap;
              exports2.IdentityCMap = IdentityCMap;
              const BinaryCMapReader = (/* @__PURE__ */ __name(function BinaryCMapReaderClosure() {
                function hexToInt(a, size) {
                  let n = 0;
                  for (let i = 0; i <= size; i++) {
                    n = n << 8 | a[i];
                  }
                  return n >>> 0;
                }
                __name(hexToInt, "hexToInt");
                function hexToStr(a, size) {
                  if (size === 1) {
                    return String.fromCharCode(a[0], a[1]);
                  }
                  if (size === 3) {
                    return String.fromCharCode(a[0], a[1], a[2], a[3]);
                  }
                  return String.fromCharCode.apply(null, a.subarray(0, size + 1));
                }
                __name(hexToStr, "hexToStr");
                function addHex(a, b, size) {
                  let c = 0;
                  for (let i = size; i >= 0; i--) {
                    c += a[i] + b[i];
                    a[i] = c & 255;
                    c >>= 8;
                  }
                }
                __name(addHex, "addHex");
                function incHex(a, size) {
                  let c = 1;
                  for (let i = size; i >= 0 && c > 0; i--) {
                    c += a[i];
                    a[i] = c & 255;
                    c >>= 8;
                  }
                }
                __name(incHex, "incHex");
                const MAX_NUM_SIZE = 16;
                const MAX_ENCODED_NUM_SIZE = 19;
                const _BinaryCMapStream = class _BinaryCMapStream {
                  constructor(data) {
                    this.buffer = data;
                    this.pos = 0;
                    this.end = data.length;
                    this.tmpBuf = new Uint8Array(MAX_ENCODED_NUM_SIZE);
                  }
                  readByte() {
                    if (this.pos >= this.end) {
                      return -1;
                    }
                    return this.buffer[this.pos++];
                  }
                  readNumber() {
                    let n = 0;
                    let last;
                    do {
                      const b = this.readByte();
                      if (b < 0) {
                        throw new _util.FormatError("unexpected EOF in bcmap");
                      }
                      last = !(b & 128);
                      n = n << 7 | b & 127;
                    } while (!last);
                    return n;
                  }
                  readSigned() {
                    const n = this.readNumber();
                    return n & 1 ? ~(n >>> 1) : n >>> 1;
                  }
                  readHex(num, size) {
                    num.set(this.buffer.subarray(this.pos, this.pos + size + 1));
                    this.pos += size + 1;
                  }
                  readHexNumber(num, size) {
                    let last;
                    const stack = this.tmpBuf;
                    let sp = 0;
                    do {
                      const b = this.readByte();
                      if (b < 0) {
                        throw new _util.FormatError("unexpected EOF in bcmap");
                      }
                      last = !(b & 128);
                      stack[sp++] = b & 127;
                    } while (!last);
                    let i = size, buffer = 0, bufferSize = 0;
                    while (i >= 0) {
                      while (bufferSize < 8 && stack.length > 0) {
                        buffer |= stack[--sp] << bufferSize;
                        bufferSize += 7;
                      }
                      num[i] = buffer & 255;
                      i--;
                      buffer >>= 8;
                      bufferSize -= 8;
                    }
                  }
                  readHexSigned(num, size) {
                    this.readHexNumber(num, size);
                    const sign = num[size] & 1 ? 255 : 0;
                    let c = 0;
                    for (let i = 0; i <= size; i++) {
                      c = (c & 1) << 8 | num[i];
                      num[i] = c >> 1 ^ sign;
                    }
                  }
                  readString() {
                    const len = this.readNumber();
                    let s = "";
                    for (let i = 0; i < len; i++) {
                      s += String.fromCharCode(this.readNumber());
                    }
                    return s;
                  }
                };
                __name(_BinaryCMapStream, "BinaryCMapStream");
                let BinaryCMapStream = _BinaryCMapStream;
                const _BinaryCMapReader = class _BinaryCMapReader {
                  async process(data, cMap, extend) {
                    const stream = new BinaryCMapStream(data);
                    const header = stream.readByte();
                    cMap.vertical = !!(header & 1);
                    let useCMap = null;
                    const start = new Uint8Array(MAX_NUM_SIZE);
                    const end = new Uint8Array(MAX_NUM_SIZE);
                    const char = new Uint8Array(MAX_NUM_SIZE);
                    const charCode = new Uint8Array(MAX_NUM_SIZE);
                    const tmp = new Uint8Array(MAX_NUM_SIZE);
                    let code;
                    let b;
                    while ((b = stream.readByte()) >= 0) {
                      const type = b >> 5;
                      if (type === 7) {
                        switch (b & 31) {
                          case 0:
                            stream.readString();
                            break;
                          case 1:
                            useCMap = stream.readString();
                            break;
                        }
                        continue;
                      }
                      const sequence = !!(b & 16);
                      const dataSize = b & 15;
                      if (dataSize + 1 > MAX_NUM_SIZE) {
                        throw new Error("BinaryCMapReader.process: Invalid dataSize.");
                      }
                      const ucs2DataSize = 1;
                      const subitemsCount = stream.readNumber();
                      switch (type) {
                        case 0:
                          stream.readHex(start, dataSize);
                          stream.readHexNumber(end, dataSize);
                          addHex(end, start, dataSize);
                          cMap.addCodespaceRange(dataSize + 1, hexToInt(start, dataSize), hexToInt(end, dataSize));
                          for (let i = 1; i < subitemsCount; i++) {
                            incHex(end, dataSize);
                            stream.readHexNumber(start, dataSize);
                            addHex(start, end, dataSize);
                            stream.readHexNumber(end, dataSize);
                            addHex(end, start, dataSize);
                            cMap.addCodespaceRange(dataSize + 1, hexToInt(start, dataSize), hexToInt(end, dataSize));
                          }
                          break;
                        case 1:
                          stream.readHex(start, dataSize);
                          stream.readHexNumber(end, dataSize);
                          addHex(end, start, dataSize);
                          stream.readNumber();
                          for (let i = 1; i < subitemsCount; i++) {
                            incHex(end, dataSize);
                            stream.readHexNumber(start, dataSize);
                            addHex(start, end, dataSize);
                            stream.readHexNumber(end, dataSize);
                            addHex(end, start, dataSize);
                            stream.readNumber();
                          }
                          break;
                        case 2:
                          stream.readHex(char, dataSize);
                          code = stream.readNumber();
                          cMap.mapOne(hexToInt(char, dataSize), code);
                          for (let i = 1; i < subitemsCount; i++) {
                            incHex(char, dataSize);
                            if (!sequence) {
                              stream.readHexNumber(tmp, dataSize);
                              addHex(char, tmp, dataSize);
                            }
                            code = stream.readSigned() + (code + 1);
                            cMap.mapOne(hexToInt(char, dataSize), code);
                          }
                          break;
                        case 3:
                          stream.readHex(start, dataSize);
                          stream.readHexNumber(end, dataSize);
                          addHex(end, start, dataSize);
                          code = stream.readNumber();
                          cMap.mapCidRange(hexToInt(start, dataSize), hexToInt(end, dataSize), code);
                          for (let i = 1; i < subitemsCount; i++) {
                            incHex(end, dataSize);
                            if (!sequence) {
                              stream.readHexNumber(start, dataSize);
                              addHex(start, end, dataSize);
                            } else {
                              start.set(end);
                            }
                            stream.readHexNumber(end, dataSize);
                            addHex(end, start, dataSize);
                            code = stream.readNumber();
                            cMap.mapCidRange(hexToInt(start, dataSize), hexToInt(end, dataSize), code);
                          }
                          break;
                        case 4:
                          stream.readHex(char, ucs2DataSize);
                          stream.readHex(charCode, dataSize);
                          cMap.mapOne(hexToInt(char, ucs2DataSize), hexToStr(charCode, dataSize));
                          for (let i = 1; i < subitemsCount; i++) {
                            incHex(char, ucs2DataSize);
                            if (!sequence) {
                              stream.readHexNumber(tmp, ucs2DataSize);
                              addHex(char, tmp, ucs2DataSize);
                            }
                            incHex(charCode, dataSize);
                            stream.readHexSigned(tmp, dataSize);
                            addHex(charCode, tmp, dataSize);
                            cMap.mapOne(hexToInt(char, ucs2DataSize), hexToStr(charCode, dataSize));
                          }
                          break;
                        case 5:
                          stream.readHex(start, ucs2DataSize);
                          stream.readHexNumber(end, ucs2DataSize);
                          addHex(end, start, ucs2DataSize);
                          stream.readHex(charCode, dataSize);
                          cMap.mapBfRange(hexToInt(start, ucs2DataSize), hexToInt(end, ucs2DataSize), hexToStr(charCode, dataSize));
                          for (let i = 1; i < subitemsCount; i++) {
                            incHex(end, ucs2DataSize);
                            if (!sequence) {
                              stream.readHexNumber(start, ucs2DataSize);
                              addHex(start, end, ucs2DataSize);
                            } else {
                              start.set(end);
                            }
                            stream.readHexNumber(end, ucs2DataSize);
                            addHex(end, start, ucs2DataSize);
                            stream.readHex(charCode, dataSize);
                            cMap.mapBfRange(hexToInt(start, ucs2DataSize), hexToInt(end, ucs2DataSize), hexToStr(charCode, dataSize));
                          }
                          break;
                        default:
                          throw new Error(`BinaryCMapReader.process - unknown type: ${type}`);
                      }
                    }
                    if (useCMap) {
                      return extend(useCMap);
                    }
                    return cMap;
                  }
                };
                __name(_BinaryCMapReader, "BinaryCMapReader");
                let BinaryCMapReader2 = _BinaryCMapReader;
                return BinaryCMapReader2;
              }, "BinaryCMapReaderClosure"))();
              const CMapFactory = (/* @__PURE__ */ __name(function CMapFactoryClosure() {
                function strToInt(str) {
                  let a = 0;
                  for (let i = 0; i < str.length; i++) {
                    a = a << 8 | str.charCodeAt(i);
                  }
                  return a >>> 0;
                }
                __name(strToInt, "strToInt");
                function expectString(obj) {
                  if (typeof obj !== "string") {
                    throw new _util.FormatError("Malformed CMap: expected string.");
                  }
                }
                __name(expectString, "expectString");
                function expectInt(obj) {
                  if (!Number.isInteger(obj)) {
                    throw new _util.FormatError("Malformed CMap: expected int.");
                  }
                }
                __name(expectInt, "expectInt");
                function parseBfChar(cMap, lexer) {
                  while (true) {
                    let obj = lexer.getObj();
                    if (obj === _primitives.EOF) {
                      break;
                    }
                    if ((0, _primitives.isCmd)(obj, "endbfchar")) {
                      return;
                    }
                    expectString(obj);
                    const src = strToInt(obj);
                    obj = lexer.getObj();
                    expectString(obj);
                    const dst = obj;
                    cMap.mapOne(src, dst);
                  }
                }
                __name(parseBfChar, "parseBfChar");
                function parseBfRange(cMap, lexer) {
                  while (true) {
                    let obj = lexer.getObj();
                    if (obj === _primitives.EOF) {
                      break;
                    }
                    if ((0, _primitives.isCmd)(obj, "endbfrange")) {
                      return;
                    }
                    expectString(obj);
                    const low = strToInt(obj);
                    obj = lexer.getObj();
                    expectString(obj);
                    const high = strToInt(obj);
                    obj = lexer.getObj();
                    if (Number.isInteger(obj) || typeof obj === "string") {
                      const dstLow = Number.isInteger(obj) ? String.fromCharCode(obj) : obj;
                      cMap.mapBfRange(low, high, dstLow);
                    } else if ((0, _primitives.isCmd)(obj, "[")) {
                      obj = lexer.getObj();
                      const array = [];
                      while (!(0, _primitives.isCmd)(obj, "]") && obj !== _primitives.EOF) {
                        array.push(obj);
                        obj = lexer.getObj();
                      }
                      cMap.mapBfRangeToArray(low, high, array);
                    } else {
                      break;
                    }
                  }
                  throw new _util.FormatError("Invalid bf range.");
                }
                __name(parseBfRange, "parseBfRange");
                function parseCidChar(cMap, lexer) {
                  while (true) {
                    let obj = lexer.getObj();
                    if (obj === _primitives.EOF) {
                      break;
                    }
                    if ((0, _primitives.isCmd)(obj, "endcidchar")) {
                      return;
                    }
                    expectString(obj);
                    const src = strToInt(obj);
                    obj = lexer.getObj();
                    expectInt(obj);
                    const dst = obj;
                    cMap.mapOne(src, dst);
                  }
                }
                __name(parseCidChar, "parseCidChar");
                function parseCidRange(cMap, lexer) {
                  while (true) {
                    let obj = lexer.getObj();
                    if (obj === _primitives.EOF) {
                      break;
                    }
                    if ((0, _primitives.isCmd)(obj, "endcidrange")) {
                      return;
                    }
                    expectString(obj);
                    const low = strToInt(obj);
                    obj = lexer.getObj();
                    expectString(obj);
                    const high = strToInt(obj);
                    obj = lexer.getObj();
                    expectInt(obj);
                    const dstLow = obj;
                    cMap.mapCidRange(low, high, dstLow);
                  }
                }
                __name(parseCidRange, "parseCidRange");
                function parseCodespaceRange(cMap, lexer) {
                  while (true) {
                    let obj = lexer.getObj();
                    if (obj === _primitives.EOF) {
                      break;
                    }
                    if ((0, _primitives.isCmd)(obj, "endcodespacerange")) {
                      return;
                    }
                    if (typeof obj !== "string") {
                      break;
                    }
                    const low = strToInt(obj);
                    obj = lexer.getObj();
                    if (typeof obj !== "string") {
                      break;
                    }
                    const high = strToInt(obj);
                    cMap.addCodespaceRange(obj.length, low, high);
                  }
                  throw new _util.FormatError("Invalid codespace range.");
                }
                __name(parseCodespaceRange, "parseCodespaceRange");
                function parseWMode(cMap, lexer) {
                  const obj = lexer.getObj();
                  if (Number.isInteger(obj)) {
                    cMap.vertical = !!obj;
                  }
                }
                __name(parseWMode, "parseWMode");
                function parseCMapName(cMap, lexer) {
                  const obj = lexer.getObj();
                  if (obj instanceof _primitives.Name) {
                    cMap.name = obj.name;
                  }
                }
                __name(parseCMapName, "parseCMapName");
                async function parseCMap(cMap, lexer, fetchBuiltInCMap, useCMap) {
                  let previous, embeddedUseCMap;
                  objLoop:
                    while (true) {
                      try {
                        const obj = lexer.getObj();
                        if (obj === _primitives.EOF) {
                          break;
                        } else if (obj instanceof _primitives.Name) {
                          if (obj.name === "WMode") {
                            parseWMode(cMap, lexer);
                          } else if (obj.name === "CMapName") {
                            parseCMapName(cMap, lexer);
                          }
                          previous = obj;
                        } else if (obj instanceof _primitives.Cmd) {
                          switch (obj.cmd) {
                            case "endcmap":
                              break objLoop;
                            case "usecmap":
                              if (previous instanceof _primitives.Name) {
                                embeddedUseCMap = previous.name;
                              }
                              break;
                            case "begincodespacerange":
                              parseCodespaceRange(cMap, lexer);
                              break;
                            case "beginbfchar":
                              parseBfChar(cMap, lexer);
                              break;
                            case "begincidchar":
                              parseCidChar(cMap, lexer);
                              break;
                            case "beginbfrange":
                              parseBfRange(cMap, lexer);
                              break;
                            case "begincidrange":
                              parseCidRange(cMap, lexer);
                              break;
                          }
                        }
                      } catch (ex) {
                        if (ex instanceof _core_utils.MissingDataException) {
                          throw ex;
                        }
                        (0, _util.warn)("Invalid cMap data: " + ex);
                        continue;
                      }
                    }
                  if (!useCMap && embeddedUseCMap) {
                    useCMap = embeddedUseCMap;
                  }
                  if (useCMap) {
                    return extendCMap(cMap, fetchBuiltInCMap, useCMap);
                  }
                  return cMap;
                }
                __name(parseCMap, "parseCMap");
                async function extendCMap(cMap, fetchBuiltInCMap, useCMap) {
                  cMap.useCMap = await createBuiltInCMap(useCMap, fetchBuiltInCMap);
                  if (cMap.numCodespaceRanges === 0) {
                    const useCodespaceRanges = cMap.useCMap.codespaceRanges;
                    for (let i = 0; i < useCodespaceRanges.length; i++) {
                      cMap.codespaceRanges[i] = useCodespaceRanges[i].slice();
                    }
                    cMap.numCodespaceRanges = cMap.useCMap.numCodespaceRanges;
                  }
                  cMap.useCMap.forEach(function(key, value) {
                    if (!cMap.contains(key)) {
                      cMap.mapOne(key, cMap.useCMap.lookup(key));
                    }
                  });
                  return cMap;
                }
                __name(extendCMap, "extendCMap");
                async function createBuiltInCMap(name, fetchBuiltInCMap) {
                  if (name === "Identity-H") {
                    return new IdentityCMap(false, 2);
                  } else if (name === "Identity-V") {
                    return new IdentityCMap(true, 2);
                  }
                  if (!BUILT_IN_CMAPS.includes(name)) {
                    throw new Error("Unknown CMap name: " + name);
                  }
                  if (!fetchBuiltInCMap) {
                    throw new Error("Built-in CMap parameters are not provided.");
                  }
                  const {
                    cMapData,
                    compressionType
                  } = await fetchBuiltInCMap(name);
                  const cMap = new CMap(true);
                  if (compressionType === _util.CMapCompressionType.BINARY) {
                    return new BinaryCMapReader().process(cMapData, cMap, (useCMap) => {
                      return extendCMap(cMap, fetchBuiltInCMap, useCMap);
                    });
                  }
                  if (compressionType === _util.CMapCompressionType.NONE) {
                    const lexer = new _parser.Lexer(new _stream.Stream(cMapData));
                    return parseCMap(cMap, lexer, fetchBuiltInCMap, null);
                  }
                  throw new Error("TODO: Only BINARY/NONE CMap compression is currently supported.");
                }
                __name(createBuiltInCMap, "createBuiltInCMap");
                return {
                  async create(params) {
                    const encoding = params.encoding;
                    const fetchBuiltInCMap = params.fetchBuiltInCMap;
                    const useCMap = params.useCMap;
                    if (encoding instanceof _primitives.Name) {
                      return createBuiltInCMap(encoding.name, fetchBuiltInCMap);
                    } else if (encoding instanceof _base_stream.BaseStream) {
                      const parsedCMap = await parseCMap(new CMap(), new _parser.Lexer(encoding), fetchBuiltInCMap, useCMap);
                      if (parsedCMap.isIdentityCMap) {
                        return createBuiltInCMap(parsedCMap.name, fetchBuiltInCMap);
                      }
                      return parsedCMap;
                    }
                    throw new Error("Encoding required.");
                  }
                };
              }, "CMapFactoryClosure"))();
              exports2.CMapFactory = CMapFactory;
            },
            /* 142 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Parser = exports2.Linearization = exports2.Lexer = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _primitives = __w_pdfjs_require__2(130);
              var _core_utils = __w_pdfjs_require__2(131);
              var _ascii_85_stream = __w_pdfjs_require__2(143);
              var _ascii_hex_stream = __w_pdfjs_require__2(145);
              var _ccitt_stream = __w_pdfjs_require__2(146);
              var _flate_stream = __w_pdfjs_require__2(148);
              var _jbig2_stream = __w_pdfjs_require__2(149);
              var _jpeg_stream = __w_pdfjs_require__2(152);
              var _jpx_stream = __w_pdfjs_require__2(154);
              var _lzw_stream = __w_pdfjs_require__2(156);
              var _stream = __w_pdfjs_require__2(135);
              var _predictor_stream = __w_pdfjs_require__2(157);
              var _run_length_stream = __w_pdfjs_require__2(158);
              const MAX_LENGTH_TO_CACHE = 1e3;
              const MAX_ADLER32_LENGTH = 5552;
              function computeAdler32(bytes) {
                const bytesLength = bytes.length;
                let a = 1, b = 0;
                for (let i = 0; i < bytesLength; ++i) {
                  a += bytes[i] & 255;
                  b += a;
                }
                return b % 65521 << 16 | a % 65521;
              }
              __name(computeAdler32, "computeAdler32");
              const _Parser = class _Parser {
                constructor(_ref) {
                  let {
                    lexer,
                    xref,
                    allowStreams = false,
                    recoveryMode = false
                  } = _ref;
                  this.lexer = lexer;
                  this.xref = xref;
                  this.allowStreams = allowStreams;
                  this.recoveryMode = recoveryMode;
                  this.imageCache = /* @__PURE__ */ Object.create(null);
                  this.refill();
                }
                refill() {
                  this.buf1 = this.lexer.getObj();
                  this.buf2 = this.lexer.getObj();
                }
                shift() {
                  if (this.buf2 instanceof _primitives.Cmd && this.buf2.cmd === "ID") {
                    this.buf1 = this.buf2;
                    this.buf2 = null;
                  } else {
                    this.buf1 = this.buf2;
                    this.buf2 = this.lexer.getObj();
                  }
                }
                tryShift() {
                  try {
                    this.shift();
                    return true;
                  } catch (e) {
                    if (e instanceof _core_utils.MissingDataException) {
                      throw e;
                    }
                    return false;
                  }
                }
                getObj() {
                  let cipherTransform = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                  const buf1 = this.buf1;
                  this.shift();
                  if (buf1 instanceof _primitives.Cmd) {
                    switch (buf1.cmd) {
                      case "BI":
                        return this.makeInlineImage(cipherTransform);
                      case "[":
                        const array = [];
                        while (!(0, _primitives.isCmd)(this.buf1, "]") && this.buf1 !== _primitives.EOF) {
                          array.push(this.getObj(cipherTransform));
                        }
                        if (this.buf1 === _primitives.EOF) {
                          if (this.recoveryMode) {
                            return array;
                          }
                          throw new _core_utils.ParserEOFException("End of file inside array.");
                        }
                        this.shift();
                        return array;
                      case "<<":
                        const dict = new _primitives.Dict(this.xref);
                        while (!(0, _primitives.isCmd)(this.buf1, ">>") && this.buf1 !== _primitives.EOF) {
                          if (!(this.buf1 instanceof _primitives.Name)) {
                            (0, _util.info)("Malformed dictionary: key must be a name object");
                            this.shift();
                            continue;
                          }
                          const key = this.buf1.name;
                          this.shift();
                          if (this.buf1 === _primitives.EOF) {
                            break;
                          }
                          dict.set(key, this.getObj(cipherTransform));
                        }
                        if (this.buf1 === _primitives.EOF) {
                          if (this.recoveryMode) {
                            return dict;
                          }
                          throw new _core_utils.ParserEOFException("End of file inside dictionary.");
                        }
                        if ((0, _primitives.isCmd)(this.buf2, "stream")) {
                          return this.allowStreams ? this.makeStream(dict, cipherTransform) : dict;
                        }
                        this.shift();
                        return dict;
                      default:
                        return buf1;
                    }
                  }
                  if (Number.isInteger(buf1)) {
                    if (Number.isInteger(this.buf1) && (0, _primitives.isCmd)(this.buf2, "R")) {
                      const ref = _primitives.Ref.get(buf1, this.buf1);
                      this.shift();
                      this.shift();
                      return ref;
                    }
                    return buf1;
                  }
                  if (typeof buf1 === "string") {
                    if (cipherTransform) {
                      return cipherTransform.decryptString(buf1);
                    }
                    return buf1;
                  }
                  return buf1;
                }
                findDefaultInlineStreamEnd(stream) {
                  const E = 69, I = 73, SPACE = 32, LF = 10, CR = 13, NUL = 0;
                  const lexer = this.lexer, startPos = stream.pos, n = 10;
                  let state = 0, ch, maybeEIPos;
                  while ((ch = stream.getByte()) !== -1) {
                    if (state === 0) {
                      state = ch === E ? 1 : 0;
                    } else if (state === 1) {
                      state = ch === I ? 2 : 0;
                    } else {
                      (0, _util.assert)(state === 2, "findDefaultInlineStreamEnd - invalid state.");
                      if (ch === SPACE || ch === LF || ch === CR) {
                        maybeEIPos = stream.pos;
                        const followingBytes = stream.peekBytes(n);
                        for (let i = 0, ii = followingBytes.length; i < ii; i++) {
                          ch = followingBytes[i];
                          if (ch === NUL && followingBytes[i + 1] !== NUL) {
                            continue;
                          }
                          if (ch !== LF && ch !== CR && (ch < SPACE || ch > 127)) {
                            state = 0;
                            break;
                          }
                        }
                        if (state !== 2) {
                          continue;
                        }
                        if (lexer.knownCommands) {
                          const nextObj = lexer.peekObj();
                          if (nextObj instanceof _primitives.Cmd && !lexer.knownCommands[nextObj.cmd]) {
                            state = 0;
                          }
                        } else {
                          (0, _util.warn)("findDefaultInlineStreamEnd - `lexer.knownCommands` is undefined.");
                        }
                        if (state === 2) {
                          break;
                        }
                      } else {
                        state = 0;
                      }
                    }
                  }
                  if (ch === -1) {
                    (0, _util.warn)("findDefaultInlineStreamEnd: Reached the end of the stream without finding a valid EI marker");
                    if (maybeEIPos) {
                      (0, _util.warn)('... trying to recover by using the last "EI" occurrence.');
                      stream.skip(-(stream.pos - maybeEIPos));
                    }
                  }
                  let endOffset = 4;
                  stream.skip(-endOffset);
                  ch = stream.peekByte();
                  stream.skip(endOffset);
                  if (!(0, _core_utils.isWhiteSpace)(ch)) {
                    endOffset--;
                  }
                  return stream.pos - endOffset - startPos;
                }
                findDCTDecodeInlineStreamEnd(stream) {
                  const startPos = stream.pos;
                  let foundEOI = false, b, markerLength;
                  while ((b = stream.getByte()) !== -1) {
                    if (b !== 255) {
                      continue;
                    }
                    switch (stream.getByte()) {
                      case 0:
                        break;
                      case 255:
                        stream.skip(-1);
                        break;
                      case 217:
                        foundEOI = true;
                        break;
                      case 192:
                      case 193:
                      case 194:
                      case 195:
                      case 197:
                      case 198:
                      case 199:
                      case 201:
                      case 202:
                      case 203:
                      case 205:
                      case 206:
                      case 207:
                      case 196:
                      case 204:
                      case 218:
                      case 219:
                      case 220:
                      case 221:
                      case 222:
                      case 223:
                      case 224:
                      case 225:
                      case 226:
                      case 227:
                      case 228:
                      case 229:
                      case 230:
                      case 231:
                      case 232:
                      case 233:
                      case 234:
                      case 235:
                      case 236:
                      case 237:
                      case 238:
                      case 239:
                      case 254:
                        markerLength = stream.getUint16();
                        if (markerLength > 2) {
                          stream.skip(markerLength - 2);
                        } else {
                          stream.skip(-2);
                        }
                        break;
                    }
                    if (foundEOI) {
                      break;
                    }
                  }
                  const length = stream.pos - startPos;
                  if (b === -1) {
                    (0, _util.warn)("Inline DCTDecode image stream: EOI marker not found, searching for /EI/ instead.");
                    stream.skip(-length);
                    return this.findDefaultInlineStreamEnd(stream);
                  }
                  this.inlineStreamSkipEI(stream);
                  return length;
                }
                findASCII85DecodeInlineStreamEnd(stream) {
                  const TILDE = 126, GT = 62;
                  const startPos = stream.pos;
                  let ch;
                  while ((ch = stream.getByte()) !== -1) {
                    if (ch === TILDE) {
                      const tildePos = stream.pos;
                      ch = stream.peekByte();
                      while ((0, _core_utils.isWhiteSpace)(ch)) {
                        stream.skip();
                        ch = stream.peekByte();
                      }
                      if (ch === GT) {
                        stream.skip();
                        break;
                      }
                      if (stream.pos > tildePos) {
                        const maybeEI = stream.peekBytes(2);
                        if (maybeEI[0] === 69 && maybeEI[1] === 73) {
                          break;
                        }
                      }
                    }
                  }
                  const length = stream.pos - startPos;
                  if (ch === -1) {
                    (0, _util.warn)("Inline ASCII85Decode image stream: EOD marker not found, searching for /EI/ instead.");
                    stream.skip(-length);
                    return this.findDefaultInlineStreamEnd(stream);
                  }
                  this.inlineStreamSkipEI(stream);
                  return length;
                }
                findASCIIHexDecodeInlineStreamEnd(stream) {
                  const GT = 62;
                  const startPos = stream.pos;
                  let ch;
                  while ((ch = stream.getByte()) !== -1) {
                    if (ch === GT) {
                      break;
                    }
                  }
                  const length = stream.pos - startPos;
                  if (ch === -1) {
                    (0, _util.warn)("Inline ASCIIHexDecode image stream: EOD marker not found, searching for /EI/ instead.");
                    stream.skip(-length);
                    return this.findDefaultInlineStreamEnd(stream);
                  }
                  this.inlineStreamSkipEI(stream);
                  return length;
                }
                inlineStreamSkipEI(stream) {
                  const E = 69, I = 73;
                  let state = 0, ch;
                  while ((ch = stream.getByte()) !== -1) {
                    if (state === 0) {
                      state = ch === E ? 1 : 0;
                    } else if (state === 1) {
                      state = ch === I ? 2 : 0;
                    } else if (state === 2) {
                      break;
                    }
                  }
                }
                makeInlineImage(cipherTransform) {
                  const lexer = this.lexer;
                  const stream = lexer.stream;
                  const dict = new _primitives.Dict(this.xref);
                  let dictLength;
                  while (!(0, _primitives.isCmd)(this.buf1, "ID") && this.buf1 !== _primitives.EOF) {
                    if (!(this.buf1 instanceof _primitives.Name)) {
                      throw new _util.FormatError("Dictionary key must be a name object");
                    }
                    const key = this.buf1.name;
                    this.shift();
                    if (this.buf1 === _primitives.EOF) {
                      break;
                    }
                    dict.set(key, this.getObj(cipherTransform));
                  }
                  if (lexer.beginInlineImagePos !== -1) {
                    dictLength = stream.pos - lexer.beginInlineImagePos;
                  }
                  const filter = dict.get("F", "Filter");
                  let filterName;
                  if (filter instanceof _primitives.Name) {
                    filterName = filter.name;
                  } else if (Array.isArray(filter)) {
                    const filterZero = this.xref.fetchIfRef(filter[0]);
                    if (filterZero instanceof _primitives.Name) {
                      filterName = filterZero.name;
                    }
                  }
                  const startPos = stream.pos;
                  let length;
                  switch (filterName) {
                    case "DCT":
                    case "DCTDecode":
                      length = this.findDCTDecodeInlineStreamEnd(stream);
                      break;
                    case "A85":
                    case "ASCII85Decode":
                      length = this.findASCII85DecodeInlineStreamEnd(stream);
                      break;
                    case "AHx":
                    case "ASCIIHexDecode":
                      length = this.findASCIIHexDecodeInlineStreamEnd(stream);
                      break;
                    default:
                      length = this.findDefaultInlineStreamEnd(stream);
                  }
                  let imageStream = stream.makeSubStream(startPos, length, dict);
                  let cacheKey;
                  if (length < MAX_LENGTH_TO_CACHE && dictLength < MAX_ADLER32_LENGTH) {
                    const imageBytes = imageStream.getBytes();
                    imageStream.reset();
                    const initialStreamPos = stream.pos;
                    stream.pos = lexer.beginInlineImagePos;
                    const dictBytes = stream.getBytes(dictLength);
                    stream.pos = initialStreamPos;
                    cacheKey = computeAdler32(imageBytes) + "_" + computeAdler32(dictBytes);
                    const cacheEntry = this.imageCache[cacheKey];
                    if (cacheEntry !== void 0) {
                      this.buf2 = _primitives.Cmd.get("EI");
                      this.shift();
                      cacheEntry.reset();
                      return cacheEntry;
                    }
                  }
                  if (cipherTransform) {
                    imageStream = cipherTransform.createStream(imageStream, length);
                  }
                  imageStream = this.filter(imageStream, dict, length);
                  imageStream.dict = dict;
                  if (cacheKey !== void 0) {
                    imageStream.cacheKey = `inline_${length}_${cacheKey}`;
                    this.imageCache[cacheKey] = imageStream;
                  }
                  this.buf2 = _primitives.Cmd.get("EI");
                  this.shift();
                  return imageStream;
                }
                _findStreamLength(startPos, signature) {
                  const {
                    stream
                  } = this.lexer;
                  stream.pos = startPos;
                  const SCAN_BLOCK_LENGTH = 2048;
                  const signatureLength = signature.length;
                  while (stream.pos < stream.end) {
                    const scanBytes = stream.peekBytes(SCAN_BLOCK_LENGTH);
                    const scanLength = scanBytes.length - signatureLength;
                    if (scanLength <= 0) {
                      break;
                    }
                    let pos = 0;
                    while (pos < scanLength) {
                      let j = 0;
                      while (j < signatureLength && scanBytes[pos + j] === signature[j]) {
                        j++;
                      }
                      if (j >= signatureLength) {
                        stream.pos += pos;
                        return stream.pos - startPos;
                      }
                      pos++;
                    }
                    stream.pos += scanLength;
                  }
                  return -1;
                }
                makeStream(dict, cipherTransform) {
                  const lexer = this.lexer;
                  let stream = lexer.stream;
                  lexer.skipToNextLine();
                  const startPos = stream.pos - 1;
                  let length = dict.get("Length");
                  if (!Number.isInteger(length)) {
                    (0, _util.info)(`Bad length "${length && length.toString()}" in stream.`);
                    length = 0;
                  }
                  stream.pos = startPos + length;
                  lexer.nextChar();
                  if (this.tryShift() && (0, _primitives.isCmd)(this.buf2, "endstream")) {
                    this.shift();
                  } else {
                    const ENDSTREAM_SIGNATURE = new Uint8Array([101, 110, 100, 115, 116, 114, 101, 97, 109]);
                    let actualLength = this._findStreamLength(startPos, ENDSTREAM_SIGNATURE);
                    if (actualLength < 0) {
                      const MAX_TRUNCATION = 1;
                      for (let i = 1; i <= MAX_TRUNCATION; i++) {
                        const end = ENDSTREAM_SIGNATURE.length - i;
                        const TRUNCATED_SIGNATURE = ENDSTREAM_SIGNATURE.slice(0, end);
                        const maybeLength = this._findStreamLength(startPos, TRUNCATED_SIGNATURE);
                        if (maybeLength >= 0) {
                          const lastByte = stream.peekBytes(end + 1)[end];
                          if (!(0, _core_utils.isWhiteSpace)(lastByte)) {
                            break;
                          }
                          (0, _util.info)(`Found "${(0, _util.bytesToString)(TRUNCATED_SIGNATURE)}" when searching for endstream command.`);
                          actualLength = maybeLength;
                          break;
                        }
                      }
                      if (actualLength < 0) {
                        throw new _util.FormatError("Missing endstream command.");
                      }
                    }
                    length = actualLength;
                    lexer.nextChar();
                    this.shift();
                    this.shift();
                  }
                  this.shift();
                  stream = stream.makeSubStream(startPos, length, dict);
                  if (cipherTransform) {
                    stream = cipherTransform.createStream(stream, length);
                  }
                  stream = this.filter(stream, dict, length);
                  stream.dict = dict;
                  return stream;
                }
                filter(stream, dict, length) {
                  let filter = dict.get("F", "Filter");
                  let params = dict.get("DP", "DecodeParms");
                  if (filter instanceof _primitives.Name) {
                    if (Array.isArray(params)) {
                      (0, _util.warn)("/DecodeParms should not be an Array, when /Filter is a Name.");
                    }
                    return this.makeFilter(stream, filter.name, length, params);
                  }
                  let maybeLength = length;
                  if (Array.isArray(filter)) {
                    const filterArray = filter;
                    const paramsArray = params;
                    for (let i = 0, ii = filterArray.length; i < ii; ++i) {
                      filter = this.xref.fetchIfRef(filterArray[i]);
                      if (!(filter instanceof _primitives.Name)) {
                        throw new _util.FormatError(`Bad filter name "${filter}"`);
                      }
                      params = null;
                      if (Array.isArray(paramsArray) && i in paramsArray) {
                        params = this.xref.fetchIfRef(paramsArray[i]);
                      }
                      stream = this.makeFilter(stream, filter.name, maybeLength, params);
                      maybeLength = null;
                    }
                  }
                  return stream;
                }
                makeFilter(stream, name, maybeLength, params) {
                  if (maybeLength === 0) {
                    (0, _util.warn)(`Empty "${name}" stream.`);
                    return new _stream.NullStream();
                  }
                  const xrefStats = this.xref.stats;
                  try {
                    switch (name) {
                      case "Fl":
                      case "FlateDecode":
                        xrefStats.addStreamType(_util.StreamType.FLATE);
                        if (params) {
                          return new _predictor_stream.PredictorStream(new _flate_stream.FlateStream(stream, maybeLength), maybeLength, params);
                        }
                        return new _flate_stream.FlateStream(stream, maybeLength);
                      case "LZW":
                      case "LZWDecode":
                        xrefStats.addStreamType(_util.StreamType.LZW);
                        let earlyChange = 1;
                        if (params) {
                          if (params.has("EarlyChange")) {
                            earlyChange = params.get("EarlyChange");
                          }
                          return new _predictor_stream.PredictorStream(new _lzw_stream.LZWStream(stream, maybeLength, earlyChange), maybeLength, params);
                        }
                        return new _lzw_stream.LZWStream(stream, maybeLength, earlyChange);
                      case "DCT":
                      case "DCTDecode":
                        xrefStats.addStreamType(_util.StreamType.DCT);
                        return new _jpeg_stream.JpegStream(stream, maybeLength, params);
                      case "JPX":
                      case "JPXDecode":
                        xrefStats.addStreamType(_util.StreamType.JPX);
                        return new _jpx_stream.JpxStream(stream, maybeLength, params);
                      case "A85":
                      case "ASCII85Decode":
                        xrefStats.addStreamType(_util.StreamType.A85);
                        return new _ascii_85_stream.Ascii85Stream(stream, maybeLength);
                      case "AHx":
                      case "ASCIIHexDecode":
                        xrefStats.addStreamType(_util.StreamType.AHX);
                        return new _ascii_hex_stream.AsciiHexStream(stream, maybeLength);
                      case "CCF":
                      case "CCITTFaxDecode":
                        xrefStats.addStreamType(_util.StreamType.CCF);
                        return new _ccitt_stream.CCITTFaxStream(stream, maybeLength, params);
                      case "RL":
                      case "RunLengthDecode":
                        xrefStats.addStreamType(_util.StreamType.RLX);
                        return new _run_length_stream.RunLengthStream(stream, maybeLength);
                      case "JBIG2Decode":
                        xrefStats.addStreamType(_util.StreamType.JBIG);
                        return new _jbig2_stream.Jbig2Stream(stream, maybeLength, params);
                    }
                    (0, _util.warn)(`Filter "${name}" is not supported.`);
                    return stream;
                  } catch (ex) {
                    if (ex instanceof _core_utils.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.warn)(`Invalid stream: "${ex}"`);
                    return new _stream.NullStream();
                  }
                }
              };
              __name(_Parser, "Parser");
              let Parser = _Parser;
              exports2.Parser = Parser;
              const specialChars = [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
              function toHexDigit(ch) {
                if (ch >= 48 && ch <= 57) {
                  return ch & 15;
                }
                if (ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102) {
                  return (ch & 15) + 9;
                }
                return -1;
              }
              __name(toHexDigit, "toHexDigit");
              const _Lexer = class _Lexer {
                constructor(stream) {
                  let knownCommands = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                  this.stream = stream;
                  this.nextChar();
                  this.strBuf = [];
                  this.knownCommands = knownCommands;
                  this._hexStringNumWarn = 0;
                  this.beginInlineImagePos = -1;
                }
                nextChar() {
                  return this.currentChar = this.stream.getByte();
                }
                peekChar() {
                  return this.stream.peekByte();
                }
                getNumber() {
                  let ch = this.currentChar;
                  let eNotation = false;
                  let divideBy = 0;
                  let sign = 0;
                  if (ch === 45) {
                    sign = -1;
                    ch = this.nextChar();
                    if (ch === 45) {
                      ch = this.nextChar();
                    }
                  } else if (ch === 43) {
                    sign = 1;
                    ch = this.nextChar();
                  }
                  if (ch === 10 || ch === 13) {
                    do {
                      ch = this.nextChar();
                    } while (ch === 10 || ch === 13);
                  }
                  if (ch === 46) {
                    divideBy = 10;
                    ch = this.nextChar();
                  }
                  if (ch < 48 || ch > 57) {
                    if ((0, _core_utils.isWhiteSpace)(ch) || ch === -1) {
                      if (divideBy === 10 && sign === 0) {
                        (0, _util.warn)("Lexer.getNumber - treating a single decimal point as zero.");
                        return 0;
                      }
                      if (divideBy === 0 && sign === -1) {
                        (0, _util.warn)("Lexer.getNumber - treating a single minus sign as zero.");
                        return 0;
                      }
                    }
                    throw new _util.FormatError(`Invalid number: ${String.fromCharCode(ch)} (charCode ${ch})`);
                  }
                  sign = sign || 1;
                  let baseValue = ch - 48;
                  let powerValue = 0;
                  let powerValueSign = 1;
                  while ((ch = this.nextChar()) >= 0) {
                    if (ch >= 48 && ch <= 57) {
                      const currentDigit = ch - 48;
                      if (eNotation) {
                        powerValue = powerValue * 10 + currentDigit;
                      } else {
                        if (divideBy !== 0) {
                          divideBy *= 10;
                        }
                        baseValue = baseValue * 10 + currentDigit;
                      }
                    } else if (ch === 46) {
                      if (divideBy === 0) {
                        divideBy = 1;
                      } else {
                        break;
                      }
                    } else if (ch === 45) {
                      (0, _util.warn)("Badly formatted number: minus sign in the middle");
                    } else if (ch === 69 || ch === 101) {
                      ch = this.peekChar();
                      if (ch === 43 || ch === 45) {
                        powerValueSign = ch === 45 ? -1 : 1;
                        this.nextChar();
                      } else if (ch < 48 || ch > 57) {
                        break;
                      }
                      eNotation = true;
                    } else {
                      break;
                    }
                  }
                  if (divideBy !== 0) {
                    baseValue /= divideBy;
                  }
                  if (eNotation) {
                    baseValue *= 10 ** (powerValueSign * powerValue);
                  }
                  return sign * baseValue;
                }
                getString() {
                  let numParen = 1;
                  let done = false;
                  const strBuf = this.strBuf;
                  strBuf.length = 0;
                  let ch = this.nextChar();
                  while (true) {
                    let charBuffered = false;
                    switch (ch | 0) {
                      case -1:
                        (0, _util.warn)("Unterminated string");
                        done = true;
                        break;
                      case 40:
                        ++numParen;
                        strBuf.push("(");
                        break;
                      case 41:
                        if (--numParen === 0) {
                          this.nextChar();
                          done = true;
                        } else {
                          strBuf.push(")");
                        }
                        break;
                      case 92:
                        ch = this.nextChar();
                        switch (ch) {
                          case -1:
                            (0, _util.warn)("Unterminated string");
                            done = true;
                            break;
                          case 110:
                            strBuf.push("\n");
                            break;
                          case 114:
                            strBuf.push("\r");
                            break;
                          case 116:
                            strBuf.push("	");
                            break;
                          case 98:
                            strBuf.push("\b");
                            break;
                          case 102:
                            strBuf.push("\f");
                            break;
                          case 92:
                          case 40:
                          case 41:
                            strBuf.push(String.fromCharCode(ch));
                            break;
                          case 48:
                          case 49:
                          case 50:
                          case 51:
                          case 52:
                          case 53:
                          case 54:
                          case 55:
                            let x = ch & 15;
                            ch = this.nextChar();
                            charBuffered = true;
                            if (ch >= 48 && ch <= 55) {
                              x = (x << 3) + (ch & 15);
                              ch = this.nextChar();
                              if (ch >= 48 && ch <= 55) {
                                charBuffered = false;
                                x = (x << 3) + (ch & 15);
                              }
                            }
                            strBuf.push(String.fromCharCode(x));
                            break;
                          case 13:
                            if (this.peekChar() === 10) {
                              this.nextChar();
                            }
                            break;
                          case 10:
                            break;
                          default:
                            strBuf.push(String.fromCharCode(ch));
                            break;
                        }
                        break;
                      default:
                        strBuf.push(String.fromCharCode(ch));
                        break;
                    }
                    if (done) {
                      break;
                    }
                    if (!charBuffered) {
                      ch = this.nextChar();
                    }
                  }
                  return strBuf.join("");
                }
                getName() {
                  let ch, previousCh;
                  const strBuf = this.strBuf;
                  strBuf.length = 0;
                  while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {
                    if (ch === 35) {
                      ch = this.nextChar();
                      if (specialChars[ch]) {
                        (0, _util.warn)("Lexer_getName: NUMBER SIGN (#) should be followed by a hexadecimal number.");
                        strBuf.push("#");
                        break;
                      }
                      const x = toHexDigit(ch);
                      if (x !== -1) {
                        previousCh = ch;
                        ch = this.nextChar();
                        const x2 = toHexDigit(ch);
                        if (x2 === -1) {
                          (0, _util.warn)(`Lexer_getName: Illegal digit (${String.fromCharCode(ch)}) in hexadecimal number.`);
                          strBuf.push("#", String.fromCharCode(previousCh));
                          if (specialChars[ch]) {
                            break;
                          }
                          strBuf.push(String.fromCharCode(ch));
                          continue;
                        }
                        strBuf.push(String.fromCharCode(x << 4 | x2));
                      } else {
                        strBuf.push("#", String.fromCharCode(ch));
                      }
                    } else {
                      strBuf.push(String.fromCharCode(ch));
                    }
                  }
                  if (strBuf.length > 127) {
                    (0, _util.warn)(`Name token is longer than allowed by the spec: ${strBuf.length}`);
                  }
                  return _primitives.Name.get(strBuf.join(""));
                }
                _hexStringWarn(ch) {
                  const MAX_HEX_STRING_NUM_WARN = 5;
                  if (this._hexStringNumWarn++ === MAX_HEX_STRING_NUM_WARN) {
                    (0, _util.warn)("getHexString - ignoring additional invalid characters.");
                    return;
                  }
                  if (this._hexStringNumWarn > MAX_HEX_STRING_NUM_WARN) {
                    return;
                  }
                  (0, _util.warn)(`getHexString - ignoring invalid character: ${ch}`);
                }
                getHexString() {
                  const strBuf = this.strBuf;
                  strBuf.length = 0;
                  let ch = this.currentChar;
                  let isFirstHex = true;
                  let firstDigit, secondDigit;
                  this._hexStringNumWarn = 0;
                  while (true) {
                    if (ch < 0) {
                      (0, _util.warn)("Unterminated hex string");
                      break;
                    } else if (ch === 62) {
                      this.nextChar();
                      break;
                    } else if (specialChars[ch] === 1) {
                      ch = this.nextChar();
                      continue;
                    } else {
                      if (isFirstHex) {
                        firstDigit = toHexDigit(ch);
                        if (firstDigit === -1) {
                          this._hexStringWarn(ch);
                          ch = this.nextChar();
                          continue;
                        }
                      } else {
                        secondDigit = toHexDigit(ch);
                        if (secondDigit === -1) {
                          this._hexStringWarn(ch);
                          ch = this.nextChar();
                          continue;
                        }
                        strBuf.push(String.fromCharCode(firstDigit << 4 | secondDigit));
                      }
                      isFirstHex = !isFirstHex;
                      ch = this.nextChar();
                    }
                  }
                  return strBuf.join("");
                }
                getObj() {
                  let comment = false;
                  let ch = this.currentChar;
                  while (true) {
                    if (ch < 0) {
                      return _primitives.EOF;
                    }
                    if (comment) {
                      if (ch === 10 || ch === 13) {
                        comment = false;
                      }
                    } else if (ch === 37) {
                      comment = true;
                    } else if (specialChars[ch] !== 1) {
                      break;
                    }
                    ch = this.nextChar();
                  }
                  switch (ch | 0) {
                    case 48:
                    case 49:
                    case 50:
                    case 51:
                    case 52:
                    case 53:
                    case 54:
                    case 55:
                    case 56:
                    case 57:
                    case 43:
                    case 45:
                    case 46:
                      return this.getNumber();
                    case 40:
                      return this.getString();
                    case 47:
                      return this.getName();
                    case 91:
                      this.nextChar();
                      return _primitives.Cmd.get("[");
                    case 93:
                      this.nextChar();
                      return _primitives.Cmd.get("]");
                    case 60:
                      ch = this.nextChar();
                      if (ch === 60) {
                        this.nextChar();
                        return _primitives.Cmd.get("<<");
                      }
                      return this.getHexString();
                    case 62:
                      ch = this.nextChar();
                      if (ch === 62) {
                        this.nextChar();
                        return _primitives.Cmd.get(">>");
                      }
                      return _primitives.Cmd.get(">");
                    case 123:
                      this.nextChar();
                      return _primitives.Cmd.get("{");
                    case 125:
                      this.nextChar();
                      return _primitives.Cmd.get("}");
                    case 41:
                      this.nextChar();
                      throw new _util.FormatError(`Illegal character: ${ch}`);
                  }
                  let str = String.fromCharCode(ch);
                  if (ch < 32 || ch > 127) {
                    const nextCh = this.peekChar();
                    if (nextCh >= 32 && nextCh <= 127) {
                      this.nextChar();
                      return _primitives.Cmd.get(str);
                    }
                  }
                  const knownCommands = this.knownCommands;
                  let knownCommandFound = knownCommands && knownCommands[str] !== void 0;
                  while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {
                    const possibleCommand = str + String.fromCharCode(ch);
                    if (knownCommandFound && knownCommands[possibleCommand] === void 0) {
                      break;
                    }
                    if (str.length === 128) {
                      throw new _util.FormatError(`Command token too long: ${str.length}`);
                    }
                    str = possibleCommand;
                    knownCommandFound = knownCommands && knownCommands[str] !== void 0;
                  }
                  if (str === "true") {
                    return true;
                  }
                  if (str === "false") {
                    return false;
                  }
                  if (str === "null") {
                    return null;
                  }
                  if (str === "BI") {
                    this.beginInlineImagePos = this.stream.pos;
                  }
                  return _primitives.Cmd.get(str);
                }
                peekObj() {
                  const streamPos = this.stream.pos, currentChar = this.currentChar, beginInlineImagePos = this.beginInlineImagePos;
                  let nextObj;
                  try {
                    nextObj = this.getObj();
                  } catch (ex) {
                    if (ex instanceof _core_utils.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.warn)(`peekObj: ${ex}`);
                  }
                  this.stream.pos = streamPos;
                  this.currentChar = currentChar;
                  this.beginInlineImagePos = beginInlineImagePos;
                  return nextObj;
                }
                skipToNextLine() {
                  let ch = this.currentChar;
                  while (ch >= 0) {
                    if (ch === 13) {
                      ch = this.nextChar();
                      if (ch === 10) {
                        this.nextChar();
                      }
                      break;
                    } else if (ch === 10) {
                      this.nextChar();
                      break;
                    }
                    ch = this.nextChar();
                  }
                }
              };
              __name(_Lexer, "Lexer");
              let Lexer = _Lexer;
              exports2.Lexer = Lexer;
              const _Linearization = class _Linearization {
                static create(stream) {
                  function getInt(linDict2, name) {
                    let allowZeroValue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                    const obj4 = linDict2.get(name);
                    if (Number.isInteger(obj4) && (allowZeroValue ? obj4 >= 0 : obj4 > 0)) {
                      return obj4;
                    }
                    throw new Error(`The "${name}" parameter in the linearization dictionary is invalid.`);
                  }
                  __name(getInt, "getInt");
                  function getHints(linDict2) {
                    const hints = linDict2.get("H");
                    let hintsLength;
                    if (Array.isArray(hints) && ((hintsLength = hints.length) === 2 || hintsLength === 4)) {
                      for (let index = 0; index < hintsLength; index++) {
                        const hint = hints[index];
                        if (!(Number.isInteger(hint) && hint > 0)) {
                          throw new Error(`Hint (${index}) in the linearization dictionary is invalid.`);
                        }
                      }
                      return hints;
                    }
                    throw new Error("Hint array in the linearization dictionary is invalid.");
                  }
                  __name(getHints, "getHints");
                  const parser = new Parser({
                    lexer: new Lexer(stream),
                    xref: null
                  });
                  const obj1 = parser.getObj();
                  const obj2 = parser.getObj();
                  const obj3 = parser.getObj();
                  const linDict = parser.getObj();
                  let obj, length;
                  if (!(Number.isInteger(obj1) && Number.isInteger(obj2) && (0, _primitives.isCmd)(obj3, "obj") && linDict instanceof _primitives.Dict && typeof (obj = linDict.get("Linearized")) === "number" && obj > 0)) {
                    return null;
                  } else if ((length = getInt(linDict, "L")) !== stream.length) {
                    throw new Error('The "L" parameter in the linearization dictionary does not equal the stream length.');
                  }
                  return {
                    length,
                    hints: getHints(linDict),
                    objectNumberFirst: getInt(linDict, "O"),
                    endFirst: getInt(linDict, "E"),
                    numPages: getInt(linDict, "N"),
                    mainXRefEntriesOffset: getInt(linDict, "T"),
                    pageFirst: linDict.has("P") ? getInt(linDict, "P", true) : 0
                  };
                }
              };
              __name(_Linearization, "Linearization");
              let Linearization = _Linearization;
              exports2.Linearization = Linearization;
            },
            /* 143 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Ascii85Stream = void 0;
              var _decode_stream = __w_pdfjs_require__2(144);
              var _core_utils = __w_pdfjs_require__2(131);
              const _Ascii85Stream = class _Ascii85Stream extends _decode_stream.DecodeStream {
                constructor(str, maybeLength) {
                  if (maybeLength) {
                    maybeLength *= 0.8;
                  }
                  super(maybeLength);
                  this.str = str;
                  this.dict = str.dict;
                  this.input = new Uint8Array(5);
                }
                readBlock() {
                  const TILDA_CHAR = 126;
                  const Z_LOWER_CHAR = 122;
                  const EOF = -1;
                  const str = this.str;
                  let c = str.getByte();
                  while ((0, _core_utils.isWhiteSpace)(c)) {
                    c = str.getByte();
                  }
                  if (c === EOF || c === TILDA_CHAR) {
                    this.eof = true;
                    return;
                  }
                  const bufferLength = this.bufferLength;
                  let buffer, i;
                  if (c === Z_LOWER_CHAR) {
                    buffer = this.ensureBuffer(bufferLength + 4);
                    for (i = 0; i < 4; ++i) {
                      buffer[bufferLength + i] = 0;
                    }
                    this.bufferLength += 4;
                  } else {
                    const input = this.input;
                    input[0] = c;
                    for (i = 1; i < 5; ++i) {
                      c = str.getByte();
                      while ((0, _core_utils.isWhiteSpace)(c)) {
                        c = str.getByte();
                      }
                      input[i] = c;
                      if (c === EOF || c === TILDA_CHAR) {
                        break;
                      }
                    }
                    buffer = this.ensureBuffer(bufferLength + i - 1);
                    this.bufferLength += i - 1;
                    if (i < 5) {
                      for (; i < 5; ++i) {
                        input[i] = 33 + 84;
                      }
                      this.eof = true;
                    }
                    let t = 0;
                    for (i = 0; i < 5; ++i) {
                      t = t * 85 + (input[i] - 33);
                    }
                    for (i = 3; i >= 0; --i) {
                      buffer[bufferLength + i] = t & 255;
                      t >>= 8;
                    }
                  }
                }
              };
              __name(_Ascii85Stream, "Ascii85Stream");
              let Ascii85Stream = _Ascii85Stream;
              exports2.Ascii85Stream = Ascii85Stream;
            },
            /* 144 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.StreamsSequenceStream = exports2.DecodeStream = void 0;
              var _base_stream = __w_pdfjs_require__2(132);
              var _stream = __w_pdfjs_require__2(135);
              const emptyBuffer = new Uint8Array(0);
              const _DecodeStream = class _DecodeStream extends _base_stream.BaseStream {
                constructor(maybeMinBufferLength) {
                  super();
                  this._rawMinBufferLength = maybeMinBufferLength || 0;
                  this.pos = 0;
                  this.bufferLength = 0;
                  this.eof = false;
                  this.buffer = emptyBuffer;
                  this.minBufferLength = 512;
                  if (maybeMinBufferLength) {
                    while (this.minBufferLength < maybeMinBufferLength) {
                      this.minBufferLength *= 2;
                    }
                  }
                }
                get isEmpty() {
                  while (!this.eof && this.bufferLength === 0) {
                    this.readBlock();
                  }
                  return this.bufferLength === 0;
                }
                ensureBuffer(requested) {
                  const buffer = this.buffer;
                  if (requested <= buffer.byteLength) {
                    return buffer;
                  }
                  let size = this.minBufferLength;
                  while (size < requested) {
                    size *= 2;
                  }
                  const buffer2 = new Uint8Array(size);
                  buffer2.set(buffer);
                  return this.buffer = buffer2;
                }
                getByte() {
                  const pos = this.pos;
                  while (this.bufferLength <= pos) {
                    if (this.eof) {
                      return -1;
                    }
                    this.readBlock();
                  }
                  return this.buffer[this.pos++];
                }
                getBytes(length) {
                  const pos = this.pos;
                  let end;
                  if (length) {
                    this.ensureBuffer(pos + length);
                    end = pos + length;
                    while (!this.eof && this.bufferLength < end) {
                      this.readBlock();
                    }
                    const bufEnd = this.bufferLength;
                    if (end > bufEnd) {
                      end = bufEnd;
                    }
                  } else {
                    while (!this.eof) {
                      this.readBlock();
                    }
                    end = this.bufferLength;
                  }
                  this.pos = end;
                  return this.buffer.subarray(pos, end);
                }
                reset() {
                  this.pos = 0;
                }
                makeSubStream(start, length) {
                  let dict = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                  if (length === void 0) {
                    while (!this.eof) {
                      this.readBlock();
                    }
                  } else {
                    const end = start + length;
                    while (this.bufferLength <= end && !this.eof) {
                      this.readBlock();
                    }
                  }
                  return new _stream.Stream(this.buffer, start, length, dict);
                }
                getBaseStreams() {
                  return this.str ? this.str.getBaseStreams() : null;
                }
              };
              __name(_DecodeStream, "DecodeStream");
              let DecodeStream = _DecodeStream;
              exports2.DecodeStream = DecodeStream;
              const _StreamsSequenceStream = class _StreamsSequenceStream extends DecodeStream {
                constructor(streams) {
                  let onError = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                  let maybeLength = 0;
                  for (const stream of streams) {
                    maybeLength += stream instanceof DecodeStream ? stream._rawMinBufferLength : stream.length;
                  }
                  super(maybeLength);
                  this.streams = streams;
                  this._onError = onError;
                }
                readBlock() {
                  const streams = this.streams;
                  if (streams.length === 0) {
                    this.eof = true;
                    return;
                  }
                  const stream = streams.shift();
                  let chunk;
                  try {
                    chunk = stream.getBytes();
                  } catch (reason) {
                    if (this._onError) {
                      this._onError(reason, stream.dict && stream.dict.objId);
                      return;
                    }
                    throw reason;
                  }
                  const bufferLength = this.bufferLength;
                  const newLength = bufferLength + chunk.length;
                  const buffer = this.ensureBuffer(newLength);
                  buffer.set(chunk, bufferLength);
                  this.bufferLength = newLength;
                }
                getBaseStreams() {
                  const baseStreamsBuf = [];
                  for (const stream of this.streams) {
                    const baseStreams = stream.getBaseStreams();
                    if (baseStreams) {
                      baseStreamsBuf.push(...baseStreams);
                    }
                  }
                  return baseStreamsBuf.length > 0 ? baseStreamsBuf : null;
                }
              };
              __name(_StreamsSequenceStream, "StreamsSequenceStream");
              let StreamsSequenceStream = _StreamsSequenceStream;
              exports2.StreamsSequenceStream = StreamsSequenceStream;
            },
            /* 145 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.AsciiHexStream = void 0;
              var _decode_stream = __w_pdfjs_require__2(144);
              const _AsciiHexStream = class _AsciiHexStream extends _decode_stream.DecodeStream {
                constructor(str, maybeLength) {
                  if (maybeLength) {
                    maybeLength *= 0.5;
                  }
                  super(maybeLength);
                  this.str = str;
                  this.dict = str.dict;
                  this.firstDigit = -1;
                }
                readBlock() {
                  const UPSTREAM_BLOCK_SIZE = 8e3;
                  const bytes = this.str.getBytes(UPSTREAM_BLOCK_SIZE);
                  if (!bytes.length) {
                    this.eof = true;
                    return;
                  }
                  const maxDecodeLength = bytes.length + 1 >> 1;
                  const buffer = this.ensureBuffer(this.bufferLength + maxDecodeLength);
                  let bufferLength = this.bufferLength;
                  let firstDigit = this.firstDigit;
                  for (const ch of bytes) {
                    let digit;
                    if (ch >= 48 && ch <= 57) {
                      digit = ch & 15;
                    } else if (ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102) {
                      digit = (ch & 15) + 9;
                    } else if (ch === 62) {
                      this.eof = true;
                      break;
                    } else {
                      continue;
                    }
                    if (firstDigit < 0) {
                      firstDigit = digit;
                    } else {
                      buffer[bufferLength++] = firstDigit << 4 | digit;
                      firstDigit = -1;
                    }
                  }
                  if (firstDigit >= 0 && this.eof) {
                    buffer[bufferLength++] = firstDigit << 4;
                    firstDigit = -1;
                  }
                  this.firstDigit = firstDigit;
                  this.bufferLength = bufferLength;
                }
              };
              __name(_AsciiHexStream, "AsciiHexStream");
              let AsciiHexStream = _AsciiHexStream;
              exports2.AsciiHexStream = AsciiHexStream;
            },
            /* 146 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.CCITTFaxStream = void 0;
              var _ccitt = __w_pdfjs_require__2(147);
              var _decode_stream = __w_pdfjs_require__2(144);
              var _primitives = __w_pdfjs_require__2(130);
              const _CCITTFaxStream = class _CCITTFaxStream extends _decode_stream.DecodeStream {
                constructor(str, maybeLength, params) {
                  super(maybeLength);
                  this.str = str;
                  this.dict = str.dict;
                  if (!(params instanceof _primitives.Dict)) {
                    params = _primitives.Dict.empty;
                  }
                  const source = {
                    next() {
                      return str.getByte();
                    }
                  };
                  this.ccittFaxDecoder = new _ccitt.CCITTFaxDecoder(source, {
                    K: params.get("K"),
                    EndOfLine: params.get("EndOfLine"),
                    EncodedByteAlign: params.get("EncodedByteAlign"),
                    Columns: params.get("Columns"),
                    Rows: params.get("Rows"),
                    EndOfBlock: params.get("EndOfBlock"),
                    BlackIs1: params.get("BlackIs1")
                  });
                }
                readBlock() {
                  while (!this.eof) {
                    const c = this.ccittFaxDecoder.readNextChar();
                    if (c === -1) {
                      this.eof = true;
                      return;
                    }
                    this.ensureBuffer(this.bufferLength + 1);
                    this.buffer[this.bufferLength++] = c;
                  }
                }
              };
              __name(_CCITTFaxStream, "CCITTFaxStream");
              let CCITTFaxStream = _CCITTFaxStream;
              exports2.CCITTFaxStream = CCITTFaxStream;
            },
            /* 147 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.CCITTFaxDecoder = void 0;
              var _util = __w_pdfjs_require__2(2);
              const ccittEOL = -2;
              const ccittEOF = -1;
              const twoDimPass = 0;
              const twoDimHoriz = 1;
              const twoDimVert0 = 2;
              const twoDimVertR1 = 3;
              const twoDimVertL1 = 4;
              const twoDimVertR2 = 5;
              const twoDimVertL2 = 6;
              const twoDimVertR3 = 7;
              const twoDimVertL3 = 8;
              const twoDimTable = [[-1, -1], [-1, -1], [7, twoDimVertL3], [7, twoDimVertR3], [6, twoDimVertL2], [6, twoDimVertL2], [6, twoDimVertR2], [6, twoDimVertR2], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0]];
              const whiteTable1 = [[-1, -1], [12, ccittEOL], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [12, 1984], [12, 2048], [12, 2112], [12, 2176], [12, 2240], [12, 2304], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [12, 2368], [12, 2432], [12, 2496], [12, 2560]];
              const whiteTable2 = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [8, 29], [8, 29], [8, 30], [8, 30], [8, 45], [8, 45], [8, 46], [8, 46], [7, 22], [7, 22], [7, 22], [7, 22], [7, 23], [7, 23], [7, 23], [7, 23], [8, 47], [8, 47], [8, 48], [8, 48], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [7, 20], [7, 20], [7, 20], [7, 20], [8, 33], [8, 33], [8, 34], [8, 34], [8, 35], [8, 35], [8, 36], [8, 36], [8, 37], [8, 37], [8, 38], [8, 38], [7, 19], [7, 19], [7, 19], [7, 19], [8, 31], [8, 31], [8, 32], [8, 32], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [8, 53], [8, 53], [8, 54], [8, 54], [7, 26], [7, 26], [7, 26], [7, 26], [8, 39], [8, 39], [8, 40], [8, 40], [8, 41], [8, 41], [8, 42], [8, 42], [8, 43], [8, 43], [8, 44], [8, 44], [7, 21], [7, 21], [7, 21], [7, 21], [7, 28], [7, 28], [7, 28], [7, 28], [8, 61], [8, 61], [8, 62], [8, 62], [8, 63], [8, 63], [8, 0], [8, 0], [8, 320], [8, 320], [8, 384], [8, 384], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [7, 27], [7, 27], [7, 27], [7, 27], [8, 59], [8, 59], [8, 60], [8, 60], [9, 1472], [9, 1536], [9, 1600], [9, 1728], [7, 18], [7, 18], [7, 18], [7, 18], [7, 24], [7, 24], [7, 24], [7, 24], [8, 49], [8, 49], [8, 50], [8, 50], [8, 51], [8, 51], [8, 52], [8, 52], [7, 25], [7, 25], [7, 25], [7, 25], [8, 55], [8, 55], [8, 56], [8, 56], [8, 57], [8, 57], [8, 58], [8, 58], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [8, 448], [8, 448], [8, 512], [8, 512], [9, 704], [9, 768], [8, 640], [8, 640], [8, 576], [8, 576], [9, 832], [9, 896], [9, 960], [9, 1024], [9, 1088], [9, 1152], [9, 1216], [9, 1280], [9, 1344], [9, 1408], [7, 256], [7, 256], [7, 256], [7, 256], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7]];
              const blackTable1 = [[-1, -1], [-1, -1], [12, ccittEOL], [12, ccittEOL], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [11, 1792], [11, 1792], [12, 1984], [12, 1984], [12, 2048], [12, 2048], [12, 2112], [12, 2112], [12, 2176], [12, 2176], [12, 2240], [12, 2240], [12, 2304], [12, 2304], [11, 1856], [11, 1856], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [11, 1920], [11, 1920], [12, 2368], [12, 2368], [12, 2432], [12, 2432], [12, 2496], [12, 2496], [12, 2560], [12, 2560], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [12, 52], [12, 52], [13, 640], [13, 704], [13, 768], [13, 832], [12, 55], [12, 55], [12, 56], [12, 56], [13, 1280], [13, 1344], [13, 1408], [13, 1472], [12, 59], [12, 59], [12, 60], [12, 60], [13, 1536], [13, 1600], [11, 24], [11, 24], [11, 24], [11, 24], [11, 25], [11, 25], [11, 25], [11, 25], [13, 1664], [13, 1728], [12, 320], [12, 320], [12, 384], [12, 384], [12, 448], [12, 448], [13, 512], [13, 576], [12, 53], [12, 53], [12, 54], [12, 54], [13, 896], [13, 960], [13, 1024], [13, 1088], [13, 1152], [13, 1216], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64]];
              const blackTable2 = [[8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [11, 23], [11, 23], [12, 50], [12, 51], [12, 44], [12, 45], [12, 46], [12, 47], [12, 57], [12, 58], [12, 61], [12, 256], [10, 16], [10, 16], [10, 16], [10, 16], [10, 17], [10, 17], [10, 17], [10, 17], [12, 48], [12, 49], [12, 62], [12, 63], [12, 30], [12, 31], [12, 32], [12, 33], [12, 40], [12, 41], [11, 22], [11, 22], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [12, 128], [12, 192], [12, 26], [12, 27], [12, 28], [12, 29], [11, 19], [11, 19], [11, 20], [11, 20], [12, 34], [12, 35], [12, 36], [12, 37], [12, 38], [12, 39], [11, 21], [11, 21], [12, 42], [12, 43], [10, 0], [10, 0], [10, 0], [10, 0], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12]];
              const blackTable3 = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [6, 9], [6, 8], [5, 7], [5, 7], [4, 6], [4, 6], [4, 6], [4, 6], [4, 5], [4, 5], [4, 5], [4, 5], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2]];
              const _CCITTFaxDecoder = class _CCITTFaxDecoder {
                constructor(source) {
                  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                  if (!source || typeof source.next !== "function") {
                    throw new Error('CCITTFaxDecoder - invalid "source" parameter.');
                  }
                  this.source = source;
                  this.eof = false;
                  this.encoding = options.K || 0;
                  this.eoline = options.EndOfLine || false;
                  this.byteAlign = options.EncodedByteAlign || false;
                  this.columns = options.Columns || 1728;
                  this.rows = options.Rows || 0;
                  let eoblock = options.EndOfBlock;
                  if (eoblock === null || eoblock === void 0) {
                    eoblock = true;
                  }
                  this.eoblock = eoblock;
                  this.black = options.BlackIs1 || false;
                  this.codingLine = new Uint32Array(this.columns + 1);
                  this.refLine = new Uint32Array(this.columns + 2);
                  this.codingLine[0] = this.columns;
                  this.codingPos = 0;
                  this.row = 0;
                  this.nextLine2D = this.encoding < 0;
                  this.inputBits = 0;
                  this.inputBuf = 0;
                  this.outputBits = 0;
                  this.rowsDone = false;
                  let code1;
                  while ((code1 = this._lookBits(12)) === 0) {
                    this._eatBits(1);
                  }
                  if (code1 === 1) {
                    this._eatBits(12);
                  }
                  if (this.encoding > 0) {
                    this.nextLine2D = !this._lookBits(1);
                    this._eatBits(1);
                  }
                }
                readNextChar() {
                  if (this.eof) {
                    return -1;
                  }
                  const refLine = this.refLine;
                  const codingLine = this.codingLine;
                  const columns = this.columns;
                  let refPos, blackPixels, bits, i;
                  if (this.outputBits === 0) {
                    if (this.rowsDone) {
                      this.eof = true;
                    }
                    if (this.eof) {
                      return -1;
                    }
                    this.err = false;
                    let code1, code2, code3;
                    if (this.nextLine2D) {
                      for (i = 0; codingLine[i] < columns; ++i) {
                        refLine[i] = codingLine[i];
                      }
                      refLine[i++] = columns;
                      refLine[i] = columns;
                      codingLine[0] = 0;
                      this.codingPos = 0;
                      refPos = 0;
                      blackPixels = 0;
                      while (codingLine[this.codingPos] < columns) {
                        code1 = this._getTwoDimCode();
                        switch (code1) {
                          case twoDimPass:
                            this._addPixels(refLine[refPos + 1], blackPixels);
                            if (refLine[refPos + 1] < columns) {
                              refPos += 2;
                            }
                            break;
                          case twoDimHoriz:
                            code1 = code2 = 0;
                            if (blackPixels) {
                              do {
                                code1 += code3 = this._getBlackCode();
                              } while (code3 >= 64);
                              do {
                                code2 += code3 = this._getWhiteCode();
                              } while (code3 >= 64);
                            } else {
                              do {
                                code1 += code3 = this._getWhiteCode();
                              } while (code3 >= 64);
                              do {
                                code2 += code3 = this._getBlackCode();
                              } while (code3 >= 64);
                            }
                            this._addPixels(codingLine[this.codingPos] + code1, blackPixels);
                            if (codingLine[this.codingPos] < columns) {
                              this._addPixels(codingLine[this.codingPos] + code2, blackPixels ^ 1);
                            }
                            while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                              refPos += 2;
                            }
                            break;
                          case twoDimVertR3:
                            this._addPixels(refLine[refPos] + 3, blackPixels);
                            blackPixels ^= 1;
                            if (codingLine[this.codingPos] < columns) {
                              ++refPos;
                              while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                refPos += 2;
                              }
                            }
                            break;
                          case twoDimVertR2:
                            this._addPixels(refLine[refPos] + 2, blackPixels);
                            blackPixels ^= 1;
                            if (codingLine[this.codingPos] < columns) {
                              ++refPos;
                              while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                refPos += 2;
                              }
                            }
                            break;
                          case twoDimVertR1:
                            this._addPixels(refLine[refPos] + 1, blackPixels);
                            blackPixels ^= 1;
                            if (codingLine[this.codingPos] < columns) {
                              ++refPos;
                              while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                refPos += 2;
                              }
                            }
                            break;
                          case twoDimVert0:
                            this._addPixels(refLine[refPos], blackPixels);
                            blackPixels ^= 1;
                            if (codingLine[this.codingPos] < columns) {
                              ++refPos;
                              while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                refPos += 2;
                              }
                            }
                            break;
                          case twoDimVertL3:
                            this._addPixelsNeg(refLine[refPos] - 3, blackPixels);
                            blackPixels ^= 1;
                            if (codingLine[this.codingPos] < columns) {
                              if (refPos > 0) {
                                --refPos;
                              } else {
                                ++refPos;
                              }
                              while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                refPos += 2;
                              }
                            }
                            break;
                          case twoDimVertL2:
                            this._addPixelsNeg(refLine[refPos] - 2, blackPixels);
                            blackPixels ^= 1;
                            if (codingLine[this.codingPos] < columns) {
                              if (refPos > 0) {
                                --refPos;
                              } else {
                                ++refPos;
                              }
                              while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                refPos += 2;
                              }
                            }
                            break;
                          case twoDimVertL1:
                            this._addPixelsNeg(refLine[refPos] - 1, blackPixels);
                            blackPixels ^= 1;
                            if (codingLine[this.codingPos] < columns) {
                              if (refPos > 0) {
                                --refPos;
                              } else {
                                ++refPos;
                              }
                              while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                refPos += 2;
                              }
                            }
                            break;
                          case ccittEOF:
                            this._addPixels(columns, 0);
                            this.eof = true;
                            break;
                          default:
                            (0, _util.info)("bad 2d code");
                            this._addPixels(columns, 0);
                            this.err = true;
                        }
                      }
                    } else {
                      codingLine[0] = 0;
                      this.codingPos = 0;
                      blackPixels = 0;
                      while (codingLine[this.codingPos] < columns) {
                        code1 = 0;
                        if (blackPixels) {
                          do {
                            code1 += code3 = this._getBlackCode();
                          } while (code3 >= 64);
                        } else {
                          do {
                            code1 += code3 = this._getWhiteCode();
                          } while (code3 >= 64);
                        }
                        this._addPixels(codingLine[this.codingPos] + code1, blackPixels);
                        blackPixels ^= 1;
                      }
                    }
                    let gotEOL = false;
                    if (this.byteAlign) {
                      this.inputBits &= ~7;
                    }
                    if (!this.eoblock && this.row === this.rows - 1) {
                      this.rowsDone = true;
                    } else {
                      code1 = this._lookBits(12);
                      if (this.eoline) {
                        while (code1 !== ccittEOF && code1 !== 1) {
                          this._eatBits(1);
                          code1 = this._lookBits(12);
                        }
                      } else {
                        while (code1 === 0) {
                          this._eatBits(1);
                          code1 = this._lookBits(12);
                        }
                      }
                      if (code1 === 1) {
                        this._eatBits(12);
                        gotEOL = true;
                      } else if (code1 === ccittEOF) {
                        this.eof = true;
                      }
                    }
                    if (!this.eof && this.encoding > 0 && !this.rowsDone) {
                      this.nextLine2D = !this._lookBits(1);
                      this._eatBits(1);
                    }
                    if (this.eoblock && gotEOL && this.byteAlign) {
                      code1 = this._lookBits(12);
                      if (code1 === 1) {
                        this._eatBits(12);
                        if (this.encoding > 0) {
                          this._lookBits(1);
                          this._eatBits(1);
                        }
                        if (this.encoding >= 0) {
                          for (i = 0; i < 4; ++i) {
                            code1 = this._lookBits(12);
                            if (code1 !== 1) {
                              (0, _util.info)("bad rtc code: " + code1);
                            }
                            this._eatBits(12);
                            if (this.encoding > 0) {
                              this._lookBits(1);
                              this._eatBits(1);
                            }
                          }
                        }
                        this.eof = true;
                      }
                    } else if (this.err && this.eoline) {
                      while (true) {
                        code1 = this._lookBits(13);
                        if (code1 === ccittEOF) {
                          this.eof = true;
                          return -1;
                        }
                        if (code1 >> 1 === 1) {
                          break;
                        }
                        this._eatBits(1);
                      }
                      this._eatBits(12);
                      if (this.encoding > 0) {
                        this._eatBits(1);
                        this.nextLine2D = !(code1 & 1);
                      }
                    }
                    if (codingLine[0] > 0) {
                      this.outputBits = codingLine[this.codingPos = 0];
                    } else {
                      this.outputBits = codingLine[this.codingPos = 1];
                    }
                    this.row++;
                  }
                  let c;
                  if (this.outputBits >= 8) {
                    c = this.codingPos & 1 ? 0 : 255;
                    this.outputBits -= 8;
                    if (this.outputBits === 0 && codingLine[this.codingPos] < columns) {
                      this.codingPos++;
                      this.outputBits = codingLine[this.codingPos] - codingLine[this.codingPos - 1];
                    }
                  } else {
                    bits = 8;
                    c = 0;
                    do {
                      if (typeof this.outputBits !== "number") {
                        throw new _util.FormatError('Invalid /CCITTFaxDecode data, "outputBits" must be a number.');
                      }
                      if (this.outputBits > bits) {
                        c <<= bits;
                        if (!(this.codingPos & 1)) {
                          c |= 255 >> 8 - bits;
                        }
                        this.outputBits -= bits;
                        bits = 0;
                      } else {
                        c <<= this.outputBits;
                        if (!(this.codingPos & 1)) {
                          c |= 255 >> 8 - this.outputBits;
                        }
                        bits -= this.outputBits;
                        this.outputBits = 0;
                        if (codingLine[this.codingPos] < columns) {
                          this.codingPos++;
                          this.outputBits = codingLine[this.codingPos] - codingLine[this.codingPos - 1];
                        } else if (bits > 0) {
                          c <<= bits;
                          bits = 0;
                        }
                      }
                    } while (bits);
                  }
                  if (this.black) {
                    c ^= 255;
                  }
                  return c;
                }
                _addPixels(a1, blackPixels) {
                  const codingLine = this.codingLine;
                  let codingPos = this.codingPos;
                  if (a1 > codingLine[codingPos]) {
                    if (a1 > this.columns) {
                      (0, _util.info)("row is wrong length");
                      this.err = true;
                      a1 = this.columns;
                    }
                    if (codingPos & 1 ^ blackPixels) {
                      ++codingPos;
                    }
                    codingLine[codingPos] = a1;
                  }
                  this.codingPos = codingPos;
                }
                _addPixelsNeg(a1, blackPixels) {
                  const codingLine = this.codingLine;
                  let codingPos = this.codingPos;
                  if (a1 > codingLine[codingPos]) {
                    if (a1 > this.columns) {
                      (0, _util.info)("row is wrong length");
                      this.err = true;
                      a1 = this.columns;
                    }
                    if (codingPos & 1 ^ blackPixels) {
                      ++codingPos;
                    }
                    codingLine[codingPos] = a1;
                  } else if (a1 < codingLine[codingPos]) {
                    if (a1 < 0) {
                      (0, _util.info)("invalid code");
                      this.err = true;
                      a1 = 0;
                    }
                    while (codingPos > 0 && a1 < codingLine[codingPos - 1]) {
                      --codingPos;
                    }
                    codingLine[codingPos] = a1;
                  }
                  this.codingPos = codingPos;
                }
                _findTableCode(start, end, table, limit) {
                  const limitValue = limit || 0;
                  for (let i = start; i <= end; ++i) {
                    let code = this._lookBits(i);
                    if (code === ccittEOF) {
                      return [true, 1, false];
                    }
                    if (i < end) {
                      code <<= end - i;
                    }
                    if (!limitValue || code >= limitValue) {
                      const p = table[code - limitValue];
                      if (p[0] === i) {
                        this._eatBits(i);
                        return [true, p[1], true];
                      }
                    }
                  }
                  return [false, 0, false];
                }
                _getTwoDimCode() {
                  let code = 0;
                  let p;
                  if (this.eoblock) {
                    code = this._lookBits(7);
                    p = twoDimTable[code];
                    if (p && p[0] > 0) {
                      this._eatBits(p[0]);
                      return p[1];
                    }
                  } else {
                    const result = this._findTableCode(1, 7, twoDimTable);
                    if (result[0] && result[2]) {
                      return result[1];
                    }
                  }
                  (0, _util.info)("Bad two dim code");
                  return ccittEOF;
                }
                _getWhiteCode() {
                  let code = 0;
                  let p;
                  if (this.eoblock) {
                    code = this._lookBits(12);
                    if (code === ccittEOF) {
                      return 1;
                    }
                    if (code >> 5 === 0) {
                      p = whiteTable1[code];
                    } else {
                      p = whiteTable2[code >> 3];
                    }
                    if (p[0] > 0) {
                      this._eatBits(p[0]);
                      return p[1];
                    }
                  } else {
                    let result = this._findTableCode(1, 9, whiteTable2);
                    if (result[0]) {
                      return result[1];
                    }
                    result = this._findTableCode(11, 12, whiteTable1);
                    if (result[0]) {
                      return result[1];
                    }
                  }
                  (0, _util.info)("bad white code");
                  this._eatBits(1);
                  return 1;
                }
                _getBlackCode() {
                  let code, p;
                  if (this.eoblock) {
                    code = this._lookBits(13);
                    if (code === ccittEOF) {
                      return 1;
                    }
                    if (code >> 7 === 0) {
                      p = blackTable1[code];
                    } else if (code >> 9 === 0 && code >> 7 !== 0) {
                      p = blackTable2[(code >> 1) - 64];
                    } else {
                      p = blackTable3[code >> 7];
                    }
                    if (p[0] > 0) {
                      this._eatBits(p[0]);
                      return p[1];
                    }
                  } else {
                    let result = this._findTableCode(2, 6, blackTable3);
                    if (result[0]) {
                      return result[1];
                    }
                    result = this._findTableCode(7, 12, blackTable2, 64);
                    if (result[0]) {
                      return result[1];
                    }
                    result = this._findTableCode(10, 13, blackTable1);
                    if (result[0]) {
                      return result[1];
                    }
                  }
                  (0, _util.info)("bad black code");
                  this._eatBits(1);
                  return 1;
                }
                _lookBits(n) {
                  let c;
                  while (this.inputBits < n) {
                    if ((c = this.source.next()) === -1) {
                      if (this.inputBits === 0) {
                        return ccittEOF;
                      }
                      return this.inputBuf << n - this.inputBits & 65535 >> 16 - n;
                    }
                    this.inputBuf = this.inputBuf << 8 | c;
                    this.inputBits += 8;
                  }
                  return this.inputBuf >> this.inputBits - n & 65535 >> 16 - n;
                }
                _eatBits(n) {
                  if ((this.inputBits -= n) < 0) {
                    this.inputBits = 0;
                  }
                }
              };
              __name(_CCITTFaxDecoder, "CCITTFaxDecoder");
              let CCITTFaxDecoder = _CCITTFaxDecoder;
              exports2.CCITTFaxDecoder = CCITTFaxDecoder;
            },
            /* 148 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.FlateStream = void 0;
              var _decode_stream = __w_pdfjs_require__2(144);
              var _util = __w_pdfjs_require__2(2);
              const codeLenCodeMap = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
              const lengthDecode = new Int32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]);
              const distDecode = new Int32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353, 876545]);
              const fixedLitCodeTab = [new Int32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9];
              const fixedDistCodeTab = [new Int32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5];
              const _FlateStream = class _FlateStream extends _decode_stream.DecodeStream {
                constructor(str, maybeLength) {
                  super(maybeLength);
                  this.str = str;
                  this.dict = str.dict;
                  const cmf = str.getByte();
                  const flg = str.getByte();
                  if (cmf === -1 || flg === -1) {
                    throw new _util.FormatError(`Invalid header in flate stream: ${cmf}, ${flg}`);
                  }
                  if ((cmf & 15) !== 8) {
                    throw new _util.FormatError(`Unknown compression method in flate stream: ${cmf}, ${flg}`);
                  }
                  if (((cmf << 8) + flg) % 31 !== 0) {
                    throw new _util.FormatError(`Bad FCHECK in flate stream: ${cmf}, ${flg}`);
                  }
                  if (flg & 32) {
                    throw new _util.FormatError(`FDICT bit set in flate stream: ${cmf}, ${flg}`);
                  }
                  this.codeSize = 0;
                  this.codeBuf = 0;
                }
                getBits(bits) {
                  const str = this.str;
                  let codeSize = this.codeSize;
                  let codeBuf = this.codeBuf;
                  let b;
                  while (codeSize < bits) {
                    if ((b = str.getByte()) === -1) {
                      throw new _util.FormatError("Bad encoding in flate stream");
                    }
                    codeBuf |= b << codeSize;
                    codeSize += 8;
                  }
                  b = codeBuf & (1 << bits) - 1;
                  this.codeBuf = codeBuf >> bits;
                  this.codeSize = codeSize -= bits;
                  return b;
                }
                getCode(table) {
                  const str = this.str;
                  const codes = table[0];
                  const maxLen = table[1];
                  let codeSize = this.codeSize;
                  let codeBuf = this.codeBuf;
                  let b;
                  while (codeSize < maxLen) {
                    if ((b = str.getByte()) === -1) {
                      break;
                    }
                    codeBuf |= b << codeSize;
                    codeSize += 8;
                  }
                  const code = codes[codeBuf & (1 << maxLen) - 1];
                  const codeLen = code >> 16;
                  const codeVal = code & 65535;
                  if (codeLen < 1 || codeSize < codeLen) {
                    throw new _util.FormatError("Bad encoding in flate stream");
                  }
                  this.codeBuf = codeBuf >> codeLen;
                  this.codeSize = codeSize - codeLen;
                  return codeVal;
                }
                generateHuffmanTable(lengths) {
                  const n = lengths.length;
                  let maxLen = 0;
                  let i;
                  for (i = 0; i < n; ++i) {
                    if (lengths[i] > maxLen) {
                      maxLen = lengths[i];
                    }
                  }
                  const size = 1 << maxLen;
                  const codes = new Int32Array(size);
                  for (let len = 1, code = 0, skip = 2; len <= maxLen; ++len, code <<= 1, skip <<= 1) {
                    for (let val = 0; val < n; ++val) {
                      if (lengths[val] === len) {
                        let code2 = 0;
                        let t = code;
                        for (i = 0; i < len; ++i) {
                          code2 = code2 << 1 | t & 1;
                          t >>= 1;
                        }
                        for (i = code2; i < size; i += skip) {
                          codes[i] = len << 16 | val;
                        }
                        ++code;
                      }
                    }
                  }
                  return [codes, maxLen];
                }
                readBlock() {
                  let buffer, len;
                  const str = this.str;
                  let hdr = this.getBits(3);
                  if (hdr & 1) {
                    this.eof = true;
                  }
                  hdr >>= 1;
                  if (hdr === 0) {
                    let b;
                    if ((b = str.getByte()) === -1) {
                      throw new _util.FormatError("Bad block header in flate stream");
                    }
                    let blockLen = b;
                    if ((b = str.getByte()) === -1) {
                      throw new _util.FormatError("Bad block header in flate stream");
                    }
                    blockLen |= b << 8;
                    if ((b = str.getByte()) === -1) {
                      throw new _util.FormatError("Bad block header in flate stream");
                    }
                    let check = b;
                    if ((b = str.getByte()) === -1) {
                      throw new _util.FormatError("Bad block header in flate stream");
                    }
                    check |= b << 8;
                    if (check !== (~blockLen & 65535) && (blockLen !== 0 || check !== 0)) {
                      throw new _util.FormatError("Bad uncompressed block length in flate stream");
                    }
                    this.codeBuf = 0;
                    this.codeSize = 0;
                    const bufferLength = this.bufferLength, end = bufferLength + blockLen;
                    buffer = this.ensureBuffer(end);
                    this.bufferLength = end;
                    if (blockLen === 0) {
                      if (str.peekByte() === -1) {
                        this.eof = true;
                      }
                    } else {
                      const block = str.getBytes(blockLen);
                      buffer.set(block, bufferLength);
                      if (block.length < blockLen) {
                        this.eof = true;
                      }
                    }
                    return;
                  }
                  let litCodeTable;
                  let distCodeTable;
                  if (hdr === 1) {
                    litCodeTable = fixedLitCodeTab;
                    distCodeTable = fixedDistCodeTab;
                  } else if (hdr === 2) {
                    const numLitCodes = this.getBits(5) + 257;
                    const numDistCodes = this.getBits(5) + 1;
                    const numCodeLenCodes = this.getBits(4) + 4;
                    const codeLenCodeLengths = new Uint8Array(codeLenCodeMap.length);
                    let i;
                    for (i = 0; i < numCodeLenCodes; ++i) {
                      codeLenCodeLengths[codeLenCodeMap[i]] = this.getBits(3);
                    }
                    const codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths);
                    len = 0;
                    i = 0;
                    const codes = numLitCodes + numDistCodes;
                    const codeLengths = new Uint8Array(codes);
                    let bitsLength, bitsOffset, what;
                    while (i < codes) {
                      const code = this.getCode(codeLenCodeTab);
                      if (code === 16) {
                        bitsLength = 2;
                        bitsOffset = 3;
                        what = len;
                      } else if (code === 17) {
                        bitsLength = 3;
                        bitsOffset = 3;
                        what = len = 0;
                      } else if (code === 18) {
                        bitsLength = 7;
                        bitsOffset = 11;
                        what = len = 0;
                      } else {
                        codeLengths[i++] = len = code;
                        continue;
                      }
                      let repeatLength = this.getBits(bitsLength) + bitsOffset;
                      while (repeatLength-- > 0) {
                        codeLengths[i++] = what;
                      }
                    }
                    litCodeTable = this.generateHuffmanTable(codeLengths.subarray(0, numLitCodes));
                    distCodeTable = this.generateHuffmanTable(codeLengths.subarray(numLitCodes, codes));
                  } else {
                    throw new _util.FormatError("Unknown block type in flate stream");
                  }
                  buffer = this.buffer;
                  let limit = buffer ? buffer.length : 0;
                  let pos = this.bufferLength;
                  while (true) {
                    let code1 = this.getCode(litCodeTable);
                    if (code1 < 256) {
                      if (pos + 1 >= limit) {
                        buffer = this.ensureBuffer(pos + 1);
                        limit = buffer.length;
                      }
                      buffer[pos++] = code1;
                      continue;
                    }
                    if (code1 === 256) {
                      this.bufferLength = pos;
                      return;
                    }
                    code1 -= 257;
                    code1 = lengthDecode[code1];
                    let code2 = code1 >> 16;
                    if (code2 > 0) {
                      code2 = this.getBits(code2);
                    }
                    len = (code1 & 65535) + code2;
                    code1 = this.getCode(distCodeTable);
                    code1 = distDecode[code1];
                    code2 = code1 >> 16;
                    if (code2 > 0) {
                      code2 = this.getBits(code2);
                    }
                    const dist = (code1 & 65535) + code2;
                    if (pos + len >= limit) {
                      buffer = this.ensureBuffer(pos + len);
                      limit = buffer.length;
                    }
                    for (let k = 0; k < len; ++k, ++pos) {
                      buffer[pos] = buffer[pos - dist];
                    }
                  }
                }
              };
              __name(_FlateStream, "FlateStream");
              let FlateStream = _FlateStream;
              exports2.FlateStream = FlateStream;
            },
            /* 149 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Jbig2Stream = void 0;
              var _base_stream = __w_pdfjs_require__2(132);
              var _decode_stream = __w_pdfjs_require__2(144);
              var _primitives = __w_pdfjs_require__2(130);
              var _jbig = __w_pdfjs_require__2(150);
              var _util = __w_pdfjs_require__2(2);
              const _Jbig2Stream = class _Jbig2Stream extends _decode_stream.DecodeStream {
                constructor(stream, maybeLength, params) {
                  super(maybeLength);
                  this.stream = stream;
                  this.dict = stream.dict;
                  this.maybeLength = maybeLength;
                  this.params = params;
                }
                get bytes() {
                  return (0, _util.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
                }
                ensureBuffer(requested) {
                }
                readBlock() {
                  if (this.eof) {
                    return;
                  }
                  const jbig2Image = new _jbig.Jbig2Image();
                  const chunks = [];
                  if (this.params instanceof _primitives.Dict) {
                    const globalsStream = this.params.get("JBIG2Globals");
                    if (globalsStream instanceof _base_stream.BaseStream) {
                      const globals = globalsStream.getBytes();
                      chunks.push({
                        data: globals,
                        start: 0,
                        end: globals.length
                      });
                    }
                  }
                  chunks.push({
                    data: this.bytes,
                    start: 0,
                    end: this.bytes.length
                  });
                  const data = jbig2Image.parseChunks(chunks);
                  const dataLength = data.length;
                  for (let i = 0; i < dataLength; i++) {
                    data[i] ^= 255;
                  }
                  this.buffer = data;
                  this.bufferLength = dataLength;
                  this.eof = true;
                }
              };
              __name(_Jbig2Stream, "Jbig2Stream");
              let Jbig2Stream = _Jbig2Stream;
              exports2.Jbig2Stream = Jbig2Stream;
            },
            /* 150 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Jbig2Image = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _core_utils = __w_pdfjs_require__2(131);
              var _arithmetic_decoder = __w_pdfjs_require__2(151);
              var _ccitt = __w_pdfjs_require__2(147);
              const _Jbig2Error = class _Jbig2Error extends _util.BaseException {
                constructor(msg) {
                  super(`JBIG2 error: ${msg}`, "Jbig2Error");
                }
              };
              __name(_Jbig2Error, "Jbig2Error");
              let Jbig2Error = _Jbig2Error;
              const _ContextCache = class _ContextCache {
                getContexts(id) {
                  if (id in this) {
                    return this[id];
                  }
                  return this[id] = new Int8Array(1 << 16);
                }
              };
              __name(_ContextCache, "ContextCache");
              let ContextCache = _ContextCache;
              const _DecodingContext = class _DecodingContext {
                constructor(data, start, end) {
                  this.data = data;
                  this.start = start;
                  this.end = end;
                }
                get decoder() {
                  const decoder = new _arithmetic_decoder.ArithmeticDecoder(this.data, this.start, this.end);
                  return (0, _util.shadow)(this, "decoder", decoder);
                }
                get contextCache() {
                  const cache = new ContextCache();
                  return (0, _util.shadow)(this, "contextCache", cache);
                }
              };
              __name(_DecodingContext, "DecodingContext");
              let DecodingContext = _DecodingContext;
              function decodeInteger(contextCache, procedure, decoder) {
                const contexts = contextCache.getContexts(procedure);
                let prev = 1;
                function readBits(length) {
                  let v = 0;
                  for (let i = 0; i < length; i++) {
                    const bit = decoder.readBit(contexts, prev);
                    prev = prev < 256 ? prev << 1 | bit : (prev << 1 | bit) & 511 | 256;
                    v = v << 1 | bit;
                  }
                  return v >>> 0;
                }
                __name(readBits, "readBits");
                const sign = readBits(1);
                const value = readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(32) + 4436 : readBits(12) + 340 : readBits(8) + 84 : readBits(6) + 20 : readBits(4) + 4 : readBits(2);
                if (sign === 0) {
                  return value;
                } else if (value > 0) {
                  return -value;
                }
                return null;
              }
              __name(decodeInteger, "decodeInteger");
              function decodeIAID(contextCache, decoder, codeLength) {
                const contexts = contextCache.getContexts("IAID");
                let prev = 1;
                for (let i = 0; i < codeLength; i++) {
                  const bit = decoder.readBit(contexts, prev);
                  prev = prev << 1 | bit;
                }
                if (codeLength < 31) {
                  return prev & (1 << codeLength) - 1;
                }
                return prev & 2147483647;
              }
              __name(decodeIAID, "decodeIAID");
              const SegmentTypes = ["SymbolDictionary", null, null, null, "IntermediateTextRegion", null, "ImmediateTextRegion", "ImmediateLosslessTextRegion", null, null, null, null, null, null, null, null, "PatternDictionary", null, null, null, "IntermediateHalftoneRegion", null, "ImmediateHalftoneRegion", "ImmediateLosslessHalftoneRegion", null, null, null, null, null, null, null, null, null, null, null, null, "IntermediateGenericRegion", null, "ImmediateGenericRegion", "ImmediateLosslessGenericRegion", "IntermediateGenericRefinementRegion", null, "ImmediateGenericRefinementRegion", "ImmediateLosslessGenericRefinementRegion", null, null, null, null, "PageInformation", "EndOfPage", "EndOfStripe", "EndOfFile", "Profiles", "Tables", null, null, null, null, null, null, null, null, "Extension"];
              const CodingTemplates = [[{
                x: -1,
                y: -2
              }, {
                x: 0,
                y: -2
              }, {
                x: 1,
                y: -2
              }, {
                x: -2,
                y: -1
              }, {
                x: -1,
                y: -1
              }, {
                x: 0,
                y: -1
              }, {
                x: 1,
                y: -1
              }, {
                x: 2,
                y: -1
              }, {
                x: -4,
                y: 0
              }, {
                x: -3,
                y: 0
              }, {
                x: -2,
                y: 0
              }, {
                x: -1,
                y: 0
              }], [{
                x: -1,
                y: -2
              }, {
                x: 0,
                y: -2
              }, {
                x: 1,
                y: -2
              }, {
                x: 2,
                y: -2
              }, {
                x: -2,
                y: -1
              }, {
                x: -1,
                y: -1
              }, {
                x: 0,
                y: -1
              }, {
                x: 1,
                y: -1
              }, {
                x: 2,
                y: -1
              }, {
                x: -3,
                y: 0
              }, {
                x: -2,
                y: 0
              }, {
                x: -1,
                y: 0
              }], [{
                x: -1,
                y: -2
              }, {
                x: 0,
                y: -2
              }, {
                x: 1,
                y: -2
              }, {
                x: -2,
                y: -1
              }, {
                x: -1,
                y: -1
              }, {
                x: 0,
                y: -1
              }, {
                x: 1,
                y: -1
              }, {
                x: -2,
                y: 0
              }, {
                x: -1,
                y: 0
              }], [{
                x: -3,
                y: -1
              }, {
                x: -2,
                y: -1
              }, {
                x: -1,
                y: -1
              }, {
                x: 0,
                y: -1
              }, {
                x: 1,
                y: -1
              }, {
                x: -4,
                y: 0
              }, {
                x: -3,
                y: 0
              }, {
                x: -2,
                y: 0
              }, {
                x: -1,
                y: 0
              }]];
              const RefinementTemplates = [{
                coding: [{
                  x: 0,
                  y: -1
                }, {
                  x: 1,
                  y: -1
                }, {
                  x: -1,
                  y: 0
                }],
                reference: [{
                  x: 0,
                  y: -1
                }, {
                  x: 1,
                  y: -1
                }, {
                  x: -1,
                  y: 0
                }, {
                  x: 0,
                  y: 0
                }, {
                  x: 1,
                  y: 0
                }, {
                  x: -1,
                  y: 1
                }, {
                  x: 0,
                  y: 1
                }, {
                  x: 1,
                  y: 1
                }]
              }, {
                coding: [{
                  x: -1,
                  y: -1
                }, {
                  x: 0,
                  y: -1
                }, {
                  x: 1,
                  y: -1
                }, {
                  x: -1,
                  y: 0
                }],
                reference: [{
                  x: 0,
                  y: -1
                }, {
                  x: -1,
                  y: 0
                }, {
                  x: 0,
                  y: 0
                }, {
                  x: 1,
                  y: 0
                }, {
                  x: 0,
                  y: 1
                }, {
                  x: 1,
                  y: 1
                }]
              }];
              const ReusedContexts = [39717, 1941, 229, 405];
              const RefinementReusedContexts = [32, 8];
              function decodeBitmapTemplate0(width, height, decodingContext) {
                const decoder = decodingContext.decoder;
                const contexts = decodingContext.contextCache.getContexts("GB");
                const bitmap = [];
                let contextLabel, i, j, pixel, row, row1, row2;
                const OLD_PIXEL_MASK = 31735;
                for (i = 0; i < height; i++) {
                  row = bitmap[i] = new Uint8Array(width);
                  row1 = i < 1 ? row : bitmap[i - 1];
                  row2 = i < 2 ? row : bitmap[i - 2];
                  contextLabel = row2[0] << 13 | row2[1] << 12 | row2[2] << 11 | row1[0] << 7 | row1[1] << 6 | row1[2] << 5 | row1[3] << 4;
                  for (j = 0; j < width; j++) {
                    row[j] = pixel = decoder.readBit(contexts, contextLabel);
                    contextLabel = (contextLabel & OLD_PIXEL_MASK) << 1 | (j + 3 < width ? row2[j + 3] << 11 : 0) | (j + 4 < width ? row1[j + 4] << 4 : 0) | pixel;
                  }
                }
                return bitmap;
              }
              __name(decodeBitmapTemplate0, "decodeBitmapTemplate0");
              function decodeBitmap(mmr, width, height, templateIndex, prediction, skip, at, decodingContext) {
                if (mmr) {
                  const input = new Reader(decodingContext.data, decodingContext.start, decodingContext.end);
                  return decodeMMRBitmap(input, width, height, false);
                }
                if (templateIndex === 0 && !skip && !prediction && at.length === 4 && at[0].x === 3 && at[0].y === -1 && at[1].x === -3 && at[1].y === -1 && at[2].x === 2 && at[2].y === -2 && at[3].x === -2 && at[3].y === -2) {
                  return decodeBitmapTemplate0(width, height, decodingContext);
                }
                const useskip = !!skip;
                const template = CodingTemplates[templateIndex].concat(at);
                template.sort(function(a, b) {
                  return a.y - b.y || a.x - b.x;
                });
                const templateLength = template.length;
                const templateX = new Int8Array(templateLength);
                const templateY = new Int8Array(templateLength);
                const changingTemplateEntries = [];
                let reuseMask = 0, minX = 0, maxX = 0, minY = 0;
                let c, k;
                for (k = 0; k < templateLength; k++) {
                  templateX[k] = template[k].x;
                  templateY[k] = template[k].y;
                  minX = Math.min(minX, template[k].x);
                  maxX = Math.max(maxX, template[k].x);
                  minY = Math.min(minY, template[k].y);
                  if (k < templateLength - 1 && template[k].y === template[k + 1].y && template[k].x === template[k + 1].x - 1) {
                    reuseMask |= 1 << templateLength - 1 - k;
                  } else {
                    changingTemplateEntries.push(k);
                  }
                }
                const changingEntriesLength = changingTemplateEntries.length;
                const changingTemplateX = new Int8Array(changingEntriesLength);
                const changingTemplateY = new Int8Array(changingEntriesLength);
                const changingTemplateBit = new Uint16Array(changingEntriesLength);
                for (c = 0; c < changingEntriesLength; c++) {
                  k = changingTemplateEntries[c];
                  changingTemplateX[c] = template[k].x;
                  changingTemplateY[c] = template[k].y;
                  changingTemplateBit[c] = 1 << templateLength - 1 - k;
                }
                const sbb_left = -minX;
                const sbb_top = -minY;
                const sbb_right = width - maxX;
                const pseudoPixelContext = ReusedContexts[templateIndex];
                let row = new Uint8Array(width);
                const bitmap = [];
                const decoder = decodingContext.decoder;
                const contexts = decodingContext.contextCache.getContexts("GB");
                let ltp = 0, j, i0, j0, contextLabel = 0, bit, shift;
                for (let i = 0; i < height; i++) {
                  if (prediction) {
                    const sltp = decoder.readBit(contexts, pseudoPixelContext);
                    ltp ^= sltp;
                    if (ltp) {
                      bitmap.push(row);
                      continue;
                    }
                  }
                  row = new Uint8Array(row);
                  bitmap.push(row);
                  for (j = 0; j < width; j++) {
                    if (useskip && skip[i][j]) {
                      row[j] = 0;
                      continue;
                    }
                    if (j >= sbb_left && j < sbb_right && i >= sbb_top) {
                      contextLabel = contextLabel << 1 & reuseMask;
                      for (k = 0; k < changingEntriesLength; k++) {
                        i0 = i + changingTemplateY[k];
                        j0 = j + changingTemplateX[k];
                        bit = bitmap[i0][j0];
                        if (bit) {
                          bit = changingTemplateBit[k];
                          contextLabel |= bit;
                        }
                      }
                    } else {
                      contextLabel = 0;
                      shift = templateLength - 1;
                      for (k = 0; k < templateLength; k++, shift--) {
                        j0 = j + templateX[k];
                        if (j0 >= 0 && j0 < width) {
                          i0 = i + templateY[k];
                          if (i0 >= 0) {
                            bit = bitmap[i0][j0];
                            if (bit) {
                              contextLabel |= bit << shift;
                            }
                          }
                        }
                      }
                    }
                    const pixel = decoder.readBit(contexts, contextLabel);
                    row[j] = pixel;
                  }
                }
                return bitmap;
              }
              __name(decodeBitmap, "decodeBitmap");
              function decodeRefinement(width, height, templateIndex, referenceBitmap, offsetX, offsetY, prediction, at, decodingContext) {
                let codingTemplate = RefinementTemplates[templateIndex].coding;
                if (templateIndex === 0) {
                  codingTemplate = codingTemplate.concat([at[0]]);
                }
                const codingTemplateLength = codingTemplate.length;
                const codingTemplateX = new Int32Array(codingTemplateLength);
                const codingTemplateY = new Int32Array(codingTemplateLength);
                let k;
                for (k = 0; k < codingTemplateLength; k++) {
                  codingTemplateX[k] = codingTemplate[k].x;
                  codingTemplateY[k] = codingTemplate[k].y;
                }
                let referenceTemplate = RefinementTemplates[templateIndex].reference;
                if (templateIndex === 0) {
                  referenceTemplate = referenceTemplate.concat([at[1]]);
                }
                const referenceTemplateLength = referenceTemplate.length;
                const referenceTemplateX = new Int32Array(referenceTemplateLength);
                const referenceTemplateY = new Int32Array(referenceTemplateLength);
                for (k = 0; k < referenceTemplateLength; k++) {
                  referenceTemplateX[k] = referenceTemplate[k].x;
                  referenceTemplateY[k] = referenceTemplate[k].y;
                }
                const referenceWidth = referenceBitmap[0].length;
                const referenceHeight = referenceBitmap.length;
                const pseudoPixelContext = RefinementReusedContexts[templateIndex];
                const bitmap = [];
                const decoder = decodingContext.decoder;
                const contexts = decodingContext.contextCache.getContexts("GR");
                let ltp = 0;
                for (let i = 0; i < height; i++) {
                  if (prediction) {
                    const sltp = decoder.readBit(contexts, pseudoPixelContext);
                    ltp ^= sltp;
                    if (ltp) {
                      throw new Jbig2Error("prediction is not supported");
                    }
                  }
                  const row = new Uint8Array(width);
                  bitmap.push(row);
                  for (let j = 0; j < width; j++) {
                    let i0, j0;
                    let contextLabel = 0;
                    for (k = 0; k < codingTemplateLength; k++) {
                      i0 = i + codingTemplateY[k];
                      j0 = j + codingTemplateX[k];
                      if (i0 < 0 || j0 < 0 || j0 >= width) {
                        contextLabel <<= 1;
                      } else {
                        contextLabel = contextLabel << 1 | bitmap[i0][j0];
                      }
                    }
                    for (k = 0; k < referenceTemplateLength; k++) {
                      i0 = i + referenceTemplateY[k] - offsetY;
                      j0 = j + referenceTemplateX[k] - offsetX;
                      if (i0 < 0 || i0 >= referenceHeight || j0 < 0 || j0 >= referenceWidth) {
                        contextLabel <<= 1;
                      } else {
                        contextLabel = contextLabel << 1 | referenceBitmap[i0][j0];
                      }
                    }
                    const pixel = decoder.readBit(contexts, contextLabel);
                    row[j] = pixel;
                  }
                }
                return bitmap;
              }
              __name(decodeRefinement, "decodeRefinement");
              function decodeSymbolDictionary(huffman, refinement, symbols, numberOfNewSymbols, numberOfExportedSymbols, huffmanTables, templateIndex, at, refinementTemplateIndex, refinementAt, decodingContext, huffmanInput) {
                if (huffman && refinement) {
                  throw new Jbig2Error("symbol refinement with Huffman is not supported");
                }
                const newSymbols = [];
                let currentHeight = 0;
                let symbolCodeLength = (0, _core_utils.log2)(symbols.length + numberOfNewSymbols);
                const decoder = decodingContext.decoder;
                const contextCache = decodingContext.contextCache;
                let tableB1, symbolWidths;
                if (huffman) {
                  tableB1 = getStandardTable(1);
                  symbolWidths = [];
                  symbolCodeLength = Math.max(symbolCodeLength, 1);
                }
                while (newSymbols.length < numberOfNewSymbols) {
                  const deltaHeight = huffman ? huffmanTables.tableDeltaHeight.decode(huffmanInput) : decodeInteger(contextCache, "IADH", decoder);
                  currentHeight += deltaHeight;
                  let currentWidth = 0, totalWidth = 0;
                  const firstSymbol = huffman ? symbolWidths.length : 0;
                  while (true) {
                    const deltaWidth = huffman ? huffmanTables.tableDeltaWidth.decode(huffmanInput) : decodeInteger(contextCache, "IADW", decoder);
                    if (deltaWidth === null) {
                      break;
                    }
                    currentWidth += deltaWidth;
                    totalWidth += currentWidth;
                    let bitmap;
                    if (refinement) {
                      const numberOfInstances = decodeInteger(contextCache, "IAAI", decoder);
                      if (numberOfInstances > 1) {
                        bitmap = decodeTextRegion(huffman, refinement, currentWidth, currentHeight, 0, numberOfInstances, 1, symbols.concat(newSymbols), symbolCodeLength, 0, 0, 1, 0, huffmanTables, refinementTemplateIndex, refinementAt, decodingContext, 0, huffmanInput);
                      } else {
                        const symbolId = decodeIAID(contextCache, decoder, symbolCodeLength);
                        const rdx = decodeInteger(contextCache, "IARDX", decoder);
                        const rdy = decodeInteger(contextCache, "IARDY", decoder);
                        const symbol = symbolId < symbols.length ? symbols[symbolId] : newSymbols[symbolId - symbols.length];
                        bitmap = decodeRefinement(currentWidth, currentHeight, refinementTemplateIndex, symbol, rdx, rdy, false, refinementAt, decodingContext);
                      }
                      newSymbols.push(bitmap);
                    } else if (huffman) {
                      symbolWidths.push(currentWidth);
                    } else {
                      bitmap = decodeBitmap(false, currentWidth, currentHeight, templateIndex, false, null, at, decodingContext);
                      newSymbols.push(bitmap);
                    }
                  }
                  if (huffman && !refinement) {
                    const bitmapSize = huffmanTables.tableBitmapSize.decode(huffmanInput);
                    huffmanInput.byteAlign();
                    let collectiveBitmap;
                    if (bitmapSize === 0) {
                      collectiveBitmap = readUncompressedBitmap(huffmanInput, totalWidth, currentHeight);
                    } else {
                      const originalEnd = huffmanInput.end;
                      const bitmapEnd = huffmanInput.position + bitmapSize;
                      huffmanInput.end = bitmapEnd;
                      collectiveBitmap = decodeMMRBitmap(huffmanInput, totalWidth, currentHeight, false);
                      huffmanInput.end = originalEnd;
                      huffmanInput.position = bitmapEnd;
                    }
                    const numberOfSymbolsDecoded = symbolWidths.length;
                    if (firstSymbol === numberOfSymbolsDecoded - 1) {
                      newSymbols.push(collectiveBitmap);
                    } else {
                      let i2, y, xMin = 0, xMax, bitmapWidth, symbolBitmap;
                      for (i2 = firstSymbol; i2 < numberOfSymbolsDecoded; i2++) {
                        bitmapWidth = symbolWidths[i2];
                        xMax = xMin + bitmapWidth;
                        symbolBitmap = [];
                        for (y = 0; y < currentHeight; y++) {
                          symbolBitmap.push(collectiveBitmap[y].subarray(xMin, xMax));
                        }
                        newSymbols.push(symbolBitmap);
                        xMin = xMax;
                      }
                    }
                  }
                }
                const exportedSymbols = [], flags = [];
                let currentFlag = false, i, ii;
                const totalSymbolsLength = symbols.length + numberOfNewSymbols;
                while (flags.length < totalSymbolsLength) {
                  let runLength = huffman ? tableB1.decode(huffmanInput) : decodeInteger(contextCache, "IAEX", decoder);
                  while (runLength--) {
                    flags.push(currentFlag);
                  }
                  currentFlag = !currentFlag;
                }
                for (i = 0, ii = symbols.length; i < ii; i++) {
                  if (flags[i]) {
                    exportedSymbols.push(symbols[i]);
                  }
                }
                for (let j = 0; j < numberOfNewSymbols; i++, j++) {
                  if (flags[i]) {
                    exportedSymbols.push(newSymbols[j]);
                  }
                }
                return exportedSymbols;
              }
              __name(decodeSymbolDictionary, "decodeSymbolDictionary");
              function decodeTextRegion(huffman, refinement, width, height, defaultPixelValue, numberOfSymbolInstances, stripSize, inputSymbols, symbolCodeLength, transposed, dsOffset, referenceCorner, combinationOperator, huffmanTables, refinementTemplateIndex, refinementAt, decodingContext, logStripSize, huffmanInput) {
                if (huffman && refinement) {
                  throw new Jbig2Error("refinement with Huffman is not supported");
                }
                const bitmap = [];
                let i, row;
                for (i = 0; i < height; i++) {
                  row = new Uint8Array(width);
                  if (defaultPixelValue) {
                    for (let j = 0; j < width; j++) {
                      row[j] = defaultPixelValue;
                    }
                  }
                  bitmap.push(row);
                }
                const decoder = decodingContext.decoder;
                const contextCache = decodingContext.contextCache;
                let stripT = huffman ? -huffmanTables.tableDeltaT.decode(huffmanInput) : -decodeInteger(contextCache, "IADT", decoder);
                let firstS = 0;
                i = 0;
                while (i < numberOfSymbolInstances) {
                  const deltaT = huffman ? huffmanTables.tableDeltaT.decode(huffmanInput) : decodeInteger(contextCache, "IADT", decoder);
                  stripT += deltaT;
                  const deltaFirstS = huffman ? huffmanTables.tableFirstS.decode(huffmanInput) : decodeInteger(contextCache, "IAFS", decoder);
                  firstS += deltaFirstS;
                  let currentS = firstS;
                  do {
                    let currentT = 0;
                    if (stripSize > 1) {
                      currentT = huffman ? huffmanInput.readBits(logStripSize) : decodeInteger(contextCache, "IAIT", decoder);
                    }
                    const t = stripSize * stripT + currentT;
                    const symbolId = huffman ? huffmanTables.symbolIDTable.decode(huffmanInput) : decodeIAID(contextCache, decoder, symbolCodeLength);
                    const applyRefinement = refinement && (huffman ? huffmanInput.readBit() : decodeInteger(contextCache, "IARI", decoder));
                    let symbolBitmap = inputSymbols[symbolId];
                    let symbolWidth = symbolBitmap[0].length;
                    let symbolHeight = symbolBitmap.length;
                    if (applyRefinement) {
                      const rdw = decodeInteger(contextCache, "IARDW", decoder);
                      const rdh = decodeInteger(contextCache, "IARDH", decoder);
                      const rdx = decodeInteger(contextCache, "IARDX", decoder);
                      const rdy = decodeInteger(contextCache, "IARDY", decoder);
                      symbolWidth += rdw;
                      symbolHeight += rdh;
                      symbolBitmap = decodeRefinement(symbolWidth, symbolHeight, refinementTemplateIndex, symbolBitmap, (rdw >> 1) + rdx, (rdh >> 1) + rdy, false, refinementAt, decodingContext);
                    }
                    const offsetT = t - (referenceCorner & 1 ? 0 : symbolHeight - 1);
                    const offsetS = currentS - (referenceCorner & 2 ? symbolWidth - 1 : 0);
                    let s2, t2, symbolRow;
                    if (transposed) {
                      for (s2 = 0; s2 < symbolHeight; s2++) {
                        row = bitmap[offsetS + s2];
                        if (!row) {
                          continue;
                        }
                        symbolRow = symbolBitmap[s2];
                        const maxWidth = Math.min(width - offsetT, symbolWidth);
                        switch (combinationOperator) {
                          case 0:
                            for (t2 = 0; t2 < maxWidth; t2++) {
                              row[offsetT + t2] |= symbolRow[t2];
                            }
                            break;
                          case 2:
                            for (t2 = 0; t2 < maxWidth; t2++) {
                              row[offsetT + t2] ^= symbolRow[t2];
                            }
                            break;
                          default:
                            throw new Jbig2Error(`operator ${combinationOperator} is not supported`);
                        }
                      }
                      currentS += symbolHeight - 1;
                    } else {
                      for (t2 = 0; t2 < symbolHeight; t2++) {
                        row = bitmap[offsetT + t2];
                        if (!row) {
                          continue;
                        }
                        symbolRow = symbolBitmap[t2];
                        switch (combinationOperator) {
                          case 0:
                            for (s2 = 0; s2 < symbolWidth; s2++) {
                              row[offsetS + s2] |= symbolRow[s2];
                            }
                            break;
                          case 2:
                            for (s2 = 0; s2 < symbolWidth; s2++) {
                              row[offsetS + s2] ^= symbolRow[s2];
                            }
                            break;
                          default:
                            throw new Jbig2Error(`operator ${combinationOperator} is not supported`);
                        }
                      }
                      currentS += symbolWidth - 1;
                    }
                    i++;
                    const deltaS = huffman ? huffmanTables.tableDeltaS.decode(huffmanInput) : decodeInteger(contextCache, "IADS", decoder);
                    if (deltaS === null) {
                      break;
                    }
                    currentS += deltaS + dsOffset;
                  } while (true);
                }
                return bitmap;
              }
              __name(decodeTextRegion, "decodeTextRegion");
              function decodePatternDictionary(mmr, patternWidth, patternHeight, maxPatternIndex, template, decodingContext) {
                const at = [];
                if (!mmr) {
                  at.push({
                    x: -patternWidth,
                    y: 0
                  });
                  if (template === 0) {
                    at.push({
                      x: -3,
                      y: -1
                    }, {
                      x: 2,
                      y: -2
                    }, {
                      x: -2,
                      y: -2
                    });
                  }
                }
                const collectiveWidth = (maxPatternIndex + 1) * patternWidth;
                const collectiveBitmap = decodeBitmap(mmr, collectiveWidth, patternHeight, template, false, null, at, decodingContext);
                const patterns = [];
                for (let i = 0; i <= maxPatternIndex; i++) {
                  const patternBitmap = [];
                  const xMin = patternWidth * i;
                  const xMax = xMin + patternWidth;
                  for (let y = 0; y < patternHeight; y++) {
                    patternBitmap.push(collectiveBitmap[y].subarray(xMin, xMax));
                  }
                  patterns.push(patternBitmap);
                }
                return patterns;
              }
              __name(decodePatternDictionary, "decodePatternDictionary");
              function decodeHalftoneRegion(mmr, patterns, template, regionWidth, regionHeight, defaultPixelValue, enableSkip, combinationOperator, gridWidth, gridHeight, gridOffsetX, gridOffsetY, gridVectorX, gridVectorY, decodingContext) {
                const skip = null;
                if (enableSkip) {
                  throw new Jbig2Error("skip is not supported");
                }
                if (combinationOperator !== 0) {
                  throw new Jbig2Error(`operator "${combinationOperator}" is not supported in halftone region`);
                }
                const regionBitmap = [];
                let i, j, row;
                for (i = 0; i < regionHeight; i++) {
                  row = new Uint8Array(regionWidth);
                  if (defaultPixelValue) {
                    for (j = 0; j < regionWidth; j++) {
                      row[j] = defaultPixelValue;
                    }
                  }
                  regionBitmap.push(row);
                }
                const numberOfPatterns = patterns.length;
                const pattern0 = patterns[0];
                const patternWidth = pattern0[0].length, patternHeight = pattern0.length;
                const bitsPerValue = (0, _core_utils.log2)(numberOfPatterns);
                const at = [];
                if (!mmr) {
                  at.push({
                    x: template <= 1 ? 3 : 2,
                    y: -1
                  });
                  if (template === 0) {
                    at.push({
                      x: -3,
                      y: -1
                    }, {
                      x: 2,
                      y: -2
                    }, {
                      x: -2,
                      y: -2
                    });
                  }
                }
                const grayScaleBitPlanes = [];
                let mmrInput, bitmap;
                if (mmr) {
                  mmrInput = new Reader(decodingContext.data, decodingContext.start, decodingContext.end);
                }
                for (i = bitsPerValue - 1; i >= 0; i--) {
                  if (mmr) {
                    bitmap = decodeMMRBitmap(mmrInput, gridWidth, gridHeight, true);
                  } else {
                    bitmap = decodeBitmap(false, gridWidth, gridHeight, template, false, skip, at, decodingContext);
                  }
                  grayScaleBitPlanes[i] = bitmap;
                }
                let mg, ng, bit, patternIndex, patternBitmap, x, y, patternRow, regionRow;
                for (mg = 0; mg < gridHeight; mg++) {
                  for (ng = 0; ng < gridWidth; ng++) {
                    bit = 0;
                    patternIndex = 0;
                    for (j = bitsPerValue - 1; j >= 0; j--) {
                      bit ^= grayScaleBitPlanes[j][mg][ng];
                      patternIndex |= bit << j;
                    }
                    patternBitmap = patterns[patternIndex];
                    x = gridOffsetX + mg * gridVectorY + ng * gridVectorX >> 8;
                    y = gridOffsetY + mg * gridVectorX - ng * gridVectorY >> 8;
                    if (x >= 0 && x + patternWidth <= regionWidth && y >= 0 && y + patternHeight <= regionHeight) {
                      for (i = 0; i < patternHeight; i++) {
                        regionRow = regionBitmap[y + i];
                        patternRow = patternBitmap[i];
                        for (j = 0; j < patternWidth; j++) {
                          regionRow[x + j] |= patternRow[j];
                        }
                      }
                    } else {
                      let regionX, regionY;
                      for (i = 0; i < patternHeight; i++) {
                        regionY = y + i;
                        if (regionY < 0 || regionY >= regionHeight) {
                          continue;
                        }
                        regionRow = regionBitmap[regionY];
                        patternRow = patternBitmap[i];
                        for (j = 0; j < patternWidth; j++) {
                          regionX = x + j;
                          if (regionX >= 0 && regionX < regionWidth) {
                            regionRow[regionX] |= patternRow[j];
                          }
                        }
                      }
                    }
                  }
                }
                return regionBitmap;
              }
              __name(decodeHalftoneRegion, "decodeHalftoneRegion");
              function readSegmentHeader(data, start) {
                const segmentHeader = {};
                segmentHeader.number = (0, _core_utils.readUint32)(data, start);
                const flags = data[start + 4];
                const segmentType = flags & 63;
                if (!SegmentTypes[segmentType]) {
                  throw new Jbig2Error("invalid segment type: " + segmentType);
                }
                segmentHeader.type = segmentType;
                segmentHeader.typeName = SegmentTypes[segmentType];
                segmentHeader.deferredNonRetain = !!(flags & 128);
                const pageAssociationFieldSize = !!(flags & 64);
                const referredFlags = data[start + 5];
                let referredToCount = referredFlags >> 5 & 7;
                const retainBits = [referredFlags & 31];
                let position = start + 6;
                if (referredFlags === 7) {
                  referredToCount = (0, _core_utils.readUint32)(data, position - 1) & 536870911;
                  position += 3;
                  let bytes = referredToCount + 7 >> 3;
                  retainBits[0] = data[position++];
                  while (--bytes > 0) {
                    retainBits.push(data[position++]);
                  }
                } else if (referredFlags === 5 || referredFlags === 6) {
                  throw new Jbig2Error("invalid referred-to flags");
                }
                segmentHeader.retainBits = retainBits;
                let referredToSegmentNumberSize = 4;
                if (segmentHeader.number <= 256) {
                  referredToSegmentNumberSize = 1;
                } else if (segmentHeader.number <= 65536) {
                  referredToSegmentNumberSize = 2;
                }
                const referredTo = [];
                let i, ii;
                for (i = 0; i < referredToCount; i++) {
                  let number;
                  if (referredToSegmentNumberSize === 1) {
                    number = data[position];
                  } else if (referredToSegmentNumberSize === 2) {
                    number = (0, _core_utils.readUint16)(data, position);
                  } else {
                    number = (0, _core_utils.readUint32)(data, position);
                  }
                  referredTo.push(number);
                  position += referredToSegmentNumberSize;
                }
                segmentHeader.referredTo = referredTo;
                if (!pageAssociationFieldSize) {
                  segmentHeader.pageAssociation = data[position++];
                } else {
                  segmentHeader.pageAssociation = (0, _core_utils.readUint32)(data, position);
                  position += 4;
                }
                segmentHeader.length = (0, _core_utils.readUint32)(data, position);
                position += 4;
                if (segmentHeader.length === 4294967295) {
                  if (segmentType === 38) {
                    const genericRegionInfo = readRegionSegmentInformation(data, position);
                    const genericRegionSegmentFlags = data[position + RegionSegmentInformationFieldLength];
                    const genericRegionMmr = !!(genericRegionSegmentFlags & 1);
                    const searchPatternLength = 6;
                    const searchPattern = new Uint8Array(searchPatternLength);
                    if (!genericRegionMmr) {
                      searchPattern[0] = 255;
                      searchPattern[1] = 172;
                    }
                    searchPattern[2] = genericRegionInfo.height >>> 24 & 255;
                    searchPattern[3] = genericRegionInfo.height >> 16 & 255;
                    searchPattern[4] = genericRegionInfo.height >> 8 & 255;
                    searchPattern[5] = genericRegionInfo.height & 255;
                    for (i = position, ii = data.length; i < ii; i++) {
                      let j = 0;
                      while (j < searchPatternLength && searchPattern[j] === data[i + j]) {
                        j++;
                      }
                      if (j === searchPatternLength) {
                        segmentHeader.length = i + searchPatternLength;
                        break;
                      }
                    }
                    if (segmentHeader.length === 4294967295) {
                      throw new Jbig2Error("segment end was not found");
                    }
                  } else {
                    throw new Jbig2Error("invalid unknown segment length");
                  }
                }
                segmentHeader.headerEnd = position;
                return segmentHeader;
              }
              __name(readSegmentHeader, "readSegmentHeader");
              function readSegments(header, data, start, end) {
                const segments = [];
                let position = start;
                while (position < end) {
                  const segmentHeader = readSegmentHeader(data, position);
                  position = segmentHeader.headerEnd;
                  const segment = {
                    header: segmentHeader,
                    data
                  };
                  if (!header.randomAccess) {
                    segment.start = position;
                    position += segmentHeader.length;
                    segment.end = position;
                  }
                  segments.push(segment);
                  if (segmentHeader.type === 51) {
                    break;
                  }
                }
                if (header.randomAccess) {
                  for (let i = 0, ii = segments.length; i < ii; i++) {
                    segments[i].start = position;
                    position += segments[i].header.length;
                    segments[i].end = position;
                  }
                }
                return segments;
              }
              __name(readSegments, "readSegments");
              function readRegionSegmentInformation(data, start) {
                return {
                  width: (0, _core_utils.readUint32)(data, start),
                  height: (0, _core_utils.readUint32)(data, start + 4),
                  x: (0, _core_utils.readUint32)(data, start + 8),
                  y: (0, _core_utils.readUint32)(data, start + 12),
                  combinationOperator: data[start + 16] & 7
                };
              }
              __name(readRegionSegmentInformation, "readRegionSegmentInformation");
              const RegionSegmentInformationFieldLength = 17;
              function processSegment(segment, visitor) {
                const header = segment.header;
                const data = segment.data, end = segment.end;
                let position = segment.start;
                let args, at, i, atLength;
                switch (header.type) {
                  case 0:
                    const dictionary = {};
                    const dictionaryFlags = (0, _core_utils.readUint16)(data, position);
                    dictionary.huffman = !!(dictionaryFlags & 1);
                    dictionary.refinement = !!(dictionaryFlags & 2);
                    dictionary.huffmanDHSelector = dictionaryFlags >> 2 & 3;
                    dictionary.huffmanDWSelector = dictionaryFlags >> 4 & 3;
                    dictionary.bitmapSizeSelector = dictionaryFlags >> 6 & 1;
                    dictionary.aggregationInstancesSelector = dictionaryFlags >> 7 & 1;
                    dictionary.bitmapCodingContextUsed = !!(dictionaryFlags & 256);
                    dictionary.bitmapCodingContextRetained = !!(dictionaryFlags & 512);
                    dictionary.template = dictionaryFlags >> 10 & 3;
                    dictionary.refinementTemplate = dictionaryFlags >> 12 & 1;
                    position += 2;
                    if (!dictionary.huffman) {
                      atLength = dictionary.template === 0 ? 4 : 1;
                      at = [];
                      for (i = 0; i < atLength; i++) {
                        at.push({
                          x: (0, _core_utils.readInt8)(data, position),
                          y: (0, _core_utils.readInt8)(data, position + 1)
                        });
                        position += 2;
                      }
                      dictionary.at = at;
                    }
                    if (dictionary.refinement && !dictionary.refinementTemplate) {
                      at = [];
                      for (i = 0; i < 2; i++) {
                        at.push({
                          x: (0, _core_utils.readInt8)(data, position),
                          y: (0, _core_utils.readInt8)(data, position + 1)
                        });
                        position += 2;
                      }
                      dictionary.refinementAt = at;
                    }
                    dictionary.numberOfExportedSymbols = (0, _core_utils.readUint32)(data, position);
                    position += 4;
                    dictionary.numberOfNewSymbols = (0, _core_utils.readUint32)(data, position);
                    position += 4;
                    args = [dictionary, header.number, header.referredTo, data, position, end];
                    break;
                  case 6:
                  case 7:
                    const textRegion = {};
                    textRegion.info = readRegionSegmentInformation(data, position);
                    position += RegionSegmentInformationFieldLength;
                    const textRegionSegmentFlags = (0, _core_utils.readUint16)(data, position);
                    position += 2;
                    textRegion.huffman = !!(textRegionSegmentFlags & 1);
                    textRegion.refinement = !!(textRegionSegmentFlags & 2);
                    textRegion.logStripSize = textRegionSegmentFlags >> 2 & 3;
                    textRegion.stripSize = 1 << textRegion.logStripSize;
                    textRegion.referenceCorner = textRegionSegmentFlags >> 4 & 3;
                    textRegion.transposed = !!(textRegionSegmentFlags & 64);
                    textRegion.combinationOperator = textRegionSegmentFlags >> 7 & 3;
                    textRegion.defaultPixelValue = textRegionSegmentFlags >> 9 & 1;
                    textRegion.dsOffset = textRegionSegmentFlags << 17 >> 27;
                    textRegion.refinementTemplate = textRegionSegmentFlags >> 15 & 1;
                    if (textRegion.huffman) {
                      const textRegionHuffmanFlags = (0, _core_utils.readUint16)(data, position);
                      position += 2;
                      textRegion.huffmanFS = textRegionHuffmanFlags & 3;
                      textRegion.huffmanDS = textRegionHuffmanFlags >> 2 & 3;
                      textRegion.huffmanDT = textRegionHuffmanFlags >> 4 & 3;
                      textRegion.huffmanRefinementDW = textRegionHuffmanFlags >> 6 & 3;
                      textRegion.huffmanRefinementDH = textRegionHuffmanFlags >> 8 & 3;
                      textRegion.huffmanRefinementDX = textRegionHuffmanFlags >> 10 & 3;
                      textRegion.huffmanRefinementDY = textRegionHuffmanFlags >> 12 & 3;
                      textRegion.huffmanRefinementSizeSelector = !!(textRegionHuffmanFlags & 16384);
                    }
                    if (textRegion.refinement && !textRegion.refinementTemplate) {
                      at = [];
                      for (i = 0; i < 2; i++) {
                        at.push({
                          x: (0, _core_utils.readInt8)(data, position),
                          y: (0, _core_utils.readInt8)(data, position + 1)
                        });
                        position += 2;
                      }
                      textRegion.refinementAt = at;
                    }
                    textRegion.numberOfSymbolInstances = (0, _core_utils.readUint32)(data, position);
                    position += 4;
                    args = [textRegion, header.referredTo, data, position, end];
                    break;
                  case 16:
                    const patternDictionary = {};
                    const patternDictionaryFlags = data[position++];
                    patternDictionary.mmr = !!(patternDictionaryFlags & 1);
                    patternDictionary.template = patternDictionaryFlags >> 1 & 3;
                    patternDictionary.patternWidth = data[position++];
                    patternDictionary.patternHeight = data[position++];
                    patternDictionary.maxPatternIndex = (0, _core_utils.readUint32)(data, position);
                    position += 4;
                    args = [patternDictionary, header.number, data, position, end];
                    break;
                  case 22:
                  case 23:
                    const halftoneRegion = {};
                    halftoneRegion.info = readRegionSegmentInformation(data, position);
                    position += RegionSegmentInformationFieldLength;
                    const halftoneRegionFlags = data[position++];
                    halftoneRegion.mmr = !!(halftoneRegionFlags & 1);
                    halftoneRegion.template = halftoneRegionFlags >> 1 & 3;
                    halftoneRegion.enableSkip = !!(halftoneRegionFlags & 8);
                    halftoneRegion.combinationOperator = halftoneRegionFlags >> 4 & 7;
                    halftoneRegion.defaultPixelValue = halftoneRegionFlags >> 7 & 1;
                    halftoneRegion.gridWidth = (0, _core_utils.readUint32)(data, position);
                    position += 4;
                    halftoneRegion.gridHeight = (0, _core_utils.readUint32)(data, position);
                    position += 4;
                    halftoneRegion.gridOffsetX = (0, _core_utils.readUint32)(data, position) & 4294967295;
                    position += 4;
                    halftoneRegion.gridOffsetY = (0, _core_utils.readUint32)(data, position) & 4294967295;
                    position += 4;
                    halftoneRegion.gridVectorX = (0, _core_utils.readUint16)(data, position);
                    position += 2;
                    halftoneRegion.gridVectorY = (0, _core_utils.readUint16)(data, position);
                    position += 2;
                    args = [halftoneRegion, header.referredTo, data, position, end];
                    break;
                  case 38:
                  case 39:
                    const genericRegion = {};
                    genericRegion.info = readRegionSegmentInformation(data, position);
                    position += RegionSegmentInformationFieldLength;
                    const genericRegionSegmentFlags = data[position++];
                    genericRegion.mmr = !!(genericRegionSegmentFlags & 1);
                    genericRegion.template = genericRegionSegmentFlags >> 1 & 3;
                    genericRegion.prediction = !!(genericRegionSegmentFlags & 8);
                    if (!genericRegion.mmr) {
                      atLength = genericRegion.template === 0 ? 4 : 1;
                      at = [];
                      for (i = 0; i < atLength; i++) {
                        at.push({
                          x: (0, _core_utils.readInt8)(data, position),
                          y: (0, _core_utils.readInt8)(data, position + 1)
                        });
                        position += 2;
                      }
                      genericRegion.at = at;
                    }
                    args = [genericRegion, data, position, end];
                    break;
                  case 48:
                    const pageInfo = {
                      width: (0, _core_utils.readUint32)(data, position),
                      height: (0, _core_utils.readUint32)(data, position + 4),
                      resolutionX: (0, _core_utils.readUint32)(data, position + 8),
                      resolutionY: (0, _core_utils.readUint32)(data, position + 12)
                    };
                    if (pageInfo.height === 4294967295) {
                      delete pageInfo.height;
                    }
                    const pageSegmentFlags = data[position + 16];
                    (0, _core_utils.readUint16)(data, position + 17);
                    pageInfo.lossless = !!(pageSegmentFlags & 1);
                    pageInfo.refinement = !!(pageSegmentFlags & 2);
                    pageInfo.defaultPixelValue = pageSegmentFlags >> 2 & 1;
                    pageInfo.combinationOperator = pageSegmentFlags >> 3 & 3;
                    pageInfo.requiresBuffer = !!(pageSegmentFlags & 32);
                    pageInfo.combinationOperatorOverride = !!(pageSegmentFlags & 64);
                    args = [pageInfo];
                    break;
                  case 49:
                    break;
                  case 50:
                    break;
                  case 51:
                    break;
                  case 53:
                    args = [header.number, data, position, end];
                    break;
                  case 62:
                    break;
                  default:
                    throw new Jbig2Error(`segment type ${header.typeName}(${header.type}) is not implemented`);
                }
                const callbackName = "on" + header.typeName;
                if (callbackName in visitor) {
                  visitor[callbackName].apply(visitor, args);
                }
              }
              __name(processSegment, "processSegment");
              function processSegments(segments, visitor) {
                for (let i = 0, ii = segments.length; i < ii; i++) {
                  processSegment(segments[i], visitor);
                }
              }
              __name(processSegments, "processSegments");
              function parseJbig2Chunks(chunks) {
                const visitor = new SimpleSegmentVisitor();
                for (let i = 0, ii = chunks.length; i < ii; i++) {
                  const chunk = chunks[i];
                  const segments = readSegments({}, chunk.data, chunk.start, chunk.end);
                  processSegments(segments, visitor);
                }
                return visitor.buffer;
              }
              __name(parseJbig2Chunks, "parseJbig2Chunks");
              const _SimpleSegmentVisitor = class _SimpleSegmentVisitor {
                onPageInformation(info) {
                  this.currentPageInfo = info;
                  const rowSize = info.width + 7 >> 3;
                  const buffer = new Uint8ClampedArray(rowSize * info.height);
                  if (info.defaultPixelValue) {
                    buffer.fill(255);
                  }
                  this.buffer = buffer;
                }
                drawBitmap(regionInfo, bitmap) {
                  const pageInfo = this.currentPageInfo;
                  const width = regionInfo.width, height = regionInfo.height;
                  const rowSize = pageInfo.width + 7 >> 3;
                  const combinationOperator = pageInfo.combinationOperatorOverride ? regionInfo.combinationOperator : pageInfo.combinationOperator;
                  const buffer = this.buffer;
                  const mask0 = 128 >> (regionInfo.x & 7);
                  let offset0 = regionInfo.y * rowSize + (regionInfo.x >> 3);
                  let i, j, mask, offset;
                  switch (combinationOperator) {
                    case 0:
                      for (i = 0; i < height; i++) {
                        mask = mask0;
                        offset = offset0;
                        for (j = 0; j < width; j++) {
                          if (bitmap[i][j]) {
                            buffer[offset] |= mask;
                          }
                          mask >>= 1;
                          if (!mask) {
                            mask = 128;
                            offset++;
                          }
                        }
                        offset0 += rowSize;
                      }
                      break;
                    case 2:
                      for (i = 0; i < height; i++) {
                        mask = mask0;
                        offset = offset0;
                        for (j = 0; j < width; j++) {
                          if (bitmap[i][j]) {
                            buffer[offset] ^= mask;
                          }
                          mask >>= 1;
                          if (!mask) {
                            mask = 128;
                            offset++;
                          }
                        }
                        offset0 += rowSize;
                      }
                      break;
                    default:
                      throw new Jbig2Error(`operator ${combinationOperator} is not supported`);
                  }
                }
                onImmediateGenericRegion(region, data, start, end) {
                  const regionInfo = region.info;
                  const decodingContext = new DecodingContext(data, start, end);
                  const bitmap = decodeBitmap(region.mmr, regionInfo.width, regionInfo.height, region.template, region.prediction, null, region.at, decodingContext);
                  this.drawBitmap(regionInfo, bitmap);
                }
                onImmediateLosslessGenericRegion() {
                  this.onImmediateGenericRegion(...arguments);
                }
                onSymbolDictionary(dictionary, currentSegment, referredSegments, data, start, end) {
                  let huffmanTables, huffmanInput;
                  if (dictionary.huffman) {
                    huffmanTables = getSymbolDictionaryHuffmanTables(dictionary, referredSegments, this.customTables);
                    huffmanInput = new Reader(data, start, end);
                  }
                  let symbols = this.symbols;
                  if (!symbols) {
                    this.symbols = symbols = {};
                  }
                  const inputSymbols = [];
                  for (const referredSegment of referredSegments) {
                    const referredSymbols = symbols[referredSegment];
                    if (referredSymbols) {
                      inputSymbols.push(...referredSymbols);
                    }
                  }
                  const decodingContext = new DecodingContext(data, start, end);
                  symbols[currentSegment] = decodeSymbolDictionary(dictionary.huffman, dictionary.refinement, inputSymbols, dictionary.numberOfNewSymbols, dictionary.numberOfExportedSymbols, huffmanTables, dictionary.template, dictionary.at, dictionary.refinementTemplate, dictionary.refinementAt, decodingContext, huffmanInput);
                }
                onImmediateTextRegion(region, referredSegments, data, start, end) {
                  const regionInfo = region.info;
                  let huffmanTables, huffmanInput;
                  const symbols = this.symbols;
                  const inputSymbols = [];
                  for (const referredSegment of referredSegments) {
                    const referredSymbols = symbols[referredSegment];
                    if (referredSymbols) {
                      inputSymbols.push(...referredSymbols);
                    }
                  }
                  const symbolCodeLength = (0, _core_utils.log2)(inputSymbols.length);
                  if (region.huffman) {
                    huffmanInput = new Reader(data, start, end);
                    huffmanTables = getTextRegionHuffmanTables(region, referredSegments, this.customTables, inputSymbols.length, huffmanInput);
                  }
                  const decodingContext = new DecodingContext(data, start, end);
                  const bitmap = decodeTextRegion(region.huffman, region.refinement, regionInfo.width, regionInfo.height, region.defaultPixelValue, region.numberOfSymbolInstances, region.stripSize, inputSymbols, symbolCodeLength, region.transposed, region.dsOffset, region.referenceCorner, region.combinationOperator, huffmanTables, region.refinementTemplate, region.refinementAt, decodingContext, region.logStripSize, huffmanInput);
                  this.drawBitmap(regionInfo, bitmap);
                }
                onImmediateLosslessTextRegion() {
                  this.onImmediateTextRegion(...arguments);
                }
                onPatternDictionary(dictionary, currentSegment, data, start, end) {
                  let patterns = this.patterns;
                  if (!patterns) {
                    this.patterns = patterns = {};
                  }
                  const decodingContext = new DecodingContext(data, start, end);
                  patterns[currentSegment] = decodePatternDictionary(dictionary.mmr, dictionary.patternWidth, dictionary.patternHeight, dictionary.maxPatternIndex, dictionary.template, decodingContext);
                }
                onImmediateHalftoneRegion(region, referredSegments, data, start, end) {
                  const patterns = this.patterns[referredSegments[0]];
                  const regionInfo = region.info;
                  const decodingContext = new DecodingContext(data, start, end);
                  const bitmap = decodeHalftoneRegion(region.mmr, patterns, region.template, regionInfo.width, regionInfo.height, region.defaultPixelValue, region.enableSkip, region.combinationOperator, region.gridWidth, region.gridHeight, region.gridOffsetX, region.gridOffsetY, region.gridVectorX, region.gridVectorY, decodingContext);
                  this.drawBitmap(regionInfo, bitmap);
                }
                onImmediateLosslessHalftoneRegion() {
                  this.onImmediateHalftoneRegion(...arguments);
                }
                onTables(currentSegment, data, start, end) {
                  let customTables = this.customTables;
                  if (!customTables) {
                    this.customTables = customTables = {};
                  }
                  customTables[currentSegment] = decodeTablesSegment(data, start, end);
                }
              };
              __name(_SimpleSegmentVisitor, "SimpleSegmentVisitor");
              let SimpleSegmentVisitor = _SimpleSegmentVisitor;
              const _HuffmanLine = class _HuffmanLine {
                constructor(lineData) {
                  if (lineData.length === 2) {
                    this.isOOB = true;
                    this.rangeLow = 0;
                    this.prefixLength = lineData[0];
                    this.rangeLength = 0;
                    this.prefixCode = lineData[1];
                    this.isLowerRange = false;
                  } else {
                    this.isOOB = false;
                    this.rangeLow = lineData[0];
                    this.prefixLength = lineData[1];
                    this.rangeLength = lineData[2];
                    this.prefixCode = lineData[3];
                    this.isLowerRange = lineData[4] === "lower";
                  }
                }
              };
              __name(_HuffmanLine, "HuffmanLine");
              let HuffmanLine = _HuffmanLine;
              const _HuffmanTreeNode = class _HuffmanTreeNode {
                constructor(line) {
                  this.children = [];
                  if (line) {
                    this.isLeaf = true;
                    this.rangeLength = line.rangeLength;
                    this.rangeLow = line.rangeLow;
                    this.isLowerRange = line.isLowerRange;
                    this.isOOB = line.isOOB;
                  } else {
                    this.isLeaf = false;
                  }
                }
                buildTree(line, shift) {
                  const bit = line.prefixCode >> shift & 1;
                  if (shift <= 0) {
                    this.children[bit] = new _HuffmanTreeNode(line);
                  } else {
                    let node = this.children[bit];
                    if (!node) {
                      this.children[bit] = node = new _HuffmanTreeNode(null);
                    }
                    node.buildTree(line, shift - 1);
                  }
                }
                decodeNode(reader) {
                  if (this.isLeaf) {
                    if (this.isOOB) {
                      return null;
                    }
                    const htOffset = reader.readBits(this.rangeLength);
                    return this.rangeLow + (this.isLowerRange ? -htOffset : htOffset);
                  }
                  const node = this.children[reader.readBit()];
                  if (!node) {
                    throw new Jbig2Error("invalid Huffman data");
                  }
                  return node.decodeNode(reader);
                }
              };
              __name(_HuffmanTreeNode, "HuffmanTreeNode");
              let HuffmanTreeNode = _HuffmanTreeNode;
              const _HuffmanTable = class _HuffmanTable {
                constructor(lines, prefixCodesDone) {
                  if (!prefixCodesDone) {
                    this.assignPrefixCodes(lines);
                  }
                  this.rootNode = new HuffmanTreeNode(null);
                  for (let i = 0, ii = lines.length; i < ii; i++) {
                    const line = lines[i];
                    if (line.prefixLength > 0) {
                      this.rootNode.buildTree(line, line.prefixLength - 1);
                    }
                  }
                }
                decode(reader) {
                  return this.rootNode.decodeNode(reader);
                }
                assignPrefixCodes(lines) {
                  const linesLength = lines.length;
                  let prefixLengthMax = 0;
                  for (let i = 0; i < linesLength; i++) {
                    prefixLengthMax = Math.max(prefixLengthMax, lines[i].prefixLength);
                  }
                  const histogram = new Uint32Array(prefixLengthMax + 1);
                  for (let i = 0; i < linesLength; i++) {
                    histogram[lines[i].prefixLength]++;
                  }
                  let currentLength = 1, firstCode = 0, currentCode, currentTemp, line;
                  histogram[0] = 0;
                  while (currentLength <= prefixLengthMax) {
                    firstCode = firstCode + histogram[currentLength - 1] << 1;
                    currentCode = firstCode;
                    currentTemp = 0;
                    while (currentTemp < linesLength) {
                      line = lines[currentTemp];
                      if (line.prefixLength === currentLength) {
                        line.prefixCode = currentCode;
                        currentCode++;
                      }
                      currentTemp++;
                    }
                    currentLength++;
                  }
                }
              };
              __name(_HuffmanTable, "HuffmanTable");
              let HuffmanTable = _HuffmanTable;
              function decodeTablesSegment(data, start, end) {
                const flags = data[start];
                const lowestValue = (0, _core_utils.readUint32)(data, start + 1) & 4294967295;
                const highestValue = (0, _core_utils.readUint32)(data, start + 5) & 4294967295;
                const reader = new Reader(data, start + 9, end);
                const prefixSizeBits = (flags >> 1 & 7) + 1;
                const rangeSizeBits = (flags >> 4 & 7) + 1;
                const lines = [];
                let prefixLength, rangeLength, currentRangeLow = lowestValue;
                do {
                  prefixLength = reader.readBits(prefixSizeBits);
                  rangeLength = reader.readBits(rangeSizeBits);
                  lines.push(new HuffmanLine([currentRangeLow, prefixLength, rangeLength, 0]));
                  currentRangeLow += 1 << rangeLength;
                } while (currentRangeLow < highestValue);
                prefixLength = reader.readBits(prefixSizeBits);
                lines.push(new HuffmanLine([lowestValue - 1, prefixLength, 32, 0, "lower"]));
                prefixLength = reader.readBits(prefixSizeBits);
                lines.push(new HuffmanLine([highestValue, prefixLength, 32, 0]));
                if (flags & 1) {
                  prefixLength = reader.readBits(prefixSizeBits);
                  lines.push(new HuffmanLine([prefixLength, 0]));
                }
                return new HuffmanTable(lines, false);
              }
              __name(decodeTablesSegment, "decodeTablesSegment");
              const standardTablesCache = {};
              function getStandardTable(number) {
                let table = standardTablesCache[number];
                if (table) {
                  return table;
                }
                let lines;
                switch (number) {
                  case 1:
                    lines = [[0, 1, 4, 0], [16, 2, 8, 2], [272, 3, 16, 6], [65808, 3, 32, 7]];
                    break;
                  case 2:
                    lines = [[0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [75, 6, 32, 62], [6, 63]];
                    break;
                  case 3:
                    lines = [[-256, 8, 8, 254], [0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [-257, 8, 32, 255, "lower"], [75, 7, 32, 126], [6, 62]];
                    break;
                  case 4:
                    lines = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [76, 5, 32, 31]];
                    break;
                  case 5:
                    lines = [[-255, 7, 8, 126], [1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [-256, 7, 32, 127, "lower"], [76, 6, 32, 62]];
                    break;
                  case 6:
                    lines = [[-2048, 5, 10, 28], [-1024, 4, 9, 8], [-512, 4, 8, 9], [-256, 4, 7, 10], [-128, 5, 6, 29], [-64, 5, 5, 30], [-32, 4, 5, 11], [0, 2, 7, 0], [128, 3, 7, 2], [256, 3, 8, 3], [512, 4, 9, 12], [1024, 4, 10, 13], [-2049, 6, 32, 62, "lower"], [2048, 6, 32, 63]];
                    break;
                  case 7:
                    lines = [[-1024, 4, 9, 8], [-512, 3, 8, 0], [-256, 4, 7, 9], [-128, 5, 6, 26], [-64, 5, 5, 27], [-32, 4, 5, 10], [0, 4, 5, 11], [32, 5, 5, 28], [64, 5, 6, 29], [128, 4, 7, 12], [256, 3, 8, 1], [512, 3, 9, 2], [1024, 3, 10, 3], [-1025, 5, 32, 30, "lower"], [2048, 5, 32, 31]];
                    break;
                  case 8:
                    lines = [[-15, 8, 3, 252], [-7, 9, 1, 508], [-5, 8, 1, 253], [-3, 9, 0, 509], [-2, 7, 0, 124], [-1, 4, 0, 10], [0, 2, 1, 0], [2, 5, 0, 26], [3, 6, 0, 58], [4, 3, 4, 4], [20, 6, 1, 59], [22, 4, 4, 11], [38, 4, 5, 12], [70, 5, 6, 27], [134, 5, 7, 28], [262, 6, 7, 60], [390, 7, 8, 125], [646, 6, 10, 61], [-16, 9, 32, 510, "lower"], [1670, 9, 32, 511], [2, 1]];
                    break;
                  case 9:
                    lines = [[-31, 8, 4, 252], [-15, 9, 2, 508], [-11, 8, 2, 253], [-7, 9, 1, 509], [-5, 7, 1, 124], [-3, 4, 1, 10], [-1, 3, 1, 2], [1, 3, 1, 3], [3, 5, 1, 26], [5, 6, 1, 58], [7, 3, 5, 4], [39, 6, 2, 59], [43, 4, 5, 11], [75, 4, 6, 12], [139, 5, 7, 27], [267, 5, 8, 28], [523, 6, 8, 60], [779, 7, 9, 125], [1291, 6, 11, 61], [-32, 9, 32, 510, "lower"], [3339, 9, 32, 511], [2, 0]];
                    break;
                  case 10:
                    lines = [[-21, 7, 4, 122], [-5, 8, 0, 252], [-4, 7, 0, 123], [-3, 5, 0, 24], [-2, 2, 2, 0], [2, 5, 0, 25], [3, 6, 0, 54], [4, 7, 0, 124], [5, 8, 0, 253], [6, 2, 6, 1], [70, 5, 5, 26], [102, 6, 5, 55], [134, 6, 6, 56], [198, 6, 7, 57], [326, 6, 8, 58], [582, 6, 9, 59], [1094, 6, 10, 60], [2118, 7, 11, 125], [-22, 8, 32, 254, "lower"], [4166, 8, 32, 255], [2, 2]];
                    break;
                  case 11:
                    lines = [[1, 1, 0, 0], [2, 2, 1, 2], [4, 4, 0, 12], [5, 4, 1, 13], [7, 5, 1, 28], [9, 5, 2, 29], [13, 6, 2, 60], [17, 7, 2, 122], [21, 7, 3, 123], [29, 7, 4, 124], [45, 7, 5, 125], [77, 7, 6, 126], [141, 7, 32, 127]];
                    break;
                  case 12:
                    lines = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 1, 6], [5, 5, 0, 28], [6, 5, 1, 29], [8, 6, 1, 60], [10, 7, 0, 122], [11, 7, 1, 123], [13, 7, 2, 124], [17, 7, 3, 125], [25, 7, 4, 126], [41, 8, 5, 254], [73, 8, 32, 255]];
                    break;
                  case 13:
                    lines = [[1, 1, 0, 0], [2, 3, 0, 4], [3, 4, 0, 12], [4, 5, 0, 28], [5, 4, 1, 13], [7, 3, 3, 5], [15, 6, 1, 58], [17, 6, 2, 59], [21, 6, 3, 60], [29, 6, 4, 61], [45, 6, 5, 62], [77, 7, 6, 126], [141, 7, 32, 127]];
                    break;
                  case 14:
                    lines = [[-2, 3, 0, 4], [-1, 3, 0, 5], [0, 1, 0, 0], [1, 3, 0, 6], [2, 3, 0, 7]];
                    break;
                  case 15:
                    lines = [[-24, 7, 4, 124], [-8, 6, 2, 60], [-4, 5, 1, 28], [-2, 4, 0, 12], [-1, 3, 0, 4], [0, 1, 0, 0], [1, 3, 0, 5], [2, 4, 0, 13], [3, 5, 1, 29], [5, 6, 2, 61], [9, 7, 4, 125], [-25, 7, 32, 126, "lower"], [25, 7, 32, 127]];
                    break;
                  default:
                    throw new Jbig2Error(`standard table B.${number} does not exist`);
                }
                for (let i = 0, ii = lines.length; i < ii; i++) {
                  lines[i] = new HuffmanLine(lines[i]);
                }
                table = new HuffmanTable(lines, true);
                standardTablesCache[number] = table;
                return table;
              }
              __name(getStandardTable, "getStandardTable");
              const _Reader = class _Reader {
                constructor(data, start, end) {
                  this.data = data;
                  this.start = start;
                  this.end = end;
                  this.position = start;
                  this.shift = -1;
                  this.currentByte = 0;
                }
                readBit() {
                  if (this.shift < 0) {
                    if (this.position >= this.end) {
                      throw new Jbig2Error("end of data while reading bit");
                    }
                    this.currentByte = this.data[this.position++];
                    this.shift = 7;
                  }
                  const bit = this.currentByte >> this.shift & 1;
                  this.shift--;
                  return bit;
                }
                readBits(numBits) {
                  let result = 0, i;
                  for (i = numBits - 1; i >= 0; i--) {
                    result |= this.readBit() << i;
                  }
                  return result;
                }
                byteAlign() {
                  this.shift = -1;
                }
                next() {
                  if (this.position >= this.end) {
                    return -1;
                  }
                  return this.data[this.position++];
                }
              };
              __name(_Reader, "Reader");
              let Reader = _Reader;
              function getCustomHuffmanTable(index, referredTo, customTables) {
                let currentIndex = 0;
                for (let i = 0, ii = referredTo.length; i < ii; i++) {
                  const table = customTables[referredTo[i]];
                  if (table) {
                    if (index === currentIndex) {
                      return table;
                    }
                    currentIndex++;
                  }
                }
                throw new Jbig2Error("can't find custom Huffman table");
              }
              __name(getCustomHuffmanTable, "getCustomHuffmanTable");
              function getTextRegionHuffmanTables(textRegion, referredTo, customTables, numberOfSymbols, reader) {
                const codes = [];
                for (let i = 0; i <= 34; i++) {
                  const codeLength = reader.readBits(4);
                  codes.push(new HuffmanLine([i, codeLength, 0, 0]));
                }
                const runCodesTable = new HuffmanTable(codes, false);
                codes.length = 0;
                for (let i = 0; i < numberOfSymbols; ) {
                  const codeLength = runCodesTable.decode(reader);
                  if (codeLength >= 32) {
                    let repeatedLength, numberOfRepeats, j;
                    switch (codeLength) {
                      case 32:
                        if (i === 0) {
                          throw new Jbig2Error("no previous value in symbol ID table");
                        }
                        numberOfRepeats = reader.readBits(2) + 3;
                        repeatedLength = codes[i - 1].prefixLength;
                        break;
                      case 33:
                        numberOfRepeats = reader.readBits(3) + 3;
                        repeatedLength = 0;
                        break;
                      case 34:
                        numberOfRepeats = reader.readBits(7) + 11;
                        repeatedLength = 0;
                        break;
                      default:
                        throw new Jbig2Error("invalid code length in symbol ID table");
                    }
                    for (j = 0; j < numberOfRepeats; j++) {
                      codes.push(new HuffmanLine([i, repeatedLength, 0, 0]));
                      i++;
                    }
                  } else {
                    codes.push(new HuffmanLine([i, codeLength, 0, 0]));
                    i++;
                  }
                }
                reader.byteAlign();
                const symbolIDTable = new HuffmanTable(codes, false);
                let customIndex = 0, tableFirstS, tableDeltaS, tableDeltaT;
                switch (textRegion.huffmanFS) {
                  case 0:
                  case 1:
                    tableFirstS = getStandardTable(textRegion.huffmanFS + 6);
                    break;
                  case 3:
                    tableFirstS = getCustomHuffmanTable(customIndex, referredTo, customTables);
                    customIndex++;
                    break;
                  default:
                    throw new Jbig2Error("invalid Huffman FS selector");
                }
                switch (textRegion.huffmanDS) {
                  case 0:
                  case 1:
                  case 2:
                    tableDeltaS = getStandardTable(textRegion.huffmanDS + 8);
                    break;
                  case 3:
                    tableDeltaS = getCustomHuffmanTable(customIndex, referredTo, customTables);
                    customIndex++;
                    break;
                  default:
                    throw new Jbig2Error("invalid Huffman DS selector");
                }
                switch (textRegion.huffmanDT) {
                  case 0:
                  case 1:
                  case 2:
                    tableDeltaT = getStandardTable(textRegion.huffmanDT + 11);
                    break;
                  case 3:
                    tableDeltaT = getCustomHuffmanTable(customIndex, referredTo, customTables);
                    customIndex++;
                    break;
                  default:
                    throw new Jbig2Error("invalid Huffman DT selector");
                }
                if (textRegion.refinement) {
                  throw new Jbig2Error("refinement with Huffman is not supported");
                }
                return {
                  symbolIDTable,
                  tableFirstS,
                  tableDeltaS,
                  tableDeltaT
                };
              }
              __name(getTextRegionHuffmanTables, "getTextRegionHuffmanTables");
              function getSymbolDictionaryHuffmanTables(dictionary, referredTo, customTables) {
                let customIndex = 0, tableDeltaHeight, tableDeltaWidth;
                switch (dictionary.huffmanDHSelector) {
                  case 0:
                  case 1:
                    tableDeltaHeight = getStandardTable(dictionary.huffmanDHSelector + 4);
                    break;
                  case 3:
                    tableDeltaHeight = getCustomHuffmanTable(customIndex, referredTo, customTables);
                    customIndex++;
                    break;
                  default:
                    throw new Jbig2Error("invalid Huffman DH selector");
                }
                switch (dictionary.huffmanDWSelector) {
                  case 0:
                  case 1:
                    tableDeltaWidth = getStandardTable(dictionary.huffmanDWSelector + 2);
                    break;
                  case 3:
                    tableDeltaWidth = getCustomHuffmanTable(customIndex, referredTo, customTables);
                    customIndex++;
                    break;
                  default:
                    throw new Jbig2Error("invalid Huffman DW selector");
                }
                let tableBitmapSize, tableAggregateInstances;
                if (dictionary.bitmapSizeSelector) {
                  tableBitmapSize = getCustomHuffmanTable(customIndex, referredTo, customTables);
                  customIndex++;
                } else {
                  tableBitmapSize = getStandardTable(1);
                }
                if (dictionary.aggregationInstancesSelector) {
                  tableAggregateInstances = getCustomHuffmanTable(customIndex, referredTo, customTables);
                } else {
                  tableAggregateInstances = getStandardTable(1);
                }
                return {
                  tableDeltaHeight,
                  tableDeltaWidth,
                  tableBitmapSize,
                  tableAggregateInstances
                };
              }
              __name(getSymbolDictionaryHuffmanTables, "getSymbolDictionaryHuffmanTables");
              function readUncompressedBitmap(reader, width, height) {
                const bitmap = [];
                for (let y = 0; y < height; y++) {
                  const row = new Uint8Array(width);
                  bitmap.push(row);
                  for (let x = 0; x < width; x++) {
                    row[x] = reader.readBit();
                  }
                  reader.byteAlign();
                }
                return bitmap;
              }
              __name(readUncompressedBitmap, "readUncompressedBitmap");
              function decodeMMRBitmap(input, width, height, endOfBlock) {
                const params = {
                  K: -1,
                  Columns: width,
                  Rows: height,
                  BlackIs1: true,
                  EndOfBlock: endOfBlock
                };
                const decoder = new _ccitt.CCITTFaxDecoder(input, params);
                const bitmap = [];
                let currentByte, eof = false;
                for (let y = 0; y < height; y++) {
                  const row = new Uint8Array(width);
                  bitmap.push(row);
                  let shift = -1;
                  for (let x = 0; x < width; x++) {
                    if (shift < 0) {
                      currentByte = decoder.readNextChar();
                      if (currentByte === -1) {
                        currentByte = 0;
                        eof = true;
                      }
                      shift = 7;
                    }
                    row[x] = currentByte >> shift & 1;
                    shift--;
                  }
                }
                if (endOfBlock && !eof) {
                  const lookForEOFLimit = 5;
                  for (let i = 0; i < lookForEOFLimit; i++) {
                    if (decoder.readNextChar() === -1) {
                      break;
                    }
                  }
                }
                return bitmap;
              }
              __name(decodeMMRBitmap, "decodeMMRBitmap");
              const _Jbig2Image = class _Jbig2Image {
                parseChunks(chunks) {
                  return parseJbig2Chunks(chunks);
                }
                parse(data) {
                  throw new Error("Not implemented: Jbig2Image.parse");
                }
              };
              __name(_Jbig2Image, "Jbig2Image");
              let Jbig2Image = _Jbig2Image;
              exports2.Jbig2Image = Jbig2Image;
            },
            /* 151 */
            /***/
            (__unused_webpack_module, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.ArithmeticDecoder = void 0;
              const QeTable = [{
                qe: 22017,
                nmps: 1,
                nlps: 1,
                switchFlag: 1
              }, {
                qe: 13313,
                nmps: 2,
                nlps: 6,
                switchFlag: 0
              }, {
                qe: 6145,
                nmps: 3,
                nlps: 9,
                switchFlag: 0
              }, {
                qe: 2753,
                nmps: 4,
                nlps: 12,
                switchFlag: 0
              }, {
                qe: 1313,
                nmps: 5,
                nlps: 29,
                switchFlag: 0
              }, {
                qe: 545,
                nmps: 38,
                nlps: 33,
                switchFlag: 0
              }, {
                qe: 22017,
                nmps: 7,
                nlps: 6,
                switchFlag: 1
              }, {
                qe: 21505,
                nmps: 8,
                nlps: 14,
                switchFlag: 0
              }, {
                qe: 18433,
                nmps: 9,
                nlps: 14,
                switchFlag: 0
              }, {
                qe: 14337,
                nmps: 10,
                nlps: 14,
                switchFlag: 0
              }, {
                qe: 12289,
                nmps: 11,
                nlps: 17,
                switchFlag: 0
              }, {
                qe: 9217,
                nmps: 12,
                nlps: 18,
                switchFlag: 0
              }, {
                qe: 7169,
                nmps: 13,
                nlps: 20,
                switchFlag: 0
              }, {
                qe: 5633,
                nmps: 29,
                nlps: 21,
                switchFlag: 0
              }, {
                qe: 22017,
                nmps: 15,
                nlps: 14,
                switchFlag: 1
              }, {
                qe: 21505,
                nmps: 16,
                nlps: 14,
                switchFlag: 0
              }, {
                qe: 20737,
                nmps: 17,
                nlps: 15,
                switchFlag: 0
              }, {
                qe: 18433,
                nmps: 18,
                nlps: 16,
                switchFlag: 0
              }, {
                qe: 14337,
                nmps: 19,
                nlps: 17,
                switchFlag: 0
              }, {
                qe: 13313,
                nmps: 20,
                nlps: 18,
                switchFlag: 0
              }, {
                qe: 12289,
                nmps: 21,
                nlps: 19,
                switchFlag: 0
              }, {
                qe: 10241,
                nmps: 22,
                nlps: 19,
                switchFlag: 0
              }, {
                qe: 9217,
                nmps: 23,
                nlps: 20,
                switchFlag: 0
              }, {
                qe: 8705,
                nmps: 24,
                nlps: 21,
                switchFlag: 0
              }, {
                qe: 7169,
                nmps: 25,
                nlps: 22,
                switchFlag: 0
              }, {
                qe: 6145,
                nmps: 26,
                nlps: 23,
                switchFlag: 0
              }, {
                qe: 5633,
                nmps: 27,
                nlps: 24,
                switchFlag: 0
              }, {
                qe: 5121,
                nmps: 28,
                nlps: 25,
                switchFlag: 0
              }, {
                qe: 4609,
                nmps: 29,
                nlps: 26,
                switchFlag: 0
              }, {
                qe: 4353,
                nmps: 30,
                nlps: 27,
                switchFlag: 0
              }, {
                qe: 2753,
                nmps: 31,
                nlps: 28,
                switchFlag: 0
              }, {
                qe: 2497,
                nmps: 32,
                nlps: 29,
                switchFlag: 0
              }, {
                qe: 2209,
                nmps: 33,
                nlps: 30,
                switchFlag: 0
              }, {
                qe: 1313,
                nmps: 34,
                nlps: 31,
                switchFlag: 0
              }, {
                qe: 1089,
                nmps: 35,
                nlps: 32,
                switchFlag: 0
              }, {
                qe: 673,
                nmps: 36,
                nlps: 33,
                switchFlag: 0
              }, {
                qe: 545,
                nmps: 37,
                nlps: 34,
                switchFlag: 0
              }, {
                qe: 321,
                nmps: 38,
                nlps: 35,
                switchFlag: 0
              }, {
                qe: 273,
                nmps: 39,
                nlps: 36,
                switchFlag: 0
              }, {
                qe: 133,
                nmps: 40,
                nlps: 37,
                switchFlag: 0
              }, {
                qe: 73,
                nmps: 41,
                nlps: 38,
                switchFlag: 0
              }, {
                qe: 37,
                nmps: 42,
                nlps: 39,
                switchFlag: 0
              }, {
                qe: 21,
                nmps: 43,
                nlps: 40,
                switchFlag: 0
              }, {
                qe: 9,
                nmps: 44,
                nlps: 41,
                switchFlag: 0
              }, {
                qe: 5,
                nmps: 45,
                nlps: 42,
                switchFlag: 0
              }, {
                qe: 1,
                nmps: 45,
                nlps: 43,
                switchFlag: 0
              }, {
                qe: 22017,
                nmps: 46,
                nlps: 46,
                switchFlag: 0
              }];
              const _ArithmeticDecoder = class _ArithmeticDecoder {
                constructor(data, start, end) {
                  this.data = data;
                  this.bp = start;
                  this.dataEnd = end;
                  this.chigh = data[start];
                  this.clow = 0;
                  this.byteIn();
                  this.chigh = this.chigh << 7 & 65535 | this.clow >> 9 & 127;
                  this.clow = this.clow << 7 & 65535;
                  this.ct -= 7;
                  this.a = 32768;
                }
                byteIn() {
                  const data = this.data;
                  let bp = this.bp;
                  if (data[bp] === 255) {
                    if (data[bp + 1] > 143) {
                      this.clow += 65280;
                      this.ct = 8;
                    } else {
                      bp++;
                      this.clow += data[bp] << 9;
                      this.ct = 7;
                      this.bp = bp;
                    }
                  } else {
                    bp++;
                    this.clow += bp < this.dataEnd ? data[bp] << 8 : 65280;
                    this.ct = 8;
                    this.bp = bp;
                  }
                  if (this.clow > 65535) {
                    this.chigh += this.clow >> 16;
                    this.clow &= 65535;
                  }
                }
                readBit(contexts, pos) {
                  let cx_index = contexts[pos] >> 1, cx_mps = contexts[pos] & 1;
                  const qeTableIcx = QeTable[cx_index];
                  const qeIcx = qeTableIcx.qe;
                  let d;
                  let a = this.a - qeIcx;
                  if (this.chigh < qeIcx) {
                    if (a < qeIcx) {
                      a = qeIcx;
                      d = cx_mps;
                      cx_index = qeTableIcx.nmps;
                    } else {
                      a = qeIcx;
                      d = 1 ^ cx_mps;
                      if (qeTableIcx.switchFlag === 1) {
                        cx_mps = d;
                      }
                      cx_index = qeTableIcx.nlps;
                    }
                  } else {
                    this.chigh -= qeIcx;
                    if ((a & 32768) !== 0) {
                      this.a = a;
                      return cx_mps;
                    }
                    if (a < qeIcx) {
                      d = 1 ^ cx_mps;
                      if (qeTableIcx.switchFlag === 1) {
                        cx_mps = d;
                      }
                      cx_index = qeTableIcx.nlps;
                    } else {
                      d = cx_mps;
                      cx_index = qeTableIcx.nmps;
                    }
                  }
                  do {
                    if (this.ct === 0) {
                      this.byteIn();
                    }
                    a <<= 1;
                    this.chigh = this.chigh << 1 & 65535 | this.clow >> 15 & 1;
                    this.clow = this.clow << 1 & 65535;
                    this.ct--;
                  } while ((a & 32768) === 0);
                  this.a = a;
                  contexts[pos] = cx_index << 1 | cx_mps;
                  return d;
                }
              };
              __name(_ArithmeticDecoder, "ArithmeticDecoder");
              let ArithmeticDecoder = _ArithmeticDecoder;
              exports2.ArithmeticDecoder = ArithmeticDecoder;
            },
            /* 152 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.JpegStream = void 0;
              var _decode_stream = __w_pdfjs_require__2(144);
              var _primitives = __w_pdfjs_require__2(130);
              var _jpg = __w_pdfjs_require__2(153);
              var _util = __w_pdfjs_require__2(2);
              const _JpegStream = class _JpegStream extends _decode_stream.DecodeStream {
                constructor(stream, maybeLength, params) {
                  let ch;
                  while ((ch = stream.getByte()) !== -1) {
                    if (ch === 255) {
                      stream.skip(-1);
                      break;
                    }
                  }
                  super(maybeLength);
                  this.stream = stream;
                  this.dict = stream.dict;
                  this.maybeLength = maybeLength;
                  this.params = params;
                }
                get bytes() {
                  return (0, _util.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
                }
                ensureBuffer(requested) {
                }
                readBlock() {
                  if (this.eof) {
                    return;
                  }
                  const jpegOptions = {
                    decodeTransform: void 0,
                    colorTransform: void 0
                  };
                  const decodeArr = this.dict.getArray("D", "Decode");
                  if (this.forceRGB && Array.isArray(decodeArr)) {
                    const bitsPerComponent = this.dict.get("BPC", "BitsPerComponent") || 8;
                    const decodeArrLength = decodeArr.length;
                    const transform = new Int32Array(decodeArrLength);
                    let transformNeeded = false;
                    const maxValue = (1 << bitsPerComponent) - 1;
                    for (let i = 0; i < decodeArrLength; i += 2) {
                      transform[i] = (decodeArr[i + 1] - decodeArr[i]) * 256 | 0;
                      transform[i + 1] = decodeArr[i] * maxValue | 0;
                      if (transform[i] !== 256 || transform[i + 1] !== 0) {
                        transformNeeded = true;
                      }
                    }
                    if (transformNeeded) {
                      jpegOptions.decodeTransform = transform;
                    }
                  }
                  if (this.params instanceof _primitives.Dict) {
                    const colorTransform = this.params.get("ColorTransform");
                    if (Number.isInteger(colorTransform)) {
                      jpegOptions.colorTransform = colorTransform;
                    }
                  }
                  const jpegImage = new _jpg.JpegImage(jpegOptions);
                  jpegImage.parse(this.bytes);
                  const data = jpegImage.getData({
                    width: this.drawWidth,
                    height: this.drawHeight,
                    forceRGB: this.forceRGB,
                    isSourcePDF: true
                  });
                  this.buffer = data;
                  this.bufferLength = data.length;
                  this.eof = true;
                }
              };
              __name(_JpegStream, "JpegStream");
              let JpegStream = _JpegStream;
              exports2.JpegStream = JpegStream;
            },
            /* 153 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.JpegImage = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _core_utils = __w_pdfjs_require__2(131);
              const _JpegError = class _JpegError extends _util.BaseException {
                constructor(msg) {
                  super(`JPEG error: ${msg}`, "JpegError");
                }
              };
              __name(_JpegError, "JpegError");
              let JpegError = _JpegError;
              const _DNLMarkerError = class _DNLMarkerError extends _util.BaseException {
                constructor(message, scanLines) {
                  super(message, "DNLMarkerError");
                  this.scanLines = scanLines;
                }
              };
              __name(_DNLMarkerError, "DNLMarkerError");
              let DNLMarkerError = _DNLMarkerError;
              const _EOIMarkerError = class _EOIMarkerError extends _util.BaseException {
                constructor(msg) {
                  super(msg, "EOIMarkerError");
                }
              };
              __name(_EOIMarkerError, "EOIMarkerError");
              let EOIMarkerError = _EOIMarkerError;
              const dctZigZag = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]);
              const dctCos1 = 4017;
              const dctSin1 = 799;
              const dctCos3 = 3406;
              const dctSin3 = 2276;
              const dctCos6 = 1567;
              const dctSin6 = 3784;
              const dctSqrt2 = 5793;
              const dctSqrt1d2 = 2896;
              function buildHuffmanTable(codeLengths, values) {
                let k = 0, i, j, length = 16;
                while (length > 0 && !codeLengths[length - 1]) {
                  length--;
                }
                const code = [{
                  children: [],
                  index: 0
                }];
                let p = code[0], q;
                for (i = 0; i < length; i++) {
                  for (j = 0; j < codeLengths[i]; j++) {
                    p = code.pop();
                    p.children[p.index] = values[k];
                    while (p.index > 0) {
                      p = code.pop();
                    }
                    p.index++;
                    code.push(p);
                    while (code.length <= i) {
                      code.push(q = {
                        children: [],
                        index: 0
                      });
                      p.children[p.index] = q.children;
                      p = q;
                    }
                    k++;
                  }
                  if (i + 1 < length) {
                    code.push(q = {
                      children: [],
                      index: 0
                    });
                    p.children[p.index] = q.children;
                    p = q;
                  }
                }
                return code[0].children;
              }
              __name(buildHuffmanTable, "buildHuffmanTable");
              function getBlockBufferOffset(component, row, col) {
                return 64 * ((component.blocksPerLine + 1) * row + col);
              }
              __name(getBlockBufferOffset, "getBlockBufferOffset");
              function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive) {
                let parseDNLMarker = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : false;
                const mcusPerLine = frame.mcusPerLine;
                const progressive = frame.progressive;
                const startOffset = offset;
                let bitsData = 0, bitsCount = 0;
                function readBit() {
                  if (bitsCount > 0) {
                    bitsCount--;
                    return bitsData >> bitsCount & 1;
                  }
                  bitsData = data[offset++];
                  if (bitsData === 255) {
                    const nextByte = data[offset++];
                    if (nextByte) {
                      if (nextByte === 220 && parseDNLMarker) {
                        offset += 2;
                        const scanLines = (0, _core_utils.readUint16)(data, offset);
                        offset += 2;
                        if (scanLines > 0 && scanLines !== frame.scanLines) {
                          throw new DNLMarkerError("Found DNL marker (0xFFDC) while parsing scan data", scanLines);
                        }
                      } else if (nextByte === 217) {
                        if (parseDNLMarker) {
                          const maybeScanLines = blockRow * (frame.precision === 8 ? 8 : 0);
                          if (maybeScanLines > 0 && Math.round(frame.scanLines / maybeScanLines) >= 10) {
                            throw new DNLMarkerError("Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter", maybeScanLines);
                          }
                        }
                        throw new EOIMarkerError("Found EOI marker (0xFFD9) while parsing scan data");
                      }
                      throw new JpegError(`unexpected marker ${(bitsData << 8 | nextByte).toString(16)}`);
                    }
                  }
                  bitsCount = 7;
                  return bitsData >>> 7;
                }
                __name(readBit, "readBit");
                function decodeHuffman(tree) {
                  let node = tree;
                  while (true) {
                    node = node[readBit()];
                    switch (typeof node) {
                      case "number":
                        return node;
                      case "object":
                        continue;
                    }
                    throw new JpegError("invalid huffman sequence");
                  }
                }
                __name(decodeHuffman, "decodeHuffman");
                function receive(length) {
                  let n2 = 0;
                  while (length > 0) {
                    n2 = n2 << 1 | readBit();
                    length--;
                  }
                  return n2;
                }
                __name(receive, "receive");
                function receiveAndExtend(length) {
                  if (length === 1) {
                    return readBit() === 1 ? 1 : -1;
                  }
                  const n2 = receive(length);
                  if (n2 >= 1 << length - 1) {
                    return n2;
                  }
                  return n2 + (-1 << length) + 1;
                }
                __name(receiveAndExtend, "receiveAndExtend");
                function decodeBaseline(component2, blockOffset) {
                  const t = decodeHuffman(component2.huffmanTableDC);
                  const diff = t === 0 ? 0 : receiveAndExtend(t);
                  component2.blockData[blockOffset] = component2.pred += diff;
                  let k2 = 1;
                  while (k2 < 64) {
                    const rs = decodeHuffman(component2.huffmanTableAC);
                    const s = rs & 15, r = rs >> 4;
                    if (s === 0) {
                      if (r < 15) {
                        break;
                      }
                      k2 += 16;
                      continue;
                    }
                    k2 += r;
                    const z = dctZigZag[k2];
                    component2.blockData[blockOffset + z] = receiveAndExtend(s);
                    k2++;
                  }
                }
                __name(decodeBaseline, "decodeBaseline");
                function decodeDCFirst(component2, blockOffset) {
                  const t = decodeHuffman(component2.huffmanTableDC);
                  const diff = t === 0 ? 0 : receiveAndExtend(t) << successive;
                  component2.blockData[blockOffset] = component2.pred += diff;
                }
                __name(decodeDCFirst, "decodeDCFirst");
                function decodeDCSuccessive(component2, blockOffset) {
                  component2.blockData[blockOffset] |= readBit() << successive;
                }
                __name(decodeDCSuccessive, "decodeDCSuccessive");
                let eobrun = 0;
                function decodeACFirst(component2, blockOffset) {
                  if (eobrun > 0) {
                    eobrun--;
                    return;
                  }
                  let k2 = spectralStart;
                  const e = spectralEnd;
                  while (k2 <= e) {
                    const rs = decodeHuffman(component2.huffmanTableAC);
                    const s = rs & 15, r = rs >> 4;
                    if (s === 0) {
                      if (r < 15) {
                        eobrun = receive(r) + (1 << r) - 1;
                        break;
                      }
                      k2 += 16;
                      continue;
                    }
                    k2 += r;
                    const z = dctZigZag[k2];
                    component2.blockData[blockOffset + z] = receiveAndExtend(s) * (1 << successive);
                    k2++;
                  }
                }
                __name(decodeACFirst, "decodeACFirst");
                let successiveACState = 0, successiveACNextValue;
                function decodeACSuccessive(component2, blockOffset) {
                  let k2 = spectralStart;
                  const e = spectralEnd;
                  let r = 0;
                  let s;
                  let rs;
                  while (k2 <= e) {
                    const offsetZ = blockOffset + dctZigZag[k2];
                    const sign = component2.blockData[offsetZ] < 0 ? -1 : 1;
                    switch (successiveACState) {
                      case 0:
                        rs = decodeHuffman(component2.huffmanTableAC);
                        s = rs & 15;
                        r = rs >> 4;
                        if (s === 0) {
                          if (r < 15) {
                            eobrun = receive(r) + (1 << r);
                            successiveACState = 4;
                          } else {
                            r = 16;
                            successiveACState = 1;
                          }
                        } else {
                          if (s !== 1) {
                            throw new JpegError("invalid ACn encoding");
                          }
                          successiveACNextValue = receiveAndExtend(s);
                          successiveACState = r ? 2 : 3;
                        }
                        continue;
                      case 1:
                      case 2:
                        if (component2.blockData[offsetZ]) {
                          component2.blockData[offsetZ] += sign * (readBit() << successive);
                        } else {
                          r--;
                          if (r === 0) {
                            successiveACState = successiveACState === 2 ? 3 : 0;
                          }
                        }
                        break;
                      case 3:
                        if (component2.blockData[offsetZ]) {
                          component2.blockData[offsetZ] += sign * (readBit() << successive);
                        } else {
                          component2.blockData[offsetZ] = successiveACNextValue << successive;
                          successiveACState = 0;
                        }
                        break;
                      case 4:
                        if (component2.blockData[offsetZ]) {
                          component2.blockData[offsetZ] += sign * (readBit() << successive);
                        }
                        break;
                    }
                    k2++;
                  }
                  if (successiveACState === 4) {
                    eobrun--;
                    if (eobrun === 0) {
                      successiveACState = 0;
                    }
                  }
                }
                __name(decodeACSuccessive, "decodeACSuccessive");
                let blockRow = 0;
                function decodeMcu(component2, decode, mcu2, row, col) {
                  const mcuRow = mcu2 / mcusPerLine | 0;
                  const mcuCol = mcu2 % mcusPerLine;
                  blockRow = mcuRow * component2.v + row;
                  const blockCol = mcuCol * component2.h + col;
                  const blockOffset = getBlockBufferOffset(component2, blockRow, blockCol);
                  decode(component2, blockOffset);
                }
                __name(decodeMcu, "decodeMcu");
                function decodeBlock(component2, decode, mcu2) {
                  blockRow = mcu2 / component2.blocksPerLine | 0;
                  const blockCol = mcu2 % component2.blocksPerLine;
                  const blockOffset = getBlockBufferOffset(component2, blockRow, blockCol);
                  decode(component2, blockOffset);
                }
                __name(decodeBlock, "decodeBlock");
                const componentsLength = components.length;
                let component, i, j, k, n;
                let decodeFn;
                if (progressive) {
                  if (spectralStart === 0) {
                    decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
                  } else {
                    decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
                  }
                } else {
                  decodeFn = decodeBaseline;
                }
                let mcu = 0, fileMarker;
                let mcuExpected;
                if (componentsLength === 1) {
                  mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
                } else {
                  mcuExpected = mcusPerLine * frame.mcusPerColumn;
                }
                let h, v;
                while (mcu <= mcuExpected) {
                  const mcuToRead = resetInterval ? Math.min(mcuExpected - mcu, resetInterval) : mcuExpected;
                  if (mcuToRead > 0) {
                    for (i = 0; i < componentsLength; i++) {
                      components[i].pred = 0;
                    }
                    eobrun = 0;
                    if (componentsLength === 1) {
                      component = components[0];
                      for (n = 0; n < mcuToRead; n++) {
                        decodeBlock(component, decodeFn, mcu);
                        mcu++;
                      }
                    } else {
                      for (n = 0; n < mcuToRead; n++) {
                        for (i = 0; i < componentsLength; i++) {
                          component = components[i];
                          h = component.h;
                          v = component.v;
                          for (j = 0; j < v; j++) {
                            for (k = 0; k < h; k++) {
                              decodeMcu(component, decodeFn, mcu, j, k);
                            }
                          }
                        }
                        mcu++;
                      }
                    }
                  }
                  bitsCount = 0;
                  fileMarker = findNextFileMarker(data, offset);
                  if (!fileMarker) {
                    break;
                  }
                  if (fileMarker.invalid) {
                    const partialMsg = mcuToRead > 0 ? "unexpected" : "excessive";
                    (0, _util.warn)(`decodeScan - ${partialMsg} MCU data, current marker is: ${fileMarker.invalid}`);
                    offset = fileMarker.offset;
                  }
                  if (fileMarker.marker >= 65488 && fileMarker.marker <= 65495) {
                    offset += 2;
                  } else {
                    break;
                  }
                }
                return offset - startOffset;
              }
              __name(decodeScan, "decodeScan");
              function quantizeAndInverse(component, blockBufferOffset, p) {
                const qt = component.quantizationTable, blockData = component.blockData;
                let v0, v1, v2, v3, v4, v5, v6, v7;
                let p0, p1, p2, p3, p4, p5, p6, p7;
                let t;
                if (!qt) {
                  throw new JpegError("missing required Quantization Table.");
                }
                for (let row = 0; row < 64; row += 8) {
                  p0 = blockData[blockBufferOffset + row];
                  p1 = blockData[blockBufferOffset + row + 1];
                  p2 = blockData[blockBufferOffset + row + 2];
                  p3 = blockData[blockBufferOffset + row + 3];
                  p4 = blockData[blockBufferOffset + row + 4];
                  p5 = blockData[blockBufferOffset + row + 5];
                  p6 = blockData[blockBufferOffset + row + 6];
                  p7 = blockData[blockBufferOffset + row + 7];
                  p0 *= qt[row];
                  if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {
                    t = dctSqrt2 * p0 + 512 >> 10;
                    p[row] = t;
                    p[row + 1] = t;
                    p[row + 2] = t;
                    p[row + 3] = t;
                    p[row + 4] = t;
                    p[row + 5] = t;
                    p[row + 6] = t;
                    p[row + 7] = t;
                    continue;
                  }
                  p1 *= qt[row + 1];
                  p2 *= qt[row + 2];
                  p3 *= qt[row + 3];
                  p4 *= qt[row + 4];
                  p5 *= qt[row + 5];
                  p6 *= qt[row + 6];
                  p7 *= qt[row + 7];
                  v0 = dctSqrt2 * p0 + 128 >> 8;
                  v1 = dctSqrt2 * p4 + 128 >> 8;
                  v2 = p2;
                  v3 = p6;
                  v4 = dctSqrt1d2 * (p1 - p7) + 128 >> 8;
                  v7 = dctSqrt1d2 * (p1 + p7) + 128 >> 8;
                  v5 = p3 << 4;
                  v6 = p5 << 4;
                  v0 = v0 + v1 + 1 >> 1;
                  v1 = v0 - v1;
                  t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;
                  v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;
                  v3 = t;
                  v4 = v4 + v6 + 1 >> 1;
                  v6 = v4 - v6;
                  v7 = v7 + v5 + 1 >> 1;
                  v5 = v7 - v5;
                  v0 = v0 + v3 + 1 >> 1;
                  v3 = v0 - v3;
                  v1 = v1 + v2 + 1 >> 1;
                  v2 = v1 - v2;
                  t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
                  v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
                  v7 = t;
                  t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
                  v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
                  v6 = t;
                  p[row] = v0 + v7;
                  p[row + 7] = v0 - v7;
                  p[row + 1] = v1 + v6;
                  p[row + 6] = v1 - v6;
                  p[row + 2] = v2 + v5;
                  p[row + 5] = v2 - v5;
                  p[row + 3] = v3 + v4;
                  p[row + 4] = v3 - v4;
                }
                for (let col = 0; col < 8; ++col) {
                  p0 = p[col];
                  p1 = p[col + 8];
                  p2 = p[col + 16];
                  p3 = p[col + 24];
                  p4 = p[col + 32];
                  p5 = p[col + 40];
                  p6 = p[col + 48];
                  p7 = p[col + 56];
                  if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {
                    t = dctSqrt2 * p0 + 8192 >> 14;
                    if (t < -2040) {
                      t = 0;
                    } else if (t >= 2024) {
                      t = 255;
                    } else {
                      t = t + 2056 >> 4;
                    }
                    blockData[blockBufferOffset + col] = t;
                    blockData[blockBufferOffset + col + 8] = t;
                    blockData[blockBufferOffset + col + 16] = t;
                    blockData[blockBufferOffset + col + 24] = t;
                    blockData[blockBufferOffset + col + 32] = t;
                    blockData[blockBufferOffset + col + 40] = t;
                    blockData[blockBufferOffset + col + 48] = t;
                    blockData[blockBufferOffset + col + 56] = t;
                    continue;
                  }
                  v0 = dctSqrt2 * p0 + 2048 >> 12;
                  v1 = dctSqrt2 * p4 + 2048 >> 12;
                  v2 = p2;
                  v3 = p6;
                  v4 = dctSqrt1d2 * (p1 - p7) + 2048 >> 12;
                  v7 = dctSqrt1d2 * (p1 + p7) + 2048 >> 12;
                  v5 = p3;
                  v6 = p5;
                  v0 = (v0 + v1 + 1 >> 1) + 4112;
                  v1 = v0 - v1;
                  t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
                  v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
                  v3 = t;
                  v4 = v4 + v6 + 1 >> 1;
                  v6 = v4 - v6;
                  v7 = v7 + v5 + 1 >> 1;
                  v5 = v7 - v5;
                  v0 = v0 + v3 + 1 >> 1;
                  v3 = v0 - v3;
                  v1 = v1 + v2 + 1 >> 1;
                  v2 = v1 - v2;
                  t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
                  v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
                  v7 = t;
                  t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
                  v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
                  v6 = t;
                  p0 = v0 + v7;
                  p7 = v0 - v7;
                  p1 = v1 + v6;
                  p6 = v1 - v6;
                  p2 = v2 + v5;
                  p5 = v2 - v5;
                  p3 = v3 + v4;
                  p4 = v3 - v4;
                  if (p0 < 16) {
                    p0 = 0;
                  } else if (p0 >= 4080) {
                    p0 = 255;
                  } else {
                    p0 >>= 4;
                  }
                  if (p1 < 16) {
                    p1 = 0;
                  } else if (p1 >= 4080) {
                    p1 = 255;
                  } else {
                    p1 >>= 4;
                  }
                  if (p2 < 16) {
                    p2 = 0;
                  } else if (p2 >= 4080) {
                    p2 = 255;
                  } else {
                    p2 >>= 4;
                  }
                  if (p3 < 16) {
                    p3 = 0;
                  } else if (p3 >= 4080) {
                    p3 = 255;
                  } else {
                    p3 >>= 4;
                  }
                  if (p4 < 16) {
                    p4 = 0;
                  } else if (p4 >= 4080) {
                    p4 = 255;
                  } else {
                    p4 >>= 4;
                  }
                  if (p5 < 16) {
                    p5 = 0;
                  } else if (p5 >= 4080) {
                    p5 = 255;
                  } else {
                    p5 >>= 4;
                  }
                  if (p6 < 16) {
                    p6 = 0;
                  } else if (p6 >= 4080) {
                    p6 = 255;
                  } else {
                    p6 >>= 4;
                  }
                  if (p7 < 16) {
                    p7 = 0;
                  } else if (p7 >= 4080) {
                    p7 = 255;
                  } else {
                    p7 >>= 4;
                  }
                  blockData[blockBufferOffset + col] = p0;
                  blockData[blockBufferOffset + col + 8] = p1;
                  blockData[blockBufferOffset + col + 16] = p2;
                  blockData[blockBufferOffset + col + 24] = p3;
                  blockData[blockBufferOffset + col + 32] = p4;
                  blockData[blockBufferOffset + col + 40] = p5;
                  blockData[blockBufferOffset + col + 48] = p6;
                  blockData[blockBufferOffset + col + 56] = p7;
                }
              }
              __name(quantizeAndInverse, "quantizeAndInverse");
              function buildComponentData(frame, component) {
                const blocksPerLine = component.blocksPerLine;
                const blocksPerColumn = component.blocksPerColumn;
                const computationBuffer = new Int16Array(64);
                for (let blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
                  for (let blockCol = 0; blockCol < blocksPerLine; blockCol++) {
                    const offset = getBlockBufferOffset(component, blockRow, blockCol);
                    quantizeAndInverse(component, offset, computationBuffer);
                  }
                }
                return component.blockData;
              }
              __name(buildComponentData, "buildComponentData");
              function findNextFileMarker(data, currentPos) {
                let startPos = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : currentPos;
                const maxPos = data.length - 1;
                let newPos = startPos < currentPos ? startPos : currentPos;
                if (currentPos >= maxPos) {
                  return null;
                }
                const currentMarker = (0, _core_utils.readUint16)(data, currentPos);
                if (currentMarker >= 65472 && currentMarker <= 65534) {
                  return {
                    invalid: null,
                    marker: currentMarker,
                    offset: currentPos
                  };
                }
                let newMarker = (0, _core_utils.readUint16)(data, newPos);
                while (!(newMarker >= 65472 && newMarker <= 65534)) {
                  if (++newPos >= maxPos) {
                    return null;
                  }
                  newMarker = (0, _core_utils.readUint16)(data, newPos);
                }
                return {
                  invalid: currentMarker.toString(16),
                  marker: newMarker,
                  offset: newPos
                };
              }
              __name(findNextFileMarker, "findNextFileMarker");
              const _JpegImage = class _JpegImage {
                constructor() {
                  let {
                    decodeTransform = null,
                    colorTransform = -1
                  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  this._decodeTransform = decodeTransform;
                  this._colorTransform = colorTransform;
                }
                parse(data) {
                  let {
                    dnlScanLines = null
                  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                  function readDataBlock() {
                    const length = (0, _core_utils.readUint16)(data, offset);
                    offset += 2;
                    let endOffset = offset + length - 2;
                    const fileMarker2 = findNextFileMarker(data, endOffset, offset);
                    if (fileMarker2 && fileMarker2.invalid) {
                      (0, _util.warn)("readDataBlock - incorrect length, current marker is: " + fileMarker2.invalid);
                      endOffset = fileMarker2.offset;
                    }
                    const array = data.subarray(offset, endOffset);
                    offset += array.length;
                    return array;
                  }
                  __name(readDataBlock, "readDataBlock");
                  function prepareComponents(frame2) {
                    const mcusPerLine = Math.ceil(frame2.samplesPerLine / 8 / frame2.maxH);
                    const mcusPerColumn = Math.ceil(frame2.scanLines / 8 / frame2.maxV);
                    for (let i = 0, ii = frame2.components.length; i < ii; i++) {
                      const component = frame2.components[i];
                      const blocksPerLine = Math.ceil(Math.ceil(frame2.samplesPerLine / 8) * component.h / frame2.maxH);
                      const blocksPerColumn = Math.ceil(Math.ceil(frame2.scanLines / 8) * component.v / frame2.maxV);
                      const blocksPerLineForMcu = mcusPerLine * component.h;
                      const blocksPerColumnForMcu = mcusPerColumn * component.v;
                      const blocksBufferSize = 64 * blocksPerColumnForMcu * (blocksPerLineForMcu + 1);
                      component.blockData = new Int16Array(blocksBufferSize);
                      component.blocksPerLine = blocksPerLine;
                      component.blocksPerColumn = blocksPerColumn;
                    }
                    frame2.mcusPerLine = mcusPerLine;
                    frame2.mcusPerColumn = mcusPerColumn;
                  }
                  __name(prepareComponents, "prepareComponents");
                  let offset = 0;
                  let jfif = null;
                  let adobe = null;
                  let frame, resetInterval;
                  let numSOSMarkers = 0;
                  const quantizationTables = [];
                  const huffmanTablesAC = [], huffmanTablesDC = [];
                  let fileMarker = (0, _core_utils.readUint16)(data, offset);
                  offset += 2;
                  if (fileMarker !== 65496) {
                    throw new JpegError("SOI not found");
                  }
                  fileMarker = (0, _core_utils.readUint16)(data, offset);
                  offset += 2;
                  markerLoop:
                    while (fileMarker !== 65497) {
                      let i, j, l;
                      switch (fileMarker) {
                        case 65504:
                        case 65505:
                        case 65506:
                        case 65507:
                        case 65508:
                        case 65509:
                        case 65510:
                        case 65511:
                        case 65512:
                        case 65513:
                        case 65514:
                        case 65515:
                        case 65516:
                        case 65517:
                        case 65518:
                        case 65519:
                        case 65534:
                          const appData = readDataBlock();
                          if (fileMarker === 65504) {
                            if (appData[0] === 74 && appData[1] === 70 && appData[2] === 73 && appData[3] === 70 && appData[4] === 0) {
                              jfif = {
                                version: {
                                  major: appData[5],
                                  minor: appData[6]
                                },
                                densityUnits: appData[7],
                                xDensity: appData[8] << 8 | appData[9],
                                yDensity: appData[10] << 8 | appData[11],
                                thumbWidth: appData[12],
                                thumbHeight: appData[13],
                                thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                              };
                            }
                          }
                          if (fileMarker === 65518) {
                            if (appData[0] === 65 && appData[1] === 100 && appData[2] === 111 && appData[3] === 98 && appData[4] === 101) {
                              adobe = {
                                version: appData[5] << 8 | appData[6],
                                flags0: appData[7] << 8 | appData[8],
                                flags1: appData[9] << 8 | appData[10],
                                transformCode: appData[11]
                              };
                            }
                          }
                          break;
                        case 65499:
                          const quantizationTablesLength = (0, _core_utils.readUint16)(data, offset);
                          offset += 2;
                          const quantizationTablesEnd = quantizationTablesLength + offset - 2;
                          let z;
                          while (offset < quantizationTablesEnd) {
                            const quantizationTableSpec = data[offset++];
                            const tableData = new Uint16Array(64);
                            if (quantizationTableSpec >> 4 === 0) {
                              for (j = 0; j < 64; j++) {
                                z = dctZigZag[j];
                                tableData[z] = data[offset++];
                              }
                            } else if (quantizationTableSpec >> 4 === 1) {
                              for (j = 0; j < 64; j++) {
                                z = dctZigZag[j];
                                tableData[z] = (0, _core_utils.readUint16)(data, offset);
                                offset += 2;
                              }
                            } else {
                              throw new JpegError("DQT - invalid table spec");
                            }
                            quantizationTables[quantizationTableSpec & 15] = tableData;
                          }
                          break;
                        case 65472:
                        case 65473:
                        case 65474:
                          if (frame) {
                            throw new JpegError("Only single frame JPEGs supported");
                          }
                          offset += 2;
                          frame = {};
                          frame.extended = fileMarker === 65473;
                          frame.progressive = fileMarker === 65474;
                          frame.precision = data[offset++];
                          const sofScanLines = (0, _core_utils.readUint16)(data, offset);
                          offset += 2;
                          frame.scanLines = dnlScanLines || sofScanLines;
                          frame.samplesPerLine = (0, _core_utils.readUint16)(data, offset);
                          offset += 2;
                          frame.components = [];
                          frame.componentIds = {};
                          const componentsCount = data[offset++];
                          let maxH = 0, maxV = 0;
                          for (i = 0; i < componentsCount; i++) {
                            const componentId = data[offset];
                            const h = data[offset + 1] >> 4;
                            const v = data[offset + 1] & 15;
                            if (maxH < h) {
                              maxH = h;
                            }
                            if (maxV < v) {
                              maxV = v;
                            }
                            const qId = data[offset + 2];
                            l = frame.components.push({
                              h,
                              v,
                              quantizationId: qId,
                              quantizationTable: null
                            });
                            frame.componentIds[componentId] = l - 1;
                            offset += 3;
                          }
                          frame.maxH = maxH;
                          frame.maxV = maxV;
                          prepareComponents(frame);
                          break;
                        case 65476:
                          const huffmanLength = (0, _core_utils.readUint16)(data, offset);
                          offset += 2;
                          for (i = 2; i < huffmanLength; ) {
                            const huffmanTableSpec = data[offset++];
                            const codeLengths = new Uint8Array(16);
                            let codeLengthSum = 0;
                            for (j = 0; j < 16; j++, offset++) {
                              codeLengthSum += codeLengths[j] = data[offset];
                            }
                            const huffmanValues = new Uint8Array(codeLengthSum);
                            for (j = 0; j < codeLengthSum; j++, offset++) {
                              huffmanValues[j] = data[offset];
                            }
                            i += 17 + codeLengthSum;
                            (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
                          }
                          break;
                        case 65501:
                          offset += 2;
                          resetInterval = (0, _core_utils.readUint16)(data, offset);
                          offset += 2;
                          break;
                        case 65498:
                          const parseDNLMarker = ++numSOSMarkers === 1 && !dnlScanLines;
                          offset += 2;
                          const selectorsCount = data[offset++], components = [];
                          for (i = 0; i < selectorsCount; i++) {
                            const index = data[offset++];
                            const componentIndex = frame.componentIds[index];
                            const component = frame.components[componentIndex];
                            component.index = index;
                            const tableSpec = data[offset++];
                            component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
                            component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
                            components.push(component);
                          }
                          const spectralStart = data[offset++], spectralEnd = data[offset++], successiveApproximation = data[offset++];
                          try {
                            const processed = decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15, parseDNLMarker);
                            offset += processed;
                          } catch (ex) {
                            if (ex instanceof DNLMarkerError) {
                              (0, _util.warn)(`${ex.message} -- attempting to re-parse the JPEG image.`);
                              return this.parse(data, {
                                dnlScanLines: ex.scanLines
                              });
                            } else if (ex instanceof EOIMarkerError) {
                              (0, _util.warn)(`${ex.message} -- ignoring the rest of the image data.`);
                              break markerLoop;
                            }
                            throw ex;
                          }
                          break;
                        case 65500:
                          offset += 4;
                          break;
                        case 65535:
                          if (data[offset] !== 255) {
                            offset--;
                          }
                          break;
                        default:
                          const nextFileMarker = findNextFileMarker(data, offset - 2, offset - 3);
                          if (nextFileMarker && nextFileMarker.invalid) {
                            (0, _util.warn)("JpegImage.parse - unexpected data, current marker is: " + nextFileMarker.invalid);
                            offset = nextFileMarker.offset;
                            break;
                          }
                          if (!nextFileMarker || offset >= data.length - 1) {
                            (0, _util.warn)("JpegImage.parse - reached the end of the image data without finding an EOI marker (0xFFD9).");
                            break markerLoop;
                          }
                          throw new JpegError("JpegImage.parse - unknown marker: " + fileMarker.toString(16));
                      }
                      fileMarker = (0, _core_utils.readUint16)(data, offset);
                      offset += 2;
                    }
                  this.width = frame.samplesPerLine;
                  this.height = frame.scanLines;
                  this.jfif = jfif;
                  this.adobe = adobe;
                  this.components = [];
                  for (let i = 0, ii = frame.components.length; i < ii; i++) {
                    const component = frame.components[i];
                    const quantizationTable = quantizationTables[component.quantizationId];
                    if (quantizationTable) {
                      component.quantizationTable = quantizationTable;
                    }
                    this.components.push({
                      index: component.index,
                      output: buildComponentData(frame, component),
                      scaleX: component.h / frame.maxH,
                      scaleY: component.v / frame.maxV,
                      blocksPerLine: component.blocksPerLine,
                      blocksPerColumn: component.blocksPerColumn
                    });
                  }
                  this.numComponents = this.components.length;
                  return void 0;
                }
                _getLinearizedBlockData(width, height) {
                  let isSourcePDF = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                  const scaleX = this.width / width, scaleY = this.height / height;
                  let component, componentScaleX, componentScaleY, blocksPerScanline;
                  let x, y, i, j, k;
                  let index;
                  let offset = 0;
                  let output;
                  const numComponents = this.components.length;
                  const dataLength = width * height * numComponents;
                  const data = new Uint8ClampedArray(dataLength);
                  const xScaleBlockOffset = new Uint32Array(width);
                  const mask3LSB = 4294967288;
                  let lastComponentScaleX;
                  for (i = 0; i < numComponents; i++) {
                    component = this.components[i];
                    componentScaleX = component.scaleX * scaleX;
                    componentScaleY = component.scaleY * scaleY;
                    offset = i;
                    output = component.output;
                    blocksPerScanline = component.blocksPerLine + 1 << 3;
                    if (componentScaleX !== lastComponentScaleX) {
                      for (x = 0; x < width; x++) {
                        j = 0 | x * componentScaleX;
                        xScaleBlockOffset[x] = (j & mask3LSB) << 3 | j & 7;
                      }
                      lastComponentScaleX = componentScaleX;
                    }
                    for (y = 0; y < height; y++) {
                      j = 0 | y * componentScaleY;
                      index = blocksPerScanline * (j & mask3LSB) | (j & 7) << 3;
                      for (x = 0; x < width; x++) {
                        data[offset] = output[index + xScaleBlockOffset[x]];
                        offset += numComponents;
                      }
                    }
                  }
                  let transform = this._decodeTransform;
                  if (!isSourcePDF && numComponents === 4 && !transform) {
                    transform = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255]);
                  }
                  if (transform) {
                    for (i = 0; i < dataLength; ) {
                      for (j = 0, k = 0; j < numComponents; j++, i++, k += 2) {
                        data[i] = (data[i] * transform[k] >> 8) + transform[k + 1];
                      }
                    }
                  }
                  return data;
                }
                get _isColorConversionNeeded() {
                  if (this.adobe) {
                    return !!this.adobe.transformCode;
                  }
                  if (this.numComponents === 3) {
                    if (this._colorTransform === 0) {
                      return false;
                    } else if (this.components[0].index === 82 && this.components[1].index === 71 && this.components[2].index === 66) {
                      return false;
                    }
                    return true;
                  }
                  if (this._colorTransform === 1) {
                    return true;
                  }
                  return false;
                }
                _convertYccToRgb(data) {
                  let Y, Cb, Cr;
                  for (let i = 0, length = data.length; i < length; i += 3) {
                    Y = data[i];
                    Cb = data[i + 1];
                    Cr = data[i + 2];
                    data[i] = Y - 179.456 + 1.402 * Cr;
                    data[i + 1] = Y + 135.459 - 0.344 * Cb - 0.714 * Cr;
                    data[i + 2] = Y - 226.816 + 1.772 * Cb;
                  }
                  return data;
                }
                _convertYcckToRgb(data) {
                  let Y, Cb, Cr, k;
                  let offset = 0;
                  for (let i = 0, length = data.length; i < length; i += 4) {
                    Y = data[i];
                    Cb = data[i + 1];
                    Cr = data[i + 2];
                    k = data[i + 3];
                    data[offset++] = -122.67195406894 + Cb * (-660635669420364e-19 * Cb + 437130475926232e-18 * Cr - 54080610064599e-18 * Y + 48449797120281e-17 * k - 0.154362151871126) + Cr * (-957964378445773e-18 * Cr + 817076911346625e-18 * Y - 0.00477271405408747 * k + 1.53380253221734) + Y * (961250184130688e-18 * Y - 0.00266257332283933 * k + 0.48357088451265) + k * (-336197177618394e-18 * k + 0.484791561490776);
                    data[offset++] = 107.268039397724 + Cb * (219927104525741e-19 * Cb - 640992018297945e-18 * Cr + 659397001245577e-18 * Y + 426105652938837e-18 * k - 0.176491792462875) + Cr * (-778269941513683e-18 * Cr + 0.00130872261408275 * Y + 770482631801132e-18 * k - 0.151051492775562) + Y * (0.00126935368114843 * Y - 0.00265090189010898 * k + 0.25802910206845) + k * (-318913117588328e-18 * k - 0.213742400323665);
                    data[offset++] = -20.810012546947 + Cb * (-570115196973677e-18 * Cb - 263409051004589e-19 * Cr + 0.0020741088115012 * Y - 0.00288260236853442 * k + 0.814272968359295) + Cr * (-153496057440975e-19 * Cr - 132689043961446e-18 * Y + 560833691242812e-18 * k - 0.195152027534049) + Y * (0.00174418132927582 * Y - 0.00255243321439347 * k + 0.116935020465145) + k * (-343531996510555e-18 * k + 0.24165260232407);
                  }
                  return data.subarray(0, offset);
                }
                _convertYcckToCmyk(data) {
                  let Y, Cb, Cr;
                  for (let i = 0, length = data.length; i < length; i += 4) {
                    Y = data[i];
                    Cb = data[i + 1];
                    Cr = data[i + 2];
                    data[i] = 434.456 - Y - 1.402 * Cr;
                    data[i + 1] = 119.541 - Y + 0.344 * Cb + 0.714 * Cr;
                    data[i + 2] = 481.816 - Y - 1.772 * Cb;
                  }
                  return data;
                }
                _convertCmykToRgb(data) {
                  let c, m, y, k;
                  let offset = 0;
                  for (let i = 0, length = data.length; i < length; i += 4) {
                    c = data[i];
                    m = data[i + 1];
                    y = data[i + 2];
                    k = data[i + 3];
                    data[offset++] = 255 + c * (-6747147073602441e-20 * c + 8379262121013727e-19 * m + 2894718188643294e-19 * y + 0.003264231057537806 * k - 1.1185611867203937) + m * (26374107616089405e-21 * m - 8626949158638572e-20 * y - 2748769067499491e-19 * k - 0.02155688794978967) + y * (-3878099212869363e-20 * y - 3267808279485286e-19 * k + 0.0686742238595345) - k * (3361971776183937e-19 * k + 0.7430659151342254);
                    data[offset++] = 255 + c * (13596372813588848e-20 * c + 924537132573585e-18 * m + 10567359618683593e-20 * y + 4791864687436512e-19 * k - 0.3109689587515875) + m * (-23545346108370344e-20 * m + 2702845253534714e-19 * y + 0.0020200308977307156 * k - 0.7488052167015494) + y * (6834815998235662e-20 * y + 15168452363460973e-20 * k - 0.09751927774728933) - k * (3189131175883281e-19 * k + 0.7364883807733168);
                    data[offset++] = 255 + c * (13598650411385307e-21 * c + 12423956175490851e-20 * m + 4751985097583589e-19 * y - 36729317476630422e-22 * k - 0.05562186980264034) + m * (16141380598724676e-20 * m + 9692239130725186e-19 * y + 7782692450036253e-19 * k - 0.44015232367526463) + y * (5068882914068769e-22 * y + 0.0017778369011375071 * k - 0.7591454649749609) - k * (3435319965105553e-19 * k + 0.7063770186160144);
                  }
                  return data.subarray(0, offset);
                }
                getData(_ref) {
                  let {
                    width,
                    height,
                    forceRGB = false,
                    isSourcePDF = false
                  } = _ref;
                  if (this.numComponents > 4) {
                    throw new JpegError("Unsupported color mode");
                  }
                  const data = this._getLinearizedBlockData(width, height, isSourcePDF);
                  if (this.numComponents === 1 && forceRGB) {
                    const dataLength = data.length;
                    const rgbData = new Uint8ClampedArray(dataLength * 3);
                    let offset = 0;
                    for (let i = 0; i < dataLength; i++) {
                      const grayColor = data[i];
                      rgbData[offset++] = grayColor;
                      rgbData[offset++] = grayColor;
                      rgbData[offset++] = grayColor;
                    }
                    return rgbData;
                  } else if (this.numComponents === 3 && this._isColorConversionNeeded) {
                    return this._convertYccToRgb(data);
                  } else if (this.numComponents === 4) {
                    if (this._isColorConversionNeeded) {
                      if (forceRGB) {
                        return this._convertYcckToRgb(data);
                      }
                      return this._convertYcckToCmyk(data);
                    } else if (forceRGB) {
                      return this._convertCmykToRgb(data);
                    }
                  }
                  return data;
                }
              };
              __name(_JpegImage, "JpegImage");
              let JpegImage = _JpegImage;
              exports2.JpegImage = JpegImage;
            },
            /* 154 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.JpxStream = void 0;
              var _decode_stream = __w_pdfjs_require__2(144);
              var _jpx = __w_pdfjs_require__2(155);
              var _util = __w_pdfjs_require__2(2);
              const _JpxStream = class _JpxStream extends _decode_stream.DecodeStream {
                constructor(stream, maybeLength, params) {
                  super(maybeLength);
                  this.stream = stream;
                  this.dict = stream.dict;
                  this.maybeLength = maybeLength;
                  this.params = params;
                }
                get bytes() {
                  return (0, _util.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
                }
                ensureBuffer(requested) {
                }
                readBlock() {
                  if (this.eof) {
                    return;
                  }
                  const jpxImage = new _jpx.JpxImage();
                  jpxImage.parse(this.bytes);
                  const width = jpxImage.width;
                  const height = jpxImage.height;
                  const componentsCount = jpxImage.componentsCount;
                  const tileCount = jpxImage.tiles.length;
                  if (tileCount === 1) {
                    this.buffer = jpxImage.tiles[0].items;
                  } else {
                    const data = new Uint8ClampedArray(width * height * componentsCount);
                    for (let k = 0; k < tileCount; k++) {
                      const tileComponents = jpxImage.tiles[k];
                      const tileWidth = tileComponents.width;
                      const tileHeight = tileComponents.height;
                      const tileLeft = tileComponents.left;
                      const tileTop = tileComponents.top;
                      const src = tileComponents.items;
                      let srcPosition = 0;
                      let dataPosition = (width * tileTop + tileLeft) * componentsCount;
                      const imgRowSize = width * componentsCount;
                      const tileRowSize = tileWidth * componentsCount;
                      for (let j = 0; j < tileHeight; j++) {
                        const rowBytes = src.subarray(srcPosition, srcPosition + tileRowSize);
                        data.set(rowBytes, dataPosition);
                        srcPosition += tileRowSize;
                        dataPosition += imgRowSize;
                      }
                    }
                    this.buffer = data;
                  }
                  this.bufferLength = this.buffer.length;
                  this.eof = true;
                }
              };
              __name(_JpxStream, "JpxStream");
              let JpxStream = _JpxStream;
              exports2.JpxStream = JpxStream;
            },
            /* 155 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.JpxImage = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _core_utils = __w_pdfjs_require__2(131);
              var _arithmetic_decoder = __w_pdfjs_require__2(151);
              const _JpxError = class _JpxError extends _util.BaseException {
                constructor(msg) {
                  super(`JPX error: ${msg}`, "JpxError");
                }
              };
              __name(_JpxError, "JpxError");
              let JpxError = _JpxError;
              const SubbandsGainLog2 = {
                LL: 0,
                LH: 1,
                HL: 1,
                HH: 2
              };
              const _JpxImage = class _JpxImage {
                constructor() {
                  this.failOnCorruptedImage = false;
                }
                parse(data) {
                  const head = (0, _core_utils.readUint16)(data, 0);
                  if (head === 65359) {
                    this.parseCodestream(data, 0, data.length);
                    return;
                  }
                  const length = data.length;
                  let position = 0;
                  while (position < length) {
                    let headerSize = 8;
                    let lbox = (0, _core_utils.readUint32)(data, position);
                    const tbox = (0, _core_utils.readUint32)(data, position + 4);
                    position += headerSize;
                    if (lbox === 1) {
                      lbox = (0, _core_utils.readUint32)(data, position) * 4294967296 + (0, _core_utils.readUint32)(data, position + 4);
                      position += 8;
                      headerSize += 8;
                    }
                    if (lbox === 0) {
                      lbox = length - position + headerSize;
                    }
                    if (lbox < headerSize) {
                      throw new JpxError("Invalid box field size");
                    }
                    const dataLength = lbox - headerSize;
                    let jumpDataLength = true;
                    switch (tbox) {
                      case 1785737832:
                        jumpDataLength = false;
                        break;
                      case 1668246642:
                        const method = data[position];
                        if (method === 1) {
                          const colorspace = (0, _core_utils.readUint32)(data, position + 3);
                          switch (colorspace) {
                            case 16:
                            case 17:
                            case 18:
                              break;
                            default:
                              (0, _util.warn)("Unknown colorspace " + colorspace);
                              break;
                          }
                        } else if (method === 2) {
                          (0, _util.info)("ICC profile not supported");
                        }
                        break;
                      case 1785737827:
                        this.parseCodestream(data, position, position + dataLength);
                        break;
                      case 1783636e3:
                        if ((0, _core_utils.readUint32)(data, position) !== 218793738) {
                          (0, _util.warn)("Invalid JP2 signature");
                        }
                        break;
                      case 1783634458:
                      case 1718909296:
                      case 1920099697:
                      case 1919251232:
                      case 1768449138:
                        break;
                      default:
                        const headerType = String.fromCharCode(tbox >> 24 & 255, tbox >> 16 & 255, tbox >> 8 & 255, tbox & 255);
                        (0, _util.warn)(`Unsupported header type ${tbox} (${headerType}).`);
                        break;
                    }
                    if (jumpDataLength) {
                      position += dataLength;
                    }
                  }
                }
                parseImageProperties(stream) {
                  let newByte = stream.getByte();
                  while (newByte >= 0) {
                    const oldByte = newByte;
                    newByte = stream.getByte();
                    const code = oldByte << 8 | newByte;
                    if (code === 65361) {
                      stream.skip(4);
                      const Xsiz = stream.getInt32() >>> 0;
                      const Ysiz = stream.getInt32() >>> 0;
                      const XOsiz = stream.getInt32() >>> 0;
                      const YOsiz = stream.getInt32() >>> 0;
                      stream.skip(16);
                      const Csiz = stream.getUint16();
                      this.width = Xsiz - XOsiz;
                      this.height = Ysiz - YOsiz;
                      this.componentsCount = Csiz;
                      this.bitsPerComponent = 8;
                      return;
                    }
                  }
                  throw new JpxError("No size marker found in JPX stream");
                }
                parseCodestream(data, start, end) {
                  const context = {};
                  let doNotRecover = false;
                  try {
                    let position = start;
                    while (position + 1 < end) {
                      const code = (0, _core_utils.readUint16)(data, position);
                      position += 2;
                      let length = 0, j, sqcd, spqcds, spqcdSize, scalarExpounded, tile;
                      switch (code) {
                        case 65359:
                          context.mainHeader = true;
                          break;
                        case 65497:
                          break;
                        case 65361:
                          length = (0, _core_utils.readUint16)(data, position);
                          const siz = {};
                          siz.Xsiz = (0, _core_utils.readUint32)(data, position + 4);
                          siz.Ysiz = (0, _core_utils.readUint32)(data, position + 8);
                          siz.XOsiz = (0, _core_utils.readUint32)(data, position + 12);
                          siz.YOsiz = (0, _core_utils.readUint32)(data, position + 16);
                          siz.XTsiz = (0, _core_utils.readUint32)(data, position + 20);
                          siz.YTsiz = (0, _core_utils.readUint32)(data, position + 24);
                          siz.XTOsiz = (0, _core_utils.readUint32)(data, position + 28);
                          siz.YTOsiz = (0, _core_utils.readUint32)(data, position + 32);
                          const componentsCount = (0, _core_utils.readUint16)(data, position + 36);
                          siz.Csiz = componentsCount;
                          const components = [];
                          j = position + 38;
                          for (let i = 0; i < componentsCount; i++) {
                            const component = {
                              precision: (data[j] & 127) + 1,
                              isSigned: !!(data[j] & 128),
                              XRsiz: data[j + 1],
                              YRsiz: data[j + 2]
                            };
                            j += 3;
                            calculateComponentDimensions(component, siz);
                            components.push(component);
                          }
                          context.SIZ = siz;
                          context.components = components;
                          calculateTileGrids(context, components);
                          context.QCC = [];
                          context.COC = [];
                          break;
                        case 65372:
                          length = (0, _core_utils.readUint16)(data, position);
                          const qcd = {};
                          j = position + 2;
                          sqcd = data[j++];
                          switch (sqcd & 31) {
                            case 0:
                              spqcdSize = 8;
                              scalarExpounded = true;
                              break;
                            case 1:
                              spqcdSize = 16;
                              scalarExpounded = false;
                              break;
                            case 2:
                              spqcdSize = 16;
                              scalarExpounded = true;
                              break;
                            default:
                              throw new Error("Invalid SQcd value " + sqcd);
                          }
                          qcd.noQuantization = spqcdSize === 8;
                          qcd.scalarExpounded = scalarExpounded;
                          qcd.guardBits = sqcd >> 5;
                          spqcds = [];
                          while (j < length + position) {
                            const spqcd = {};
                            if (spqcdSize === 8) {
                              spqcd.epsilon = data[j++] >> 3;
                              spqcd.mu = 0;
                            } else {
                              spqcd.epsilon = data[j] >> 3;
                              spqcd.mu = (data[j] & 7) << 8 | data[j + 1];
                              j += 2;
                            }
                            spqcds.push(spqcd);
                          }
                          qcd.SPqcds = spqcds;
                          if (context.mainHeader) {
                            context.QCD = qcd;
                          } else {
                            context.currentTile.QCD = qcd;
                            context.currentTile.QCC = [];
                          }
                          break;
                        case 65373:
                          length = (0, _core_utils.readUint16)(data, position);
                          const qcc = {};
                          j = position + 2;
                          let cqcc;
                          if (context.SIZ.Csiz < 257) {
                            cqcc = data[j++];
                          } else {
                            cqcc = (0, _core_utils.readUint16)(data, j);
                            j += 2;
                          }
                          sqcd = data[j++];
                          switch (sqcd & 31) {
                            case 0:
                              spqcdSize = 8;
                              scalarExpounded = true;
                              break;
                            case 1:
                              spqcdSize = 16;
                              scalarExpounded = false;
                              break;
                            case 2:
                              spqcdSize = 16;
                              scalarExpounded = true;
                              break;
                            default:
                              throw new Error("Invalid SQcd value " + sqcd);
                          }
                          qcc.noQuantization = spqcdSize === 8;
                          qcc.scalarExpounded = scalarExpounded;
                          qcc.guardBits = sqcd >> 5;
                          spqcds = [];
                          while (j < length + position) {
                            const spqcd = {};
                            if (spqcdSize === 8) {
                              spqcd.epsilon = data[j++] >> 3;
                              spqcd.mu = 0;
                            } else {
                              spqcd.epsilon = data[j] >> 3;
                              spqcd.mu = (data[j] & 7) << 8 | data[j + 1];
                              j += 2;
                            }
                            spqcds.push(spqcd);
                          }
                          qcc.SPqcds = spqcds;
                          if (context.mainHeader) {
                            context.QCC[cqcc] = qcc;
                          } else {
                            context.currentTile.QCC[cqcc] = qcc;
                          }
                          break;
                        case 65362:
                          length = (0, _core_utils.readUint16)(data, position);
                          const cod = {};
                          j = position + 2;
                          const scod = data[j++];
                          cod.entropyCoderWithCustomPrecincts = !!(scod & 1);
                          cod.sopMarkerUsed = !!(scod & 2);
                          cod.ephMarkerUsed = !!(scod & 4);
                          cod.progressionOrder = data[j++];
                          cod.layersCount = (0, _core_utils.readUint16)(data, j);
                          j += 2;
                          cod.multipleComponentTransform = data[j++];
                          cod.decompositionLevelsCount = data[j++];
                          cod.xcb = (data[j++] & 15) + 2;
                          cod.ycb = (data[j++] & 15) + 2;
                          const blockStyle = data[j++];
                          cod.selectiveArithmeticCodingBypass = !!(blockStyle & 1);
                          cod.resetContextProbabilities = !!(blockStyle & 2);
                          cod.terminationOnEachCodingPass = !!(blockStyle & 4);
                          cod.verticallyStripe = !!(blockStyle & 8);
                          cod.predictableTermination = !!(blockStyle & 16);
                          cod.segmentationSymbolUsed = !!(blockStyle & 32);
                          cod.reversibleTransformation = data[j++];
                          if (cod.entropyCoderWithCustomPrecincts) {
                            const precinctsSizes = [];
                            while (j < length + position) {
                              const precinctsSize = data[j++];
                              precinctsSizes.push({
                                PPx: precinctsSize & 15,
                                PPy: precinctsSize >> 4
                              });
                            }
                            cod.precinctsSizes = precinctsSizes;
                          }
                          const unsupported = [];
                          if (cod.selectiveArithmeticCodingBypass) {
                            unsupported.push("selectiveArithmeticCodingBypass");
                          }
                          if (cod.terminationOnEachCodingPass) {
                            unsupported.push("terminationOnEachCodingPass");
                          }
                          if (cod.verticallyStripe) {
                            unsupported.push("verticallyStripe");
                          }
                          if (cod.predictableTermination) {
                            unsupported.push("predictableTermination");
                          }
                          if (unsupported.length > 0) {
                            doNotRecover = true;
                            (0, _util.warn)(`JPX: Unsupported COD options (${unsupported.join(", ")}).`);
                          }
                          if (context.mainHeader) {
                            context.COD = cod;
                          } else {
                            context.currentTile.COD = cod;
                            context.currentTile.COC = [];
                          }
                          break;
                        case 65424:
                          length = (0, _core_utils.readUint16)(data, position);
                          tile = {};
                          tile.index = (0, _core_utils.readUint16)(data, position + 2);
                          tile.length = (0, _core_utils.readUint32)(data, position + 4);
                          tile.dataEnd = tile.length + position - 2;
                          tile.partIndex = data[position + 8];
                          tile.partsCount = data[position + 9];
                          context.mainHeader = false;
                          if (tile.partIndex === 0) {
                            tile.COD = context.COD;
                            tile.COC = context.COC.slice(0);
                            tile.QCD = context.QCD;
                            tile.QCC = context.QCC.slice(0);
                          }
                          context.currentTile = tile;
                          break;
                        case 65427:
                          tile = context.currentTile;
                          if (tile.partIndex === 0) {
                            initializeTile(context, tile.index);
                            buildPackets(context);
                          }
                          length = tile.dataEnd - position;
                          parseTilePackets(context, data, position, length);
                          break;
                        case 65363:
                          (0, _util.warn)("JPX: Codestream code 0xFF53 (COC) is not implemented.");
                        case 65365:
                        case 65367:
                        case 65368:
                        case 65380:
                          length = (0, _core_utils.readUint16)(data, position);
                          break;
                        default:
                          throw new Error("Unknown codestream code: " + code.toString(16));
                      }
                      position += length;
                    }
                  } catch (e) {
                    if (doNotRecover || this.failOnCorruptedImage) {
                      throw new JpxError(e.message);
                    } else {
                      (0, _util.warn)(`JPX: Trying to recover from: "${e.message}".`);
                    }
                  }
                  this.tiles = transformComponents(context);
                  this.width = context.SIZ.Xsiz - context.SIZ.XOsiz;
                  this.height = context.SIZ.Ysiz - context.SIZ.YOsiz;
                  this.componentsCount = context.SIZ.Csiz;
                }
              };
              __name(_JpxImage, "JpxImage");
              let JpxImage = _JpxImage;
              exports2.JpxImage = JpxImage;
              function calculateComponentDimensions(component, siz) {
                component.x0 = Math.ceil(siz.XOsiz / component.XRsiz);
                component.x1 = Math.ceil(siz.Xsiz / component.XRsiz);
                component.y0 = Math.ceil(siz.YOsiz / component.YRsiz);
                component.y1 = Math.ceil(siz.Ysiz / component.YRsiz);
                component.width = component.x1 - component.x0;
                component.height = component.y1 - component.y0;
              }
              __name(calculateComponentDimensions, "calculateComponentDimensions");
              function calculateTileGrids(context, components) {
                const siz = context.SIZ;
                const tiles = [];
                let tile;
                const numXtiles = Math.ceil((siz.Xsiz - siz.XTOsiz) / siz.XTsiz);
                const numYtiles = Math.ceil((siz.Ysiz - siz.YTOsiz) / siz.YTsiz);
                for (let q = 0; q < numYtiles; q++) {
                  for (let p = 0; p < numXtiles; p++) {
                    tile = {};
                    tile.tx0 = Math.max(siz.XTOsiz + p * siz.XTsiz, siz.XOsiz);
                    tile.ty0 = Math.max(siz.YTOsiz + q * siz.YTsiz, siz.YOsiz);
                    tile.tx1 = Math.min(siz.XTOsiz + (p + 1) * siz.XTsiz, siz.Xsiz);
                    tile.ty1 = Math.min(siz.YTOsiz + (q + 1) * siz.YTsiz, siz.Ysiz);
                    tile.width = tile.tx1 - tile.tx0;
                    tile.height = tile.ty1 - tile.ty0;
                    tile.components = [];
                    tiles.push(tile);
                  }
                }
                context.tiles = tiles;
                const componentsCount = siz.Csiz;
                for (let i = 0, ii = componentsCount; i < ii; i++) {
                  const component = components[i];
                  for (let j = 0, jj = tiles.length; j < jj; j++) {
                    const tileComponent = {};
                    tile = tiles[j];
                    tileComponent.tcx0 = Math.ceil(tile.tx0 / component.XRsiz);
                    tileComponent.tcy0 = Math.ceil(tile.ty0 / component.YRsiz);
                    tileComponent.tcx1 = Math.ceil(tile.tx1 / component.XRsiz);
                    tileComponent.tcy1 = Math.ceil(tile.ty1 / component.YRsiz);
                    tileComponent.width = tileComponent.tcx1 - tileComponent.tcx0;
                    tileComponent.height = tileComponent.tcy1 - tileComponent.tcy0;
                    tile.components[i] = tileComponent;
                  }
                }
              }
              __name(calculateTileGrids, "calculateTileGrids");
              function getBlocksDimensions(context, component, r) {
                const codOrCoc = component.codingStyleParameters;
                const result = {};
                if (!codOrCoc.entropyCoderWithCustomPrecincts) {
                  result.PPx = 15;
                  result.PPy = 15;
                } else {
                  result.PPx = codOrCoc.precinctsSizes[r].PPx;
                  result.PPy = codOrCoc.precinctsSizes[r].PPy;
                }
                result.xcb_ = r > 0 ? Math.min(codOrCoc.xcb, result.PPx - 1) : Math.min(codOrCoc.xcb, result.PPx);
                result.ycb_ = r > 0 ? Math.min(codOrCoc.ycb, result.PPy - 1) : Math.min(codOrCoc.ycb, result.PPy);
                return result;
              }
              __name(getBlocksDimensions, "getBlocksDimensions");
              function buildPrecincts(context, resolution, dimensions) {
                const precinctWidth = 1 << dimensions.PPx;
                const precinctHeight = 1 << dimensions.PPy;
                const isZeroRes = resolution.resLevel === 0;
                const precinctWidthInSubband = 1 << dimensions.PPx + (isZeroRes ? 0 : -1);
                const precinctHeightInSubband = 1 << dimensions.PPy + (isZeroRes ? 0 : -1);
                const numprecinctswide = resolution.trx1 > resolution.trx0 ? Math.ceil(resolution.trx1 / precinctWidth) - Math.floor(resolution.trx0 / precinctWidth) : 0;
                const numprecinctshigh = resolution.try1 > resolution.try0 ? Math.ceil(resolution.try1 / precinctHeight) - Math.floor(resolution.try0 / precinctHeight) : 0;
                const numprecincts = numprecinctswide * numprecinctshigh;
                resolution.precinctParameters = {
                  precinctWidth,
                  precinctHeight,
                  numprecinctswide,
                  numprecinctshigh,
                  numprecincts,
                  precinctWidthInSubband,
                  precinctHeightInSubband
                };
              }
              __name(buildPrecincts, "buildPrecincts");
              function buildCodeblocks(context, subband, dimensions) {
                const xcb_ = dimensions.xcb_;
                const ycb_ = dimensions.ycb_;
                const codeblockWidth = 1 << xcb_;
                const codeblockHeight = 1 << ycb_;
                const cbx0 = subband.tbx0 >> xcb_;
                const cby0 = subband.tby0 >> ycb_;
                const cbx1 = subband.tbx1 + codeblockWidth - 1 >> xcb_;
                const cby1 = subband.tby1 + codeblockHeight - 1 >> ycb_;
                const precinctParameters = subband.resolution.precinctParameters;
                const codeblocks = [];
                const precincts = [];
                let i, j, codeblock, precinctNumber;
                for (j = cby0; j < cby1; j++) {
                  for (i = cbx0; i < cbx1; i++) {
                    codeblock = {
                      cbx: i,
                      cby: j,
                      tbx0: codeblockWidth * i,
                      tby0: codeblockHeight * j,
                      tbx1: codeblockWidth * (i + 1),
                      tby1: codeblockHeight * (j + 1)
                    };
                    codeblock.tbx0_ = Math.max(subband.tbx0, codeblock.tbx0);
                    codeblock.tby0_ = Math.max(subband.tby0, codeblock.tby0);
                    codeblock.tbx1_ = Math.min(subband.tbx1, codeblock.tbx1);
                    codeblock.tby1_ = Math.min(subband.tby1, codeblock.tby1);
                    const pi = Math.floor((codeblock.tbx0_ - subband.tbx0) / precinctParameters.precinctWidthInSubband);
                    const pj = Math.floor((codeblock.tby0_ - subband.tby0) / precinctParameters.precinctHeightInSubband);
                    precinctNumber = pi + pj * precinctParameters.numprecinctswide;
                    codeblock.precinctNumber = precinctNumber;
                    codeblock.subbandType = subband.type;
                    codeblock.Lblock = 3;
                    if (codeblock.tbx1_ <= codeblock.tbx0_ || codeblock.tby1_ <= codeblock.tby0_) {
                      continue;
                    }
                    codeblocks.push(codeblock);
                    let precinct = precincts[precinctNumber];
                    if (precinct !== void 0) {
                      if (i < precinct.cbxMin) {
                        precinct.cbxMin = i;
                      } else if (i > precinct.cbxMax) {
                        precinct.cbxMax = i;
                      }
                      if (j < precinct.cbyMin) {
                        precinct.cbxMin = j;
                      } else if (j > precinct.cbyMax) {
                        precinct.cbyMax = j;
                      }
                    } else {
                      precincts[precinctNumber] = precinct = {
                        cbxMin: i,
                        cbyMin: j,
                        cbxMax: i,
                        cbyMax: j
                      };
                    }
                    codeblock.precinct = precinct;
                  }
                }
                subband.codeblockParameters = {
                  codeblockWidth: xcb_,
                  codeblockHeight: ycb_,
                  numcodeblockwide: cbx1 - cbx0 + 1,
                  numcodeblockhigh: cby1 - cby0 + 1
                };
                subband.codeblocks = codeblocks;
                subband.precincts = precincts;
              }
              __name(buildCodeblocks, "buildCodeblocks");
              function createPacket(resolution, precinctNumber, layerNumber) {
                const precinctCodeblocks = [];
                const subbands = resolution.subbands;
                for (let i = 0, ii = subbands.length; i < ii; i++) {
                  const subband = subbands[i];
                  const codeblocks = subband.codeblocks;
                  for (let j = 0, jj = codeblocks.length; j < jj; j++) {
                    const codeblock = codeblocks[j];
                    if (codeblock.precinctNumber !== precinctNumber) {
                      continue;
                    }
                    precinctCodeblocks.push(codeblock);
                  }
                }
                return {
                  layerNumber,
                  codeblocks: precinctCodeblocks
                };
              }
              __name(createPacket, "createPacket");
              function LayerResolutionComponentPositionIterator(context) {
                const siz = context.SIZ;
                const tileIndex = context.currentTile.index;
                const tile = context.tiles[tileIndex];
                const layersCount = tile.codingStyleDefaultParameters.layersCount;
                const componentsCount = siz.Csiz;
                let maxDecompositionLevelsCount = 0;
                for (let q = 0; q < componentsCount; q++) {
                  maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, tile.components[q].codingStyleParameters.decompositionLevelsCount);
                }
                let l = 0, r = 0, i = 0, k = 0;
                this.nextPacket = /* @__PURE__ */ __name(function JpxImage_nextPacket() {
                  for (; l < layersCount; l++) {
                    for (; r <= maxDecompositionLevelsCount; r++) {
                      for (; i < componentsCount; i++) {
                        const component = tile.components[i];
                        if (r > component.codingStyleParameters.decompositionLevelsCount) {
                          continue;
                        }
                        const resolution = component.resolutions[r];
                        const numprecincts = resolution.precinctParameters.numprecincts;
                        for (; k < numprecincts; ) {
                          const packet = createPacket(resolution, k, l);
                          k++;
                          return packet;
                        }
                        k = 0;
                      }
                      i = 0;
                    }
                    r = 0;
                  }
                  throw new JpxError("Out of packets");
                }, "JpxImage_nextPacket");
              }
              __name(LayerResolutionComponentPositionIterator, "LayerResolutionComponentPositionIterator");
              function ResolutionLayerComponentPositionIterator(context) {
                const siz = context.SIZ;
                const tileIndex = context.currentTile.index;
                const tile = context.tiles[tileIndex];
                const layersCount = tile.codingStyleDefaultParameters.layersCount;
                const componentsCount = siz.Csiz;
                let maxDecompositionLevelsCount = 0;
                for (let q = 0; q < componentsCount; q++) {
                  maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, tile.components[q].codingStyleParameters.decompositionLevelsCount);
                }
                let r = 0, l = 0, i = 0, k = 0;
                this.nextPacket = /* @__PURE__ */ __name(function JpxImage_nextPacket() {
                  for (; r <= maxDecompositionLevelsCount; r++) {
                    for (; l < layersCount; l++) {
                      for (; i < componentsCount; i++) {
                        const component = tile.components[i];
                        if (r > component.codingStyleParameters.decompositionLevelsCount) {
                          continue;
                        }
                        const resolution = component.resolutions[r];
                        const numprecincts = resolution.precinctParameters.numprecincts;
                        for (; k < numprecincts; ) {
                          const packet = createPacket(resolution, k, l);
                          k++;
                          return packet;
                        }
                        k = 0;
                      }
                      i = 0;
                    }
                    l = 0;
                  }
                  throw new JpxError("Out of packets");
                }, "JpxImage_nextPacket");
              }
              __name(ResolutionLayerComponentPositionIterator, "ResolutionLayerComponentPositionIterator");
              function ResolutionPositionComponentLayerIterator(context) {
                const siz = context.SIZ;
                const tileIndex = context.currentTile.index;
                const tile = context.tiles[tileIndex];
                const layersCount = tile.codingStyleDefaultParameters.layersCount;
                const componentsCount = siz.Csiz;
                let l, r, c, p;
                let maxDecompositionLevelsCount = 0;
                for (c = 0; c < componentsCount; c++) {
                  const component = tile.components[c];
                  maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, component.codingStyleParameters.decompositionLevelsCount);
                }
                const maxNumPrecinctsInLevel = new Int32Array(maxDecompositionLevelsCount + 1);
                for (r = 0; r <= maxDecompositionLevelsCount; ++r) {
                  let maxNumPrecincts = 0;
                  for (c = 0; c < componentsCount; ++c) {
                    const resolutions = tile.components[c].resolutions;
                    if (r < resolutions.length) {
                      maxNumPrecincts = Math.max(maxNumPrecincts, resolutions[r].precinctParameters.numprecincts);
                    }
                  }
                  maxNumPrecinctsInLevel[r] = maxNumPrecincts;
                }
                l = 0;
                r = 0;
                c = 0;
                p = 0;
                this.nextPacket = /* @__PURE__ */ __name(function JpxImage_nextPacket() {
                  for (; r <= maxDecompositionLevelsCount; r++) {
                    for (; p < maxNumPrecinctsInLevel[r]; p++) {
                      for (; c < componentsCount; c++) {
                        const component = tile.components[c];
                        if (r > component.codingStyleParameters.decompositionLevelsCount) {
                          continue;
                        }
                        const resolution = component.resolutions[r];
                        const numprecincts = resolution.precinctParameters.numprecincts;
                        if (p >= numprecincts) {
                          continue;
                        }
                        for (; l < layersCount; ) {
                          const packet = createPacket(resolution, p, l);
                          l++;
                          return packet;
                        }
                        l = 0;
                      }
                      c = 0;
                    }
                    p = 0;
                  }
                  throw new JpxError("Out of packets");
                }, "JpxImage_nextPacket");
              }
              __name(ResolutionPositionComponentLayerIterator, "ResolutionPositionComponentLayerIterator");
              function PositionComponentResolutionLayerIterator(context) {
                const siz = context.SIZ;
                const tileIndex = context.currentTile.index;
                const tile = context.tiles[tileIndex];
                const layersCount = tile.codingStyleDefaultParameters.layersCount;
                const componentsCount = siz.Csiz;
                const precinctsSizes = getPrecinctSizesInImageScale(tile);
                const precinctsIterationSizes = precinctsSizes;
                let l = 0, r = 0, c = 0, px = 0, py = 0;
                this.nextPacket = /* @__PURE__ */ __name(function JpxImage_nextPacket() {
                  for (; py < precinctsIterationSizes.maxNumHigh; py++) {
                    for (; px < precinctsIterationSizes.maxNumWide; px++) {
                      for (; c < componentsCount; c++) {
                        const component = tile.components[c];
                        const decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
                        for (; r <= decompositionLevelsCount; r++) {
                          const resolution = component.resolutions[r];
                          const sizeInImageScale = precinctsSizes.components[c].resolutions[r];
                          const k = getPrecinctIndexIfExist(px, py, sizeInImageScale, precinctsIterationSizes, resolution);
                          if (k === null) {
                            continue;
                          }
                          for (; l < layersCount; ) {
                            const packet = createPacket(resolution, k, l);
                            l++;
                            return packet;
                          }
                          l = 0;
                        }
                        r = 0;
                      }
                      c = 0;
                    }
                    px = 0;
                  }
                  throw new JpxError("Out of packets");
                }, "JpxImage_nextPacket");
              }
              __name(PositionComponentResolutionLayerIterator, "PositionComponentResolutionLayerIterator");
              function ComponentPositionResolutionLayerIterator(context) {
                const siz = context.SIZ;
                const tileIndex = context.currentTile.index;
                const tile = context.tiles[tileIndex];
                const layersCount = tile.codingStyleDefaultParameters.layersCount;
                const componentsCount = siz.Csiz;
                const precinctsSizes = getPrecinctSizesInImageScale(tile);
                let l = 0, r = 0, c = 0, px = 0, py = 0;
                this.nextPacket = /* @__PURE__ */ __name(function JpxImage_nextPacket() {
                  for (; c < componentsCount; ++c) {
                    const component = tile.components[c];
                    const precinctsIterationSizes = precinctsSizes.components[c];
                    const decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
                    for (; py < precinctsIterationSizes.maxNumHigh; py++) {
                      for (; px < precinctsIterationSizes.maxNumWide; px++) {
                        for (; r <= decompositionLevelsCount; r++) {
                          const resolution = component.resolutions[r];
                          const sizeInImageScale = precinctsIterationSizes.resolutions[r];
                          const k = getPrecinctIndexIfExist(px, py, sizeInImageScale, precinctsIterationSizes, resolution);
                          if (k === null) {
                            continue;
                          }
                          for (; l < layersCount; ) {
                            const packet = createPacket(resolution, k, l);
                            l++;
                            return packet;
                          }
                          l = 0;
                        }
                        r = 0;
                      }
                      px = 0;
                    }
                    py = 0;
                  }
                  throw new JpxError("Out of packets");
                }, "JpxImage_nextPacket");
              }
              __name(ComponentPositionResolutionLayerIterator, "ComponentPositionResolutionLayerIterator");
              function getPrecinctIndexIfExist(pxIndex, pyIndex, sizeInImageScale, precinctIterationSizes, resolution) {
                const posX = pxIndex * precinctIterationSizes.minWidth;
                const posY = pyIndex * precinctIterationSizes.minHeight;
                if (posX % sizeInImageScale.width !== 0 || posY % sizeInImageScale.height !== 0) {
                  return null;
                }
                const startPrecinctRowIndex = posY / sizeInImageScale.width * resolution.precinctParameters.numprecinctswide;
                return posX / sizeInImageScale.height + startPrecinctRowIndex;
              }
              __name(getPrecinctIndexIfExist, "getPrecinctIndexIfExist");
              function getPrecinctSizesInImageScale(tile) {
                const componentsCount = tile.components.length;
                let minWidth = Number.MAX_VALUE;
                let minHeight = Number.MAX_VALUE;
                let maxNumWide = 0;
                let maxNumHigh = 0;
                const sizePerComponent = new Array(componentsCount);
                for (let c = 0; c < componentsCount; c++) {
                  const component = tile.components[c];
                  const decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
                  const sizePerResolution = new Array(decompositionLevelsCount + 1);
                  let minWidthCurrentComponent = Number.MAX_VALUE;
                  let minHeightCurrentComponent = Number.MAX_VALUE;
                  let maxNumWideCurrentComponent = 0;
                  let maxNumHighCurrentComponent = 0;
                  let scale = 1;
                  for (let r = decompositionLevelsCount; r >= 0; --r) {
                    const resolution = component.resolutions[r];
                    const widthCurrentResolution = scale * resolution.precinctParameters.precinctWidth;
                    const heightCurrentResolution = scale * resolution.precinctParameters.precinctHeight;
                    minWidthCurrentComponent = Math.min(minWidthCurrentComponent, widthCurrentResolution);
                    minHeightCurrentComponent = Math.min(minHeightCurrentComponent, heightCurrentResolution);
                    maxNumWideCurrentComponent = Math.max(maxNumWideCurrentComponent, resolution.precinctParameters.numprecinctswide);
                    maxNumHighCurrentComponent = Math.max(maxNumHighCurrentComponent, resolution.precinctParameters.numprecinctshigh);
                    sizePerResolution[r] = {
                      width: widthCurrentResolution,
                      height: heightCurrentResolution
                    };
                    scale <<= 1;
                  }
                  minWidth = Math.min(minWidth, minWidthCurrentComponent);
                  minHeight = Math.min(minHeight, minHeightCurrentComponent);
                  maxNumWide = Math.max(maxNumWide, maxNumWideCurrentComponent);
                  maxNumHigh = Math.max(maxNumHigh, maxNumHighCurrentComponent);
                  sizePerComponent[c] = {
                    resolutions: sizePerResolution,
                    minWidth: minWidthCurrentComponent,
                    minHeight: minHeightCurrentComponent,
                    maxNumWide: maxNumWideCurrentComponent,
                    maxNumHigh: maxNumHighCurrentComponent
                  };
                }
                return {
                  components: sizePerComponent,
                  minWidth,
                  minHeight,
                  maxNumWide,
                  maxNumHigh
                };
              }
              __name(getPrecinctSizesInImageScale, "getPrecinctSizesInImageScale");
              function buildPackets(context) {
                const siz = context.SIZ;
                const tileIndex = context.currentTile.index;
                const tile = context.tiles[tileIndex];
                const componentsCount = siz.Csiz;
                for (let c = 0; c < componentsCount; c++) {
                  const component = tile.components[c];
                  const decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
                  const resolutions = [];
                  const subbands = [];
                  for (let r = 0; r <= decompositionLevelsCount; r++) {
                    const blocksDimensions = getBlocksDimensions(context, component, r);
                    const resolution = {};
                    const scale = 1 << decompositionLevelsCount - r;
                    resolution.trx0 = Math.ceil(component.tcx0 / scale);
                    resolution.try0 = Math.ceil(component.tcy0 / scale);
                    resolution.trx1 = Math.ceil(component.tcx1 / scale);
                    resolution.try1 = Math.ceil(component.tcy1 / scale);
                    resolution.resLevel = r;
                    buildPrecincts(context, resolution, blocksDimensions);
                    resolutions.push(resolution);
                    let subband;
                    if (r === 0) {
                      subband = {};
                      subband.type = "LL";
                      subband.tbx0 = Math.ceil(component.tcx0 / scale);
                      subband.tby0 = Math.ceil(component.tcy0 / scale);
                      subband.tbx1 = Math.ceil(component.tcx1 / scale);
                      subband.tby1 = Math.ceil(component.tcy1 / scale);
                      subband.resolution = resolution;
                      buildCodeblocks(context, subband, blocksDimensions);
                      subbands.push(subband);
                      resolution.subbands = [subband];
                    } else {
                      const bscale = 1 << decompositionLevelsCount - r + 1;
                      const resolutionSubbands = [];
                      subband = {};
                      subband.type = "HL";
                      subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
                      subband.tby0 = Math.ceil(component.tcy0 / bscale);
                      subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
                      subband.tby1 = Math.ceil(component.tcy1 / bscale);
                      subband.resolution = resolution;
                      buildCodeblocks(context, subband, blocksDimensions);
                      subbands.push(subband);
                      resolutionSubbands.push(subband);
                      subband = {};
                      subband.type = "LH";
                      subband.tbx0 = Math.ceil(component.tcx0 / bscale);
                      subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
                      subband.tbx1 = Math.ceil(component.tcx1 / bscale);
                      subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
                      subband.resolution = resolution;
                      buildCodeblocks(context, subband, blocksDimensions);
                      subbands.push(subband);
                      resolutionSubbands.push(subband);
                      subband = {};
                      subband.type = "HH";
                      subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
                      subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
                      subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
                      subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
                      subband.resolution = resolution;
                      buildCodeblocks(context, subband, blocksDimensions);
                      subbands.push(subband);
                      resolutionSubbands.push(subband);
                      resolution.subbands = resolutionSubbands;
                    }
                  }
                  component.resolutions = resolutions;
                  component.subbands = subbands;
                }
                const progressionOrder = tile.codingStyleDefaultParameters.progressionOrder;
                switch (progressionOrder) {
                  case 0:
                    tile.packetsIterator = new LayerResolutionComponentPositionIterator(context);
                    break;
                  case 1:
                    tile.packetsIterator = new ResolutionLayerComponentPositionIterator(context);
                    break;
                  case 2:
                    tile.packetsIterator = new ResolutionPositionComponentLayerIterator(context);
                    break;
                  case 3:
                    tile.packetsIterator = new PositionComponentResolutionLayerIterator(context);
                    break;
                  case 4:
                    tile.packetsIterator = new ComponentPositionResolutionLayerIterator(context);
                    break;
                  default:
                    throw new JpxError(`Unsupported progression order ${progressionOrder}`);
                }
              }
              __name(buildPackets, "buildPackets");
              function parseTilePackets(context, data, offset, dataLength) {
                let position = 0;
                let buffer, bufferSize = 0, skipNextBit = false;
                function readBits(count) {
                  while (bufferSize < count) {
                    const b = data[offset + position];
                    position++;
                    if (skipNextBit) {
                      buffer = buffer << 7 | b;
                      bufferSize += 7;
                      skipNextBit = false;
                    } else {
                      buffer = buffer << 8 | b;
                      bufferSize += 8;
                    }
                    if (b === 255) {
                      skipNextBit = true;
                    }
                  }
                  bufferSize -= count;
                  return buffer >>> bufferSize & (1 << count) - 1;
                }
                __name(readBits, "readBits");
                function skipMarkerIfEqual(value) {
                  if (data[offset + position - 1] === 255 && data[offset + position] === value) {
                    skipBytes(1);
                    return true;
                  } else if (data[offset + position] === 255 && data[offset + position + 1] === value) {
                    skipBytes(2);
                    return true;
                  }
                  return false;
                }
                __name(skipMarkerIfEqual, "skipMarkerIfEqual");
                function skipBytes(count) {
                  position += count;
                }
                __name(skipBytes, "skipBytes");
                function alignToByte() {
                  bufferSize = 0;
                  if (skipNextBit) {
                    position++;
                    skipNextBit = false;
                  }
                }
                __name(alignToByte, "alignToByte");
                function readCodingpasses() {
                  if (readBits(1) === 0) {
                    return 1;
                  }
                  if (readBits(1) === 0) {
                    return 2;
                  }
                  let value = readBits(2);
                  if (value < 3) {
                    return value + 3;
                  }
                  value = readBits(5);
                  if (value < 31) {
                    return value + 6;
                  }
                  value = readBits(7);
                  return value + 37;
                }
                __name(readCodingpasses, "readCodingpasses");
                const tileIndex = context.currentTile.index;
                const tile = context.tiles[tileIndex];
                const sopMarkerUsed = context.COD.sopMarkerUsed;
                const ephMarkerUsed = context.COD.ephMarkerUsed;
                const packetsIterator = tile.packetsIterator;
                while (position < dataLength) {
                  alignToByte();
                  if (sopMarkerUsed && skipMarkerIfEqual(145)) {
                    skipBytes(4);
                  }
                  const packet = packetsIterator.nextPacket();
                  if (!readBits(1)) {
                    continue;
                  }
                  const layerNumber = packet.layerNumber, queue = [];
                  let codeblock;
                  for (let i = 0, ii = packet.codeblocks.length; i < ii; i++) {
                    codeblock = packet.codeblocks[i];
                    let precinct = codeblock.precinct;
                    const codeblockColumn = codeblock.cbx - precinct.cbxMin;
                    const codeblockRow = codeblock.cby - precinct.cbyMin;
                    let codeblockIncluded = false;
                    let firstTimeInclusion = false;
                    let valueReady, zeroBitPlanesTree;
                    if (codeblock.included !== void 0) {
                      codeblockIncluded = !!readBits(1);
                    } else {
                      precinct = codeblock.precinct;
                      let inclusionTree;
                      if (precinct.inclusionTree !== void 0) {
                        inclusionTree = precinct.inclusionTree;
                      } else {
                        const width = precinct.cbxMax - precinct.cbxMin + 1;
                        const height = precinct.cbyMax - precinct.cbyMin + 1;
                        inclusionTree = new InclusionTree(width, height, layerNumber);
                        zeroBitPlanesTree = new TagTree(width, height);
                        precinct.inclusionTree = inclusionTree;
                        precinct.zeroBitPlanesTree = zeroBitPlanesTree;
                        for (let l = 0; l < layerNumber; l++) {
                          if (readBits(1) !== 0) {
                            throw new JpxError("Invalid tag tree");
                          }
                        }
                      }
                      if (inclusionTree.reset(codeblockColumn, codeblockRow, layerNumber)) {
                        while (true) {
                          if (readBits(1)) {
                            valueReady = !inclusionTree.nextLevel();
                            if (valueReady) {
                              codeblock.included = true;
                              codeblockIncluded = firstTimeInclusion = true;
                              break;
                            }
                          } else {
                            inclusionTree.incrementValue(layerNumber);
                            break;
                          }
                        }
                      }
                    }
                    if (!codeblockIncluded) {
                      continue;
                    }
                    if (firstTimeInclusion) {
                      zeroBitPlanesTree = precinct.zeroBitPlanesTree;
                      zeroBitPlanesTree.reset(codeblockColumn, codeblockRow);
                      while (true) {
                        if (readBits(1)) {
                          valueReady = !zeroBitPlanesTree.nextLevel();
                          if (valueReady) {
                            break;
                          }
                        } else {
                          zeroBitPlanesTree.incrementValue();
                        }
                      }
                      codeblock.zeroBitPlanes = zeroBitPlanesTree.value;
                    }
                    const codingpasses = readCodingpasses();
                    while (readBits(1)) {
                      codeblock.Lblock++;
                    }
                    const codingpassesLog2 = (0, _core_utils.log2)(codingpasses);
                    const bits = (codingpasses < 1 << codingpassesLog2 ? codingpassesLog2 - 1 : codingpassesLog2) + codeblock.Lblock;
                    const codedDataLength = readBits(bits);
                    queue.push({
                      codeblock,
                      codingpasses,
                      dataLength: codedDataLength
                    });
                  }
                  alignToByte();
                  if (ephMarkerUsed) {
                    skipMarkerIfEqual(146);
                  }
                  while (queue.length > 0) {
                    const packetItem = queue.shift();
                    codeblock = packetItem.codeblock;
                    if (codeblock.data === void 0) {
                      codeblock.data = [];
                    }
                    codeblock.data.push({
                      data,
                      start: offset + position,
                      end: offset + position + packetItem.dataLength,
                      codingpasses: packetItem.codingpasses
                    });
                    position += packetItem.dataLength;
                  }
                }
                return position;
              }
              __name(parseTilePackets, "parseTilePackets");
              function copyCoefficients(coefficients, levelWidth, levelHeight, subband, delta, mb, reversible, segmentationSymbolUsed, resetContextProbabilities) {
                const x0 = subband.tbx0;
                const y0 = subband.tby0;
                const width = subband.tbx1 - subband.tbx0;
                const codeblocks = subband.codeblocks;
                const right = subband.type.charAt(0) === "H" ? 1 : 0;
                const bottom = subband.type.charAt(1) === "H" ? levelWidth : 0;
                for (let i = 0, ii = codeblocks.length; i < ii; ++i) {
                  const codeblock = codeblocks[i];
                  const blockWidth = codeblock.tbx1_ - codeblock.tbx0_;
                  const blockHeight = codeblock.tby1_ - codeblock.tby0_;
                  if (blockWidth === 0 || blockHeight === 0) {
                    continue;
                  }
                  if (codeblock.data === void 0) {
                    continue;
                  }
                  const bitModel = new BitModel(blockWidth, blockHeight, codeblock.subbandType, codeblock.zeroBitPlanes, mb);
                  let currentCodingpassType = 2;
                  const data = codeblock.data;
                  let totalLength = 0, codingpasses = 0;
                  let j, jj, dataItem;
                  for (j = 0, jj = data.length; j < jj; j++) {
                    dataItem = data[j];
                    totalLength += dataItem.end - dataItem.start;
                    codingpasses += dataItem.codingpasses;
                  }
                  const encodedData = new Uint8Array(totalLength);
                  let position = 0;
                  for (j = 0, jj = data.length; j < jj; j++) {
                    dataItem = data[j];
                    const chunk = dataItem.data.subarray(dataItem.start, dataItem.end);
                    encodedData.set(chunk, position);
                    position += chunk.length;
                  }
                  const decoder = new _arithmetic_decoder.ArithmeticDecoder(encodedData, 0, totalLength);
                  bitModel.setDecoder(decoder);
                  for (j = 0; j < codingpasses; j++) {
                    switch (currentCodingpassType) {
                      case 0:
                        bitModel.runSignificancePropagationPass();
                        break;
                      case 1:
                        bitModel.runMagnitudeRefinementPass();
                        break;
                      case 2:
                        bitModel.runCleanupPass();
                        if (segmentationSymbolUsed) {
                          bitModel.checkSegmentationSymbol();
                        }
                        break;
                    }
                    if (resetContextProbabilities) {
                      bitModel.reset();
                    }
                    currentCodingpassType = (currentCodingpassType + 1) % 3;
                  }
                  let offset = codeblock.tbx0_ - x0 + (codeblock.tby0_ - y0) * width;
                  const sign = bitModel.coefficentsSign;
                  const magnitude = bitModel.coefficentsMagnitude;
                  const bitsDecoded = bitModel.bitsDecoded;
                  const magnitudeCorrection = reversible ? 0 : 0.5;
                  let k, n, nb;
                  position = 0;
                  const interleave = subband.type !== "LL";
                  for (j = 0; j < blockHeight; j++) {
                    const row = offset / width | 0;
                    const levelOffset = 2 * row * (levelWidth - width) + right + bottom;
                    for (k = 0; k < blockWidth; k++) {
                      n = magnitude[position];
                      if (n !== 0) {
                        n = (n + magnitudeCorrection) * delta;
                        if (sign[position] !== 0) {
                          n = -n;
                        }
                        nb = bitsDecoded[position];
                        const pos = interleave ? levelOffset + (offset << 1) : offset;
                        if (reversible && nb >= mb) {
                          coefficients[pos] = n;
                        } else {
                          coefficients[pos] = n * (1 << mb - nb);
                        }
                      }
                      offset++;
                      position++;
                    }
                    offset += width - blockWidth;
                  }
                }
              }
              __name(copyCoefficients, "copyCoefficients");
              function transformTile(context, tile, c) {
                const component = tile.components[c];
                const codingStyleParameters = component.codingStyleParameters;
                const quantizationParameters = component.quantizationParameters;
                const decompositionLevelsCount = codingStyleParameters.decompositionLevelsCount;
                const spqcds = quantizationParameters.SPqcds;
                const scalarExpounded = quantizationParameters.scalarExpounded;
                const guardBits = quantizationParameters.guardBits;
                const segmentationSymbolUsed = codingStyleParameters.segmentationSymbolUsed;
                const resetContextProbabilities = codingStyleParameters.resetContextProbabilities;
                const precision = context.components[c].precision;
                const reversible = codingStyleParameters.reversibleTransformation;
                const transform = reversible ? new ReversibleTransform() : new IrreversibleTransform();
                const subbandCoefficients = [];
                let b = 0;
                for (let i = 0; i <= decompositionLevelsCount; i++) {
                  const resolution = component.resolutions[i];
                  const width = resolution.trx1 - resolution.trx0;
                  const height = resolution.try1 - resolution.try0;
                  const coefficients = new Float32Array(width * height);
                  for (let j = 0, jj = resolution.subbands.length; j < jj; j++) {
                    let mu, epsilon;
                    if (!scalarExpounded) {
                      mu = spqcds[0].mu;
                      epsilon = spqcds[0].epsilon + (i > 0 ? 1 - i : 0);
                    } else {
                      mu = spqcds[b].mu;
                      epsilon = spqcds[b].epsilon;
                      b++;
                    }
                    const subband = resolution.subbands[j];
                    const gainLog2 = SubbandsGainLog2[subband.type];
                    const delta = reversible ? 1 : 2 ** (precision + gainLog2 - epsilon) * (1 + mu / 2048);
                    const mb = guardBits + epsilon - 1;
                    copyCoefficients(coefficients, width, height, subband, delta, mb, reversible, segmentationSymbolUsed, resetContextProbabilities);
                  }
                  subbandCoefficients.push({
                    width,
                    height,
                    items: coefficients
                  });
                }
                const result = transform.calculate(subbandCoefficients, component.tcx0, component.tcy0);
                return {
                  left: component.tcx0,
                  top: component.tcy0,
                  width: result.width,
                  height: result.height,
                  items: result.items
                };
              }
              __name(transformTile, "transformTile");
              function transformComponents(context) {
                const siz = context.SIZ;
                const components = context.components;
                const componentsCount = siz.Csiz;
                const resultImages = [];
                for (let i = 0, ii = context.tiles.length; i < ii; i++) {
                  const tile = context.tiles[i];
                  const transformedTiles = [];
                  for (let c = 0; c < componentsCount; c++) {
                    transformedTiles[c] = transformTile(context, tile, c);
                  }
                  const tile0 = transformedTiles[0];
                  const out = new Uint8ClampedArray(tile0.items.length * componentsCount);
                  const result = {
                    left: tile0.left,
                    top: tile0.top,
                    width: tile0.width,
                    height: tile0.height,
                    items: out
                  };
                  let shift, offset;
                  let pos = 0, j, jj, y0, y1, y2;
                  if (tile.codingStyleDefaultParameters.multipleComponentTransform) {
                    const fourComponents = componentsCount === 4;
                    const y0items = transformedTiles[0].items;
                    const y1items = transformedTiles[1].items;
                    const y2items = transformedTiles[2].items;
                    const y3items = fourComponents ? transformedTiles[3].items : null;
                    shift = components[0].precision - 8;
                    offset = (128 << shift) + 0.5;
                    const component0 = tile.components[0];
                    const alpha01 = componentsCount - 3;
                    jj = y0items.length;
                    if (!component0.codingStyleParameters.reversibleTransformation) {
                      for (j = 0; j < jj; j++, pos += alpha01) {
                        y0 = y0items[j] + offset;
                        y1 = y1items[j];
                        y2 = y2items[j];
                        out[pos++] = y0 + 1.402 * y2 >> shift;
                        out[pos++] = y0 - 0.34413 * y1 - 0.71414 * y2 >> shift;
                        out[pos++] = y0 + 1.772 * y1 >> shift;
                      }
                    } else {
                      for (j = 0; j < jj; j++, pos += alpha01) {
                        y0 = y0items[j] + offset;
                        y1 = y1items[j];
                        y2 = y2items[j];
                        const g = y0 - (y2 + y1 >> 2);
                        out[pos++] = g + y2 >> shift;
                        out[pos++] = g >> shift;
                        out[pos++] = g + y1 >> shift;
                      }
                    }
                    if (fourComponents) {
                      for (j = 0, pos = 3; j < jj; j++, pos += 4) {
                        out[pos] = y3items[j] + offset >> shift;
                      }
                    }
                  } else {
                    for (let c = 0; c < componentsCount; c++) {
                      const items = transformedTiles[c].items;
                      shift = components[c].precision - 8;
                      offset = (128 << shift) + 0.5;
                      for (pos = c, j = 0, jj = items.length; j < jj; j++) {
                        out[pos] = items[j] + offset >> shift;
                        pos += componentsCount;
                      }
                    }
                  }
                  resultImages.push(result);
                }
                return resultImages;
              }
              __name(transformComponents, "transformComponents");
              function initializeTile(context, tileIndex) {
                const siz = context.SIZ;
                const componentsCount = siz.Csiz;
                const tile = context.tiles[tileIndex];
                for (let c = 0; c < componentsCount; c++) {
                  const component = tile.components[c];
                  const qcdOrQcc = context.currentTile.QCC[c] !== void 0 ? context.currentTile.QCC[c] : context.currentTile.QCD;
                  component.quantizationParameters = qcdOrQcc;
                  const codOrCoc = context.currentTile.COC[c] !== void 0 ? context.currentTile.COC[c] : context.currentTile.COD;
                  component.codingStyleParameters = codOrCoc;
                }
                tile.codingStyleDefaultParameters = context.currentTile.COD;
              }
              __name(initializeTile, "initializeTile");
              const _TagTree = class _TagTree {
                constructor(width, height) {
                  const levelsLength = (0, _core_utils.log2)(Math.max(width, height)) + 1;
                  this.levels = [];
                  for (let i = 0; i < levelsLength; i++) {
                    const level = {
                      width,
                      height,
                      items: []
                    };
                    this.levels.push(level);
                    width = Math.ceil(width / 2);
                    height = Math.ceil(height / 2);
                  }
                }
                reset(i, j) {
                  let currentLevel = 0, value = 0, level;
                  while (currentLevel < this.levels.length) {
                    level = this.levels[currentLevel];
                    const index = i + j * level.width;
                    if (level.items[index] !== void 0) {
                      value = level.items[index];
                      break;
                    }
                    level.index = index;
                    i >>= 1;
                    j >>= 1;
                    currentLevel++;
                  }
                  currentLevel--;
                  level = this.levels[currentLevel];
                  level.items[level.index] = value;
                  this.currentLevel = currentLevel;
                  delete this.value;
                }
                incrementValue() {
                  const level = this.levels[this.currentLevel];
                  level.items[level.index]++;
                }
                nextLevel() {
                  let currentLevel = this.currentLevel;
                  let level = this.levels[currentLevel];
                  const value = level.items[level.index];
                  currentLevel--;
                  if (currentLevel < 0) {
                    this.value = value;
                    return false;
                  }
                  this.currentLevel = currentLevel;
                  level = this.levels[currentLevel];
                  level.items[level.index] = value;
                  return true;
                }
              };
              __name(_TagTree, "TagTree");
              let TagTree = _TagTree;
              const _InclusionTree = class _InclusionTree {
                constructor(width, height, defaultValue) {
                  const levelsLength = (0, _core_utils.log2)(Math.max(width, height)) + 1;
                  this.levels = [];
                  for (let i = 0; i < levelsLength; i++) {
                    const items = new Uint8Array(width * height);
                    for (let j = 0, jj = items.length; j < jj; j++) {
                      items[j] = defaultValue;
                    }
                    const level = {
                      width,
                      height,
                      items
                    };
                    this.levels.push(level);
                    width = Math.ceil(width / 2);
                    height = Math.ceil(height / 2);
                  }
                }
                reset(i, j, stopValue) {
                  let currentLevel = 0;
                  while (currentLevel < this.levels.length) {
                    const level = this.levels[currentLevel];
                    const index = i + j * level.width;
                    level.index = index;
                    const value = level.items[index];
                    if (value === 255) {
                      break;
                    }
                    if (value > stopValue) {
                      this.currentLevel = currentLevel;
                      this.propagateValues();
                      return false;
                    }
                    i >>= 1;
                    j >>= 1;
                    currentLevel++;
                  }
                  this.currentLevel = currentLevel - 1;
                  return true;
                }
                incrementValue(stopValue) {
                  const level = this.levels[this.currentLevel];
                  level.items[level.index] = stopValue + 1;
                  this.propagateValues();
                }
                propagateValues() {
                  let levelIndex = this.currentLevel;
                  let level = this.levels[levelIndex];
                  const currentValue = level.items[level.index];
                  while (--levelIndex >= 0) {
                    level = this.levels[levelIndex];
                    level.items[level.index] = currentValue;
                  }
                }
                nextLevel() {
                  let currentLevel = this.currentLevel;
                  let level = this.levels[currentLevel];
                  const value = level.items[level.index];
                  level.items[level.index] = 255;
                  currentLevel--;
                  if (currentLevel < 0) {
                    return false;
                  }
                  this.currentLevel = currentLevel;
                  level = this.levels[currentLevel];
                  level.items[level.index] = value;
                  return true;
                }
              };
              __name(_InclusionTree, "InclusionTree");
              let InclusionTree = _InclusionTree;
              const BitModel = (/* @__PURE__ */ __name(function BitModelClosure() {
                const UNIFORM_CONTEXT = 17;
                const RUNLENGTH_CONTEXT = 18;
                const LLAndLHContextsLabel = new Uint8Array([0, 5, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 1, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8]);
                const HLContextLabel = new Uint8Array([0, 3, 4, 0, 5, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 1, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8]);
                const HHContextLabel = new Uint8Array([0, 1, 2, 0, 1, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 3, 4, 5, 0, 4, 5, 5, 0, 5, 5, 5, 0, 0, 0, 0, 0, 6, 7, 7, 0, 7, 7, 7, 0, 7, 7, 7, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8]);
                const _BitModel = class _BitModel {
                  constructor(width, height, subband, zeroBitPlanes, mb) {
                    this.width = width;
                    this.height = height;
                    let contextLabelTable;
                    if (subband === "HH") {
                      contextLabelTable = HHContextLabel;
                    } else if (subband === "HL") {
                      contextLabelTable = HLContextLabel;
                    } else {
                      contextLabelTable = LLAndLHContextsLabel;
                    }
                    this.contextLabelTable = contextLabelTable;
                    const coefficientCount = width * height;
                    this.neighborsSignificance = new Uint8Array(coefficientCount);
                    this.coefficentsSign = new Uint8Array(coefficientCount);
                    let coefficentsMagnitude;
                    if (mb > 14) {
                      coefficentsMagnitude = new Uint32Array(coefficientCount);
                    } else if (mb > 6) {
                      coefficentsMagnitude = new Uint16Array(coefficientCount);
                    } else {
                      coefficentsMagnitude = new Uint8Array(coefficientCount);
                    }
                    this.coefficentsMagnitude = coefficentsMagnitude;
                    this.processingFlags = new Uint8Array(coefficientCount);
                    const bitsDecoded = new Uint8Array(coefficientCount);
                    if (zeroBitPlanes !== 0) {
                      for (let i = 0; i < coefficientCount; i++) {
                        bitsDecoded[i] = zeroBitPlanes;
                      }
                    }
                    this.bitsDecoded = bitsDecoded;
                    this.reset();
                  }
                  setDecoder(decoder) {
                    this.decoder = decoder;
                  }
                  reset() {
                    this.contexts = new Int8Array(19);
                    this.contexts[0] = 4 << 1 | 0;
                    this.contexts[UNIFORM_CONTEXT] = 46 << 1 | 0;
                    this.contexts[RUNLENGTH_CONTEXT] = 3 << 1 | 0;
                  }
                  setNeighborsSignificance(row, column, index) {
                    const neighborsSignificance = this.neighborsSignificance;
                    const width = this.width, height = this.height;
                    const left = column > 0;
                    const right = column + 1 < width;
                    let i;
                    if (row > 0) {
                      i = index - width;
                      if (left) {
                        neighborsSignificance[i - 1] += 16;
                      }
                      if (right) {
                        neighborsSignificance[i + 1] += 16;
                      }
                      neighborsSignificance[i] += 4;
                    }
                    if (row + 1 < height) {
                      i = index + width;
                      if (left) {
                        neighborsSignificance[i - 1] += 16;
                      }
                      if (right) {
                        neighborsSignificance[i + 1] += 16;
                      }
                      neighborsSignificance[i] += 4;
                    }
                    if (left) {
                      neighborsSignificance[index - 1] += 1;
                    }
                    if (right) {
                      neighborsSignificance[index + 1] += 1;
                    }
                    neighborsSignificance[index] |= 128;
                  }
                  runSignificancePropagationPass() {
                    const decoder = this.decoder;
                    const width = this.width, height = this.height;
                    const coefficentsMagnitude = this.coefficentsMagnitude;
                    const coefficentsSign = this.coefficentsSign;
                    const neighborsSignificance = this.neighborsSignificance;
                    const processingFlags = this.processingFlags;
                    const contexts = this.contexts;
                    const labels = this.contextLabelTable;
                    const bitsDecoded = this.bitsDecoded;
                    const processedInverseMask = ~1;
                    const processedMask = 1;
                    const firstMagnitudeBitMask = 2;
                    for (let i0 = 0; i0 < height; i0 += 4) {
                      for (let j = 0; j < width; j++) {
                        let index = i0 * width + j;
                        for (let i1 = 0; i1 < 4; i1++, index += width) {
                          const i = i0 + i1;
                          if (i >= height) {
                            break;
                          }
                          processingFlags[index] &= processedInverseMask;
                          if (coefficentsMagnitude[index] || !neighborsSignificance[index]) {
                            continue;
                          }
                          const contextLabel = labels[neighborsSignificance[index]];
                          const decision = decoder.readBit(contexts, contextLabel);
                          if (decision) {
                            const sign = this.decodeSignBit(i, j, index);
                            coefficentsSign[index] = sign;
                            coefficentsMagnitude[index] = 1;
                            this.setNeighborsSignificance(i, j, index);
                            processingFlags[index] |= firstMagnitudeBitMask;
                          }
                          bitsDecoded[index]++;
                          processingFlags[index] |= processedMask;
                        }
                      }
                    }
                  }
                  decodeSignBit(row, column, index) {
                    const width = this.width, height = this.height;
                    const coefficentsMagnitude = this.coefficentsMagnitude;
                    const coefficentsSign = this.coefficentsSign;
                    let contribution, sign0, sign1, significance1;
                    let contextLabel, decoded;
                    significance1 = column > 0 && coefficentsMagnitude[index - 1] !== 0;
                    if (column + 1 < width && coefficentsMagnitude[index + 1] !== 0) {
                      sign1 = coefficentsSign[index + 1];
                      if (significance1) {
                        sign0 = coefficentsSign[index - 1];
                        contribution = 1 - sign1 - sign0;
                      } else {
                        contribution = 1 - sign1 - sign1;
                      }
                    } else if (significance1) {
                      sign0 = coefficentsSign[index - 1];
                      contribution = 1 - sign0 - sign0;
                    } else {
                      contribution = 0;
                    }
                    const horizontalContribution = 3 * contribution;
                    significance1 = row > 0 && coefficentsMagnitude[index - width] !== 0;
                    if (row + 1 < height && coefficentsMagnitude[index + width] !== 0) {
                      sign1 = coefficentsSign[index + width];
                      if (significance1) {
                        sign0 = coefficentsSign[index - width];
                        contribution = 1 - sign1 - sign0 + horizontalContribution;
                      } else {
                        contribution = 1 - sign1 - sign1 + horizontalContribution;
                      }
                    } else if (significance1) {
                      sign0 = coefficentsSign[index - width];
                      contribution = 1 - sign0 - sign0 + horizontalContribution;
                    } else {
                      contribution = horizontalContribution;
                    }
                    if (contribution >= 0) {
                      contextLabel = 9 + contribution;
                      decoded = this.decoder.readBit(this.contexts, contextLabel);
                    } else {
                      contextLabel = 9 - contribution;
                      decoded = this.decoder.readBit(this.contexts, contextLabel) ^ 1;
                    }
                    return decoded;
                  }
                  runMagnitudeRefinementPass() {
                    const decoder = this.decoder;
                    const width = this.width, height = this.height;
                    const coefficentsMagnitude = this.coefficentsMagnitude;
                    const neighborsSignificance = this.neighborsSignificance;
                    const contexts = this.contexts;
                    const bitsDecoded = this.bitsDecoded;
                    const processingFlags = this.processingFlags;
                    const processedMask = 1;
                    const firstMagnitudeBitMask = 2;
                    const length = width * height;
                    const width4 = width * 4;
                    for (let index0 = 0, indexNext; index0 < length; index0 = indexNext) {
                      indexNext = Math.min(length, index0 + width4);
                      for (let j = 0; j < width; j++) {
                        for (let index = index0 + j; index < indexNext; index += width) {
                          if (!coefficentsMagnitude[index] || (processingFlags[index] & processedMask) !== 0) {
                            continue;
                          }
                          let contextLabel = 16;
                          if ((processingFlags[index] & firstMagnitudeBitMask) !== 0) {
                            processingFlags[index] ^= firstMagnitudeBitMask;
                            const significance = neighborsSignificance[index] & 127;
                            contextLabel = significance === 0 ? 15 : 14;
                          }
                          const bit = decoder.readBit(contexts, contextLabel);
                          coefficentsMagnitude[index] = coefficentsMagnitude[index] << 1 | bit;
                          bitsDecoded[index]++;
                          processingFlags[index] |= processedMask;
                        }
                      }
                    }
                  }
                  runCleanupPass() {
                    const decoder = this.decoder;
                    const width = this.width, height = this.height;
                    const neighborsSignificance = this.neighborsSignificance;
                    const coefficentsMagnitude = this.coefficentsMagnitude;
                    const coefficentsSign = this.coefficentsSign;
                    const contexts = this.contexts;
                    const labels = this.contextLabelTable;
                    const bitsDecoded = this.bitsDecoded;
                    const processingFlags = this.processingFlags;
                    const processedMask = 1;
                    const firstMagnitudeBitMask = 2;
                    const oneRowDown = width;
                    const twoRowsDown = width * 2;
                    const threeRowsDown = width * 3;
                    let iNext;
                    for (let i0 = 0; i0 < height; i0 = iNext) {
                      iNext = Math.min(i0 + 4, height);
                      const indexBase = i0 * width;
                      const checkAllEmpty = i0 + 3 < height;
                      for (let j = 0; j < width; j++) {
                        const index0 = indexBase + j;
                        const allEmpty = checkAllEmpty && processingFlags[index0] === 0 && processingFlags[index0 + oneRowDown] === 0 && processingFlags[index0 + twoRowsDown] === 0 && processingFlags[index0 + threeRowsDown] === 0 && neighborsSignificance[index0] === 0 && neighborsSignificance[index0 + oneRowDown] === 0 && neighborsSignificance[index0 + twoRowsDown] === 0 && neighborsSignificance[index0 + threeRowsDown] === 0;
                        let i1 = 0, index = index0;
                        let i = i0, sign;
                        if (allEmpty) {
                          const hasSignificantCoefficent = decoder.readBit(contexts, RUNLENGTH_CONTEXT);
                          if (!hasSignificantCoefficent) {
                            bitsDecoded[index0]++;
                            bitsDecoded[index0 + oneRowDown]++;
                            bitsDecoded[index0 + twoRowsDown]++;
                            bitsDecoded[index0 + threeRowsDown]++;
                            continue;
                          }
                          i1 = decoder.readBit(contexts, UNIFORM_CONTEXT) << 1 | decoder.readBit(contexts, UNIFORM_CONTEXT);
                          if (i1 !== 0) {
                            i = i0 + i1;
                            index += i1 * width;
                          }
                          sign = this.decodeSignBit(i, j, index);
                          coefficentsSign[index] = sign;
                          coefficentsMagnitude[index] = 1;
                          this.setNeighborsSignificance(i, j, index);
                          processingFlags[index] |= firstMagnitudeBitMask;
                          index = index0;
                          for (let i2 = i0; i2 <= i; i2++, index += width) {
                            bitsDecoded[index]++;
                          }
                          i1++;
                        }
                        for (i = i0 + i1; i < iNext; i++, index += width) {
                          if (coefficentsMagnitude[index] || (processingFlags[index] & processedMask) !== 0) {
                            continue;
                          }
                          const contextLabel = labels[neighborsSignificance[index]];
                          const decision = decoder.readBit(contexts, contextLabel);
                          if (decision === 1) {
                            sign = this.decodeSignBit(i, j, index);
                            coefficentsSign[index] = sign;
                            coefficentsMagnitude[index] = 1;
                            this.setNeighborsSignificance(i, j, index);
                            processingFlags[index] |= firstMagnitudeBitMask;
                          }
                          bitsDecoded[index]++;
                        }
                      }
                    }
                  }
                  checkSegmentationSymbol() {
                    const decoder = this.decoder;
                    const contexts = this.contexts;
                    const symbol = decoder.readBit(contexts, UNIFORM_CONTEXT) << 3 | decoder.readBit(contexts, UNIFORM_CONTEXT) << 2 | decoder.readBit(contexts, UNIFORM_CONTEXT) << 1 | decoder.readBit(contexts, UNIFORM_CONTEXT);
                    if (symbol !== 10) {
                      throw new JpxError("Invalid segmentation symbol");
                    }
                  }
                };
                __name(_BitModel, "BitModel");
                let BitModel2 = _BitModel;
                return BitModel2;
              }, "BitModelClosure"))();
              const _Transform = class _Transform {
                constructor() {
                  if (this.constructor === _Transform) {
                    (0, _util.unreachable)("Cannot initialize Transform.");
                  }
                }
                calculate(subbands, u0, v0) {
                  let ll = subbands[0];
                  for (let i = 1, ii = subbands.length; i < ii; i++) {
                    ll = this.iterate(ll, subbands[i], u0, v0);
                  }
                  return ll;
                }
                extend(buffer, offset, size) {
                  let i1 = offset - 1, j1 = offset + 1;
                  let i2 = offset + size - 2, j2 = offset + size;
                  buffer[i1--] = buffer[j1++];
                  buffer[j2++] = buffer[i2--];
                  buffer[i1--] = buffer[j1++];
                  buffer[j2++] = buffer[i2--];
                  buffer[i1--] = buffer[j1++];
                  buffer[j2++] = buffer[i2--];
                  buffer[i1] = buffer[j1];
                  buffer[j2] = buffer[i2];
                }
                filter(x, offset, length) {
                  (0, _util.unreachable)("Abstract method `filter` called");
                }
                iterate(ll, hl_lh_hh, u0, v0) {
                  const llWidth = ll.width, llHeight = ll.height;
                  let llItems = ll.items;
                  const width = hl_lh_hh.width;
                  const height = hl_lh_hh.height;
                  const items = hl_lh_hh.items;
                  let i, j, k, l, u, v;
                  for (k = 0, i = 0; i < llHeight; i++) {
                    l = i * 2 * width;
                    for (j = 0; j < llWidth; j++, k++, l += 2) {
                      items[l] = llItems[k];
                    }
                  }
                  llItems = ll.items = null;
                  const bufferPadding = 4;
                  const rowBuffer = new Float32Array(width + 2 * bufferPadding);
                  if (width === 1) {
                    if ((u0 & 1) !== 0) {
                      for (v = 0, k = 0; v < height; v++, k += width) {
                        items[k] *= 0.5;
                      }
                    }
                  } else {
                    for (v = 0, k = 0; v < height; v++, k += width) {
                      rowBuffer.set(items.subarray(k, k + width), bufferPadding);
                      this.extend(rowBuffer, bufferPadding, width);
                      this.filter(rowBuffer, bufferPadding, width);
                      items.set(rowBuffer.subarray(bufferPadding, bufferPadding + width), k);
                    }
                  }
                  let numBuffers = 16;
                  const colBuffers = [];
                  for (i = 0; i < numBuffers; i++) {
                    colBuffers.push(new Float32Array(height + 2 * bufferPadding));
                  }
                  let b, currentBuffer = 0;
                  ll = bufferPadding + height;
                  if (height === 1) {
                    if ((v0 & 1) !== 0) {
                      for (u = 0; u < width; u++) {
                        items[u] *= 0.5;
                      }
                    }
                  } else {
                    for (u = 0; u < width; u++) {
                      if (currentBuffer === 0) {
                        numBuffers = Math.min(width - u, numBuffers);
                        for (k = u, l = bufferPadding; l < ll; k += width, l++) {
                          for (b = 0; b < numBuffers; b++) {
                            colBuffers[b][l] = items[k + b];
                          }
                        }
                        currentBuffer = numBuffers;
                      }
                      currentBuffer--;
                      const buffer = colBuffers[currentBuffer];
                      this.extend(buffer, bufferPadding, height);
                      this.filter(buffer, bufferPadding, height);
                      if (currentBuffer === 0) {
                        k = u - numBuffers + 1;
                        for (l = bufferPadding; l < ll; k += width, l++) {
                          for (b = 0; b < numBuffers; b++) {
                            items[k + b] = colBuffers[b][l];
                          }
                        }
                      }
                    }
                  }
                  return {
                    width,
                    height,
                    items
                  };
                }
              };
              __name(_Transform, "Transform");
              let Transform = _Transform;
              const _IrreversibleTransform = class _IrreversibleTransform extends Transform {
                filter(x, offset, length) {
                  const len = length >> 1;
                  offset |= 0;
                  let j, n, current, next;
                  const alpha = -1.586134342059924;
                  const beta = -0.052980118572961;
                  const gamma = 0.882911075530934;
                  const delta = 0.443506852043971;
                  const K = 1.230174104914001;
                  const K_ = 1 / K;
                  j = offset - 3;
                  for (n = len + 4; n--; j += 2) {
                    x[j] *= K_;
                  }
                  j = offset - 2;
                  current = delta * x[j - 1];
                  for (n = len + 3; n--; j += 2) {
                    next = delta * x[j + 1];
                    x[j] = K * x[j] - current - next;
                    if (n--) {
                      j += 2;
                      current = delta * x[j + 1];
                      x[j] = K * x[j] - current - next;
                    } else {
                      break;
                    }
                  }
                  j = offset - 1;
                  current = gamma * x[j - 1];
                  for (n = len + 2; n--; j += 2) {
                    next = gamma * x[j + 1];
                    x[j] -= current + next;
                    if (n--) {
                      j += 2;
                      current = gamma * x[j + 1];
                      x[j] -= current + next;
                    } else {
                      break;
                    }
                  }
                  j = offset;
                  current = beta * x[j - 1];
                  for (n = len + 1; n--; j += 2) {
                    next = beta * x[j + 1];
                    x[j] -= current + next;
                    if (n--) {
                      j += 2;
                      current = beta * x[j + 1];
                      x[j] -= current + next;
                    } else {
                      break;
                    }
                  }
                  if (len !== 0) {
                    j = offset + 1;
                    current = alpha * x[j - 1];
                    for (n = len; n--; j += 2) {
                      next = alpha * x[j + 1];
                      x[j] -= current + next;
                      if (n--) {
                        j += 2;
                        current = alpha * x[j + 1];
                        x[j] -= current + next;
                      } else {
                        break;
                      }
                    }
                  }
                }
              };
              __name(_IrreversibleTransform, "IrreversibleTransform");
              let IrreversibleTransform = _IrreversibleTransform;
              const _ReversibleTransform = class _ReversibleTransform extends Transform {
                filter(x, offset, length) {
                  const len = length >> 1;
                  offset |= 0;
                  let j, n;
                  for (j = offset, n = len + 1; n--; j += 2) {
                    x[j] -= x[j - 1] + x[j + 1] + 2 >> 2;
                  }
                  for (j = offset + 1, n = len; n--; j += 2) {
                    x[j] += x[j - 1] + x[j + 1] >> 1;
                  }
                }
              };
              __name(_ReversibleTransform, "ReversibleTransform");
              let ReversibleTransform = _ReversibleTransform;
            },
            /* 156 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.LZWStream = void 0;
              var _decode_stream = __w_pdfjs_require__2(144);
              const _LZWStream = class _LZWStream extends _decode_stream.DecodeStream {
                constructor(str, maybeLength, earlyChange) {
                  super(maybeLength);
                  this.str = str;
                  this.dict = str.dict;
                  this.cachedData = 0;
                  this.bitsCached = 0;
                  const maxLzwDictionarySize = 4096;
                  const lzwState = {
                    earlyChange,
                    codeLength: 9,
                    nextCode: 258,
                    dictionaryValues: new Uint8Array(maxLzwDictionarySize),
                    dictionaryLengths: new Uint16Array(maxLzwDictionarySize),
                    dictionaryPrevCodes: new Uint16Array(maxLzwDictionarySize),
                    currentSequence: new Uint8Array(maxLzwDictionarySize),
                    currentSequenceLength: 0
                  };
                  for (let i = 0; i < 256; ++i) {
                    lzwState.dictionaryValues[i] = i;
                    lzwState.dictionaryLengths[i] = 1;
                  }
                  this.lzwState = lzwState;
                }
                readBits(n) {
                  let bitsCached = this.bitsCached;
                  let cachedData = this.cachedData;
                  while (bitsCached < n) {
                    const c = this.str.getByte();
                    if (c === -1) {
                      this.eof = true;
                      return null;
                    }
                    cachedData = cachedData << 8 | c;
                    bitsCached += 8;
                  }
                  this.bitsCached = bitsCached -= n;
                  this.cachedData = cachedData;
                  this.lastCode = null;
                  return cachedData >>> bitsCached & (1 << n) - 1;
                }
                readBlock() {
                  const blockSize = 512, decodedSizeDelta = blockSize;
                  let estimatedDecodedSize = blockSize * 2;
                  let i, j, q;
                  const lzwState = this.lzwState;
                  if (!lzwState) {
                    return;
                  }
                  const earlyChange = lzwState.earlyChange;
                  let nextCode = lzwState.nextCode;
                  const dictionaryValues = lzwState.dictionaryValues;
                  const dictionaryLengths = lzwState.dictionaryLengths;
                  const dictionaryPrevCodes = lzwState.dictionaryPrevCodes;
                  let codeLength = lzwState.codeLength;
                  let prevCode = lzwState.prevCode;
                  const currentSequence = lzwState.currentSequence;
                  let currentSequenceLength = lzwState.currentSequenceLength;
                  let decodedLength = 0;
                  let currentBufferLength = this.bufferLength;
                  let buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
                  for (i = 0; i < blockSize; i++) {
                    const code = this.readBits(codeLength);
                    const hasPrev = currentSequenceLength > 0;
                    if (code < 256) {
                      currentSequence[0] = code;
                      currentSequenceLength = 1;
                    } else if (code >= 258) {
                      if (code < nextCode) {
                        currentSequenceLength = dictionaryLengths[code];
                        for (j = currentSequenceLength - 1, q = code; j >= 0; j--) {
                          currentSequence[j] = dictionaryValues[q];
                          q = dictionaryPrevCodes[q];
                        }
                      } else {
                        currentSequence[currentSequenceLength++] = currentSequence[0];
                      }
                    } else if (code === 256) {
                      codeLength = 9;
                      nextCode = 258;
                      currentSequenceLength = 0;
                      continue;
                    } else {
                      this.eof = true;
                      delete this.lzwState;
                      break;
                    }
                    if (hasPrev) {
                      dictionaryPrevCodes[nextCode] = prevCode;
                      dictionaryLengths[nextCode] = dictionaryLengths[prevCode] + 1;
                      dictionaryValues[nextCode] = currentSequence[0];
                      nextCode++;
                      codeLength = nextCode + earlyChange & nextCode + earlyChange - 1 ? codeLength : Math.min(Math.log(nextCode + earlyChange) / 0.6931471805599453 + 1, 12) | 0;
                    }
                    prevCode = code;
                    decodedLength += currentSequenceLength;
                    if (estimatedDecodedSize < decodedLength) {
                      do {
                        estimatedDecodedSize += decodedSizeDelta;
                      } while (estimatedDecodedSize < decodedLength);
                      buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
                    }
                    for (j = 0; j < currentSequenceLength; j++) {
                      buffer[currentBufferLength++] = currentSequence[j];
                    }
                  }
                  lzwState.nextCode = nextCode;
                  lzwState.codeLength = codeLength;
                  lzwState.prevCode = prevCode;
                  lzwState.currentSequenceLength = currentSequenceLength;
                  this.bufferLength = currentBufferLength;
                }
              };
              __name(_LZWStream, "LZWStream");
              let LZWStream = _LZWStream;
              exports2.LZWStream = LZWStream;
            },
            /* 157 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PredictorStream = void 0;
              var _decode_stream = __w_pdfjs_require__2(144);
              var _primitives = __w_pdfjs_require__2(130);
              var _util = __w_pdfjs_require__2(2);
              const _PredictorStream = class _PredictorStream extends _decode_stream.DecodeStream {
                constructor(str, maybeLength, params) {
                  super(maybeLength);
                  if (!(params instanceof _primitives.Dict)) {
                    return str;
                  }
                  const predictor = this.predictor = params.get("Predictor") || 1;
                  if (predictor <= 1) {
                    return str;
                  }
                  if (predictor !== 2 && (predictor < 10 || predictor > 15)) {
                    throw new _util.FormatError(`Unsupported predictor: ${predictor}`);
                  }
                  if (predictor === 2) {
                    this.readBlock = this.readBlockTiff;
                  } else {
                    this.readBlock = this.readBlockPng;
                  }
                  this.str = str;
                  this.dict = str.dict;
                  const colors = this.colors = params.get("Colors") || 1;
                  const bits = this.bits = params.get("BPC", "BitsPerComponent") || 8;
                  const columns = this.columns = params.get("Columns") || 1;
                  this.pixBytes = colors * bits + 7 >> 3;
                  this.rowBytes = columns * colors * bits + 7 >> 3;
                  return this;
                }
                readBlockTiff() {
                  const rowBytes = this.rowBytes;
                  const bufferLength = this.bufferLength;
                  const buffer = this.ensureBuffer(bufferLength + rowBytes);
                  const bits = this.bits;
                  const colors = this.colors;
                  const rawBytes = this.str.getBytes(rowBytes);
                  this.eof = !rawBytes.length;
                  if (this.eof) {
                    return;
                  }
                  let inbuf = 0, outbuf = 0;
                  let inbits = 0, outbits = 0;
                  let pos = bufferLength;
                  let i;
                  if (bits === 1 && colors === 1) {
                    for (i = 0; i < rowBytes; ++i) {
                      let c = rawBytes[i] ^ inbuf;
                      c ^= c >> 1;
                      c ^= c >> 2;
                      c ^= c >> 4;
                      inbuf = (c & 1) << 7;
                      buffer[pos++] = c;
                    }
                  } else if (bits === 8) {
                    for (i = 0; i < colors; ++i) {
                      buffer[pos++] = rawBytes[i];
                    }
                    for (; i < rowBytes; ++i) {
                      buffer[pos] = buffer[pos - colors] + rawBytes[i];
                      pos++;
                    }
                  } else if (bits === 16) {
                    const bytesPerPixel = colors * 2;
                    for (i = 0; i < bytesPerPixel; ++i) {
                      buffer[pos++] = rawBytes[i];
                    }
                    for (; i < rowBytes; i += 2) {
                      const sum = ((rawBytes[i] & 255) << 8) + (rawBytes[i + 1] & 255) + ((buffer[pos - bytesPerPixel] & 255) << 8) + (buffer[pos - bytesPerPixel + 1] & 255);
                      buffer[pos++] = sum >> 8 & 255;
                      buffer[pos++] = sum & 255;
                    }
                  } else {
                    const compArray = new Uint8Array(colors + 1);
                    const bitMask = (1 << bits) - 1;
                    let j = 0, k = bufferLength;
                    const columns = this.columns;
                    for (i = 0; i < columns; ++i) {
                      for (let kk = 0; kk < colors; ++kk) {
                        if (inbits < bits) {
                          inbuf = inbuf << 8 | rawBytes[j++] & 255;
                          inbits += 8;
                        }
                        compArray[kk] = compArray[kk] + (inbuf >> inbits - bits) & bitMask;
                        inbits -= bits;
                        outbuf = outbuf << bits | compArray[kk];
                        outbits += bits;
                        if (outbits >= 8) {
                          buffer[k++] = outbuf >> outbits - 8 & 255;
                          outbits -= 8;
                        }
                      }
                    }
                    if (outbits > 0) {
                      buffer[k++] = (outbuf << 8 - outbits) + (inbuf & (1 << 8 - outbits) - 1);
                    }
                  }
                  this.bufferLength += rowBytes;
                }
                readBlockPng() {
                  const rowBytes = this.rowBytes;
                  const pixBytes = this.pixBytes;
                  const predictor = this.str.getByte();
                  const rawBytes = this.str.getBytes(rowBytes);
                  this.eof = !rawBytes.length;
                  if (this.eof) {
                    return;
                  }
                  const bufferLength = this.bufferLength;
                  const buffer = this.ensureBuffer(bufferLength + rowBytes);
                  let prevRow = buffer.subarray(bufferLength - rowBytes, bufferLength);
                  if (prevRow.length === 0) {
                    prevRow = new Uint8Array(rowBytes);
                  }
                  let i, j = bufferLength, up, c;
                  switch (predictor) {
                    case 0:
                      for (i = 0; i < rowBytes; ++i) {
                        buffer[j++] = rawBytes[i];
                      }
                      break;
                    case 1:
                      for (i = 0; i < pixBytes; ++i) {
                        buffer[j++] = rawBytes[i];
                      }
                      for (; i < rowBytes; ++i) {
                        buffer[j] = buffer[j - pixBytes] + rawBytes[i] & 255;
                        j++;
                      }
                      break;
                    case 2:
                      for (i = 0; i < rowBytes; ++i) {
                        buffer[j++] = prevRow[i] + rawBytes[i] & 255;
                      }
                      break;
                    case 3:
                      for (i = 0; i < pixBytes; ++i) {
                        buffer[j++] = (prevRow[i] >> 1) + rawBytes[i];
                      }
                      for (; i < rowBytes; ++i) {
                        buffer[j] = (prevRow[i] + buffer[j - pixBytes] >> 1) + rawBytes[i] & 255;
                        j++;
                      }
                      break;
                    case 4:
                      for (i = 0; i < pixBytes; ++i) {
                        up = prevRow[i];
                        c = rawBytes[i];
                        buffer[j++] = up + c;
                      }
                      for (; i < rowBytes; ++i) {
                        up = prevRow[i];
                        const upLeft = prevRow[i - pixBytes];
                        const left = buffer[j - pixBytes];
                        const p = left + up - upLeft;
                        let pa = p - left;
                        if (pa < 0) {
                          pa = -pa;
                        }
                        let pb = p - up;
                        if (pb < 0) {
                          pb = -pb;
                        }
                        let pc = p - upLeft;
                        if (pc < 0) {
                          pc = -pc;
                        }
                        c = rawBytes[i];
                        if (pa <= pb && pa <= pc) {
                          buffer[j++] = left + c;
                        } else if (pb <= pc) {
                          buffer[j++] = up + c;
                        } else {
                          buffer[j++] = upLeft + c;
                        }
                      }
                      break;
                    default:
                      throw new _util.FormatError(`Unsupported predictor: ${predictor}`);
                  }
                  this.bufferLength += rowBytes;
                }
              };
              __name(_PredictorStream, "PredictorStream");
              let PredictorStream = _PredictorStream;
              exports2.PredictorStream = PredictorStream;
            },
            /* 158 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.RunLengthStream = void 0;
              var _decode_stream = __w_pdfjs_require__2(144);
              const _RunLengthStream = class _RunLengthStream extends _decode_stream.DecodeStream {
                constructor(str, maybeLength) {
                  super(maybeLength);
                  this.str = str;
                  this.dict = str.dict;
                }
                readBlock() {
                  const repeatHeader = this.str.getBytes(2);
                  if (!repeatHeader || repeatHeader.length < 2 || repeatHeader[0] === 128) {
                    this.eof = true;
                    return;
                  }
                  let buffer;
                  let bufferLength = this.bufferLength;
                  let n = repeatHeader[0];
                  if (n < 128) {
                    buffer = this.ensureBuffer(bufferLength + n + 1);
                    buffer[bufferLength++] = repeatHeader[1];
                    if (n > 0) {
                      const source = this.str.getBytes(n);
                      buffer.set(source, bufferLength);
                      bufferLength += n;
                    }
                  } else {
                    n = 257 - n;
                    const b = repeatHeader[1];
                    buffer = this.ensureBuffer(bufferLength + n + 1);
                    for (let i = 0; i < n; i++) {
                      buffer[bufferLength++] = b;
                    }
                  }
                  this.bufferLength = bufferLength;
                }
              };
              __name(_RunLengthStream, "RunLengthStream");
              let RunLengthStream = _RunLengthStream;
              exports2.RunLengthStream = RunLengthStream;
            },
            /* 159 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Font = exports2.ErrorFont = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _cff_parser = __w_pdfjs_require__2(160);
              var _fonts_utils = __w_pdfjs_require__2(163);
              var _unicode = __w_pdfjs_require__2(165);
              var _glyphlist = __w_pdfjs_require__2(164);
              var _encodings = __w_pdfjs_require__2(162);
              var _standard_fonts = __w_pdfjs_require__2(166);
              var _to_unicode_map = __w_pdfjs_require__2(167);
              var _cff_font = __w_pdfjs_require__2(168);
              var _font_renderer = __w_pdfjs_require__2(169);
              var _metrics = __w_pdfjs_require__2(170);
              var _glyf = __w_pdfjs_require__2(171);
              var _cmap = __w_pdfjs_require__2(141);
              var _opentype_file_builder = __w_pdfjs_require__2(172);
              var _core_utils = __w_pdfjs_require__2(131);
              var _stream = __w_pdfjs_require__2(135);
              var _type1_font = __w_pdfjs_require__2(173);
              const PRIVATE_USE_AREAS = [[57344, 63743], [1048576, 1114109]];
              const PDF_GLYPH_SPACE_UNITS = 1e3;
              const EXPORT_DATA_PROPERTIES = ["ascent", "bbox", "black", "bold", "charProcOperatorList", "composite", "cssFontInfo", "data", "defaultVMetrics", "defaultWidth", "descent", "fallbackName", "fontMatrix", "fontType", "isType3Font", "italic", "loadedName", "mimetype", "missingFile", "name", "remeasure", "subtype", "type", "vertical"];
              const EXPORT_DATA_EXTRA_PROPERTIES = ["cMap", "defaultEncoding", "differences", "isMonospace", "isSerifFont", "isSymbolicFont", "seacMap", "toFontChar", "toUnicode", "vmetrics", "widths"];
              function adjustWidths(properties) {
                if (!properties.fontMatrix) {
                  return;
                }
                if (properties.fontMatrix[0] === _util.FONT_IDENTITY_MATRIX[0]) {
                  return;
                }
                const scale = 1e-3 / properties.fontMatrix[0];
                const glyphsWidths = properties.widths;
                for (const glyph in glyphsWidths) {
                  glyphsWidths[glyph] *= scale;
                }
                properties.defaultWidth *= scale;
              }
              __name(adjustWidths, "adjustWidths");
              function adjustToUnicode(properties, builtInEncoding) {
                if (properties.isInternalFont) {
                  return;
                }
                if (builtInEncoding === properties.defaultEncoding) {
                  return;
                }
                if (properties.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap) {
                  return;
                }
                const toUnicode = [], glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
                for (const charCode in builtInEncoding) {
                  if (properties.hasIncludedToUnicodeMap) {
                    if (properties.toUnicode.has(charCode)) {
                      continue;
                    }
                  } else if (properties.hasEncoding) {
                    if (properties.differences.length === 0 || properties.differences[charCode] !== void 0) {
                      continue;
                    }
                  }
                  const glyphName = builtInEncoding[charCode];
                  const unicode = (0, _unicode.getUnicodeForGlyph)(glyphName, glyphsUnicodeMap);
                  if (unicode !== -1) {
                    toUnicode[charCode] = String.fromCharCode(unicode);
                  }
                }
                if (toUnicode.length > 0) {
                  properties.toUnicode.amend(toUnicode);
                }
              }
              __name(adjustToUnicode, "adjustToUnicode");
              function amendFallbackToUnicode(properties) {
                if (!properties.fallbackToUnicode) {
                  return;
                }
                if (properties.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap) {
                  return;
                }
                const toUnicode = [];
                for (const charCode in properties.fallbackToUnicode) {
                  if (properties.toUnicode.has(charCode)) {
                    continue;
                  }
                  toUnicode[charCode] = properties.fallbackToUnicode[charCode];
                }
                if (toUnicode.length > 0) {
                  properties.toUnicode.amend(toUnicode);
                }
              }
              __name(amendFallbackToUnicode, "amendFallbackToUnicode");
              const _Glyph = class _Glyph {
                constructor(originalCharCode, fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont) {
                  this.originalCharCode = originalCharCode;
                  this.fontChar = fontChar;
                  this.unicode = unicode;
                  this.accent = accent;
                  this.width = width;
                  this.vmetric = vmetric;
                  this.operatorListId = operatorListId;
                  this.isSpace = isSpace;
                  this.isInFont = isInFont;
                  const category = (0, _unicode.getCharUnicodeCategory)(unicode);
                  this.isWhitespace = category.isWhitespace;
                  this.isZeroWidthDiacritic = category.isZeroWidthDiacritic;
                  this.isInvisibleFormatMark = category.isInvisibleFormatMark;
                }
                matchesForCache(originalCharCode, fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont) {
                  return this.originalCharCode === originalCharCode && this.fontChar === fontChar && this.unicode === unicode && this.accent === accent && this.width === width && this.vmetric === vmetric && this.operatorListId === operatorListId && this.isSpace === isSpace && this.isInFont === isInFont;
                }
              };
              __name(_Glyph, "Glyph");
              let Glyph = _Glyph;
              function int16(b0, b1) {
                return (b0 << 8) + b1;
              }
              __name(int16, "int16");
              function writeSignedInt16(bytes, index, value) {
                bytes[index + 1] = value;
                bytes[index] = value >>> 8;
              }
              __name(writeSignedInt16, "writeSignedInt16");
              function signedInt16(b0, b1) {
                const value = (b0 << 8) + b1;
                return value & 1 << 15 ? value - 65536 : value;
              }
              __name(signedInt16, "signedInt16");
              function int32(b0, b1, b2, b3) {
                return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
              }
              __name(int32, "int32");
              function string16(value) {
                return String.fromCharCode(value >> 8 & 255, value & 255);
              }
              __name(string16, "string16");
              function safeString16(value) {
                if (value > 32767) {
                  value = 32767;
                } else if (value < -32768) {
                  value = -32768;
                }
                return String.fromCharCode(value >> 8 & 255, value & 255);
              }
              __name(safeString16, "safeString16");
              function isTrueTypeFile(file) {
                const header = file.peekBytes(4);
                return (0, _core_utils.readUint32)(header, 0) === 65536 || (0, _util.bytesToString)(header) === "true";
              }
              __name(isTrueTypeFile, "isTrueTypeFile");
              function isTrueTypeCollectionFile(file) {
                const header = file.peekBytes(4);
                return (0, _util.bytesToString)(header) === "ttcf";
              }
              __name(isTrueTypeCollectionFile, "isTrueTypeCollectionFile");
              function isOpenTypeFile(file) {
                const header = file.peekBytes(4);
                return (0, _util.bytesToString)(header) === "OTTO";
              }
              __name(isOpenTypeFile, "isOpenTypeFile");
              function isType1File(file) {
                const header = file.peekBytes(2);
                if (header[0] === 37 && header[1] === 33) {
                  return true;
                }
                if (header[0] === 128 && header[1] === 1) {
                  return true;
                }
                return false;
              }
              __name(isType1File, "isType1File");
              function isCFFFile(file) {
                const header = file.peekBytes(4);
                if (header[0] >= 1 && header[3] >= 1 && header[3] <= 4) {
                  return true;
                }
                return false;
              }
              __name(isCFFFile, "isCFFFile");
              function getFontFileType(file, _ref) {
                let {
                  type,
                  subtype,
                  composite
                } = _ref;
                let fileType, fileSubtype;
                if (isTrueTypeFile(file) || isTrueTypeCollectionFile(file)) {
                  if (composite) {
                    fileType = "CIDFontType2";
                  } else {
                    fileType = "TrueType";
                  }
                } else if (isOpenTypeFile(file)) {
                  if (composite) {
                    fileType = "CIDFontType2";
                  } else {
                    fileType = "OpenType";
                  }
                } else if (isType1File(file)) {
                  if (composite) {
                    fileType = "CIDFontType0";
                  } else {
                    fileType = type === "MMType1" ? "MMType1" : "Type1";
                  }
                } else if (isCFFFile(file)) {
                  if (composite) {
                    fileType = "CIDFontType0";
                    fileSubtype = "CIDFontType0C";
                  } else {
                    fileType = type === "MMType1" ? "MMType1" : "Type1";
                    fileSubtype = "Type1C";
                  }
                } else {
                  (0, _util.warn)("getFontFileType: Unable to detect correct font file Type/Subtype.");
                  fileType = type;
                  fileSubtype = subtype;
                }
                return [fileType, fileSubtype];
              }
              __name(getFontFileType, "getFontFileType");
              function applyStandardFontGlyphMap(map, glyphMap) {
                for (const charCode in glyphMap) {
                  map[+charCode] = glyphMap[charCode];
                }
              }
              __name(applyStandardFontGlyphMap, "applyStandardFontGlyphMap");
              function buildToFontChar(encoding, glyphsUnicodeMap, differences) {
                const toFontChar = [];
                let unicode;
                for (let i = 0, ii = encoding.length; i < ii; i++) {
                  unicode = (0, _unicode.getUnicodeForGlyph)(encoding[i], glyphsUnicodeMap);
                  if (unicode !== -1) {
                    toFontChar[i] = unicode;
                  }
                }
                for (const charCode in differences) {
                  unicode = (0, _unicode.getUnicodeForGlyph)(differences[charCode], glyphsUnicodeMap);
                  if (unicode !== -1) {
                    toFontChar[+charCode] = unicode;
                  }
                }
                return toFontChar;
              }
              __name(buildToFontChar, "buildToFontChar");
              function convertCidString(charCode, cid) {
                let shouldThrow = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                switch (cid.length) {
                  case 1:
                    return cid.charCodeAt(0);
                  case 2:
                    return cid.charCodeAt(0) << 8 | cid.charCodeAt(1);
                }
                const msg = `Unsupported CID string (charCode ${charCode}): "${cid}".`;
                if (shouldThrow) {
                  throw new _util.FormatError(msg);
                }
                (0, _util.warn)(msg);
                return cid;
              }
              __name(convertCidString, "convertCidString");
              function adjustMapping(charCodeToGlyphId, hasGlyph, newGlyphZeroId, toUnicode) {
                const newMap = /* @__PURE__ */ Object.create(null);
                const toUnicodeExtraMap = /* @__PURE__ */ new Map();
                const toFontChar = [];
                const usedGlyphIds = /* @__PURE__ */ new Set();
                let privateUseAreaIndex = 0;
                const privateUseOffetStart = PRIVATE_USE_AREAS[privateUseAreaIndex][0];
                let nextAvailableFontCharCode = privateUseOffetStart;
                let privateUseOffetEnd = PRIVATE_USE_AREAS[privateUseAreaIndex][1];
                for (let originalCharCode in charCodeToGlyphId) {
                  originalCharCode |= 0;
                  let glyphId = charCodeToGlyphId[originalCharCode];
                  if (!hasGlyph(glyphId)) {
                    continue;
                  }
                  if (nextAvailableFontCharCode > privateUseOffetEnd) {
                    privateUseAreaIndex++;
                    if (privateUseAreaIndex >= PRIVATE_USE_AREAS.length) {
                      (0, _util.warn)("Ran out of space in font private use area.");
                      break;
                    }
                    nextAvailableFontCharCode = PRIVATE_USE_AREAS[privateUseAreaIndex][0];
                    privateUseOffetEnd = PRIVATE_USE_AREAS[privateUseAreaIndex][1];
                  }
                  const fontCharCode = nextAvailableFontCharCode++;
                  if (glyphId === 0) {
                    glyphId = newGlyphZeroId;
                  }
                  let unicode = toUnicode.get(originalCharCode);
                  if (typeof unicode === "string") {
                    unicode = unicode.codePointAt(0);
                  }
                  if (unicode && unicode < privateUseOffetStart && !usedGlyphIds.has(glyphId)) {
                    toUnicodeExtraMap.set(unicode, glyphId);
                    usedGlyphIds.add(glyphId);
                  }
                  newMap[fontCharCode] = glyphId;
                  toFontChar[originalCharCode] = fontCharCode;
                }
                return {
                  toFontChar,
                  charCodeToGlyphId: newMap,
                  toUnicodeExtraMap,
                  nextAvailableFontCharCode
                };
              }
              __name(adjustMapping, "adjustMapping");
              function getRanges(glyphs, toUnicodeExtraMap, numGlyphs) {
                const codes = [];
                for (const charCode in glyphs) {
                  if (glyphs[charCode] >= numGlyphs) {
                    continue;
                  }
                  codes.push({
                    fontCharCode: charCode | 0,
                    glyphId: glyphs[charCode]
                  });
                }
                if (toUnicodeExtraMap) {
                  for (const [unicode, glyphId] of toUnicodeExtraMap) {
                    if (glyphId >= numGlyphs) {
                      continue;
                    }
                    codes.push({
                      fontCharCode: unicode,
                      glyphId
                    });
                  }
                }
                if (codes.length === 0) {
                  codes.push({
                    fontCharCode: 0,
                    glyphId: 0
                  });
                }
                codes.sort(/* @__PURE__ */ __name(function fontGetRangesSort(a, b) {
                  return a.fontCharCode - b.fontCharCode;
                }, "fontGetRangesSort"));
                const ranges = [];
                const length = codes.length;
                for (let n = 0; n < length; ) {
                  const start = codes[n].fontCharCode;
                  const codeIndices = [codes[n].glyphId];
                  ++n;
                  let end = start;
                  while (n < length && end + 1 === codes[n].fontCharCode) {
                    codeIndices.push(codes[n].glyphId);
                    ++end;
                    ++n;
                    if (end === 65535) {
                      break;
                    }
                  }
                  ranges.push([start, end, codeIndices]);
                }
                return ranges;
              }
              __name(getRanges, "getRanges");
              function createCmapTable(glyphs, toUnicodeExtraMap, numGlyphs) {
                const ranges = getRanges(glyphs, toUnicodeExtraMap, numGlyphs);
                const numTables = ranges.at(-1)[1] > 65535 ? 2 : 1;
                let cmap = "\0\0" + string16(numTables) + "\0\0" + (0, _util.string32)(4 + numTables * 8);
                let i, ii, j, jj;
                for (i = ranges.length - 1; i >= 0; --i) {
                  if (ranges[i][0] <= 65535) {
                    break;
                  }
                }
                const bmpLength = i + 1;
                if (ranges[i][0] < 65535 && ranges[i][1] === 65535) {
                  ranges[i][1] = 65534;
                }
                const trailingRangesCount = ranges[i][1] < 65535 ? 1 : 0;
                const segCount = bmpLength + trailingRangesCount;
                const searchParams = _opentype_file_builder.OpenTypeFileBuilder.getSearchParams(segCount, 2);
                let startCount = "";
                let endCount = "";
                let idDeltas = "";
                let idRangeOffsets = "";
                let glyphsIds = "";
                let bias = 0;
                let range, start, end, codes;
                for (i = 0, ii = bmpLength; i < ii; i++) {
                  range = ranges[i];
                  start = range[0];
                  end = range[1];
                  startCount += string16(start);
                  endCount += string16(end);
                  codes = range[2];
                  let contiguous = true;
                  for (j = 1, jj = codes.length; j < jj; ++j) {
                    if (codes[j] !== codes[j - 1] + 1) {
                      contiguous = false;
                      break;
                    }
                  }
                  if (!contiguous) {
                    const offset = (segCount - i) * 2 + bias * 2;
                    bias += end - start + 1;
                    idDeltas += string16(0);
                    idRangeOffsets += string16(offset);
                    for (j = 0, jj = codes.length; j < jj; ++j) {
                      glyphsIds += string16(codes[j]);
                    }
                  } else {
                    const startCode = codes[0];
                    idDeltas += string16(startCode - start & 65535);
                    idRangeOffsets += string16(0);
                  }
                }
                if (trailingRangesCount > 0) {
                  endCount += "Ã¿Ã¿";
                  startCount += "Ã¿Ã¿";
                  idDeltas += "\0";
                  idRangeOffsets += "\0\0";
                }
                const format314 = "\0\0" + string16(2 * segCount) + string16(searchParams.range) + string16(searchParams.entry) + string16(searchParams.rangeShift) + endCount + "\0\0" + startCount + idDeltas + idRangeOffsets + glyphsIds;
                let format31012 = "";
                let header31012 = "";
                if (numTables > 1) {
                  cmap += "\0\0\n" + (0, _util.string32)(4 + numTables * 8 + 4 + format314.length);
                  format31012 = "";
                  for (i = 0, ii = ranges.length; i < ii; i++) {
                    range = ranges[i];
                    start = range[0];
                    codes = range[2];
                    let code = codes[0];
                    for (j = 1, jj = codes.length; j < jj; ++j) {
                      if (codes[j] !== codes[j - 1] + 1) {
                        end = range[0] + j - 1;
                        format31012 += (0, _util.string32)(start) + (0, _util.string32)(end) + (0, _util.string32)(code);
                        start = end + 1;
                        code = codes[j];
                      }
                    }
                    format31012 += (0, _util.string32)(start) + (0, _util.string32)(range[1]) + (0, _util.string32)(code);
                  }
                  header31012 = "\0\f\0\0" + (0, _util.string32)(format31012.length + 16) + "\0\0\0\0" + (0, _util.string32)(format31012.length / 12);
                }
                return cmap + "\0" + string16(format314.length + 4) + format314 + header31012 + format31012;
              }
              __name(createCmapTable, "createCmapTable");
              function validateOS2Table(os2, file) {
                file.pos = (file.start || 0) + os2.offset;
                const version = file.getUint16();
                file.skip(60);
                const selection = file.getUint16();
                if (version < 4 && selection & 768) {
                  return false;
                }
                const firstChar = file.getUint16();
                const lastChar = file.getUint16();
                if (firstChar > lastChar) {
                  return false;
                }
                file.skip(6);
                const usWinAscent = file.getUint16();
                if (usWinAscent === 0) {
                  return false;
                }
                os2.data[8] = os2.data[9] = 0;
                return true;
              }
              __name(validateOS2Table, "validateOS2Table");
              function createOS2Table(properties, charstrings, override) {
                override = override || {
                  unitsPerEm: 0,
                  yMax: 0,
                  yMin: 0,
                  ascent: 0,
                  descent: 0
                };
                let ulUnicodeRange1 = 0;
                let ulUnicodeRange2 = 0;
                let ulUnicodeRange3 = 0;
                let ulUnicodeRange4 = 0;
                let firstCharIndex = null;
                let lastCharIndex = 0;
                if (charstrings) {
                  for (let code in charstrings) {
                    code |= 0;
                    if (firstCharIndex > code || !firstCharIndex) {
                      firstCharIndex = code;
                    }
                    if (lastCharIndex < code) {
                      lastCharIndex = code;
                    }
                    const position = (0, _unicode.getUnicodeRangeFor)(code);
                    if (position < 32) {
                      ulUnicodeRange1 |= 1 << position;
                    } else if (position < 64) {
                      ulUnicodeRange2 |= 1 << position - 32;
                    } else if (position < 96) {
                      ulUnicodeRange3 |= 1 << position - 64;
                    } else if (position < 123) {
                      ulUnicodeRange4 |= 1 << position - 96;
                    } else {
                      throw new _util.FormatError("Unicode ranges Bits > 123 are reserved for internal usage");
                    }
                  }
                  if (lastCharIndex > 65535) {
                    lastCharIndex = 65535;
                  }
                } else {
                  firstCharIndex = 0;
                  lastCharIndex = 255;
                }
                const bbox = properties.bbox || [0, 0, 0, 0];
                const unitsPerEm = override.unitsPerEm || 1 / (properties.fontMatrix || _util.FONT_IDENTITY_MATRIX)[0];
                const scale = properties.ascentScaled ? 1 : unitsPerEm / PDF_GLYPH_SPACE_UNITS;
                const typoAscent = override.ascent || Math.round(scale * (properties.ascent || bbox[3]));
                let typoDescent = override.descent || Math.round(scale * (properties.descent || bbox[1]));
                if (typoDescent > 0 && properties.descent > 0 && bbox[1] < 0) {
                  typoDescent = -typoDescent;
                }
                const winAscent = override.yMax || typoAscent;
                const winDescent = -override.yMin || -typoDescent;
                return "\0$Ã´\0\0\0ÂÂ»\0\0\0ÂÂÂ»\0\0Ã\x001\0\0\0\0" + String.fromCharCode(properties.fixedPitch ? 9 : 0) + "\0\0\0\0\0\0" + (0, _util.string32)(ulUnicodeRange1) + (0, _util.string32)(ulUnicodeRange2) + (0, _util.string32)(ulUnicodeRange3) + (0, _util.string32)(ulUnicodeRange4) + "*21*" + string16(properties.italicAngle ? 1 : 0) + string16(firstCharIndex || properties.firstChar) + string16(lastCharIndex || properties.lastChar) + string16(typoAscent) + string16(typoDescent) + "\0d" + string16(winAscent) + string16(winDescent) + "\0\0\0\0\0\0\0\0" + string16(properties.xHeight) + string16(properties.capHeight) + string16(0) + string16(firstCharIndex || properties.firstChar) + "\0";
              }
              __name(createOS2Table, "createOS2Table");
              function createPostTable(properties) {
                const angle = Math.floor(properties.italicAngle * 2 ** 16);
                return "\0\0\0" + (0, _util.string32)(angle) + "\0\0\0\0" + (0, _util.string32)(properties.fixedPitch ? 1 : 0) + "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
              }
              __name(createPostTable, "createPostTable");
              function createPostscriptName(name) {
                return name.replace(/[^\x21-\x7E]|[[\](){}<>/%]/g, "").slice(0, 63);
              }
              __name(createPostscriptName, "createPostscriptName");
              function createNameTable(name, proto) {
                if (!proto) {
                  proto = [[], []];
                }
                const strings = [proto[0][0] || "Original licence", proto[0][1] || name, proto[0][2] || "Unknown", proto[0][3] || "uniqueID", proto[0][4] || name, proto[0][5] || "Version 0.11", proto[0][6] || createPostscriptName(name), proto[0][7] || "Unknown", proto[0][8] || "Unknown", proto[0][9] || "Unknown"];
                const stringsUnicode = [];
                let i, ii, j, jj, str;
                for (i = 0, ii = strings.length; i < ii; i++) {
                  str = proto[1][i] || strings[i];
                  const strBufUnicode = [];
                  for (j = 0, jj = str.length; j < jj; j++) {
                    strBufUnicode.push(string16(str.charCodeAt(j)));
                  }
                  stringsUnicode.push(strBufUnicode.join(""));
                }
                const names = [strings, stringsUnicode];
                const platforms = ["\0", "\0"];
                const encodings = ["\0\0", "\0"];
                const languages = ["\0\0", "	"];
                const namesRecordCount = strings.length * platforms.length;
                let nameTable = "\0\0" + string16(namesRecordCount) + string16(namesRecordCount * 12 + 6);
                let strOffset = 0;
                for (i = 0, ii = platforms.length; i < ii; i++) {
                  const strs = names[i];
                  for (j = 0, jj = strs.length; j < jj; j++) {
                    str = strs[j];
                    const nameRecord = platforms[i] + encodings[i] + languages[i] + string16(j) + string16(str.length) + string16(strOffset);
                    nameTable += nameRecord;
                    strOffset += str.length;
                  }
                }
                nameTable += strings.join("") + stringsUnicode.join("");
                return nameTable;
              }
              __name(createNameTable, "createNameTable");
              const _Font = class _Font {
                constructor(name, file, properties) {
                  this.name = name;
                  this.psName = null;
                  this.mimetype = null;
                  this.disableFontFace = false;
                  this.loadedName = properties.loadedName;
                  this.isType3Font = properties.isType3Font;
                  this.missingFile = false;
                  this.cssFontInfo = properties.cssFontInfo;
                  this._charsCache = /* @__PURE__ */ Object.create(null);
                  this._glyphCache = /* @__PURE__ */ Object.create(null);
                  let isSerifFont = !!(properties.flags & _fonts_utils.FontFlags.Serif);
                  if (!isSerifFont && !properties.isSimulatedFlags) {
                    const baseName = name.replace(/[,_]/g, "-").split("-")[0], serifFonts = (0, _standard_fonts.getSerifFonts)();
                    for (const namePart of baseName.split("+")) {
                      if (serifFonts[namePart]) {
                        isSerifFont = true;
                        break;
                      }
                    }
                  }
                  this.isSerifFont = isSerifFont;
                  this.isSymbolicFont = !!(properties.flags & _fonts_utils.FontFlags.Symbolic);
                  this.isMonospace = !!(properties.flags & _fonts_utils.FontFlags.FixedPitch);
                  let type = properties.type;
                  let subtype = properties.subtype;
                  this.type = type;
                  this.subtype = subtype;
                  let fallbackName = "sans-serif";
                  if (this.isMonospace) {
                    fallbackName = "monospace";
                  } else if (this.isSerifFont) {
                    fallbackName = "serif";
                  }
                  this.fallbackName = fallbackName;
                  this.differences = properties.differences;
                  this.widths = properties.widths;
                  this.defaultWidth = properties.defaultWidth;
                  this.composite = properties.composite;
                  this.cMap = properties.cMap;
                  this.capHeight = properties.capHeight / PDF_GLYPH_SPACE_UNITS;
                  this.ascent = properties.ascent / PDF_GLYPH_SPACE_UNITS;
                  this.descent = properties.descent / PDF_GLYPH_SPACE_UNITS;
                  this.lineHeight = this.ascent - this.descent;
                  this.fontMatrix = properties.fontMatrix;
                  this.bbox = properties.bbox;
                  this.defaultEncoding = properties.defaultEncoding;
                  this.toUnicode = properties.toUnicode;
                  this.toFontChar = [];
                  if (properties.type === "Type3") {
                    for (let charCode = 0; charCode < 256; charCode++) {
                      this.toFontChar[charCode] = this.differences[charCode] || properties.defaultEncoding[charCode];
                    }
                    this.fontType = _util.FontType.TYPE3;
                    return;
                  }
                  this.cidEncoding = properties.cidEncoding || "";
                  this.vertical = !!properties.vertical;
                  if (this.vertical) {
                    this.vmetrics = properties.vmetrics;
                    this.defaultVMetrics = properties.defaultVMetrics;
                  }
                  if (!file || file.isEmpty) {
                    if (file) {
                      (0, _util.warn)('Font file is empty in "' + name + '" (' + this.loadedName + ")");
                    }
                    this.fallbackToSystemFont(properties);
                    return;
                  }
                  [type, subtype] = getFontFileType(file, properties);
                  if (type !== this.type || subtype !== this.subtype) {
                    (0, _util.info)(`Inconsistent font file Type/SubType, expected: ${this.type}/${this.subtype} but found: ${type}/${subtype}.`);
                  }
                  let data;
                  try {
                    switch (type) {
                      case "MMType1":
                        (0, _util.info)("MMType1 font (" + name + "), falling back to Type1.");
                      case "Type1":
                      case "CIDFontType0":
                        this.mimetype = "font/opentype";
                        const cff = subtype === "Type1C" || subtype === "CIDFontType0C" ? new _cff_font.CFFFont(file, properties) : new _type1_font.Type1Font(name, file, properties);
                        adjustWidths(properties);
                        data = this.convert(name, cff, properties);
                        break;
                      case "OpenType":
                      case "TrueType":
                      case "CIDFontType2":
                        this.mimetype = "font/opentype";
                        data = this.checkAndRepair(name, file, properties);
                        if (this.isOpenType) {
                          adjustWidths(properties);
                          type = "OpenType";
                        }
                        break;
                      default:
                        throw new _util.FormatError(`Font ${type} is not supported`);
                    }
                  } catch (e) {
                    (0, _util.warn)(e);
                    this.fallbackToSystemFont(properties);
                    return;
                  }
                  amendFallbackToUnicode(properties);
                  this.data = data;
                  this.fontType = (0, _fonts_utils.getFontType)(type, subtype, properties.isStandardFont);
                  this.fontMatrix = properties.fontMatrix;
                  this.widths = properties.widths;
                  this.defaultWidth = properties.defaultWidth;
                  this.toUnicode = properties.toUnicode;
                  this.seacMap = properties.seacMap;
                }
                get renderer() {
                  const renderer = _font_renderer.FontRendererFactory.create(this, _fonts_utils.SEAC_ANALYSIS_ENABLED);
                  return (0, _util.shadow)(this, "renderer", renderer);
                }
                exportData() {
                  let extraProperties = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  const exportDataProperties = extraProperties ? [...EXPORT_DATA_PROPERTIES, ...EXPORT_DATA_EXTRA_PROPERTIES] : EXPORT_DATA_PROPERTIES;
                  const data = /* @__PURE__ */ Object.create(null);
                  let property, value;
                  for (property of exportDataProperties) {
                    value = this[property];
                    if (value !== void 0) {
                      data[property] = value;
                    }
                  }
                  return data;
                }
                fallbackToSystemFont(properties) {
                  this.missingFile = true;
                  const name = this.name;
                  const type = this.type;
                  const subtype = this.subtype;
                  let fontName = (0, _fonts_utils.normalizeFontName)(name);
                  const stdFontMap = (0, _standard_fonts.getStdFontMap)(), nonStdFontMap = (0, _standard_fonts.getNonStdFontMap)();
                  const isStandardFont = !!stdFontMap[fontName];
                  const isMappedToStandardFont = !!(nonStdFontMap[fontName] && stdFontMap[nonStdFontMap[fontName]]);
                  fontName = stdFontMap[fontName] || nonStdFontMap[fontName] || fontName;
                  const fontBasicMetricsMap = (0, _metrics.getFontBasicMetrics)();
                  const metrics = fontBasicMetricsMap[fontName];
                  if (metrics) {
                    if (isNaN(this.ascent)) {
                      this.ascent = metrics.ascent / PDF_GLYPH_SPACE_UNITS;
                    }
                    if (isNaN(this.descent)) {
                      this.descent = metrics.descent / PDF_GLYPH_SPACE_UNITS;
                    }
                    if (isNaN(this.capHeight)) {
                      this.capHeight = metrics.capHeight / PDF_GLYPH_SPACE_UNITS;
                    }
                  }
                  this.bold = fontName.search(/bold/gi) !== -1;
                  this.italic = fontName.search(/oblique/gi) !== -1 || fontName.search(/italic/gi) !== -1;
                  this.black = name.search(/Black/g) !== -1;
                  const isNarrow = name.search(/Narrow/g) !== -1;
                  this.remeasure = (!isStandardFont || isNarrow) && Object.keys(this.widths).length > 0;
                  if ((isStandardFont || isMappedToStandardFont) && type === "CIDFontType2" && this.cidEncoding.startsWith("Identity-")) {
                    const cidToGidMap = properties.cidToGidMap;
                    const map = [];
                    applyStandardFontGlyphMap(map, (0, _standard_fonts.getGlyphMapForStandardFonts)());
                    if (/Arial-?Black/i.test(name)) {
                      applyStandardFontGlyphMap(map, (0, _standard_fonts.getSupplementalGlyphMapForArialBlack)());
                    } else if (/Calibri/i.test(name)) {
                      applyStandardFontGlyphMap(map, (0, _standard_fonts.getSupplementalGlyphMapForCalibri)());
                    }
                    if (cidToGidMap) {
                      for (const charCode in map) {
                        const cid = map[charCode];
                        if (cidToGidMap[cid] !== void 0) {
                          map[+charCode] = cidToGidMap[cid];
                        }
                      }
                      if (cidToGidMap.length !== this.toUnicode.length && properties.hasIncludedToUnicodeMap && this.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap) {
                        this.toUnicode.forEach(function(charCode, unicodeCharCode) {
                          const cid = map[charCode];
                          if (cidToGidMap[cid] === void 0) {
                            map[+charCode] = unicodeCharCode;
                          }
                        });
                      }
                    }
                    if (!(this.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap)) {
                      this.toUnicode.forEach(function(charCode, unicodeCharCode) {
                        map[+charCode] = unicodeCharCode;
                      });
                    }
                    this.toFontChar = map;
                    this.toUnicode = new _to_unicode_map.ToUnicodeMap(map);
                  } else if (/Symbol/i.test(fontName)) {
                    this.toFontChar = buildToFontChar(_encodings.SymbolSetEncoding, (0, _glyphlist.getGlyphsUnicode)(), this.differences);
                  } else if (/Dingbats/i.test(fontName)) {
                    if (/Wingdings/i.test(name)) {
                      (0, _util.warn)("Non-embedded Wingdings font, falling back to ZapfDingbats.");
                    }
                    this.toFontChar = buildToFontChar(_encodings.ZapfDingbatsEncoding, (0, _glyphlist.getDingbatsGlyphsUnicode)(), this.differences);
                  } else if (isStandardFont) {
                    const map = buildToFontChar(this.defaultEncoding, (0, _glyphlist.getGlyphsUnicode)(), this.differences);
                    if (type === "CIDFontType2" && !this.cidEncoding.startsWith("Identity-") && !(this.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap)) {
                      this.toUnicode.forEach(function(charCode, unicodeCharCode) {
                        map[+charCode] = unicodeCharCode;
                      });
                    }
                    this.toFontChar = map;
                  } else {
                    const glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
                    const map = [];
                    this.toUnicode.forEach((charCode, unicodeCharCode) => {
                      if (!this.composite) {
                        const glyphName = this.differences[charCode] || this.defaultEncoding[charCode];
                        const unicode = (0, _unicode.getUnicodeForGlyph)(glyphName, glyphsUnicodeMap);
                        if (unicode !== -1) {
                          unicodeCharCode = unicode;
                        }
                      }
                      map[+charCode] = unicodeCharCode;
                    });
                    if (this.composite && this.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap) {
                      if (/Verdana/i.test(name)) {
                        applyStandardFontGlyphMap(map, (0, _standard_fonts.getGlyphMapForStandardFonts)());
                      }
                    }
                    this.toFontChar = map;
                  }
                  amendFallbackToUnicode(properties);
                  this.loadedName = fontName.split("-")[0];
                  this.fontType = (0, _fonts_utils.getFontType)(type, subtype, properties.isStandardFont);
                }
                checkAndRepair(name, font, properties) {
                  const VALID_TABLES = ["OS/2", "cmap", "head", "hhea", "hmtx", "maxp", "name", "post", "loca", "glyf", "fpgm", "prep", "cvt ", "CFF "];
                  function readTables(file, numTables) {
                    const tables2 = /* @__PURE__ */ Object.create(null);
                    tables2["OS/2"] = null;
                    tables2.cmap = null;
                    tables2.head = null;
                    tables2.hhea = null;
                    tables2.hmtx = null;
                    tables2.maxp = null;
                    tables2.name = null;
                    tables2.post = null;
                    for (let i = 0; i < numTables; i++) {
                      const table = readTableEntry(file);
                      if (!VALID_TABLES.includes(table.tag)) {
                        continue;
                      }
                      if (table.length === 0) {
                        continue;
                      }
                      tables2[table.tag] = table;
                    }
                    return tables2;
                  }
                  __name(readTables, "readTables");
                  function readTableEntry(file) {
                    const tag = file.getString(4);
                    const checksum = file.getInt32() >>> 0;
                    const offset = file.getInt32() >>> 0;
                    const length = file.getInt32() >>> 0;
                    const previousPosition = file.pos;
                    file.pos = file.start || 0;
                    file.skip(offset);
                    const data = file.getBytes(length);
                    file.pos = previousPosition;
                    if (tag === "head") {
                      data[8] = data[9] = data[10] = data[11] = 0;
                      data[17] |= 32;
                    }
                    return {
                      tag,
                      checksum,
                      length,
                      offset,
                      data
                    };
                  }
                  __name(readTableEntry, "readTableEntry");
                  function readOpenTypeHeader(ttf) {
                    return {
                      version: ttf.getString(4),
                      numTables: ttf.getUint16(),
                      searchRange: ttf.getUint16(),
                      entrySelector: ttf.getUint16(),
                      rangeShift: ttf.getUint16()
                    };
                  }
                  __name(readOpenTypeHeader, "readOpenTypeHeader");
                  function readTrueTypeCollectionHeader(ttc) {
                    const ttcTag = ttc.getString(4);
                    (0, _util.assert)(ttcTag === "ttcf", "Must be a TrueType Collection font.");
                    const majorVersion = ttc.getUint16();
                    const minorVersion = ttc.getUint16();
                    const numFonts = ttc.getInt32() >>> 0;
                    const offsetTable = [];
                    for (let i = 0; i < numFonts; i++) {
                      offsetTable.push(ttc.getInt32() >>> 0);
                    }
                    const header2 = {
                      ttcTag,
                      majorVersion,
                      minorVersion,
                      numFonts,
                      offsetTable
                    };
                    switch (majorVersion) {
                      case 1:
                        return header2;
                      case 2:
                        header2.dsigTag = ttc.getInt32() >>> 0;
                        header2.dsigLength = ttc.getInt32() >>> 0;
                        header2.dsigOffset = ttc.getInt32() >>> 0;
                        return header2;
                    }
                    throw new _util.FormatError(`Invalid TrueType Collection majorVersion: ${majorVersion}.`);
                  }
                  __name(readTrueTypeCollectionHeader, "readTrueTypeCollectionHeader");
                  function readTrueTypeCollectionData(ttc, fontName) {
                    const {
                      numFonts,
                      offsetTable
                    } = readTrueTypeCollectionHeader(ttc);
                    const fontNameParts = fontName.split("+");
                    let fallbackData;
                    for (let i = 0; i < numFonts; i++) {
                      ttc.pos = (ttc.start || 0) + offsetTable[i];
                      const potentialHeader = readOpenTypeHeader(ttc);
                      const potentialTables = readTables(ttc, potentialHeader.numTables);
                      if (!potentialTables.name) {
                        throw new _util.FormatError('TrueType Collection font must contain a "name" table.');
                      }
                      const nameTable = readNameTable(potentialTables.name);
                      for (let j = 0, jj = nameTable.length; j < jj; j++) {
                        for (let k = 0, kk = nameTable[j].length; k < kk; k++) {
                          const nameEntry = nameTable[j][k] && nameTable[j][k].replace(/\s/g, "");
                          if (!nameEntry) {
                            continue;
                          }
                          if (nameEntry === fontName) {
                            return {
                              header: potentialHeader,
                              tables: potentialTables
                            };
                          }
                          if (fontNameParts.length < 2) {
                            continue;
                          }
                          for (const part of fontNameParts) {
                            if (nameEntry === part) {
                              fallbackData = {
                                name: part,
                                header: potentialHeader,
                                tables: potentialTables
                              };
                            }
                          }
                        }
                      }
                    }
                    if (fallbackData) {
                      (0, _util.warn)(`TrueType Collection does not contain "${fontName}" font, falling back to "${fallbackData.name}" font instead.`);
                      return {
                        header: fallbackData.header,
                        tables: fallbackData.tables
                      };
                    }
                    throw new _util.FormatError(`TrueType Collection does not contain "${fontName}" font.`);
                  }
                  __name(readTrueTypeCollectionData, "readTrueTypeCollectionData");
                  function readCmapTable(cmap, file, isSymbolicFont, hasEncoding) {
                    if (!cmap) {
                      (0, _util.warn)("No cmap table available.");
                      return {
                        platformId: -1,
                        encodingId: -1,
                        mappings: [],
                        hasShortCmap: false
                      };
                    }
                    let segment;
                    let start = (file.start || 0) + cmap.offset;
                    file.pos = start;
                    file.skip(2);
                    const numTables = file.getUint16();
                    let potentialTable;
                    let canBreak = false;
                    for (let i = 0; i < numTables; i++) {
                      const platformId = file.getUint16();
                      const encodingId = file.getUint16();
                      const offset = file.getInt32() >>> 0;
                      let useTable = false;
                      if (potentialTable && potentialTable.platformId === platformId && potentialTable.encodingId === encodingId) {
                        continue;
                      }
                      if (platformId === 0 && (encodingId === 0 || encodingId === 1 || encodingId === 3)) {
                        useTable = true;
                      } else if (platformId === 1 && encodingId === 0) {
                        useTable = true;
                      } else if (platformId === 3 && encodingId === 1 && (hasEncoding || !potentialTable)) {
                        useTable = true;
                        if (!isSymbolicFont) {
                          canBreak = true;
                        }
                      } else if (isSymbolicFont && platformId === 3 && encodingId === 0) {
                        useTable = true;
                        let correctlySorted = true;
                        if (i < numTables - 1) {
                          const nextBytes = file.peekBytes(2), nextPlatformId = int16(nextBytes[0], nextBytes[1]);
                          if (nextPlatformId < platformId) {
                            correctlySorted = false;
                          }
                        }
                        if (correctlySorted) {
                          canBreak = true;
                        }
                      }
                      if (useTable) {
                        potentialTable = {
                          platformId,
                          encodingId,
                          offset
                        };
                      }
                      if (canBreak) {
                        break;
                      }
                    }
                    if (potentialTable) {
                      file.pos = start + potentialTable.offset;
                    }
                    if (!potentialTable || file.peekByte() === -1) {
                      (0, _util.warn)("Could not find a preferred cmap table.");
                      return {
                        platformId: -1,
                        encodingId: -1,
                        mappings: [],
                        hasShortCmap: false
                      };
                    }
                    const format = file.getUint16();
                    let hasShortCmap = false;
                    const mappings = [];
                    let j, glyphId;
                    if (format === 0) {
                      file.skip(2 + 2);
                      for (j = 0; j < 256; j++) {
                        const index = file.getByte();
                        if (!index) {
                          continue;
                        }
                        mappings.push({
                          charCode: j,
                          glyphId: index
                        });
                      }
                      hasShortCmap = true;
                    } else if (format === 2) {
                      file.skip(2 + 2);
                      const subHeaderKeys = [];
                      let maxSubHeaderKey = 0;
                      for (let i = 0; i < 256; i++) {
                        const subHeaderKey = file.getUint16() >> 3;
                        subHeaderKeys.push(subHeaderKey);
                        maxSubHeaderKey = Math.max(subHeaderKey, maxSubHeaderKey);
                      }
                      const subHeaders = [];
                      for (let i = 0; i <= maxSubHeaderKey; i++) {
                        subHeaders.push({
                          firstCode: file.getUint16(),
                          entryCount: file.getUint16(),
                          idDelta: signedInt16(file.getByte(), file.getByte()),
                          idRangePos: file.pos + file.getUint16()
                        });
                      }
                      for (let i = 0; i < 256; i++) {
                        if (subHeaderKeys[i] === 0) {
                          file.pos = subHeaders[0].idRangePos + 2 * i;
                          glyphId = file.getUint16();
                          mappings.push({
                            charCode: i,
                            glyphId
                          });
                        } else {
                          const s = subHeaders[subHeaderKeys[i]];
                          for (j = 0; j < s.entryCount; j++) {
                            const charCode = (i << 8) + j + s.firstCode;
                            file.pos = s.idRangePos + 2 * j;
                            glyphId = file.getUint16();
                            if (glyphId !== 0) {
                              glyphId = (glyphId + s.idDelta) % 65536;
                            }
                            mappings.push({
                              charCode,
                              glyphId
                            });
                          }
                        }
                      }
                    } else if (format === 4) {
                      file.skip(2 + 2);
                      const segCount = file.getUint16() >> 1;
                      file.skip(6);
                      const segments = [];
                      let segIndex;
                      for (segIndex = 0; segIndex < segCount; segIndex++) {
                        segments.push({
                          end: file.getUint16()
                        });
                      }
                      file.skip(2);
                      for (segIndex = 0; segIndex < segCount; segIndex++) {
                        segments[segIndex].start = file.getUint16();
                      }
                      for (segIndex = 0; segIndex < segCount; segIndex++) {
                        segments[segIndex].delta = file.getUint16();
                      }
                      let offsetsCount = 0, offsetIndex;
                      for (segIndex = 0; segIndex < segCount; segIndex++) {
                        segment = segments[segIndex];
                        const rangeOffset = file.getUint16();
                        if (!rangeOffset) {
                          segment.offsetIndex = -1;
                          continue;
                        }
                        offsetIndex = (rangeOffset >> 1) - (segCount - segIndex);
                        segment.offsetIndex = offsetIndex;
                        offsetsCount = Math.max(offsetsCount, offsetIndex + segment.end - segment.start + 1);
                      }
                      const offsets = [];
                      for (j = 0; j < offsetsCount; j++) {
                        offsets.push(file.getUint16());
                      }
                      for (segIndex = 0; segIndex < segCount; segIndex++) {
                        segment = segments[segIndex];
                        start = segment.start;
                        const end = segment.end;
                        const delta = segment.delta;
                        offsetIndex = segment.offsetIndex;
                        for (j = start; j <= end; j++) {
                          if (j === 65535) {
                            continue;
                          }
                          glyphId = offsetIndex < 0 ? j : offsets[offsetIndex + j - start];
                          glyphId = glyphId + delta & 65535;
                          mappings.push({
                            charCode: j,
                            glyphId
                          });
                        }
                      }
                    } else if (format === 6) {
                      file.skip(2 + 2);
                      const firstCode = file.getUint16();
                      const entryCount = file.getUint16();
                      for (j = 0; j < entryCount; j++) {
                        glyphId = file.getUint16();
                        const charCode = firstCode + j;
                        mappings.push({
                          charCode,
                          glyphId
                        });
                      }
                    } else if (format === 12) {
                      file.skip(2 + 4 + 4);
                      const nGroups = file.getInt32() >>> 0;
                      for (j = 0; j < nGroups; j++) {
                        const startCharCode = file.getInt32() >>> 0;
                        const endCharCode = file.getInt32() >>> 0;
                        let glyphCode = file.getInt32() >>> 0;
                        for (let charCode = startCharCode; charCode <= endCharCode; charCode++) {
                          mappings.push({
                            charCode,
                            glyphId: glyphCode++
                          });
                        }
                      }
                    } else {
                      (0, _util.warn)("cmap table has unsupported format: " + format);
                      return {
                        platformId: -1,
                        encodingId: -1,
                        mappings: [],
                        hasShortCmap: false
                      };
                    }
                    mappings.sort(function(a, b) {
                      return a.charCode - b.charCode;
                    });
                    for (let i = 1; i < mappings.length; i++) {
                      if (mappings[i - 1].charCode === mappings[i].charCode) {
                        mappings.splice(i, 1);
                        i--;
                      }
                    }
                    return {
                      platformId: potentialTable.platformId,
                      encodingId: potentialTable.encodingId,
                      mappings,
                      hasShortCmap
                    };
                  }
                  __name(readCmapTable, "readCmapTable");
                  function sanitizeMetrics(file, header2, metrics, headTable, numGlyphs2, dupFirstEntry2) {
                    if (!header2) {
                      if (metrics) {
                        metrics.data = null;
                      }
                      return;
                    }
                    file.pos = (file.start || 0) + header2.offset;
                    file.pos += 4;
                    file.pos += 2;
                    file.pos += 2;
                    file.pos += 2;
                    file.pos += 2;
                    file.pos += 2;
                    file.pos += 2;
                    file.pos += 2;
                    file.pos += 2;
                    file.pos += 2;
                    const caretOffset = file.getUint16();
                    file.pos += 8;
                    file.pos += 2;
                    let numOfMetrics = file.getUint16();
                    if (caretOffset !== 0) {
                      const macStyle = int16(headTable.data[44], headTable.data[45]);
                      if (!(macStyle & 2)) {
                        header2.data[22] = 0;
                        header2.data[23] = 0;
                      }
                    }
                    if (numOfMetrics > numGlyphs2) {
                      (0, _util.info)(`The numOfMetrics (${numOfMetrics}) should not be greater than the numGlyphs (${numGlyphs2}).`);
                      numOfMetrics = numGlyphs2;
                      header2.data[34] = (numOfMetrics & 65280) >> 8;
                      header2.data[35] = numOfMetrics & 255;
                    }
                    const numOfSidebearings = numGlyphs2 - numOfMetrics;
                    const numMissing = numOfSidebearings - (metrics.length - numOfMetrics * 4 >> 1);
                    if (numMissing > 0) {
                      const entries = new Uint8Array(metrics.length + numMissing * 2);
                      entries.set(metrics.data);
                      if (dupFirstEntry2) {
                        entries[metrics.length] = metrics.data[2];
                        entries[metrics.length + 1] = metrics.data[3];
                      }
                      metrics.data = entries;
                    }
                  }
                  __name(sanitizeMetrics, "sanitizeMetrics");
                  function sanitizeGlyph(source, sourceStart, sourceEnd, dest, destStart, hintsValid2) {
                    const glyphProfile = {
                      length: 0,
                      sizeOfInstructions: 0
                    };
                    if (sourceEnd - sourceStart <= 12) {
                      return glyphProfile;
                    }
                    const glyf = source.subarray(sourceStart, sourceEnd);
                    let contoursCount = signedInt16(glyf[0], glyf[1]);
                    if (contoursCount < 0) {
                      contoursCount = -1;
                      writeSignedInt16(glyf, 0, contoursCount);
                      dest.set(glyf, destStart);
                      glyphProfile.length = glyf.length;
                      return glyphProfile;
                    }
                    let i, j = 10, flagsCount = 0;
                    for (i = 0; i < contoursCount; i++) {
                      const endPoint = glyf[j] << 8 | glyf[j + 1];
                      flagsCount = endPoint + 1;
                      j += 2;
                    }
                    const instructionsStart = j;
                    const instructionsLength = glyf[j] << 8 | glyf[j + 1];
                    glyphProfile.sizeOfInstructions = instructionsLength;
                    j += 2 + instructionsLength;
                    const instructionsEnd = j;
                    let coordinatesLength = 0;
                    for (i = 0; i < flagsCount; i++) {
                      const flag = glyf[j++];
                      if (flag & 192) {
                        glyf[j - 1] = flag & 63;
                      }
                      let xLength = 2;
                      if (flag & 2) {
                        xLength = 1;
                      } else if (flag & 16) {
                        xLength = 0;
                      }
                      let yLength = 2;
                      if (flag & 4) {
                        yLength = 1;
                      } else if (flag & 32) {
                        yLength = 0;
                      }
                      const xyLength = xLength + yLength;
                      coordinatesLength += xyLength;
                      if (flag & 8) {
                        const repeat = glyf[j++];
                        i += repeat;
                        coordinatesLength += repeat * xyLength;
                      }
                    }
                    if (coordinatesLength === 0) {
                      return glyphProfile;
                    }
                    let glyphDataLength = j + coordinatesLength;
                    if (glyphDataLength > glyf.length) {
                      return glyphProfile;
                    }
                    if (!hintsValid2 && instructionsLength > 0) {
                      dest.set(glyf.subarray(0, instructionsStart), destStart);
                      dest.set([0, 0], destStart + instructionsStart);
                      dest.set(glyf.subarray(instructionsEnd, glyphDataLength), destStart + instructionsStart + 2);
                      glyphDataLength -= instructionsLength;
                      if (glyf.length - glyphDataLength > 3) {
                        glyphDataLength = glyphDataLength + 3 & ~3;
                      }
                      glyphProfile.length = glyphDataLength;
                      return glyphProfile;
                    }
                    if (glyf.length - glyphDataLength > 3) {
                      glyphDataLength = glyphDataLength + 3 & ~3;
                      dest.set(glyf.subarray(0, glyphDataLength), destStart);
                      glyphProfile.length = glyphDataLength;
                      return glyphProfile;
                    }
                    dest.set(glyf, destStart);
                    glyphProfile.length = glyf.length;
                    return glyphProfile;
                  }
                  __name(sanitizeGlyph, "sanitizeGlyph");
                  function sanitizeHead(head, numGlyphs2, locaLength) {
                    const data = head.data;
                    const version2 = int32(data[0], data[1], data[2], data[3]);
                    if (version2 >> 16 !== 1) {
                      (0, _util.info)("Attempting to fix invalid version in head table: " + version2);
                      data[0] = 0;
                      data[1] = 1;
                      data[2] = 0;
                      data[3] = 0;
                    }
                    const indexToLocFormat = int16(data[50], data[51]);
                    if (indexToLocFormat < 0 || indexToLocFormat > 1) {
                      (0, _util.info)("Attempting to fix invalid indexToLocFormat in head table: " + indexToLocFormat);
                      const numGlyphsPlusOne = numGlyphs2 + 1;
                      if (locaLength === numGlyphsPlusOne << 1) {
                        data[50] = 0;
                        data[51] = 0;
                      } else if (locaLength === numGlyphsPlusOne << 2) {
                        data[50] = 0;
                        data[51] = 1;
                      } else {
                        throw new _util.FormatError("Could not fix indexToLocFormat: " + indexToLocFormat);
                      }
                    }
                  }
                  __name(sanitizeHead, "sanitizeHead");
                  function sanitizeGlyphLocations(loca, glyf, numGlyphs2, isGlyphLocationsLong, hintsValid2, dupFirstEntry2, maxSizeOfInstructions2) {
                    let itemSize, itemDecode, itemEncode;
                    if (isGlyphLocationsLong) {
                      itemSize = 4;
                      itemDecode = /* @__PURE__ */ __name(function fontItemDecodeLong(data, offset) {
                        return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
                      }, "fontItemDecodeLong");
                      itemEncode = /* @__PURE__ */ __name(function fontItemEncodeLong(data, offset, value) {
                        data[offset] = value >>> 24 & 255;
                        data[offset + 1] = value >> 16 & 255;
                        data[offset + 2] = value >> 8 & 255;
                        data[offset + 3] = value & 255;
                      }, "fontItemEncodeLong");
                    } else {
                      itemSize = 2;
                      itemDecode = /* @__PURE__ */ __name(function fontItemDecode(data, offset) {
                        return data[offset] << 9 | data[offset + 1] << 1;
                      }, "fontItemDecode");
                      itemEncode = /* @__PURE__ */ __name(function fontItemEncode(data, offset, value) {
                        data[offset] = value >> 9 & 255;
                        data[offset + 1] = value >> 1 & 255;
                      }, "fontItemEncode");
                    }
                    const numGlyphsOut2 = dupFirstEntry2 ? numGlyphs2 + 1 : numGlyphs2;
                    const locaDataSize = itemSize * (1 + numGlyphsOut2);
                    const locaData = new Uint8Array(locaDataSize);
                    locaData.set(loca.data.subarray(0, locaDataSize));
                    loca.data = locaData;
                    const oldGlyfData = glyf.data;
                    const oldGlyfDataLength = oldGlyfData.length;
                    const newGlyfData = new Uint8Array(oldGlyfDataLength);
                    let i, j;
                    const locaEntries = [];
                    for (i = 0, j = 0; i < numGlyphs2 + 1; i++, j += itemSize) {
                      let offset = itemDecode(locaData, j);
                      if (offset > oldGlyfDataLength) {
                        offset = oldGlyfDataLength;
                      }
                      locaEntries.push({
                        index: i,
                        offset,
                        endOffset: 0
                      });
                    }
                    locaEntries.sort((a, b) => {
                      return a.offset - b.offset;
                    });
                    for (i = 0; i < numGlyphs2; i++) {
                      locaEntries[i].endOffset = locaEntries[i + 1].offset;
                    }
                    locaEntries.sort((a, b) => {
                      return a.index - b.index;
                    });
                    for (i = 0; i < numGlyphs2; i++) {
                      const {
                        offset,
                        endOffset
                      } = locaEntries[i];
                      if (offset !== 0 || endOffset !== 0) {
                        break;
                      }
                      const nextOffset = locaEntries[i + 1].offset;
                      if (nextOffset === 0) {
                        continue;
                      }
                      locaEntries[i].endOffset = nextOffset;
                      break;
                    }
                    const missingGlyphs2 = /* @__PURE__ */ Object.create(null);
                    let writeOffset = 0;
                    itemEncode(locaData, 0, writeOffset);
                    for (i = 0, j = itemSize; i < numGlyphs2; i++, j += itemSize) {
                      const glyphProfile = sanitizeGlyph(oldGlyfData, locaEntries[i].offset, locaEntries[i].endOffset, newGlyfData, writeOffset, hintsValid2);
                      const newLength = glyphProfile.length;
                      if (newLength === 0) {
                        missingGlyphs2[i] = true;
                      }
                      if (glyphProfile.sizeOfInstructions > maxSizeOfInstructions2) {
                        maxSizeOfInstructions2 = glyphProfile.sizeOfInstructions;
                      }
                      writeOffset += newLength;
                      itemEncode(locaData, j, writeOffset);
                    }
                    if (writeOffset === 0) {
                      const simpleGlyph = new Uint8Array([0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0]);
                      for (i = 0, j = itemSize; i < numGlyphsOut2; i++, j += itemSize) {
                        itemEncode(locaData, j, simpleGlyph.length);
                      }
                      glyf.data = simpleGlyph;
                    } else if (dupFirstEntry2) {
                      const firstEntryLength = itemDecode(locaData, itemSize);
                      if (newGlyfData.length > firstEntryLength + writeOffset) {
                        glyf.data = newGlyfData.subarray(0, firstEntryLength + writeOffset);
                      } else {
                        glyf.data = new Uint8Array(firstEntryLength + writeOffset);
                        glyf.data.set(newGlyfData.subarray(0, writeOffset));
                      }
                      glyf.data.set(newGlyfData.subarray(0, firstEntryLength), writeOffset);
                      itemEncode(loca.data, locaData.length - itemSize, writeOffset + firstEntryLength);
                    } else {
                      glyf.data = newGlyfData.subarray(0, writeOffset);
                    }
                    return {
                      missingGlyphs: missingGlyphs2,
                      maxSizeOfInstructions: maxSizeOfInstructions2
                    };
                  }
                  __name(sanitizeGlyphLocations, "sanitizeGlyphLocations");
                  function readPostScriptTable(post, propertiesObj, maxpNumGlyphs) {
                    const start = (font.start || 0) + post.offset;
                    font.pos = start;
                    const length = post.length, end = start + length;
                    const version2 = font.getInt32();
                    font.skip(28);
                    let glyphNames;
                    let valid = true;
                    let i;
                    switch (version2) {
                      case 65536:
                        glyphNames = _fonts_utils.MacStandardGlyphOrdering;
                        break;
                      case 131072:
                        const numGlyphs2 = font.getUint16();
                        if (numGlyphs2 !== maxpNumGlyphs) {
                          valid = false;
                          break;
                        }
                        const glyphNameIndexes = [];
                        for (i = 0; i < numGlyphs2; ++i) {
                          const index = font.getUint16();
                          if (index >= 32768) {
                            valid = false;
                            break;
                          }
                          glyphNameIndexes.push(index);
                        }
                        if (!valid) {
                          break;
                        }
                        const customNames = [], strBuf = [];
                        while (font.pos < end) {
                          const stringLength = font.getByte();
                          strBuf.length = stringLength;
                          for (i = 0; i < stringLength; ++i) {
                            strBuf[i] = String.fromCharCode(font.getByte());
                          }
                          customNames.push(strBuf.join(""));
                        }
                        glyphNames = [];
                        for (i = 0; i < numGlyphs2; ++i) {
                          const j = glyphNameIndexes[i];
                          if (j < 258) {
                            glyphNames.push(_fonts_utils.MacStandardGlyphOrdering[j]);
                            continue;
                          }
                          glyphNames.push(customNames[j - 258]);
                        }
                        break;
                      case 196608:
                        break;
                      default:
                        (0, _util.warn)("Unknown/unsupported post table version " + version2);
                        valid = false;
                        if (propertiesObj.defaultEncoding) {
                          glyphNames = propertiesObj.defaultEncoding;
                        }
                        break;
                    }
                    propertiesObj.glyphNames = glyphNames;
                    return valid;
                  }
                  __name(readPostScriptTable, "readPostScriptTable");
                  function readNameTable(nameTable) {
                    const start = (font.start || 0) + nameTable.offset;
                    font.pos = start;
                    const names = [[], []];
                    const length = nameTable.length, end = start + length;
                    const format = font.getUint16();
                    const FORMAT_0_HEADER_LENGTH = 6;
                    if (format !== 0 || length < FORMAT_0_HEADER_LENGTH) {
                      return names;
                    }
                    const numRecords = font.getUint16();
                    const stringsStart = font.getUint16();
                    const records = [];
                    const NAME_RECORD_LENGTH = 12;
                    let i, ii;
                    for (i = 0; i < numRecords && font.pos + NAME_RECORD_LENGTH <= end; i++) {
                      const r = {
                        platform: font.getUint16(),
                        encoding: font.getUint16(),
                        language: font.getUint16(),
                        name: font.getUint16(),
                        length: font.getUint16(),
                        offset: font.getUint16()
                      };
                      if (r.platform === 1 && r.encoding === 0 && r.language === 0 || r.platform === 3 && r.encoding === 1 && r.language === 1033) {
                        records.push(r);
                      }
                    }
                    for (i = 0, ii = records.length; i < ii; i++) {
                      const record = records[i];
                      if (record.length <= 0) {
                        continue;
                      }
                      const pos = start + stringsStart + record.offset;
                      if (pos + record.length > end) {
                        continue;
                      }
                      font.pos = pos;
                      const nameIndex = record.name;
                      if (record.encoding) {
                        let str = "";
                        for (let j = 0, jj = record.length; j < jj; j += 2) {
                          str += String.fromCharCode(font.getUint16());
                        }
                        names[1][nameIndex] = str;
                      } else {
                        names[0][nameIndex] = font.getString(record.length);
                      }
                    }
                    return names;
                  }
                  __name(readNameTable, "readNameTable");
                  const TTOpsStackDeltas = [0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1, 0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2, 0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1, -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];
                  function sanitizeTTProgram(table, ttContext) {
                    let data = table.data;
                    let i = 0, j, n, b, funcId, pc, lastEndf = 0, lastDeff = 0;
                    const stack = [];
                    const callstack = [];
                    const functionsCalled = [];
                    let tooComplexToFollowFunctions = ttContext.tooComplexToFollowFunctions;
                    let inFDEF = false, ifLevel = 0, inELSE = 0;
                    for (let ii = data.length; i < ii; ) {
                      const op = data[i++];
                      if (op === 64) {
                        n = data[i++];
                        if (inFDEF || inELSE) {
                          i += n;
                        } else {
                          for (j = 0; j < n; j++) {
                            stack.push(data[i++]);
                          }
                        }
                      } else if (op === 65) {
                        n = data[i++];
                        if (inFDEF || inELSE) {
                          i += n * 2;
                        } else {
                          for (j = 0; j < n; j++) {
                            b = data[i++];
                            stack.push(b << 8 | data[i++]);
                          }
                        }
                      } else if ((op & 248) === 176) {
                        n = op - 176 + 1;
                        if (inFDEF || inELSE) {
                          i += n;
                        } else {
                          for (j = 0; j < n; j++) {
                            stack.push(data[i++]);
                          }
                        }
                      } else if ((op & 248) === 184) {
                        n = op - 184 + 1;
                        if (inFDEF || inELSE) {
                          i += n * 2;
                        } else {
                          for (j = 0; j < n; j++) {
                            b = data[i++];
                            stack.push(b << 8 | data[i++]);
                          }
                        }
                      } else if (op === 43 && !tooComplexToFollowFunctions) {
                        if (!inFDEF && !inELSE) {
                          funcId = stack.at(-1);
                          if (isNaN(funcId)) {
                            (0, _util.info)("TT: CALL empty stack (or invalid entry).");
                          } else {
                            ttContext.functionsUsed[funcId] = true;
                            if (funcId in ttContext.functionsStackDeltas) {
                              const newStackLength = stack.length + ttContext.functionsStackDeltas[funcId];
                              if (newStackLength < 0) {
                                (0, _util.warn)("TT: CALL invalid functions stack delta.");
                                ttContext.hintsValid = false;
                                return;
                              }
                              stack.length = newStackLength;
                            } else if (funcId in ttContext.functionsDefined && !functionsCalled.includes(funcId)) {
                              callstack.push({
                                data,
                                i,
                                stackTop: stack.length - 1
                              });
                              functionsCalled.push(funcId);
                              pc = ttContext.functionsDefined[funcId];
                              if (!pc) {
                                (0, _util.warn)("TT: CALL non-existent function");
                                ttContext.hintsValid = false;
                                return;
                              }
                              data = pc.data;
                              i = pc.i;
                            }
                          }
                        }
                      } else if (op === 44 && !tooComplexToFollowFunctions) {
                        if (inFDEF || inELSE) {
                          (0, _util.warn)("TT: nested FDEFs not allowed");
                          tooComplexToFollowFunctions = true;
                        }
                        inFDEF = true;
                        lastDeff = i;
                        funcId = stack.pop();
                        ttContext.functionsDefined[funcId] = {
                          data,
                          i
                        };
                      } else if (op === 45) {
                        if (inFDEF) {
                          inFDEF = false;
                          lastEndf = i;
                        } else {
                          pc = callstack.pop();
                          if (!pc) {
                            (0, _util.warn)("TT: ENDF bad stack");
                            ttContext.hintsValid = false;
                            return;
                          }
                          funcId = functionsCalled.pop();
                          data = pc.data;
                          i = pc.i;
                          ttContext.functionsStackDeltas[funcId] = stack.length - pc.stackTop;
                        }
                      } else if (op === 137) {
                        if (inFDEF || inELSE) {
                          (0, _util.warn)("TT: nested IDEFs not allowed");
                          tooComplexToFollowFunctions = true;
                        }
                        inFDEF = true;
                        lastDeff = i;
                      } else if (op === 88) {
                        ++ifLevel;
                      } else if (op === 27) {
                        inELSE = ifLevel;
                      } else if (op === 89) {
                        if (inELSE === ifLevel) {
                          inELSE = 0;
                        }
                        --ifLevel;
                      } else if (op === 28) {
                        if (!inFDEF && !inELSE) {
                          const offset = stack.at(-1);
                          if (offset > 0) {
                            i += offset - 1;
                          }
                        }
                      }
                      if (!inFDEF && !inELSE) {
                        let stackDelta = 0;
                        if (op <= 142) {
                          stackDelta = TTOpsStackDeltas[op];
                        } else if (op >= 192 && op <= 223) {
                          stackDelta = -1;
                        } else if (op >= 224) {
                          stackDelta = -2;
                        }
                        if (op >= 113 && op <= 117) {
                          n = stack.pop();
                          if (!isNaN(n)) {
                            stackDelta = -n * 2;
                          }
                        }
                        while (stackDelta < 0 && stack.length > 0) {
                          stack.pop();
                          stackDelta++;
                        }
                        while (stackDelta > 0) {
                          stack.push(NaN);
                          stackDelta--;
                        }
                      }
                    }
                    ttContext.tooComplexToFollowFunctions = tooComplexToFollowFunctions;
                    const content = [data];
                    if (i > data.length) {
                      content.push(new Uint8Array(i - data.length));
                    }
                    if (lastDeff > lastEndf) {
                      (0, _util.warn)("TT: complementing a missing function tail");
                      content.push(new Uint8Array([34, 45]));
                    }
                    foldTTTable(table, content);
                  }
                  __name(sanitizeTTProgram, "sanitizeTTProgram");
                  function checkInvalidFunctions(ttContext, maxFunctionDefs2) {
                    if (ttContext.tooComplexToFollowFunctions) {
                      return;
                    }
                    if (ttContext.functionsDefined.length > maxFunctionDefs2) {
                      (0, _util.warn)("TT: more functions defined than expected");
                      ttContext.hintsValid = false;
                      return;
                    }
                    for (let j = 0, jj = ttContext.functionsUsed.length; j < jj; j++) {
                      if (j > maxFunctionDefs2) {
                        (0, _util.warn)("TT: invalid function id: " + j);
                        ttContext.hintsValid = false;
                        return;
                      }
                      if (ttContext.functionsUsed[j] && !ttContext.functionsDefined[j]) {
                        (0, _util.warn)("TT: undefined function: " + j);
                        ttContext.hintsValid = false;
                        return;
                      }
                    }
                  }
                  __name(checkInvalidFunctions, "checkInvalidFunctions");
                  function foldTTTable(table, content) {
                    if (content.length > 1) {
                      let newLength = 0;
                      let j, jj;
                      for (j = 0, jj = content.length; j < jj; j++) {
                        newLength += content[j].length;
                      }
                      newLength = newLength + 3 & ~3;
                      const result = new Uint8Array(newLength);
                      let pos = 0;
                      for (j = 0, jj = content.length; j < jj; j++) {
                        result.set(content[j], pos);
                        pos += content[j].length;
                      }
                      table.data = result;
                      table.length = newLength;
                    }
                  }
                  __name(foldTTTable, "foldTTTable");
                  function sanitizeTTPrograms(fpgm, prep, cvt, maxFunctionDefs2) {
                    const ttContext = {
                      functionsDefined: [],
                      functionsUsed: [],
                      functionsStackDeltas: [],
                      tooComplexToFollowFunctions: false,
                      hintsValid: true
                    };
                    if (fpgm) {
                      sanitizeTTProgram(fpgm, ttContext);
                    }
                    if (prep) {
                      sanitizeTTProgram(prep, ttContext);
                    }
                    if (fpgm) {
                      checkInvalidFunctions(ttContext, maxFunctionDefs2);
                    }
                    if (cvt && cvt.length & 1) {
                      const cvtData = new Uint8Array(cvt.length + 1);
                      cvtData.set(cvt.data);
                      cvt.data = cvtData;
                    }
                    return ttContext.hintsValid;
                  }
                  __name(sanitizeTTPrograms, "sanitizeTTPrograms");
                  font = new _stream.Stream(new Uint8Array(font.getBytes()));
                  let header, tables;
                  if (isTrueTypeCollectionFile(font)) {
                    const ttcData = readTrueTypeCollectionData(font, this.name);
                    header = ttcData.header;
                    tables = ttcData.tables;
                  } else {
                    header = readOpenTypeHeader(font);
                    tables = readTables(font, header.numTables);
                  }
                  let cff, cffFile;
                  const isTrueType = !tables["CFF "];
                  if (!isTrueType) {
                    const isComposite = properties.composite && ((properties.cidToGidMap || []).length > 0 || !(properties.cMap instanceof _cmap.IdentityCMap));
                    if (header.version === "OTTO" && !isComposite || !tables.head || !tables.hhea || !tables.maxp || !tables.post) {
                      cffFile = new _stream.Stream(tables["CFF "].data);
                      cff = new _cff_font.CFFFont(cffFile, properties);
                      adjustWidths(properties);
                      return this.convert(name, cff, properties);
                    }
                    delete tables.glyf;
                    delete tables.loca;
                    delete tables.fpgm;
                    delete tables.prep;
                    delete tables["cvt "];
                    this.isOpenType = true;
                  } else {
                    if (!tables.loca) {
                      throw new _util.FormatError('Required "loca" table is not found');
                    }
                    if (!tables.glyf) {
                      (0, _util.warn)('Required "glyf" table is not found -- trying to recover.');
                      tables.glyf = {
                        tag: "glyf",
                        data: new Uint8Array(0)
                      };
                    }
                    this.isOpenType = false;
                  }
                  if (!tables.maxp) {
                    throw new _util.FormatError('Required "maxp" table is not found');
                  }
                  font.pos = (font.start || 0) + tables.maxp.offset;
                  const version = font.getInt32();
                  const numGlyphs = font.getUint16();
                  if (properties.scaleFactors && properties.scaleFactors.length === numGlyphs && isTrueType) {
                    const {
                      scaleFactors
                    } = properties;
                    const isGlyphLocationsLong = int16(tables.head.data[50], tables.head.data[51]);
                    const glyphs = new _glyf.GlyfTable({
                      glyfTable: tables.glyf.data,
                      isGlyphLocationsLong,
                      locaTable: tables.loca.data,
                      numGlyphs
                    });
                    glyphs.scale(scaleFactors);
                    const {
                      glyf,
                      loca,
                      isLocationLong
                    } = glyphs.write();
                    tables.glyf.data = glyf;
                    tables.loca.data = loca;
                    if (isLocationLong !== !!isGlyphLocationsLong) {
                      tables.head.data[50] = 0;
                      tables.head.data[51] = isLocationLong ? 1 : 0;
                    }
                    const metrics = tables.hmtx.data;
                    for (let i = 0; i < numGlyphs; i++) {
                      const j = 4 * i;
                      const advanceWidth = Math.round(scaleFactors[i] * int16(metrics[j], metrics[j + 1]));
                      metrics[j] = advanceWidth >> 8 & 255;
                      metrics[j + 1] = advanceWidth & 255;
                      const lsb = Math.round(scaleFactors[i] * signedInt16(metrics[j + 2], metrics[j + 3]));
                      writeSignedInt16(metrics, j + 2, lsb);
                    }
                  }
                  let numGlyphsOut = numGlyphs + 1;
                  let dupFirstEntry = true;
                  if (numGlyphsOut > 65535) {
                    dupFirstEntry = false;
                    numGlyphsOut = numGlyphs;
                    (0, _util.warn)("Not enough space in glyfs to duplicate first glyph.");
                  }
                  let maxFunctionDefs = 0;
                  let maxSizeOfInstructions = 0;
                  if (version >= 65536 && tables.maxp.length >= 22) {
                    font.pos += 8;
                    const maxZones = font.getUint16();
                    if (maxZones > 2) {
                      tables.maxp.data[14] = 0;
                      tables.maxp.data[15] = 2;
                    }
                    font.pos += 4;
                    maxFunctionDefs = font.getUint16();
                    font.pos += 4;
                    maxSizeOfInstructions = font.getUint16();
                  }
                  tables.maxp.data[4] = numGlyphsOut >> 8;
                  tables.maxp.data[5] = numGlyphsOut & 255;
                  const hintsValid = sanitizeTTPrograms(tables.fpgm, tables.prep, tables["cvt "], maxFunctionDefs);
                  if (!hintsValid) {
                    delete tables.fpgm;
                    delete tables.prep;
                    delete tables["cvt "];
                  }
                  sanitizeMetrics(font, tables.hhea, tables.hmtx, tables.head, numGlyphsOut, dupFirstEntry);
                  if (!tables.head) {
                    throw new _util.FormatError('Required "head" table is not found');
                  }
                  sanitizeHead(tables.head, numGlyphs, isTrueType ? tables.loca.length : 0);
                  let missingGlyphs = /* @__PURE__ */ Object.create(null);
                  if (isTrueType) {
                    const isGlyphLocationsLong = int16(tables.head.data[50], tables.head.data[51]);
                    const glyphsInfo = sanitizeGlyphLocations(tables.loca, tables.glyf, numGlyphs, isGlyphLocationsLong, hintsValid, dupFirstEntry, maxSizeOfInstructions);
                    missingGlyphs = glyphsInfo.missingGlyphs;
                    if (version >= 65536 && tables.maxp.length >= 22) {
                      tables.maxp.data[26] = glyphsInfo.maxSizeOfInstructions >> 8;
                      tables.maxp.data[27] = glyphsInfo.maxSizeOfInstructions & 255;
                    }
                  }
                  if (!tables.hhea) {
                    throw new _util.FormatError('Required "hhea" table is not found');
                  }
                  if (tables.hhea.data[10] === 0 && tables.hhea.data[11] === 0) {
                    tables.hhea.data[10] = 255;
                    tables.hhea.data[11] = 255;
                  }
                  const metricsOverride = {
                    unitsPerEm: int16(tables.head.data[18], tables.head.data[19]),
                    yMax: int16(tables.head.data[42], tables.head.data[43]),
                    yMin: signedInt16(tables.head.data[38], tables.head.data[39]),
                    ascent: signedInt16(tables.hhea.data[4], tables.hhea.data[5]),
                    descent: signedInt16(tables.hhea.data[6], tables.hhea.data[7]),
                    lineGap: signedInt16(tables.hhea.data[8], tables.hhea.data[9])
                  };
                  this.ascent = metricsOverride.ascent / metricsOverride.unitsPerEm;
                  this.descent = metricsOverride.descent / metricsOverride.unitsPerEm;
                  this.lineGap = metricsOverride.lineGap / metricsOverride.unitsPerEm;
                  if (this.cssFontInfo && this.cssFontInfo.lineHeight) {
                    this.lineHeight = this.cssFontInfo.metrics.lineHeight;
                    this.lineGap = this.cssFontInfo.metrics.lineGap;
                  } else {
                    this.lineHeight = this.ascent - this.descent + this.lineGap;
                  }
                  if (tables.post) {
                    readPostScriptTable(tables.post, properties, numGlyphs);
                  }
                  tables.post = {
                    tag: "post",
                    data: createPostTable(properties)
                  };
                  const charCodeToGlyphId = [];
                  function hasGlyph(glyphId) {
                    return !missingGlyphs[glyphId];
                  }
                  __name(hasGlyph, "hasGlyph");
                  if (properties.composite) {
                    const cidToGidMap = properties.cidToGidMap || [];
                    const isCidToGidMapEmpty = cidToGidMap.length === 0;
                    properties.cMap.forEach(function(charCode, cid) {
                      if (typeof cid === "string") {
                        cid = convertCidString(charCode, cid, true);
                      }
                      if (cid > 65535) {
                        throw new _util.FormatError("Max size of CID is 65,535");
                      }
                      let glyphId = -1;
                      if (isCidToGidMapEmpty) {
                        glyphId = cid;
                      } else if (cidToGidMap[cid] !== void 0) {
                        glyphId = cidToGidMap[cid];
                      }
                      if (glyphId >= 0 && glyphId < numGlyphs && hasGlyph(glyphId)) {
                        charCodeToGlyphId[charCode] = glyphId;
                      }
                    });
                  } else {
                    const cmapTable = readCmapTable(tables.cmap, font, this.isSymbolicFont, properties.hasEncoding);
                    const cmapPlatformId = cmapTable.platformId;
                    const cmapEncodingId = cmapTable.encodingId;
                    const cmapMappings = cmapTable.mappings;
                    const cmapMappingsLength = cmapMappings.length;
                    let baseEncoding = [], forcePostTable = false;
                    if (properties.hasEncoding && (properties.baseEncodingName === "MacRomanEncoding" || properties.baseEncodingName === "WinAnsiEncoding")) {
                      baseEncoding = (0, _encodings.getEncoding)(properties.baseEncodingName);
                    }
                    if (properties.hasEncoding && !this.isSymbolicFont && (cmapPlatformId === 3 && cmapEncodingId === 1 || cmapPlatformId === 1 && cmapEncodingId === 0)) {
                      const glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
                      for (let charCode = 0; charCode < 256; charCode++) {
                        let glyphName;
                        if (this.differences[charCode] !== void 0) {
                          glyphName = this.differences[charCode];
                        } else if (baseEncoding.length && baseEncoding[charCode] !== "") {
                          glyphName = baseEncoding[charCode];
                        } else {
                          glyphName = _encodings.StandardEncoding[charCode];
                        }
                        if (!glyphName) {
                          continue;
                        }
                        const standardGlyphName = (0, _fonts_utils.recoverGlyphName)(glyphName, glyphsUnicodeMap);
                        let unicodeOrCharCode;
                        if (cmapPlatformId === 3 && cmapEncodingId === 1) {
                          unicodeOrCharCode = glyphsUnicodeMap[standardGlyphName];
                        } else if (cmapPlatformId === 1 && cmapEncodingId === 0) {
                          unicodeOrCharCode = _encodings.MacRomanEncoding.indexOf(standardGlyphName);
                        }
                        if (unicodeOrCharCode === void 0) {
                          if (!properties.glyphNames && properties.hasIncludedToUnicodeMap && !(this.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap)) {
                            const unicode = this.toUnicode.get(charCode);
                            if (unicode) {
                              unicodeOrCharCode = unicode.codePointAt(0);
                            }
                          }
                          if (unicodeOrCharCode === void 0) {
                            continue;
                          }
                        }
                        for (let i = 0; i < cmapMappingsLength; ++i) {
                          if (cmapMappings[i].charCode !== unicodeOrCharCode) {
                            continue;
                          }
                          charCodeToGlyphId[charCode] = cmapMappings[i].glyphId;
                          break;
                        }
                      }
                    } else if (cmapPlatformId === 0) {
                      for (let i = 0; i < cmapMappingsLength; ++i) {
                        charCodeToGlyphId[cmapMappings[i].charCode] = cmapMappings[i].glyphId;
                      }
                      forcePostTable = true;
                    } else {
                      for (let i = 0; i < cmapMappingsLength; ++i) {
                        let charCode = cmapMappings[i].charCode;
                        if (cmapPlatformId === 3 && charCode >= 61440 && charCode <= 61695) {
                          charCode &= 255;
                        }
                        charCodeToGlyphId[charCode] = cmapMappings[i].glyphId;
                      }
                    }
                    if (properties.glyphNames && (baseEncoding.length || this.differences.length)) {
                      for (let i = 0; i < 256; ++i) {
                        if (!forcePostTable && charCodeToGlyphId[i] !== void 0) {
                          continue;
                        }
                        const glyphName = this.differences[i] || baseEncoding[i];
                        if (!glyphName) {
                          continue;
                        }
                        const glyphId = properties.glyphNames.indexOf(glyphName);
                        if (glyphId > 0 && hasGlyph(glyphId)) {
                          charCodeToGlyphId[i] = glyphId;
                        }
                      }
                    }
                  }
                  if (charCodeToGlyphId.length === 0) {
                    charCodeToGlyphId[0] = 0;
                  }
                  let glyphZeroId = numGlyphsOut - 1;
                  if (!dupFirstEntry) {
                    glyphZeroId = 0;
                  }
                  if (!properties.cssFontInfo) {
                    const newMapping = adjustMapping(charCodeToGlyphId, hasGlyph, glyphZeroId, this.toUnicode);
                    this.toFontChar = newMapping.toFontChar;
                    tables.cmap = {
                      tag: "cmap",
                      data: createCmapTable(newMapping.charCodeToGlyphId, newMapping.toUnicodeExtraMap, numGlyphsOut)
                    };
                    if (!tables["OS/2"] || !validateOS2Table(tables["OS/2"], font)) {
                      tables["OS/2"] = {
                        tag: "OS/2",
                        data: createOS2Table(properties, newMapping.charCodeToGlyphId, metricsOverride)
                      };
                    }
                  }
                  if (!isTrueType) {
                    try {
                      cffFile = new _stream.Stream(tables["CFF "].data);
                      const parser = new _cff_parser.CFFParser(cffFile, properties, _fonts_utils.SEAC_ANALYSIS_ENABLED);
                      cff = parser.parse();
                      cff.duplicateFirstGlyph();
                      const compiler = new _cff_parser.CFFCompiler(cff);
                      tables["CFF "].data = compiler.compile();
                    } catch (e) {
                      (0, _util.warn)("Failed to compile font " + properties.loadedName);
                    }
                  }
                  if (!tables.name) {
                    tables.name = {
                      tag: "name",
                      data: createNameTable(this.name)
                    };
                  } else {
                    const namePrototype = readNameTable(tables.name);
                    tables.name.data = createNameTable(name, namePrototype);
                    this.psName = namePrototype[0][6] || null;
                  }
                  const builder = new _opentype_file_builder.OpenTypeFileBuilder(header.version);
                  for (const tableTag in tables) {
                    builder.addTable(tableTag, tables[tableTag].data);
                  }
                  return builder.toArray();
                }
                convert(fontName, font, properties) {
                  properties.fixedPitch = false;
                  if (properties.builtInEncoding) {
                    adjustToUnicode(properties, properties.builtInEncoding);
                  }
                  let glyphZeroId = 1;
                  if (font instanceof _cff_font.CFFFont) {
                    glyphZeroId = font.numGlyphs - 1;
                  }
                  const mapping = font.getGlyphMapping(properties);
                  let newMapping = null;
                  let newCharCodeToGlyphId = mapping;
                  let toUnicodeExtraMap = null;
                  if (!properties.cssFontInfo) {
                    newMapping = adjustMapping(mapping, font.hasGlyphId.bind(font), glyphZeroId, this.toUnicode);
                    this.toFontChar = newMapping.toFontChar;
                    newCharCodeToGlyphId = newMapping.charCodeToGlyphId;
                    toUnicodeExtraMap = newMapping.toUnicodeExtraMap;
                  }
                  const numGlyphs = font.numGlyphs;
                  function getCharCodes(charCodeToGlyphId, glyphId) {
                    let charCodes = null;
                    for (const charCode in charCodeToGlyphId) {
                      if (glyphId === charCodeToGlyphId[charCode]) {
                        if (!charCodes) {
                          charCodes = [];
                        }
                        charCodes.push(charCode | 0);
                      }
                    }
                    return charCodes;
                  }
                  __name(getCharCodes, "getCharCodes");
                  function createCharCode(charCodeToGlyphId, glyphId) {
                    for (const charCode in charCodeToGlyphId) {
                      if (glyphId === charCodeToGlyphId[charCode]) {
                        return charCode | 0;
                      }
                    }
                    newMapping.charCodeToGlyphId[newMapping.nextAvailableFontCharCode] = glyphId;
                    return newMapping.nextAvailableFontCharCode++;
                  }
                  __name(createCharCode, "createCharCode");
                  const seacs = font.seacs;
                  if (newMapping && _fonts_utils.SEAC_ANALYSIS_ENABLED && seacs && seacs.length) {
                    const matrix = properties.fontMatrix || _util.FONT_IDENTITY_MATRIX;
                    const charset = font.getCharset();
                    const seacMap = /* @__PURE__ */ Object.create(null);
                    for (let glyphId in seacs) {
                      glyphId |= 0;
                      const seac = seacs[glyphId];
                      const baseGlyphName = _encodings.StandardEncoding[seac[2]];
                      const accentGlyphName = _encodings.StandardEncoding[seac[3]];
                      const baseGlyphId = charset.indexOf(baseGlyphName);
                      const accentGlyphId = charset.indexOf(accentGlyphName);
                      if (baseGlyphId < 0 || accentGlyphId < 0) {
                        continue;
                      }
                      const accentOffset = {
                        x: seac[0] * matrix[0] + seac[1] * matrix[2] + matrix[4],
                        y: seac[0] * matrix[1] + seac[1] * matrix[3] + matrix[5]
                      };
                      const charCodes = getCharCodes(mapping, glyphId);
                      if (!charCodes) {
                        continue;
                      }
                      for (let i = 0, ii = charCodes.length; i < ii; i++) {
                        const charCode = charCodes[i];
                        const charCodeToGlyphId = newMapping.charCodeToGlyphId;
                        const baseFontCharCode = createCharCode(charCodeToGlyphId, baseGlyphId);
                        const accentFontCharCode = createCharCode(charCodeToGlyphId, accentGlyphId);
                        seacMap[charCode] = {
                          baseFontCharCode,
                          accentFontCharCode,
                          accentOffset
                        };
                      }
                    }
                    properties.seacMap = seacMap;
                  }
                  const unitsPerEm = 1 / (properties.fontMatrix || _util.FONT_IDENTITY_MATRIX)[0];
                  const builder = new _opentype_file_builder.OpenTypeFileBuilder("OTTO");
                  builder.addTable("CFF ", font.data);
                  builder.addTable("OS/2", createOS2Table(properties, newCharCodeToGlyphId));
                  builder.addTable("cmap", createCmapTable(newCharCodeToGlyphId, toUnicodeExtraMap, numGlyphs));
                  builder.addTable("head", "\0\0\0\0\0\0\0\0\0\0_<Ãµ\0\0" + safeString16(unitsPerEm) + "\0\0\0\0Â\v~'\0\0\0\0Â\v~'\0\0" + safeString16(properties.descent) + "Ã¿" + safeString16(properties.ascent) + string16(properties.italicAngle ? 2 : 0) + "\0\0\0\0\0\0\0");
                  builder.addTable("hhea", "\0\0\0" + safeString16(properties.ascent) + safeString16(properties.descent) + "\0\0Ã¿Ã¿\0\0\0\0\0\0" + safeString16(properties.capHeight) + safeString16(Math.tan(properties.italicAngle) * properties.xHeight) + "\0\0\0\0\0\0\0\0\0\0\0\0" + string16(numGlyphs));
                  builder.addTable("hmtx", (/* @__PURE__ */ __name(function fontFieldsHmtx() {
                    const charstrings = font.charstrings;
                    const cffWidths = font.cff ? font.cff.widths : null;
                    let hmtx = "\0\0\0\0";
                    for (let i = 1, ii = numGlyphs; i < ii; i++) {
                      let width = 0;
                      if (charstrings) {
                        const charstring = charstrings[i - 1];
                        width = "width" in charstring ? charstring.width : 0;
                      } else if (cffWidths) {
                        width = Math.ceil(cffWidths[i] || 0);
                      }
                      hmtx += string16(width) + string16(0);
                    }
                    return hmtx;
                  }, "fontFieldsHmtx"))());
                  builder.addTable("maxp", "\0\0P\0" + string16(numGlyphs));
                  builder.addTable("name", createNameTable(fontName));
                  builder.addTable("post", createPostTable(properties));
                  return builder.toArray();
                }
                get spaceWidth() {
                  const possibleSpaceReplacements = ["space", "minus", "one", "i", "I"];
                  let width;
                  for (let i = 0, ii = possibleSpaceReplacements.length; i < ii; i++) {
                    const glyphName = possibleSpaceReplacements[i];
                    if (glyphName in this.widths) {
                      width = this.widths[glyphName];
                      break;
                    }
                    const glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
                    const glyphUnicode = glyphsUnicodeMap[glyphName];
                    let charcode = 0;
                    if (this.composite && this.cMap.contains(glyphUnicode)) {
                      charcode = this.cMap.lookup(glyphUnicode);
                      if (typeof charcode === "string") {
                        charcode = convertCidString(glyphUnicode, charcode);
                      }
                    }
                    if (!charcode && this.toUnicode) {
                      charcode = this.toUnicode.charCodeOf(glyphUnicode);
                    }
                    if (charcode <= 0) {
                      charcode = glyphUnicode;
                    }
                    width = this.widths[charcode];
                    if (width) {
                      break;
                    }
                  }
                  width = width || this.defaultWidth;
                  return (0, _util.shadow)(this, "spaceWidth", width);
                }
                _charToGlyph(charcode) {
                  let isSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  let fontCharCode, width, operatorListId;
                  let widthCode = charcode;
                  if (this.cMap && this.cMap.contains(charcode)) {
                    widthCode = this.cMap.lookup(charcode);
                    if (typeof widthCode === "string") {
                      widthCode = convertCidString(charcode, widthCode);
                    }
                  }
                  width = this.widths[widthCode];
                  if (typeof width !== "number") {
                    width = this.defaultWidth;
                  }
                  const vmetric = this.vmetrics && this.vmetrics[widthCode];
                  let unicode = this.toUnicode.get(charcode) || charcode;
                  if (typeof unicode === "number") {
                    unicode = String.fromCharCode(unicode);
                  }
                  let isInFont = this.toFontChar[charcode] !== void 0;
                  fontCharCode = this.toFontChar[charcode] || charcode;
                  if (this.missingFile) {
                    const glyphName = this.differences[charcode] || this.defaultEncoding[charcode];
                    if ((glyphName === ".notdef" || glyphName === "") && this.type === "Type1") {
                      fontCharCode = 32;
                    }
                    fontCharCode = (0, _unicode.mapSpecialUnicodeValues)(fontCharCode);
                  }
                  if (this.isType3Font) {
                    operatorListId = fontCharCode;
                  }
                  let accent = null;
                  if (this.seacMap && this.seacMap[charcode]) {
                    isInFont = true;
                    const seac = this.seacMap[charcode];
                    fontCharCode = seac.baseFontCharCode;
                    accent = {
                      fontChar: String.fromCodePoint(seac.accentFontCharCode),
                      offset: seac.accentOffset
                    };
                  }
                  let fontChar = "";
                  if (typeof fontCharCode === "number") {
                    if (fontCharCode <= 1114111) {
                      fontChar = String.fromCodePoint(fontCharCode);
                    } else {
                      (0, _util.warn)(`charToGlyph - invalid fontCharCode: ${fontCharCode}`);
                    }
                  }
                  let glyph = this._glyphCache[charcode];
                  if (!glyph || !glyph.matchesForCache(charcode, fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont)) {
                    glyph = new Glyph(charcode, fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont);
                    this._glyphCache[charcode] = glyph;
                  }
                  return glyph;
                }
                charsToGlyphs(chars) {
                  let glyphs = this._charsCache[chars];
                  if (glyphs) {
                    return glyphs;
                  }
                  glyphs = [];
                  if (this.cMap) {
                    const c = /* @__PURE__ */ Object.create(null), ii = chars.length;
                    let i = 0;
                    while (i < ii) {
                      this.cMap.readCharCode(chars, i, c);
                      const {
                        charcode,
                        length
                      } = c;
                      i += length;
                      const glyph = this._charToGlyph(charcode, length === 1 && chars.charCodeAt(i - 1) === 32);
                      glyphs.push(glyph);
                    }
                  } else {
                    for (let i = 0, ii = chars.length; i < ii; ++i) {
                      const charcode = chars.charCodeAt(i);
                      const glyph = this._charToGlyph(charcode, charcode === 32);
                      glyphs.push(glyph);
                    }
                  }
                  return this._charsCache[chars] = glyphs;
                }
                getCharPositions(chars) {
                  const positions = [];
                  if (this.cMap) {
                    const c = /* @__PURE__ */ Object.create(null);
                    let i = 0;
                    while (i < chars.length) {
                      this.cMap.readCharCode(chars, i, c);
                      const length = c.length;
                      positions.push([i, i + length]);
                      i += length;
                    }
                  } else {
                    for (let i = 0, ii = chars.length; i < ii; ++i) {
                      positions.push([i, i + 1]);
                    }
                  }
                  return positions;
                }
                get glyphCacheValues() {
                  return Object.values(this._glyphCache);
                }
                encodeString(str) {
                  const buffers = [];
                  const currentBuf = [];
                  const hasCurrentBufErrors = /* @__PURE__ */ __name(() => buffers.length % 2 === 1, "hasCurrentBufErrors");
                  const getCharCode = this.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap ? (unicode) => this.toUnicode.charCodeOf(unicode) : (unicode) => this.toUnicode.charCodeOf(String.fromCodePoint(unicode));
                  for (let i = 0, ii = str.length; i < ii; i++) {
                    const unicode = str.codePointAt(i);
                    if (unicode > 55295 && (unicode < 57344 || unicode > 65533)) {
                      i++;
                    }
                    if (this.toUnicode) {
                      const charCode = getCharCode(unicode);
                      if (charCode !== -1) {
                        if (hasCurrentBufErrors()) {
                          buffers.push(currentBuf.join(""));
                          currentBuf.length = 0;
                        }
                        const charCodeLength = this.cMap ? this.cMap.getCharCodeLength(charCode) : 1;
                        for (let j = charCodeLength - 1; j >= 0; j--) {
                          currentBuf.push(String.fromCharCode(charCode >> 8 * j & 255));
                        }
                        continue;
                      }
                    }
                    if (!hasCurrentBufErrors()) {
                      buffers.push(currentBuf.join(""));
                      currentBuf.length = 0;
                    }
                    currentBuf.push(String.fromCodePoint(unicode));
                  }
                  buffers.push(currentBuf.join(""));
                  return buffers;
                }
              };
              __name(_Font, "Font");
              let Font = _Font;
              exports2.Font = Font;
              const _ErrorFont = class _ErrorFont {
                constructor(error) {
                  this.error = error;
                  this.loadedName = "g_font_error";
                  this.missingFile = true;
                }
                charsToGlyphs() {
                  return [];
                }
                encodeString(chars) {
                  return [chars];
                }
                exportData() {
                  return {
                    error: this.error
                  };
                }
              };
              __name(_ErrorFont, "ErrorFont");
              let ErrorFont = _ErrorFont;
              exports2.ErrorFont = ErrorFont;
            },
            /* 160 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.CFFTopDict = exports2.CFFStrings = exports2.CFFStandardStrings = exports2.CFFPrivateDict = exports2.CFFParser = exports2.CFFIndex = exports2.CFFHeader = exports2.CFFFDSelect = exports2.CFFCompiler = exports2.CFFCharset = exports2.CFF = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _charsets = __w_pdfjs_require__2(161);
              var _encodings = __w_pdfjs_require__2(162);
              const MAX_SUBR_NESTING = 10;
              const CFFStandardStrings = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"];
              exports2.CFFStandardStrings = CFFStandardStrings;
              const NUM_STANDARD_CFF_STRINGS = 391;
              const CharstringValidationData = [null, {
                id: "hstem",
                min: 2,
                stackClearing: true,
                stem: true
              }, null, {
                id: "vstem",
                min: 2,
                stackClearing: true,
                stem: true
              }, {
                id: "vmoveto",
                min: 1,
                stackClearing: true
              }, {
                id: "rlineto",
                min: 2,
                resetStack: true
              }, {
                id: "hlineto",
                min: 1,
                resetStack: true
              }, {
                id: "vlineto",
                min: 1,
                resetStack: true
              }, {
                id: "rrcurveto",
                min: 6,
                resetStack: true
              }, null, {
                id: "callsubr",
                min: 1,
                undefStack: true
              }, {
                id: "return",
                min: 0,
                undefStack: true
              }, null, null, {
                id: "endchar",
                min: 0,
                stackClearing: true
              }, null, null, null, {
                id: "hstemhm",
                min: 2,
                stackClearing: true,
                stem: true
              }, {
                id: "hintmask",
                min: 0,
                stackClearing: true
              }, {
                id: "cntrmask",
                min: 0,
                stackClearing: true
              }, {
                id: "rmoveto",
                min: 2,
                stackClearing: true
              }, {
                id: "hmoveto",
                min: 1,
                stackClearing: true
              }, {
                id: "vstemhm",
                min: 2,
                stackClearing: true,
                stem: true
              }, {
                id: "rcurveline",
                min: 8,
                resetStack: true
              }, {
                id: "rlinecurve",
                min: 8,
                resetStack: true
              }, {
                id: "vvcurveto",
                min: 4,
                resetStack: true
              }, {
                id: "hhcurveto",
                min: 4,
                resetStack: true
              }, null, {
                id: "callgsubr",
                min: 1,
                undefStack: true
              }, {
                id: "vhcurveto",
                min: 4,
                resetStack: true
              }, {
                id: "hvcurveto",
                min: 4,
                resetStack: true
              }];
              const CharstringValidationData12 = [null, null, null, {
                id: "and",
                min: 2,
                stackDelta: -1
              }, {
                id: "or",
                min: 2,
                stackDelta: -1
              }, {
                id: "not",
                min: 1,
                stackDelta: 0
              }, null, null, null, {
                id: "abs",
                min: 1,
                stackDelta: 0
              }, {
                id: "add",
                min: 2,
                stackDelta: -1,
                stackFn(stack, index) {
                  stack[index - 2] = stack[index - 2] + stack[index - 1];
                }
              }, {
                id: "sub",
                min: 2,
                stackDelta: -1,
                stackFn(stack, index) {
                  stack[index - 2] = stack[index - 2] - stack[index - 1];
                }
              }, {
                id: "div",
                min: 2,
                stackDelta: -1,
                stackFn(stack, index) {
                  stack[index - 2] = stack[index - 2] / stack[index - 1];
                }
              }, null, {
                id: "neg",
                min: 1,
                stackDelta: 0,
                stackFn(stack, index) {
                  stack[index - 1] = -stack[index - 1];
                }
              }, {
                id: "eq",
                min: 2,
                stackDelta: -1
              }, null, null, {
                id: "drop",
                min: 1,
                stackDelta: -1
              }, null, {
                id: "put",
                min: 2,
                stackDelta: -2
              }, {
                id: "get",
                min: 1,
                stackDelta: 0
              }, {
                id: "ifelse",
                min: 4,
                stackDelta: -3
              }, {
                id: "random",
                min: 0,
                stackDelta: 1
              }, {
                id: "mul",
                min: 2,
                stackDelta: -1,
                stackFn(stack, index) {
                  stack[index - 2] = stack[index - 2] * stack[index - 1];
                }
              }, null, {
                id: "sqrt",
                min: 1,
                stackDelta: 0
              }, {
                id: "dup",
                min: 1,
                stackDelta: 1
              }, {
                id: "exch",
                min: 2,
                stackDelta: 0
              }, {
                id: "index",
                min: 2,
                stackDelta: 0
              }, {
                id: "roll",
                min: 3,
                stackDelta: -2
              }, null, null, null, {
                id: "hflex",
                min: 7,
                resetStack: true
              }, {
                id: "flex",
                min: 13,
                resetStack: true
              }, {
                id: "hflex1",
                min: 9,
                resetStack: true
              }, {
                id: "flex1",
                min: 11,
                resetStack: true
              }];
              const _CFFParser = class _CFFParser {
                constructor(file, properties, seacAnalysisEnabled) {
                  this.bytes = file.getBytes();
                  this.properties = properties;
                  this.seacAnalysisEnabled = !!seacAnalysisEnabled;
                }
                parse() {
                  const properties = this.properties;
                  const cff = new CFF();
                  this.cff = cff;
                  const header = this.parseHeader();
                  const nameIndex = this.parseIndex(header.endPos);
                  const topDictIndex = this.parseIndex(nameIndex.endPos);
                  const stringIndex = this.parseIndex(topDictIndex.endPos);
                  const globalSubrIndex = this.parseIndex(stringIndex.endPos);
                  const topDictParsed = this.parseDict(topDictIndex.obj.get(0));
                  const topDict = this.createDict(CFFTopDict, topDictParsed, cff.strings);
                  cff.header = header.obj;
                  cff.names = this.parseNameIndex(nameIndex.obj);
                  cff.strings = this.parseStringIndex(stringIndex.obj);
                  cff.topDict = topDict;
                  cff.globalSubrIndex = globalSubrIndex.obj;
                  this.parsePrivateDict(cff.topDict);
                  cff.isCIDFont = topDict.hasName("ROS");
                  const charStringOffset = topDict.getByName("CharStrings");
                  const charStringIndex = this.parseIndex(charStringOffset).obj;
                  const fontMatrix = topDict.getByName("FontMatrix");
                  if (fontMatrix) {
                    properties.fontMatrix = fontMatrix;
                  }
                  const fontBBox = topDict.getByName("FontBBox");
                  if (fontBBox) {
                    properties.ascent = Math.max(fontBBox[3], fontBBox[1]);
                    properties.descent = Math.min(fontBBox[1], fontBBox[3]);
                    properties.ascentScaled = true;
                  }
                  let charset, encoding;
                  if (cff.isCIDFont) {
                    const fdArrayIndex = this.parseIndex(topDict.getByName("FDArray")).obj;
                    for (let i = 0, ii = fdArrayIndex.count; i < ii; ++i) {
                      const dictRaw = fdArrayIndex.get(i);
                      const fontDict = this.createDict(CFFTopDict, this.parseDict(dictRaw), cff.strings);
                      this.parsePrivateDict(fontDict);
                      cff.fdArray.push(fontDict);
                    }
                    encoding = null;
                    charset = this.parseCharsets(topDict.getByName("charset"), charStringIndex.count, cff.strings, true);
                    cff.fdSelect = this.parseFDSelect(topDict.getByName("FDSelect"), charStringIndex.count);
                  } else {
                    charset = this.parseCharsets(topDict.getByName("charset"), charStringIndex.count, cff.strings, false);
                    encoding = this.parseEncoding(topDict.getByName("Encoding"), properties, cff.strings, charset.charset);
                  }
                  cff.charset = charset;
                  cff.encoding = encoding;
                  const charStringsAndSeacs = this.parseCharStrings({
                    charStrings: charStringIndex,
                    localSubrIndex: topDict.privateDict.subrsIndex,
                    globalSubrIndex: globalSubrIndex.obj,
                    fdSelect: cff.fdSelect,
                    fdArray: cff.fdArray,
                    privateDict: topDict.privateDict
                  });
                  cff.charStrings = charStringsAndSeacs.charStrings;
                  cff.seacs = charStringsAndSeacs.seacs;
                  cff.widths = charStringsAndSeacs.widths;
                  return cff;
                }
                parseHeader() {
                  let bytes = this.bytes;
                  const bytesLength = bytes.length;
                  let offset = 0;
                  while (offset < bytesLength && bytes[offset] !== 1) {
                    ++offset;
                  }
                  if (offset >= bytesLength) {
                    throw new _util.FormatError("Invalid CFF header");
                  }
                  if (offset !== 0) {
                    (0, _util.info)("cff data is shifted");
                    bytes = bytes.subarray(offset);
                    this.bytes = bytes;
                  }
                  const major = bytes[0];
                  const minor = bytes[1];
                  const hdrSize = bytes[2];
                  const offSize = bytes[3];
                  const header = new CFFHeader(major, minor, hdrSize, offSize);
                  return {
                    obj: header,
                    endPos: hdrSize
                  };
                }
                parseDict(dict) {
                  let pos = 0;
                  function parseOperand() {
                    let value = dict[pos++];
                    if (value === 30) {
                      return parseFloatOperand();
                    } else if (value === 28) {
                      value = dict[pos++];
                      value = (value << 24 | dict[pos++] << 16) >> 16;
                      return value;
                    } else if (value === 29) {
                      value = dict[pos++];
                      value = value << 8 | dict[pos++];
                      value = value << 8 | dict[pos++];
                      value = value << 8 | dict[pos++];
                      return value;
                    } else if (value >= 32 && value <= 246) {
                      return value - 139;
                    } else if (value >= 247 && value <= 250) {
                      return (value - 247) * 256 + dict[pos++] + 108;
                    } else if (value >= 251 && value <= 254) {
                      return -((value - 251) * 256) - dict[pos++] - 108;
                    }
                    (0, _util.warn)('CFFParser_parseDict: "' + value + '" is a reserved command.');
                    return NaN;
                  }
                  __name(parseOperand, "parseOperand");
                  function parseFloatOperand() {
                    let str = "";
                    const eof = 15;
                    const lookup = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"];
                    const length = dict.length;
                    while (pos < length) {
                      const b = dict[pos++];
                      const b1 = b >> 4;
                      const b2 = b & 15;
                      if (b1 === eof) {
                        break;
                      }
                      str += lookup[b1];
                      if (b2 === eof) {
                        break;
                      }
                      str += lookup[b2];
                    }
                    return parseFloat(str);
                  }
                  __name(parseFloatOperand, "parseFloatOperand");
                  let operands = [];
                  const entries = [];
                  pos = 0;
                  const end = dict.length;
                  while (pos < end) {
                    let b = dict[pos];
                    if (b <= 21) {
                      if (b === 12) {
                        b = b << 8 | dict[++pos];
                      }
                      entries.push([b, operands]);
                      operands = [];
                      ++pos;
                    } else {
                      operands.push(parseOperand());
                    }
                  }
                  return entries;
                }
                parseIndex(pos) {
                  const cffIndex = new CFFIndex();
                  const bytes = this.bytes;
                  const count = bytes[pos++] << 8 | bytes[pos++];
                  const offsets = [];
                  let end = pos;
                  let i, ii;
                  if (count !== 0) {
                    const offsetSize = bytes[pos++];
                    const startPos = pos + (count + 1) * offsetSize - 1;
                    for (i = 0, ii = count + 1; i < ii; ++i) {
                      let offset = 0;
                      for (let j = 0; j < offsetSize; ++j) {
                        offset <<= 8;
                        offset += bytes[pos++];
                      }
                      offsets.push(startPos + offset);
                    }
                    end = offsets[count];
                  }
                  for (i = 0, ii = offsets.length - 1; i < ii; ++i) {
                    const offsetStart = offsets[i];
                    const offsetEnd = offsets[i + 1];
                    cffIndex.add(bytes.subarray(offsetStart, offsetEnd));
                  }
                  return {
                    obj: cffIndex,
                    endPos: end
                  };
                }
                parseNameIndex(index) {
                  const names = [];
                  for (let i = 0, ii = index.count; i < ii; ++i) {
                    const name = index.get(i);
                    names.push((0, _util.bytesToString)(name));
                  }
                  return names;
                }
                parseStringIndex(index) {
                  const strings = new CFFStrings();
                  for (let i = 0, ii = index.count; i < ii; ++i) {
                    const data = index.get(i);
                    strings.add((0, _util.bytesToString)(data));
                  }
                  return strings;
                }
                createDict(Type, dict, strings) {
                  const cffDict = new Type(strings);
                  for (let i = 0, ii = dict.length; i < ii; ++i) {
                    const pair = dict[i];
                    const key = pair[0];
                    const value = pair[1];
                    cffDict.setByKey(key, value);
                  }
                  return cffDict;
                }
                parseCharString(state, data, localSubrIndex, globalSubrIndex) {
                  if (!data || state.callDepth > MAX_SUBR_NESTING) {
                    return false;
                  }
                  let stackSize = state.stackSize;
                  const stack = state.stack;
                  const length = data.length;
                  for (let j = 0; j < length; ) {
                    const value = data[j++];
                    let validationCommand = null;
                    if (value === 12) {
                      const q = data[j++];
                      if (q === 0) {
                        data[j - 2] = 139;
                        data[j - 1] = 22;
                        stackSize = 0;
                      } else {
                        validationCommand = CharstringValidationData12[q];
                      }
                    } else if (value === 28) {
                      stack[stackSize] = (data[j] << 24 | data[j + 1] << 16) >> 16;
                      j += 2;
                      stackSize++;
                    } else if (value === 14) {
                      if (stackSize >= 4) {
                        stackSize -= 4;
                        if (this.seacAnalysisEnabled) {
                          state.seac = stack.slice(stackSize, stackSize + 4);
                          return false;
                        }
                      }
                      validationCommand = CharstringValidationData[value];
                    } else if (value >= 32 && value <= 246) {
                      stack[stackSize] = value - 139;
                      stackSize++;
                    } else if (value >= 247 && value <= 254) {
                      stack[stackSize] = value < 251 ? (value - 247 << 8) + data[j] + 108 : -(value - 251 << 8) - data[j] - 108;
                      j++;
                      stackSize++;
                    } else if (value === 255) {
                      stack[stackSize] = (data[j] << 24 | data[j + 1] << 16 | data[j + 2] << 8 | data[j + 3]) / 65536;
                      j += 4;
                      stackSize++;
                    } else if (value === 19 || value === 20) {
                      state.hints += stackSize >> 1;
                      j += state.hints + 7 >> 3;
                      stackSize %= 2;
                      validationCommand = CharstringValidationData[value];
                    } else if (value === 10 || value === 29) {
                      let subrsIndex;
                      if (value === 10) {
                        subrsIndex = localSubrIndex;
                      } else {
                        subrsIndex = globalSubrIndex;
                      }
                      if (!subrsIndex) {
                        validationCommand = CharstringValidationData[value];
                        (0, _util.warn)("Missing subrsIndex for " + validationCommand.id);
                        return false;
                      }
                      let bias = 32768;
                      if (subrsIndex.count < 1240) {
                        bias = 107;
                      } else if (subrsIndex.count < 33900) {
                        bias = 1131;
                      }
                      const subrNumber = stack[--stackSize] + bias;
                      if (subrNumber < 0 || subrNumber >= subrsIndex.count || isNaN(subrNumber)) {
                        validationCommand = CharstringValidationData[value];
                        (0, _util.warn)("Out of bounds subrIndex for " + validationCommand.id);
                        return false;
                      }
                      state.stackSize = stackSize;
                      state.callDepth++;
                      const valid = this.parseCharString(state, subrsIndex.get(subrNumber), localSubrIndex, globalSubrIndex);
                      if (!valid) {
                        return false;
                      }
                      state.callDepth--;
                      stackSize = state.stackSize;
                      continue;
                    } else if (value === 11) {
                      state.stackSize = stackSize;
                      return true;
                    } else if (value === 0 && j === data.length) {
                      data[j - 1] = 14;
                      validationCommand = CharstringValidationData[14];
                    } else {
                      validationCommand = CharstringValidationData[value];
                    }
                    if (validationCommand) {
                      if (validationCommand.stem) {
                        state.hints += stackSize >> 1;
                        if (value === 3 || value === 23) {
                          state.hasVStems = true;
                        } else if (state.hasVStems && (value === 1 || value === 18)) {
                          (0, _util.warn)("CFF stem hints are in wrong order");
                          data[j - 1] = value === 1 ? 3 : 23;
                        }
                      }
                      if ("min" in validationCommand) {
                        if (!state.undefStack && stackSize < validationCommand.min) {
                          (0, _util.warn)("Not enough parameters for " + validationCommand.id + "; actual: " + stackSize + ", expected: " + validationCommand.min);
                          if (stackSize === 0) {
                            data[j - 1] = 14;
                            return true;
                          }
                          return false;
                        }
                      }
                      if (state.firstStackClearing && validationCommand.stackClearing) {
                        state.firstStackClearing = false;
                        stackSize -= validationCommand.min;
                        if (stackSize >= 2 && validationCommand.stem) {
                          stackSize %= 2;
                        } else if (stackSize > 1) {
                          (0, _util.warn)("Found too many parameters for stack-clearing command");
                        }
                        if (stackSize > 0) {
                          state.width = stack[stackSize - 1];
                        }
                      }
                      if ("stackDelta" in validationCommand) {
                        if ("stackFn" in validationCommand) {
                          validationCommand.stackFn(stack, stackSize);
                        }
                        stackSize += validationCommand.stackDelta;
                      } else if (validationCommand.stackClearing) {
                        stackSize = 0;
                      } else if (validationCommand.resetStack) {
                        stackSize = 0;
                        state.undefStack = false;
                      } else if (validationCommand.undefStack) {
                        stackSize = 0;
                        state.undefStack = true;
                        state.firstStackClearing = false;
                      }
                    }
                  }
                  state.stackSize = stackSize;
                  return true;
                }
                parseCharStrings(_ref) {
                  let {
                    charStrings,
                    localSubrIndex,
                    globalSubrIndex,
                    fdSelect,
                    fdArray,
                    privateDict
                  } = _ref;
                  const seacs = [];
                  const widths = [];
                  const count = charStrings.count;
                  for (let i = 0; i < count; i++) {
                    const charstring = charStrings.get(i);
                    const state = {
                      callDepth: 0,
                      stackSize: 0,
                      stack: [],
                      undefStack: true,
                      hints: 0,
                      firstStackClearing: true,
                      seac: null,
                      width: null,
                      hasVStems: false
                    };
                    let valid = true;
                    let localSubrToUse = null;
                    let privateDictToUse = privateDict;
                    if (fdSelect && fdArray.length) {
                      const fdIndex = fdSelect.getFDIndex(i);
                      if (fdIndex === -1) {
                        (0, _util.warn)("Glyph index is not in fd select.");
                        valid = false;
                      }
                      if (fdIndex >= fdArray.length) {
                        (0, _util.warn)("Invalid fd index for glyph index.");
                        valid = false;
                      }
                      if (valid) {
                        privateDictToUse = fdArray[fdIndex].privateDict;
                        localSubrToUse = privateDictToUse.subrsIndex;
                      }
                    } else if (localSubrIndex) {
                      localSubrToUse = localSubrIndex;
                    }
                    if (valid) {
                      valid = this.parseCharString(state, charstring, localSubrToUse, globalSubrIndex);
                    }
                    if (state.width !== null) {
                      const nominalWidth = privateDictToUse.getByName("nominalWidthX");
                      widths[i] = nominalWidth + state.width;
                    } else {
                      const defaultWidth = privateDictToUse.getByName("defaultWidthX");
                      widths[i] = defaultWidth;
                    }
                    if (state.seac !== null) {
                      seacs[i] = state.seac;
                    }
                    if (!valid) {
                      charStrings.set(i, new Uint8Array([14]));
                    }
                  }
                  return {
                    charStrings,
                    seacs,
                    widths
                  };
                }
                emptyPrivateDictionary(parentDict) {
                  const privateDict = this.createDict(CFFPrivateDict, [], parentDict.strings);
                  parentDict.setByKey(18, [0, 0]);
                  parentDict.privateDict = privateDict;
                }
                parsePrivateDict(parentDict) {
                  if (!parentDict.hasName("Private")) {
                    this.emptyPrivateDictionary(parentDict);
                    return;
                  }
                  const privateOffset = parentDict.getByName("Private");
                  if (!Array.isArray(privateOffset) || privateOffset.length !== 2) {
                    parentDict.removeByName("Private");
                    return;
                  }
                  const size = privateOffset[0];
                  const offset = privateOffset[1];
                  if (size === 0 || offset >= this.bytes.length) {
                    this.emptyPrivateDictionary(parentDict);
                    return;
                  }
                  const privateDictEnd = offset + size;
                  const dictData = this.bytes.subarray(offset, privateDictEnd);
                  const dict = this.parseDict(dictData);
                  const privateDict = this.createDict(CFFPrivateDict, dict, parentDict.strings);
                  parentDict.privateDict = privateDict;
                  if (!privateDict.getByName("Subrs")) {
                    return;
                  }
                  const subrsOffset = privateDict.getByName("Subrs");
                  const relativeOffset = offset + subrsOffset;
                  if (subrsOffset === 0 || relativeOffset >= this.bytes.length) {
                    this.emptyPrivateDictionary(parentDict);
                    return;
                  }
                  const subrsIndex = this.parseIndex(relativeOffset);
                  privateDict.subrsIndex = subrsIndex.obj;
                }
                parseCharsets(pos, length, strings, cid) {
                  if (pos === 0) {
                    return new CFFCharset(true, CFFCharsetPredefinedTypes.ISO_ADOBE, _charsets.ISOAdobeCharset);
                  } else if (pos === 1) {
                    return new CFFCharset(true, CFFCharsetPredefinedTypes.EXPERT, _charsets.ExpertCharset);
                  } else if (pos === 2) {
                    return new CFFCharset(true, CFFCharsetPredefinedTypes.EXPERT_SUBSET, _charsets.ExpertSubsetCharset);
                  }
                  const bytes = this.bytes;
                  const start = pos;
                  const format = bytes[pos++];
                  const charset = [cid ? 0 : ".notdef"];
                  let id, count, i;
                  length -= 1;
                  switch (format) {
                    case 0:
                      for (i = 0; i < length; i++) {
                        id = bytes[pos++] << 8 | bytes[pos++];
                        charset.push(cid ? id : strings.get(id));
                      }
                      break;
                    case 1:
                      while (charset.length <= length) {
                        id = bytes[pos++] << 8 | bytes[pos++];
                        count = bytes[pos++];
                        for (i = 0; i <= count; i++) {
                          charset.push(cid ? id++ : strings.get(id++));
                        }
                      }
                      break;
                    case 2:
                      while (charset.length <= length) {
                        id = bytes[pos++] << 8 | bytes[pos++];
                        count = bytes[pos++] << 8 | bytes[pos++];
                        for (i = 0; i <= count; i++) {
                          charset.push(cid ? id++ : strings.get(id++));
                        }
                      }
                      break;
                    default:
                      throw new _util.FormatError("Unknown charset format");
                  }
                  const end = pos;
                  const raw = bytes.subarray(start, end);
                  return new CFFCharset(false, format, charset, raw);
                }
                parseEncoding(pos, properties, strings, charset) {
                  const encoding = /* @__PURE__ */ Object.create(null);
                  const bytes = this.bytes;
                  let predefined = false;
                  let format, i, ii;
                  let raw = null;
                  function readSupplement() {
                    const supplementsCount = bytes[pos++];
                    for (i = 0; i < supplementsCount; i++) {
                      const code = bytes[pos++];
                      const sid = (bytes[pos++] << 8) + (bytes[pos++] & 255);
                      encoding[code] = charset.indexOf(strings.get(sid));
                    }
                  }
                  __name(readSupplement, "readSupplement");
                  if (pos === 0 || pos === 1) {
                    predefined = true;
                    format = pos;
                    const baseEncoding = pos ? _encodings.ExpertEncoding : _encodings.StandardEncoding;
                    for (i = 0, ii = charset.length; i < ii; i++) {
                      const index = baseEncoding.indexOf(charset[i]);
                      if (index !== -1) {
                        encoding[index] = i;
                      }
                    }
                  } else {
                    const dataStart = pos;
                    format = bytes[pos++];
                    switch (format & 127) {
                      case 0:
                        const glyphsCount = bytes[pos++];
                        for (i = 1; i <= glyphsCount; i++) {
                          encoding[bytes[pos++]] = i;
                        }
                        break;
                      case 1:
                        const rangesCount = bytes[pos++];
                        let gid = 1;
                        for (i = 0; i < rangesCount; i++) {
                          const start = bytes[pos++];
                          const left = bytes[pos++];
                          for (let j = start; j <= start + left; j++) {
                            encoding[j] = gid++;
                          }
                        }
                        break;
                      default:
                        throw new _util.FormatError(`Unknown encoding format: ${format} in CFF`);
                    }
                    const dataEnd = pos;
                    if (format & 128) {
                      bytes[dataStart] &= 127;
                      readSupplement();
                    }
                    raw = bytes.subarray(dataStart, dataEnd);
                  }
                  format &= 127;
                  return new CFFEncoding(predefined, format, encoding, raw);
                }
                parseFDSelect(pos, length) {
                  const bytes = this.bytes;
                  const format = bytes[pos++];
                  const fdSelect = [];
                  let i;
                  switch (format) {
                    case 0:
                      for (i = 0; i < length; ++i) {
                        const id = bytes[pos++];
                        fdSelect.push(id);
                      }
                      break;
                    case 3:
                      const rangesCount = bytes[pos++] << 8 | bytes[pos++];
                      for (i = 0; i < rangesCount; ++i) {
                        let first = bytes[pos++] << 8 | bytes[pos++];
                        if (i === 0 && first !== 0) {
                          (0, _util.warn)("parseFDSelect: The first range must have a first GID of 0 -- trying to recover.");
                          first = 0;
                        }
                        const fdIndex = bytes[pos++];
                        const next = bytes[pos] << 8 | bytes[pos + 1];
                        for (let j = first; j < next; ++j) {
                          fdSelect.push(fdIndex);
                        }
                      }
                      pos += 2;
                      break;
                    default:
                      throw new _util.FormatError(`parseFDSelect: Unknown format "${format}".`);
                  }
                  if (fdSelect.length !== length) {
                    throw new _util.FormatError("parseFDSelect: Invalid font data.");
                  }
                  return new CFFFDSelect(format, fdSelect);
                }
              };
              __name(_CFFParser, "CFFParser");
              let CFFParser = _CFFParser;
              exports2.CFFParser = CFFParser;
              const _CFF = class _CFF {
                constructor() {
                  this.header = null;
                  this.names = [];
                  this.topDict = null;
                  this.strings = new CFFStrings();
                  this.globalSubrIndex = null;
                  this.encoding = null;
                  this.charset = null;
                  this.charStrings = null;
                  this.fdArray = [];
                  this.fdSelect = null;
                  this.isCIDFont = false;
                }
                duplicateFirstGlyph() {
                  if (this.charStrings.count >= 65535) {
                    (0, _util.warn)("Not enough space in charstrings to duplicate first glyph.");
                    return;
                  }
                  const glyphZero = this.charStrings.get(0);
                  this.charStrings.add(glyphZero);
                  if (this.isCIDFont) {
                    this.fdSelect.fdSelect.push(this.fdSelect.fdSelect[0]);
                  }
                }
                hasGlyphId(id) {
                  if (id < 0 || id >= this.charStrings.count) {
                    return false;
                  }
                  const glyph = this.charStrings.get(id);
                  return glyph.length > 0;
                }
              };
              __name(_CFF, "CFF");
              let CFF = _CFF;
              exports2.CFF = CFF;
              const _CFFHeader = class _CFFHeader {
                constructor(major, minor, hdrSize, offSize) {
                  this.major = major;
                  this.minor = minor;
                  this.hdrSize = hdrSize;
                  this.offSize = offSize;
                }
              };
              __name(_CFFHeader, "CFFHeader");
              let CFFHeader = _CFFHeader;
              exports2.CFFHeader = CFFHeader;
              const _CFFStrings = class _CFFStrings {
                constructor() {
                  this.strings = [];
                }
                get(index) {
                  if (index >= 0 && index <= NUM_STANDARD_CFF_STRINGS - 1) {
                    return CFFStandardStrings[index];
                  }
                  if (index - NUM_STANDARD_CFF_STRINGS <= this.strings.length) {
                    return this.strings[index - NUM_STANDARD_CFF_STRINGS];
                  }
                  return CFFStandardStrings[0];
                }
                getSID(str) {
                  let index = CFFStandardStrings.indexOf(str);
                  if (index !== -1) {
                    return index;
                  }
                  index = this.strings.indexOf(str);
                  if (index !== -1) {
                    return index + NUM_STANDARD_CFF_STRINGS;
                  }
                  return -1;
                }
                add(value) {
                  this.strings.push(value);
                }
                get count() {
                  return this.strings.length;
                }
              };
              __name(_CFFStrings, "CFFStrings");
              let CFFStrings = _CFFStrings;
              exports2.CFFStrings = CFFStrings;
              const _CFFIndex = class _CFFIndex {
                constructor() {
                  this.objects = [];
                  this.length = 0;
                }
                add(data) {
                  this.length += data.length;
                  this.objects.push(data);
                }
                set(index, data) {
                  this.length += data.length - this.objects[index].length;
                  this.objects[index] = data;
                }
                get(index) {
                  return this.objects[index];
                }
                get count() {
                  return this.objects.length;
                }
              };
              __name(_CFFIndex, "CFFIndex");
              let CFFIndex = _CFFIndex;
              exports2.CFFIndex = CFFIndex;
              const _CFFDict = class _CFFDict {
                constructor(tables, strings) {
                  this.keyToNameMap = tables.keyToNameMap;
                  this.nameToKeyMap = tables.nameToKeyMap;
                  this.defaults = tables.defaults;
                  this.types = tables.types;
                  this.opcodes = tables.opcodes;
                  this.order = tables.order;
                  this.strings = strings;
                  this.values = /* @__PURE__ */ Object.create(null);
                }
                setByKey(key, value) {
                  if (!(key in this.keyToNameMap)) {
                    return false;
                  }
                  const valueLength = value.length;
                  if (valueLength === 0) {
                    return true;
                  }
                  for (let i = 0; i < valueLength; i++) {
                    if (isNaN(value[i])) {
                      (0, _util.warn)('Invalid CFFDict value: "' + value + '" for key "' + key + '".');
                      return true;
                    }
                  }
                  const type = this.types[key];
                  if (type === "num" || type === "sid" || type === "offset") {
                    value = value[0];
                  }
                  this.values[key] = value;
                  return true;
                }
                setByName(name, value) {
                  if (!(name in this.nameToKeyMap)) {
                    throw new _util.FormatError(`Invalid dictionary name "${name}"`);
                  }
                  this.values[this.nameToKeyMap[name]] = value;
                }
                hasName(name) {
                  return this.nameToKeyMap[name] in this.values;
                }
                getByName(name) {
                  if (!(name in this.nameToKeyMap)) {
                    throw new _util.FormatError(`Invalid dictionary name ${name}"`);
                  }
                  const key = this.nameToKeyMap[name];
                  if (!(key in this.values)) {
                    return this.defaults[key];
                  }
                  return this.values[key];
                }
                removeByName(name) {
                  delete this.values[this.nameToKeyMap[name]];
                }
                static createTables(layout) {
                  const tables = {
                    keyToNameMap: {},
                    nameToKeyMap: {},
                    defaults: {},
                    types: {},
                    opcodes: {},
                    order: []
                  };
                  for (let i = 0, ii = layout.length; i < ii; ++i) {
                    const entry = layout[i];
                    const key = Array.isArray(entry[0]) ? (entry[0][0] << 8) + entry[0][1] : entry[0];
                    tables.keyToNameMap[key] = entry[1];
                    tables.nameToKeyMap[entry[1]] = key;
                    tables.types[key] = entry[2];
                    tables.defaults[key] = entry[3];
                    tables.opcodes[key] = Array.isArray(entry[0]) ? entry[0] : [entry[0]];
                    tables.order.push(key);
                  }
                  return tables;
                }
              };
              __name(_CFFDict, "CFFDict");
              let CFFDict = _CFFDict;
              const CFFTopDictLayout = [[[12, 30], "ROS", ["sid", "sid", "num"], null], [[12, 20], "SyntheticBase", "num", null], [0, "version", "sid", null], [1, "Notice", "sid", null], [[12, 0], "Copyright", "sid", null], [2, "FullName", "sid", null], [3, "FamilyName", "sid", null], [4, "Weight", "sid", null], [[12, 1], "isFixedPitch", "num", 0], [[12, 2], "ItalicAngle", "num", 0], [[12, 3], "UnderlinePosition", "num", -100], [[12, 4], "UnderlineThickness", "num", 50], [[12, 5], "PaintType", "num", 0], [[12, 6], "CharstringType", "num", 2], [[12, 7], "FontMatrix", ["num", "num", "num", "num", "num", "num"], [1e-3, 0, 0, 1e-3, 0, 0]], [13, "UniqueID", "num", null], [5, "FontBBox", ["num", "num", "num", "num"], [0, 0, 0, 0]], [[12, 8], "StrokeWidth", "num", 0], [14, "XUID", "array", null], [15, "charset", "offset", 0], [16, "Encoding", "offset", 0], [17, "CharStrings", "offset", 0], [18, "Private", ["offset", "offset"], null], [[12, 21], "PostScript", "sid", null], [[12, 22], "BaseFontName", "sid", null], [[12, 23], "BaseFontBlend", "delta", null], [[12, 31], "CIDFontVersion", "num", 0], [[12, 32], "CIDFontRevision", "num", 0], [[12, 33], "CIDFontType", "num", 0], [[12, 34], "CIDCount", "num", 8720], [[12, 35], "UIDBase", "num", null], [[12, 37], "FDSelect", "offset", null], [[12, 36], "FDArray", "offset", null], [[12, 38], "FontName", "sid", null]];
              const _CFFTopDict = class _CFFTopDict extends CFFDict {
                static get tables() {
                  return (0, _util.shadow)(this, "tables", this.createTables(CFFTopDictLayout));
                }
                constructor(strings) {
                  super(_CFFTopDict.tables, strings);
                  this.privateDict = null;
                }
              };
              __name(_CFFTopDict, "CFFTopDict");
              let CFFTopDict = _CFFTopDict;
              exports2.CFFTopDict = CFFTopDict;
              const CFFPrivateDictLayout = [[6, "BlueValues", "delta", null], [7, "OtherBlues", "delta", null], [8, "FamilyBlues", "delta", null], [9, "FamilyOtherBlues", "delta", null], [[12, 9], "BlueScale", "num", 0.039625], [[12, 10], "BlueShift", "num", 7], [[12, 11], "BlueFuzz", "num", 1], [10, "StdHW", "num", null], [11, "StdVW", "num", null], [[12, 12], "StemSnapH", "delta", null], [[12, 13], "StemSnapV", "delta", null], [[12, 14], "ForceBold", "num", 0], [[12, 17], "LanguageGroup", "num", 0], [[12, 18], "ExpansionFactor", "num", 0.06], [[12, 19], "initialRandomSeed", "num", 0], [20, "defaultWidthX", "num", 0], [21, "nominalWidthX", "num", 0], [19, "Subrs", "offset", null]];
              const _CFFPrivateDict = class _CFFPrivateDict extends CFFDict {
                static get tables() {
                  return (0, _util.shadow)(this, "tables", this.createTables(CFFPrivateDictLayout));
                }
                constructor(strings) {
                  super(_CFFPrivateDict.tables, strings);
                  this.subrsIndex = null;
                }
              };
              __name(_CFFPrivateDict, "CFFPrivateDict");
              let CFFPrivateDict = _CFFPrivateDict;
              exports2.CFFPrivateDict = CFFPrivateDict;
              const CFFCharsetPredefinedTypes = {
                ISO_ADOBE: 0,
                EXPERT: 1,
                EXPERT_SUBSET: 2
              };
              const _CFFCharset = class _CFFCharset {
                constructor(predefined, format, charset, raw) {
                  this.predefined = predefined;
                  this.format = format;
                  this.charset = charset;
                  this.raw = raw;
                }
              };
              __name(_CFFCharset, "CFFCharset");
              let CFFCharset = _CFFCharset;
              exports2.CFFCharset = CFFCharset;
              const _CFFEncoding = class _CFFEncoding {
                constructor(predefined, format, encoding, raw) {
                  this.predefined = predefined;
                  this.format = format;
                  this.encoding = encoding;
                  this.raw = raw;
                }
              };
              __name(_CFFEncoding, "CFFEncoding");
              let CFFEncoding = _CFFEncoding;
              const _CFFFDSelect = class _CFFFDSelect {
                constructor(format, fdSelect) {
                  this.format = format;
                  this.fdSelect = fdSelect;
                }
                getFDIndex(glyphIndex) {
                  if (glyphIndex < 0 || glyphIndex >= this.fdSelect.length) {
                    return -1;
                  }
                  return this.fdSelect[glyphIndex];
                }
              };
              __name(_CFFFDSelect, "CFFFDSelect");
              let CFFFDSelect = _CFFFDSelect;
              exports2.CFFFDSelect = CFFFDSelect;
              const _CFFOffsetTracker = class _CFFOffsetTracker {
                constructor() {
                  this.offsets = /* @__PURE__ */ Object.create(null);
                }
                isTracking(key) {
                  return key in this.offsets;
                }
                track(key, location) {
                  if (key in this.offsets) {
                    throw new _util.FormatError(`Already tracking location of ${key}`);
                  }
                  this.offsets[key] = location;
                }
                offset(value) {
                  for (const key in this.offsets) {
                    this.offsets[key] += value;
                  }
                }
                setEntryLocation(key, values, output) {
                  if (!(key in this.offsets)) {
                    throw new _util.FormatError(`Not tracking location of ${key}`);
                  }
                  const data = output.data;
                  const dataOffset = this.offsets[key];
                  const size = 5;
                  for (let i = 0, ii = values.length; i < ii; ++i) {
                    const offset0 = i * size + dataOffset;
                    const offset1 = offset0 + 1;
                    const offset2 = offset0 + 2;
                    const offset3 = offset0 + 3;
                    const offset4 = offset0 + 4;
                    if (data[offset0] !== 29 || data[offset1] !== 0 || data[offset2] !== 0 || data[offset3] !== 0 || data[offset4] !== 0) {
                      throw new _util.FormatError("writing to an offset that is not empty");
                    }
                    const value = values[i];
                    data[offset0] = 29;
                    data[offset1] = value >> 24 & 255;
                    data[offset2] = value >> 16 & 255;
                    data[offset3] = value >> 8 & 255;
                    data[offset4] = value & 255;
                  }
                }
              };
              __name(_CFFOffsetTracker, "CFFOffsetTracker");
              let CFFOffsetTracker = _CFFOffsetTracker;
              const _CFFCompiler = class _CFFCompiler {
                constructor(cff) {
                  this.cff = cff;
                }
                compile() {
                  const cff = this.cff;
                  const output = {
                    data: [],
                    length: 0,
                    add(data) {
                      this.data = this.data.concat(data);
                      this.length = this.data.length;
                    }
                  };
                  const header = this.compileHeader(cff.header);
                  output.add(header);
                  const nameIndex = this.compileNameIndex(cff.names);
                  output.add(nameIndex);
                  if (cff.isCIDFont) {
                    if (cff.topDict.hasName("FontMatrix")) {
                      const base = cff.topDict.getByName("FontMatrix");
                      cff.topDict.removeByName("FontMatrix");
                      for (let i = 0, ii = cff.fdArray.length; i < ii; i++) {
                        const subDict = cff.fdArray[i];
                        let matrix = base.slice(0);
                        if (subDict.hasName("FontMatrix")) {
                          matrix = _util.Util.transform(matrix, subDict.getByName("FontMatrix"));
                        }
                        subDict.setByName("FontMatrix", matrix);
                      }
                    }
                  }
                  const xuid = cff.topDict.getByName("XUID");
                  if (xuid && xuid.length > 16) {
                    cff.topDict.removeByName("XUID");
                  }
                  cff.topDict.setByName("charset", 0);
                  let compiled = this.compileTopDicts([cff.topDict], output.length, cff.isCIDFont);
                  output.add(compiled.output);
                  const topDictTracker = compiled.trackers[0];
                  const stringIndex = this.compileStringIndex(cff.strings.strings);
                  output.add(stringIndex);
                  const globalSubrIndex = this.compileIndex(cff.globalSubrIndex);
                  output.add(globalSubrIndex);
                  if (cff.encoding && cff.topDict.hasName("Encoding")) {
                    if (cff.encoding.predefined) {
                      topDictTracker.setEntryLocation("Encoding", [cff.encoding.format], output);
                    } else {
                      const encoding = this.compileEncoding(cff.encoding);
                      topDictTracker.setEntryLocation("Encoding", [output.length], output);
                      output.add(encoding);
                    }
                  }
                  const charset = this.compileCharset(cff.charset, cff.charStrings.count, cff.strings, cff.isCIDFont);
                  topDictTracker.setEntryLocation("charset", [output.length], output);
                  output.add(charset);
                  const charStrings = this.compileCharStrings(cff.charStrings);
                  topDictTracker.setEntryLocation("CharStrings", [output.length], output);
                  output.add(charStrings);
                  if (cff.isCIDFont) {
                    topDictTracker.setEntryLocation("FDSelect", [output.length], output);
                    const fdSelect = this.compileFDSelect(cff.fdSelect);
                    output.add(fdSelect);
                    compiled = this.compileTopDicts(cff.fdArray, output.length, true);
                    topDictTracker.setEntryLocation("FDArray", [output.length], output);
                    output.add(compiled.output);
                    const fontDictTrackers = compiled.trackers;
                    this.compilePrivateDicts(cff.fdArray, fontDictTrackers, output);
                  }
                  this.compilePrivateDicts([cff.topDict], [topDictTracker], output);
                  output.add([0]);
                  return output.data;
                }
                encodeNumber(value) {
                  if (Number.isInteger(value)) {
                    return this.encodeInteger(value);
                  }
                  return this.encodeFloat(value);
                }
                static get EncodeFloatRegExp() {
                  return (0, _util.shadow)(this, "EncodeFloatRegExp", /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/);
                }
                encodeFloat(num) {
                  let value = num.toString();
                  const m = _CFFCompiler.EncodeFloatRegExp.exec(value);
                  if (m) {
                    const epsilon = parseFloat("1e" + ((m[2] ? +m[2] : 0) + m[1].length));
                    value = (Math.round(num * epsilon) / epsilon).toString();
                  }
                  let nibbles = "";
                  let i, ii;
                  for (i = 0, ii = value.length; i < ii; ++i) {
                    const a = value[i];
                    if (a === "e") {
                      nibbles += value[++i] === "-" ? "c" : "b";
                    } else if (a === ".") {
                      nibbles += "a";
                    } else if (a === "-") {
                      nibbles += "e";
                    } else {
                      nibbles += a;
                    }
                  }
                  nibbles += nibbles.length & 1 ? "f" : "ff";
                  const out = [30];
                  for (i = 0, ii = nibbles.length; i < ii; i += 2) {
                    out.push(parseInt(nibbles.substring(i, i + 2), 16));
                  }
                  return out;
                }
                encodeInteger(value) {
                  let code;
                  if (value >= -107 && value <= 107) {
                    code = [value + 139];
                  } else if (value >= 108 && value <= 1131) {
                    value -= 108;
                    code = [(value >> 8) + 247, value & 255];
                  } else if (value >= -1131 && value <= -108) {
                    value = -value - 108;
                    code = [(value >> 8) + 251, value & 255];
                  } else if (value >= -32768 && value <= 32767) {
                    code = [28, value >> 8 & 255, value & 255];
                  } else {
                    code = [29, value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255];
                  }
                  return code;
                }
                compileHeader(header) {
                  return [header.major, header.minor, 4, header.offSize];
                }
                compileNameIndex(names) {
                  const nameIndex = new CFFIndex();
                  for (let i = 0, ii = names.length; i < ii; ++i) {
                    const name = names[i];
                    const length = Math.min(name.length, 127);
                    let sanitizedName = new Array(length);
                    for (let j = 0; j < length; j++) {
                      let char = name[j];
                      if (char < "!" || char > "~" || char === "[" || char === "]" || char === "(" || char === ")" || char === "{" || char === "}" || char === "<" || char === ">" || char === "/" || char === "%") {
                        char = "_";
                      }
                      sanitizedName[j] = char;
                    }
                    sanitizedName = sanitizedName.join("");
                    if (sanitizedName === "") {
                      sanitizedName = "Bad_Font_Name";
                    }
                    nameIndex.add((0, _util.stringToBytes)(sanitizedName));
                  }
                  return this.compileIndex(nameIndex);
                }
                compileTopDicts(dicts, length, removeCidKeys) {
                  const fontDictTrackers = [];
                  let fdArrayIndex = new CFFIndex();
                  for (let i = 0, ii = dicts.length; i < ii; ++i) {
                    const fontDict = dicts[i];
                    if (removeCidKeys) {
                      fontDict.removeByName("CIDFontVersion");
                      fontDict.removeByName("CIDFontRevision");
                      fontDict.removeByName("CIDFontType");
                      fontDict.removeByName("CIDCount");
                      fontDict.removeByName("UIDBase");
                    }
                    const fontDictTracker = new CFFOffsetTracker();
                    const fontDictData = this.compileDict(fontDict, fontDictTracker);
                    fontDictTrackers.push(fontDictTracker);
                    fdArrayIndex.add(fontDictData);
                    fontDictTracker.offset(length);
                  }
                  fdArrayIndex = this.compileIndex(fdArrayIndex, fontDictTrackers);
                  return {
                    trackers: fontDictTrackers,
                    output: fdArrayIndex
                  };
                }
                compilePrivateDicts(dicts, trackers, output) {
                  for (let i = 0, ii = dicts.length; i < ii; ++i) {
                    const fontDict = dicts[i];
                    const privateDict = fontDict.privateDict;
                    if (!privateDict || !fontDict.hasName("Private")) {
                      throw new _util.FormatError("There must be a private dictionary.");
                    }
                    const privateDictTracker = new CFFOffsetTracker();
                    const privateDictData = this.compileDict(privateDict, privateDictTracker);
                    let outputLength = output.length;
                    privateDictTracker.offset(outputLength);
                    if (!privateDictData.length) {
                      outputLength = 0;
                    }
                    trackers[i].setEntryLocation("Private", [privateDictData.length, outputLength], output);
                    output.add(privateDictData);
                    if (privateDict.subrsIndex && privateDict.hasName("Subrs")) {
                      const subrs = this.compileIndex(privateDict.subrsIndex);
                      privateDictTracker.setEntryLocation("Subrs", [privateDictData.length], output);
                      output.add(subrs);
                    }
                  }
                }
                compileDict(dict, offsetTracker) {
                  const out = [];
                  for (const key of dict.order) {
                    if (!(key in dict.values)) {
                      continue;
                    }
                    let values = dict.values[key];
                    let types = dict.types[key];
                    if (!Array.isArray(types)) {
                      types = [types];
                    }
                    if (!Array.isArray(values)) {
                      values = [values];
                    }
                    if (values.length === 0) {
                      continue;
                    }
                    for (let j = 0, jj = types.length; j < jj; ++j) {
                      const type = types[j];
                      const value = values[j];
                      switch (type) {
                        case "num":
                        case "sid":
                          out.push(...this.encodeNumber(value));
                          break;
                        case "offset":
                          const name = dict.keyToNameMap[key];
                          if (!offsetTracker.isTracking(name)) {
                            offsetTracker.track(name, out.length);
                          }
                          out.push(29, 0, 0, 0, 0);
                          break;
                        case "array":
                        case "delta":
                          out.push(...this.encodeNumber(value));
                          for (let k = 1, kk = values.length; k < kk; ++k) {
                            out.push(...this.encodeNumber(values[k]));
                          }
                          break;
                        default:
                          throw new _util.FormatError(`Unknown data type of ${type}`);
                      }
                    }
                    out.push(...dict.opcodes[key]);
                  }
                  return out;
                }
                compileStringIndex(strings) {
                  const stringIndex = new CFFIndex();
                  for (let i = 0, ii = strings.length; i < ii; ++i) {
                    stringIndex.add((0, _util.stringToBytes)(strings[i]));
                  }
                  return this.compileIndex(stringIndex);
                }
                compileGlobalSubrIndex() {
                  const globalSubrIndex = this.cff.globalSubrIndex;
                  this.out.writeByteArray(this.compileIndex(globalSubrIndex));
                }
                compileCharStrings(charStrings) {
                  const charStringsIndex = new CFFIndex();
                  for (let i = 0; i < charStrings.count; i++) {
                    const glyph = charStrings.get(i);
                    if (glyph.length === 0) {
                      charStringsIndex.add(new Uint8Array([139, 14]));
                      continue;
                    }
                    charStringsIndex.add(glyph);
                  }
                  return this.compileIndex(charStringsIndex);
                }
                compileCharset(charset, numGlyphs, strings, isCIDFont) {
                  let out;
                  const numGlyphsLessNotDef = numGlyphs - 1;
                  if (isCIDFont) {
                    out = new Uint8Array([2, 0, 0, numGlyphsLessNotDef >> 8 & 255, numGlyphsLessNotDef & 255]);
                  } else {
                    const length = 1 + numGlyphsLessNotDef * 2;
                    out = new Uint8Array(length);
                    out[0] = 0;
                    let charsetIndex = 0;
                    const numCharsets = charset.charset.length;
                    let warned = false;
                    for (let i = 1; i < out.length; i += 2) {
                      let sid = 0;
                      if (charsetIndex < numCharsets) {
                        const name = charset.charset[charsetIndex++];
                        sid = strings.getSID(name);
                        if (sid === -1) {
                          sid = 0;
                          if (!warned) {
                            warned = true;
                            (0, _util.warn)(`Couldn't find ${name} in CFF strings`);
                          }
                        }
                      }
                      out[i] = sid >> 8 & 255;
                      out[i + 1] = sid & 255;
                    }
                  }
                  return this.compileTypedArray(out);
                }
                compileEncoding(encoding) {
                  return this.compileTypedArray(encoding.raw);
                }
                compileFDSelect(fdSelect) {
                  const format = fdSelect.format;
                  let out, i;
                  switch (format) {
                    case 0:
                      out = new Uint8Array(1 + fdSelect.fdSelect.length);
                      out[0] = format;
                      for (i = 0; i < fdSelect.fdSelect.length; i++) {
                        out[i + 1] = fdSelect.fdSelect[i];
                      }
                      break;
                    case 3:
                      const start = 0;
                      let lastFD = fdSelect.fdSelect[0];
                      const ranges = [format, 0, 0, start >> 8 & 255, start & 255, lastFD];
                      for (i = 1; i < fdSelect.fdSelect.length; i++) {
                        const currentFD = fdSelect.fdSelect[i];
                        if (currentFD !== lastFD) {
                          ranges.push(i >> 8 & 255, i & 255, currentFD);
                          lastFD = currentFD;
                        }
                      }
                      const numRanges = (ranges.length - 3) / 3;
                      ranges[1] = numRanges >> 8 & 255;
                      ranges[2] = numRanges & 255;
                      ranges.push(i >> 8 & 255, i & 255);
                      out = new Uint8Array(ranges);
                      break;
                  }
                  return this.compileTypedArray(out);
                }
                compileTypedArray(data) {
                  const out = [];
                  for (let i = 0, ii = data.length; i < ii; ++i) {
                    out[i] = data[i];
                  }
                  return out;
                }
                compileIndex(index) {
                  let trackers = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
                  const objects = index.objects;
                  const count = objects.length;
                  if (count === 0) {
                    return [0, 0];
                  }
                  const data = [count >> 8 & 255, count & 255];
                  let lastOffset = 1, i;
                  for (i = 0; i < count; ++i) {
                    lastOffset += objects[i].length;
                  }
                  let offsetSize;
                  if (lastOffset < 256) {
                    offsetSize = 1;
                  } else if (lastOffset < 65536) {
                    offsetSize = 2;
                  } else if (lastOffset < 16777216) {
                    offsetSize = 3;
                  } else {
                    offsetSize = 4;
                  }
                  data.push(offsetSize);
                  let relativeOffset = 1;
                  for (i = 0; i < count + 1; i++) {
                    if (offsetSize === 1) {
                      data.push(relativeOffset & 255);
                    } else if (offsetSize === 2) {
                      data.push(relativeOffset >> 8 & 255, relativeOffset & 255);
                    } else if (offsetSize === 3) {
                      data.push(relativeOffset >> 16 & 255, relativeOffset >> 8 & 255, relativeOffset & 255);
                    } else {
                      data.push(relativeOffset >>> 24 & 255, relativeOffset >> 16 & 255, relativeOffset >> 8 & 255, relativeOffset & 255);
                    }
                    if (objects[i]) {
                      relativeOffset += objects[i].length;
                    }
                  }
                  for (i = 0; i < count; i++) {
                    if (trackers[i]) {
                      trackers[i].offset(data.length);
                    }
                    for (let j = 0, jj = objects[i].length; j < jj; j++) {
                      data.push(objects[i][j]);
                    }
                  }
                  return data;
                }
              };
              __name(_CFFCompiler, "CFFCompiler");
              let CFFCompiler = _CFFCompiler;
              exports2.CFFCompiler = CFFCompiler;
            },
            /* 161 */
            /***/
            (__unused_webpack_module, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.ISOAdobeCharset = exports2.ExpertSubsetCharset = exports2.ExpertCharset = void 0;
              const ISOAdobeCharset = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron"];
              exports2.ISOAdobeCharset = ISOAdobeCharset;
              const ExpertCharset = [".notdef", "space", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
              exports2.ExpertCharset = ExpertCharset;
              const ExpertSubsetCharset = [".notdef", "space", "dollaroldstyle", "dollarsuperior", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "hyphensuperior", "colonmonetary", "onefitted", "rupiah", "centoldstyle", "figuredash", "hypheninferior", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior"];
              exports2.ExpertSubsetCharset = ExpertSubsetCharset;
            },
            /* 162 */
            /***/
            (__unused_webpack_module, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.ZapfDingbatsEncoding = exports2.WinAnsiEncoding = exports2.SymbolSetEncoding = exports2.StandardEncoding = exports2.MacRomanEncoding = exports2.ExpertEncoding = void 0;
              exports2.getEncoding = getEncoding;
              const ExpertEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
              exports2.ExpertEncoding = ExpertEncoding;
              const MacExpertEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "centoldstyle", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "", "threequartersemdash", "", "questionsmall", "", "", "", "", "Ethsmall", "", "", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "", "", "", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hypheninferior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "asuperior", "centsuperior", "", "", "", "", "Aacutesmall", "Agravesmall", "Acircumflexsmall", "Adieresissmall", "Atildesmall", "Aringsmall", "Ccedillasmall", "Eacutesmall", "Egravesmall", "Ecircumflexsmall", "Edieresissmall", "Iacutesmall", "Igravesmall", "Icircumflexsmall", "Idieresissmall", "Ntildesmall", "Oacutesmall", "Ogravesmall", "Ocircumflexsmall", "Odieresissmall", "Otildesmall", "Uacutesmall", "Ugravesmall", "Ucircumflexsmall", "Udieresissmall", "", "eightsuperior", "fourinferior", "threeinferior", "sixinferior", "eightinferior", "seveninferior", "Scaronsmall", "", "centinferior", "twoinferior", "", "Dieresissmall", "", "Caronsmall", "osuperior", "fiveinferior", "", "commainferior", "periodinferior", "Yacutesmall", "", "dollarinferior", "", "", "Thornsmall", "", "nineinferior", "zeroinferior", "Zcaronsmall", "AEsmall", "Oslashsmall", "questiondownsmall", "oneinferior", "Lslashsmall", "", "", "", "", "", "", "Cedillasmall", "", "", "", "", "", "OEsmall", "figuredash", "hyphensuperior", "", "", "", "", "exclamdownsmall", "", "Ydieresissmall", "", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "ninesuperior", "zerosuperior", "", "esuperior", "rsuperior", "tsuperior", "", "", "isuperior", "ssuperior", "dsuperior", "", "", "", "", "", "lsuperior", "Ogoneksmall", "Brevesmall", "Macronsmall", "bsuperior", "nsuperior", "msuperior", "commasuperior", "periodsuperior", "Dotaccentsmall", "Ringsmall", "", "", "", ""];
              const MacRomanEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "space", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron"];
              exports2.MacRomanEncoding = MacRomanEncoding;
              const StandardEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls", "", "", "", ""];
              exports2.StandardEncoding = StandardEncoding;
              const WinAnsiEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "bullet", "Euro", "bullet", "quotesinglbase", "florin", "quotedblbase", "ellipsis", "dagger", "daggerdbl", "circumflex", "perthousand", "Scaron", "guilsinglleft", "OE", "bullet", "Zcaron", "bullet", "bullet", "quoteleft", "quoteright", "quotedblleft", "quotedblright", "bullet", "endash", "emdash", "tilde", "trademark", "scaron", "guilsinglright", "oe", "bullet", "zcaron", "Ydieresis", "space", "exclamdown", "cent", "sterling", "currency", "yen", "brokenbar", "section", "dieresis", "copyright", "ordfeminine", "guillemotleft", "logicalnot", "hyphen", "registered", "macron", "degree", "plusminus", "twosuperior", "threesuperior", "acute", "mu", "paragraph", "periodcentered", "cedilla", "onesuperior", "ordmasculine", "guillemotright", "onequarter", "onehalf", "threequarters", "questiondown", "Agrave", "Aacute", "Acircumflex", "Atilde", "Adieresis", "Aring", "AE", "Ccedilla", "Egrave", "Eacute", "Ecircumflex", "Edieresis", "Igrave", "Iacute", "Icircumflex", "Idieresis", "Eth", "Ntilde", "Ograve", "Oacute", "Ocircumflex", "Otilde", "Odieresis", "multiply", "Oslash", "Ugrave", "Uacute", "Ucircumflex", "Udieresis", "Yacute", "Thorn", "germandbls", "agrave", "aacute", "acircumflex", "atilde", "adieresis", "aring", "ae", "ccedilla", "egrave", "eacute", "ecircumflex", "edieresis", "igrave", "iacute", "icircumflex", "idieresis", "eth", "ntilde", "ograve", "oacute", "ocircumflex", "otilde", "odieresis", "divide", "oslash", "ugrave", "uacute", "ucircumflex", "udieresis", "yacute", "thorn", "ydieresis"];
              exports2.WinAnsiEncoding = WinAnsiEncoding;
              const SymbolSetEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "universal", "numbersign", "existential", "percent", "ampersand", "suchthat", "parenleft", "parenright", "asteriskmath", "plus", "comma", "minus", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "congruent", "Alpha", "Beta", "Chi", "Delta", "Epsilon", "Phi", "Gamma", "Eta", "Iota", "theta1", "Kappa", "Lambda", "Mu", "Nu", "Omicron", "Pi", "Theta", "Rho", "Sigma", "Tau", "Upsilon", "sigma1", "Omega", "Xi", "Psi", "Zeta", "bracketleft", "therefore", "bracketright", "perpendicular", "underscore", "radicalex", "alpha", "beta", "chi", "delta", "epsilon", "phi", "gamma", "eta", "iota", "phi1", "kappa", "lambda", "mu", "nu", "omicron", "pi", "theta", "rho", "sigma", "tau", "upsilon", "omega1", "omega", "xi", "psi", "zeta", "braceleft", "bar", "braceright", "similar", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Euro", "Upsilon1", "minute", "lessequal", "fraction", "infinity", "florin", "club", "diamond", "heart", "spade", "arrowboth", "arrowleft", "arrowup", "arrowright", "arrowdown", "degree", "plusminus", "second", "greaterequal", "multiply", "proportional", "partialdiff", "bullet", "divide", "notequal", "equivalence", "approxequal", "ellipsis", "arrowvertex", "arrowhorizex", "carriagereturn", "aleph", "Ifraktur", "Rfraktur", "weierstrass", "circlemultiply", "circleplus", "emptyset", "intersection", "union", "propersuperset", "reflexsuperset", "notsubset", "propersubset", "reflexsubset", "element", "notelement", "angle", "gradient", "registerserif", "copyrightserif", "trademarkserif", "product", "radical", "dotmath", "logicalnot", "logicaland", "logicalor", "arrowdblboth", "arrowdblleft", "arrowdblup", "arrowdblright", "arrowdbldown", "lozenge", "angleleft", "registersans", "copyrightsans", "trademarksans", "summation", "parenlefttp", "parenleftex", "parenleftbt", "bracketlefttp", "bracketleftex", "bracketleftbt", "bracelefttp", "braceleftmid", "braceleftbt", "braceex", "", "angleright", "integral", "integraltp", "integralex", "integralbt", "parenrighttp", "parenrightex", "parenrightbt", "bracketrighttp", "bracketrightex", "bracketrightbt", "bracerighttp", "bracerightmid", "bracerightbt", ""];
              exports2.SymbolSetEncoding = SymbolSetEncoding;
              const ZapfDingbatsEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "a1", "a2", "a202", "a3", "a4", "a5", "a119", "a118", "a117", "a11", "a12", "a13", "a14", "a15", "a16", "a105", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24", "a25", "a26", "a27", "a28", "a6", "a7", "a8", "a9", "a10", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36", "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48", "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60", "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72", "a73", "a74", "a203", "a75", "a204", "a76", "a77", "a78", "a79", "a81", "a82", "a83", "a84", "a97", "a98", "a99", "a100", "", "a89", "a90", "a93", "a94", "a91", "a92", "a205", "a85", "a206", "a86", "a87", "a88", "a95", "a96", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "a101", "a102", "a103", "a104", "a106", "a107", "a108", "a112", "a111", "a110", "a109", "a120", "a121", "a122", "a123", "a124", "a125", "a126", "a127", "a128", "a129", "a130", "a131", "a132", "a133", "a134", "a135", "a136", "a137", "a138", "a139", "a140", "a141", "a142", "a143", "a144", "a145", "a146", "a147", "a148", "a149", "a150", "a151", "a152", "a153", "a154", "a155", "a156", "a157", "a158", "a159", "a160", "a161", "a163", "a164", "a196", "a165", "a192", "a166", "a167", "a168", "a169", "a170", "a171", "a172", "a173", "a162", "a174", "a175", "a176", "a177", "a178", "a179", "a193", "a180", "a199", "a181", "a200", "a182", "", "a201", "a183", "a184", "a197", "a185", "a194", "a198", "a186", "a195", "a187", "a188", "a189", "a190", "a191", ""];
              exports2.ZapfDingbatsEncoding = ZapfDingbatsEncoding;
              function getEncoding(encodingName) {
                switch (encodingName) {
                  case "WinAnsiEncoding":
                    return WinAnsiEncoding;
                  case "StandardEncoding":
                    return StandardEncoding;
                  case "MacRomanEncoding":
                    return MacRomanEncoding;
                  case "SymbolSetEncoding":
                    return SymbolSetEncoding;
                  case "ZapfDingbatsEncoding":
                    return ZapfDingbatsEncoding;
                  case "ExpertEncoding":
                    return ExpertEncoding;
                  case "MacExpertEncoding":
                    return MacExpertEncoding;
                  default:
                    return null;
                }
              }
              __name(getEncoding, "getEncoding");
            },
            /* 163 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.SEAC_ANALYSIS_ENABLED = exports2.MacStandardGlyphOrdering = exports2.FontFlags = void 0;
              exports2.getFontType = getFontType;
              exports2.normalizeFontName = normalizeFontName;
              exports2.recoverGlyphName = recoverGlyphName;
              exports2.type1FontGlyphMapping = type1FontGlyphMapping;
              var _util = __w_pdfjs_require__2(2);
              var _encodings = __w_pdfjs_require__2(162);
              var _glyphlist = __w_pdfjs_require__2(164);
              var _unicode = __w_pdfjs_require__2(165);
              const SEAC_ANALYSIS_ENABLED = true;
              exports2.SEAC_ANALYSIS_ENABLED = SEAC_ANALYSIS_ENABLED;
              const FontFlags = {
                FixedPitch: 1,
                Serif: 2,
                Symbolic: 4,
                Script: 8,
                Nonsymbolic: 32,
                Italic: 64,
                AllCap: 65536,
                SmallCap: 131072,
                ForceBold: 262144
              };
              exports2.FontFlags = FontFlags;
              const MacStandardGlyphOrdering = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];
              exports2.MacStandardGlyphOrdering = MacStandardGlyphOrdering;
              function getFontType(type, subtype) {
                let isStandardFont = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                switch (type) {
                  case "Type1":
                    if (isStandardFont) {
                      return _util.FontType.TYPE1STANDARD;
                    }
                    return subtype === "Type1C" ? _util.FontType.TYPE1C : _util.FontType.TYPE1;
                  case "CIDFontType0":
                    return subtype === "CIDFontType0C" ? _util.FontType.CIDFONTTYPE0C : _util.FontType.CIDFONTTYPE0;
                  case "OpenType":
                    return _util.FontType.OPENTYPE;
                  case "TrueType":
                    return _util.FontType.TRUETYPE;
                  case "CIDFontType2":
                    return _util.FontType.CIDFONTTYPE2;
                  case "MMType1":
                    return _util.FontType.MMTYPE1;
                  case "Type0":
                    return _util.FontType.TYPE0;
                  default:
                    return _util.FontType.UNKNOWN;
                }
              }
              __name(getFontType, "getFontType");
              function recoverGlyphName(name, glyphsUnicodeMap) {
                if (glyphsUnicodeMap[name] !== void 0) {
                  return name;
                }
                const unicode = (0, _unicode.getUnicodeForGlyph)(name, glyphsUnicodeMap);
                if (unicode !== -1) {
                  for (const key in glyphsUnicodeMap) {
                    if (glyphsUnicodeMap[key] === unicode) {
                      return key;
                    }
                  }
                }
                (0, _util.info)("Unable to recover a standard glyph name for: " + name);
                return name;
              }
              __name(recoverGlyphName, "recoverGlyphName");
              function type1FontGlyphMapping(properties, builtInEncoding, glyphNames) {
                const charCodeToGlyphId = /* @__PURE__ */ Object.create(null);
                let glyphId, charCode, baseEncoding;
                const isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
                if (properties.isInternalFont) {
                  baseEncoding = builtInEncoding;
                  for (charCode = 0; charCode < baseEncoding.length; charCode++) {
                    glyphId = glyphNames.indexOf(baseEncoding[charCode]);
                    if (glyphId >= 0) {
                      charCodeToGlyphId[charCode] = glyphId;
                    } else {
                      charCodeToGlyphId[charCode] = 0;
                    }
                  }
                } else if (properties.baseEncodingName) {
                  baseEncoding = (0, _encodings.getEncoding)(properties.baseEncodingName);
                  for (charCode = 0; charCode < baseEncoding.length; charCode++) {
                    glyphId = glyphNames.indexOf(baseEncoding[charCode]);
                    if (glyphId >= 0) {
                      charCodeToGlyphId[charCode] = glyphId;
                    } else {
                      charCodeToGlyphId[charCode] = 0;
                    }
                  }
                } else if (isSymbolicFont) {
                  for (charCode in builtInEncoding) {
                    charCodeToGlyphId[charCode] = builtInEncoding[charCode];
                  }
                } else {
                  baseEncoding = _encodings.StandardEncoding;
                  for (charCode = 0; charCode < baseEncoding.length; charCode++) {
                    glyphId = glyphNames.indexOf(baseEncoding[charCode]);
                    if (glyphId >= 0) {
                      charCodeToGlyphId[charCode] = glyphId;
                    } else {
                      charCodeToGlyphId[charCode] = 0;
                    }
                  }
                }
                const differences = properties.differences;
                let glyphsUnicodeMap;
                if (differences) {
                  for (charCode in differences) {
                    const glyphName = differences[charCode];
                    glyphId = glyphNames.indexOf(glyphName);
                    if (glyphId === -1) {
                      if (!glyphsUnicodeMap) {
                        glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
                      }
                      const standardGlyphName = recoverGlyphName(glyphName, glyphsUnicodeMap);
                      if (standardGlyphName !== glyphName) {
                        glyphId = glyphNames.indexOf(standardGlyphName);
                      }
                    }
                    if (glyphId >= 0) {
                      charCodeToGlyphId[charCode] = glyphId;
                    } else {
                      charCodeToGlyphId[charCode] = 0;
                    }
                  }
                }
                return charCodeToGlyphId;
              }
              __name(type1FontGlyphMapping, "type1FontGlyphMapping");
              function normalizeFontName(name) {
                return name.replace(/[,_]/g, "-").replace(/\s/g, "");
              }
              __name(normalizeFontName, "normalizeFontName");
            },
            /* 164 */
            /***/
            (__unused_webpack_module, __webpack_exports__2, __w_pdfjs_require__2) => {
              __w_pdfjs_require__2.r(__webpack_exports__2);
              __w_pdfjs_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "getDingbatsGlyphsUnicode": () => (
                  /* binding */
                  getDingbatsGlyphsUnicode
                ),
                /* harmony export */
                "getGlyphsUnicode": () => (
                  /* binding */
                  getGlyphsUnicode
                )
                /* harmony export */
              });
              var _core_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __w_pdfjs_require__2(131);
              const getGlyphsUnicode = (0, _core_utils_js__WEBPACK_IMPORTED_MODULE_0__.getArrayLookupTableFactory)(function() {
                return [
                  "A",
                  65,
                  "AE",
                  198,
                  "AEacute",
                  508,
                  "AEmacron",
                  482,
                  "AEsmall",
                  63462,
                  "Aacute",
                  193,
                  "Aacutesmall",
                  63457,
                  "Abreve",
                  258,
                  "Abreveacute",
                  7854,
                  "Abrevecyrillic",
                  1232,
                  "Abrevedotbelow",
                  7862,
                  "Abrevegrave",
                  7856,
                  "Abrevehookabove",
                  7858,
                  "Abrevetilde",
                  7860,
                  "Acaron",
                  461,
                  "Acircle",
                  9398,
                  "Acircumflex",
                  194,
                  "Acircumflexacute",
                  7844,
                  "Acircumflexdotbelow",
                  7852,
                  "Acircumflexgrave",
                  7846,
                  "Acircumflexhookabove",
                  7848,
                  "Acircumflexsmall",
                  63458,
                  "Acircumflextilde",
                  7850,
                  "Acute",
                  63177,
                  "Acutesmall",
                  63412,
                  "Acyrillic",
                  1040,
                  "Adblgrave",
                  512,
                  "Adieresis",
                  196,
                  "Adieresiscyrillic",
                  1234,
                  "Adieresismacron",
                  478,
                  "Adieresissmall",
                  63460,
                  "Adotbelow",
                  7840,
                  "Adotmacron",
                  480,
                  "Agrave",
                  192,
                  "Agravesmall",
                  63456,
                  "Ahookabove",
                  7842,
                  "Aiecyrillic",
                  1236,
                  "Ainvertedbreve",
                  514,
                  "Alpha",
                  913,
                  "Alphatonos",
                  902,
                  "Amacron",
                  256,
                  "Amonospace",
                  65313,
                  "Aogonek",
                  260,
                  "Aring",
                  197,
                  "Aringacute",
                  506,
                  "Aringbelow",
                  7680,
                  "Aringsmall",
                  63461,
                  "Asmall",
                  63329,
                  "Atilde",
                  195,
                  "Atildesmall",
                  63459,
                  "Aybarmenian",
                  1329,
                  "B",
                  66,
                  "Bcircle",
                  9399,
                  "Bdotaccent",
                  7682,
                  "Bdotbelow",
                  7684,
                  "Becyrillic",
                  1041,
                  "Benarmenian",
                  1330,
                  "Beta",
                  914,
                  "Bhook",
                  385,
                  "Blinebelow",
                  7686,
                  "Bmonospace",
                  65314,
                  "Brevesmall",
                  63220,
                  "Bsmall",
                  63330,
                  "Btopbar",
                  386,
                  "C",
                  67,
                  "Caarmenian",
                  1342,
                  "Cacute",
                  262,
                  "Caron",
                  63178,
                  "Caronsmall",
                  63221,
                  "Ccaron",
                  268,
                  "Ccedilla",
                  199,
                  "Ccedillaacute",
                  7688,
                  "Ccedillasmall",
                  63463,
                  "Ccircle",
                  9400,
                  "Ccircumflex",
                  264,
                  "Cdot",
                  266,
                  "Cdotaccent",
                  266,
                  "Cedillasmall",
                  63416,
                  "Chaarmenian",
                  1353,
                  "Cheabkhasiancyrillic",
                  1212,
                  "Checyrillic",
                  1063,
                  "Chedescenderabkhasiancyrillic",
                  1214,
                  "Chedescendercyrillic",
                  1206,
                  "Chedieresiscyrillic",
                  1268,
                  "Cheharmenian",
                  1347,
                  "Chekhakassiancyrillic",
                  1227,
                  "Cheverticalstrokecyrillic",
                  1208,
                  "Chi",
                  935,
                  "Chook",
                  391,
                  "Circumflexsmall",
                  63222,
                  "Cmonospace",
                  65315,
                  "Coarmenian",
                  1361,
                  "Csmall",
                  63331,
                  "D",
                  68,
                  "DZ",
                  497,
                  "DZcaron",
                  452,
                  "Daarmenian",
                  1332,
                  "Dafrican",
                  393,
                  "Dcaron",
                  270,
                  "Dcedilla",
                  7696,
                  "Dcircle",
                  9401,
                  "Dcircumflexbelow",
                  7698,
                  "Dcroat",
                  272,
                  "Ddotaccent",
                  7690,
                  "Ddotbelow",
                  7692,
                  "Decyrillic",
                  1044,
                  "Deicoptic",
                  1006,
                  "Delta",
                  8710,
                  "Deltagreek",
                  916,
                  "Dhook",
                  394,
                  "Dieresis",
                  63179,
                  "DieresisAcute",
                  63180,
                  "DieresisGrave",
                  63181,
                  "Dieresissmall",
                  63400,
                  "Digammagreek",
                  988,
                  "Djecyrillic",
                  1026,
                  "Dlinebelow",
                  7694,
                  "Dmonospace",
                  65316,
                  "Dotaccentsmall",
                  63223,
                  "Dslash",
                  272,
                  "Dsmall",
                  63332,
                  "Dtopbar",
                  395,
                  "Dz",
                  498,
                  "Dzcaron",
                  453,
                  "Dzeabkhasiancyrillic",
                  1248,
                  "Dzecyrillic",
                  1029,
                  "Dzhecyrillic",
                  1039,
                  "E",
                  69,
                  "Eacute",
                  201,
                  "Eacutesmall",
                  63465,
                  "Ebreve",
                  276,
                  "Ecaron",
                  282,
                  "Ecedillabreve",
                  7708,
                  "Echarmenian",
                  1333,
                  "Ecircle",
                  9402,
                  "Ecircumflex",
                  202,
                  "Ecircumflexacute",
                  7870,
                  "Ecircumflexbelow",
                  7704,
                  "Ecircumflexdotbelow",
                  7878,
                  "Ecircumflexgrave",
                  7872,
                  "Ecircumflexhookabove",
                  7874,
                  "Ecircumflexsmall",
                  63466,
                  "Ecircumflextilde",
                  7876,
                  "Ecyrillic",
                  1028,
                  "Edblgrave",
                  516,
                  "Edieresis",
                  203,
                  "Edieresissmall",
                  63467,
                  "Edot",
                  278,
                  "Edotaccent",
                  278,
                  "Edotbelow",
                  7864,
                  "Efcyrillic",
                  1060,
                  "Egrave",
                  200,
                  "Egravesmall",
                  63464,
                  "Eharmenian",
                  1335,
                  "Ehookabove",
                  7866,
                  "Eightroman",
                  8551,
                  "Einvertedbreve",
                  518,
                  "Eiotifiedcyrillic",
                  1124,
                  "Elcyrillic",
                  1051,
                  "Elevenroman",
                  8554,
                  "Emacron",
                  274,
                  "Emacronacute",
                  7702,
                  "Emacrongrave",
                  7700,
                  "Emcyrillic",
                  1052,
                  "Emonospace",
                  65317,
                  "Encyrillic",
                  1053,
                  "Endescendercyrillic",
                  1186,
                  "Eng",
                  330,
                  "Enghecyrillic",
                  1188,
                  "Enhookcyrillic",
                  1223,
                  "Eogonek",
                  280,
                  "Eopen",
                  400,
                  "Epsilon",
                  917,
                  "Epsilontonos",
                  904,
                  "Ercyrillic",
                  1056,
                  "Ereversed",
                  398,
                  "Ereversedcyrillic",
                  1069,
                  "Escyrillic",
                  1057,
                  "Esdescendercyrillic",
                  1194,
                  "Esh",
                  425,
                  "Esmall",
                  63333,
                  "Eta",
                  919,
                  "Etarmenian",
                  1336,
                  "Etatonos",
                  905,
                  "Eth",
                  208,
                  "Ethsmall",
                  63472,
                  "Etilde",
                  7868,
                  "Etildebelow",
                  7706,
                  "Euro",
                  8364,
                  "Ezh",
                  439,
                  "Ezhcaron",
                  494,
                  "Ezhreversed",
                  440,
                  "F",
                  70,
                  "Fcircle",
                  9403,
                  "Fdotaccent",
                  7710,
                  "Feharmenian",
                  1366,
                  "Feicoptic",
                  996,
                  "Fhook",
                  401,
                  "Fitacyrillic",
                  1138,
                  "Fiveroman",
                  8548,
                  "Fmonospace",
                  65318,
                  "Fourroman",
                  8547,
                  "Fsmall",
                  63334,
                  "G",
                  71,
                  "GBsquare",
                  13191,
                  "Gacute",
                  500,
                  "Gamma",
                  915,
                  "Gammaafrican",
                  404,
                  "Gangiacoptic",
                  1002,
                  "Gbreve",
                  286,
                  "Gcaron",
                  486,
                  "Gcedilla",
                  290,
                  "Gcircle",
                  9404,
                  "Gcircumflex",
                  284,
                  "Gcommaaccent",
                  290,
                  "Gdot",
                  288,
                  "Gdotaccent",
                  288,
                  "Gecyrillic",
                  1043,
                  "Ghadarmenian",
                  1346,
                  "Ghemiddlehookcyrillic",
                  1172,
                  "Ghestrokecyrillic",
                  1170,
                  "Gheupturncyrillic",
                  1168,
                  "Ghook",
                  403,
                  "Gimarmenian",
                  1331,
                  "Gjecyrillic",
                  1027,
                  "Gmacron",
                  7712,
                  "Gmonospace",
                  65319,
                  "Grave",
                  63182,
                  "Gravesmall",
                  63328,
                  "Gsmall",
                  63335,
                  "Gsmallhook",
                  667,
                  "Gstroke",
                  484,
                  "H",
                  72,
                  "H18533",
                  9679,
                  "H18543",
                  9642,
                  "H18551",
                  9643,
                  "H22073",
                  9633,
                  "HPsquare",
                  13259,
                  "Haabkhasiancyrillic",
                  1192,
                  "Hadescendercyrillic",
                  1202,
                  "Hardsigncyrillic",
                  1066,
                  "Hbar",
                  294,
                  "Hbrevebelow",
                  7722,
                  "Hcedilla",
                  7720,
                  "Hcircle",
                  9405,
                  "Hcircumflex",
                  292,
                  "Hdieresis",
                  7718,
                  "Hdotaccent",
                  7714,
                  "Hdotbelow",
                  7716,
                  "Hmonospace",
                  65320,
                  "Hoarmenian",
                  1344,
                  "Horicoptic",
                  1e3,
                  "Hsmall",
                  63336,
                  "Hungarumlaut",
                  63183,
                  "Hungarumlautsmall",
                  63224,
                  "Hzsquare",
                  13200,
                  "I",
                  73,
                  "IAcyrillic",
                  1071,
                  "IJ",
                  306,
                  "IUcyrillic",
                  1070,
                  "Iacute",
                  205,
                  "Iacutesmall",
                  63469,
                  "Ibreve",
                  300,
                  "Icaron",
                  463,
                  "Icircle",
                  9406,
                  "Icircumflex",
                  206,
                  "Icircumflexsmall",
                  63470,
                  "Icyrillic",
                  1030,
                  "Idblgrave",
                  520,
                  "Idieresis",
                  207,
                  "Idieresisacute",
                  7726,
                  "Idieresiscyrillic",
                  1252,
                  "Idieresissmall",
                  63471,
                  "Idot",
                  304,
                  "Idotaccent",
                  304,
                  "Idotbelow",
                  7882,
                  "Iebrevecyrillic",
                  1238,
                  "Iecyrillic",
                  1045,
                  "Ifraktur",
                  8465,
                  "Igrave",
                  204,
                  "Igravesmall",
                  63468,
                  "Ihookabove",
                  7880,
                  "Iicyrillic",
                  1048,
                  "Iinvertedbreve",
                  522,
                  "Iishortcyrillic",
                  1049,
                  "Imacron",
                  298,
                  "Imacroncyrillic",
                  1250,
                  "Imonospace",
                  65321,
                  "Iniarmenian",
                  1339,
                  "Iocyrillic",
                  1025,
                  "Iogonek",
                  302,
                  "Iota",
                  921,
                  "Iotaafrican",
                  406,
                  "Iotadieresis",
                  938,
                  "Iotatonos",
                  906,
                  "Ismall",
                  63337,
                  "Istroke",
                  407,
                  "Itilde",
                  296,
                  "Itildebelow",
                  7724,
                  "Izhitsacyrillic",
                  1140,
                  "Izhitsadblgravecyrillic",
                  1142,
                  "J",
                  74,
                  "Jaarmenian",
                  1345,
                  "Jcircle",
                  9407,
                  "Jcircumflex",
                  308,
                  "Jecyrillic",
                  1032,
                  "Jheharmenian",
                  1355,
                  "Jmonospace",
                  65322,
                  "Jsmall",
                  63338,
                  "K",
                  75,
                  "KBsquare",
                  13189,
                  "KKsquare",
                  13261,
                  "Kabashkircyrillic",
                  1184,
                  "Kacute",
                  7728,
                  "Kacyrillic",
                  1050,
                  "Kadescendercyrillic",
                  1178,
                  "Kahookcyrillic",
                  1219,
                  "Kappa",
                  922,
                  "Kastrokecyrillic",
                  1182,
                  "Kaverticalstrokecyrillic",
                  1180,
                  "Kcaron",
                  488,
                  "Kcedilla",
                  310,
                  "Kcircle",
                  9408,
                  "Kcommaaccent",
                  310,
                  "Kdotbelow",
                  7730,
                  "Keharmenian",
                  1364,
                  "Kenarmenian",
                  1343,
                  "Khacyrillic",
                  1061,
                  "Kheicoptic",
                  998,
                  "Khook",
                  408,
                  "Kjecyrillic",
                  1036,
                  "Klinebelow",
                  7732,
                  "Kmonospace",
                  65323,
                  "Koppacyrillic",
                  1152,
                  "Koppagreek",
                  990,
                  "Ksicyrillic",
                  1134,
                  "Ksmall",
                  63339,
                  "L",
                  76,
                  "LJ",
                  455,
                  "LL",
                  63167,
                  "Lacute",
                  313,
                  "Lambda",
                  923,
                  "Lcaron",
                  317,
                  "Lcedilla",
                  315,
                  "Lcircle",
                  9409,
                  "Lcircumflexbelow",
                  7740,
                  "Lcommaaccent",
                  315,
                  "Ldot",
                  319,
                  "Ldotaccent",
                  319,
                  "Ldotbelow",
                  7734,
                  "Ldotbelowmacron",
                  7736,
                  "Liwnarmenian",
                  1340,
                  "Lj",
                  456,
                  "Ljecyrillic",
                  1033,
                  "Llinebelow",
                  7738,
                  "Lmonospace",
                  65324,
                  "Lslash",
                  321,
                  "Lslashsmall",
                  63225,
                  "Lsmall",
                  63340,
                  "M",
                  77,
                  "MBsquare",
                  13190,
                  "Macron",
                  63184,
                  "Macronsmall",
                  63407,
                  "Macute",
                  7742,
                  "Mcircle",
                  9410,
                  "Mdotaccent",
                  7744,
                  "Mdotbelow",
                  7746,
                  "Menarmenian",
                  1348,
                  "Mmonospace",
                  65325,
                  "Msmall",
                  63341,
                  "Mturned",
                  412,
                  "Mu",
                  924,
                  "N",
                  78,
                  "NJ",
                  458,
                  "Nacute",
                  323,
                  "Ncaron",
                  327,
                  "Ncedilla",
                  325,
                  "Ncircle",
                  9411,
                  "Ncircumflexbelow",
                  7754,
                  "Ncommaaccent",
                  325,
                  "Ndotaccent",
                  7748,
                  "Ndotbelow",
                  7750,
                  "Nhookleft",
                  413,
                  "Nineroman",
                  8552,
                  "Nj",
                  459,
                  "Njecyrillic",
                  1034,
                  "Nlinebelow",
                  7752,
                  "Nmonospace",
                  65326,
                  "Nowarmenian",
                  1350,
                  "Nsmall",
                  63342,
                  "Ntilde",
                  209,
                  "Ntildesmall",
                  63473,
                  "Nu",
                  925,
                  "O",
                  79,
                  "OE",
                  338,
                  "OEsmall",
                  63226,
                  "Oacute",
                  211,
                  "Oacutesmall",
                  63475,
                  "Obarredcyrillic",
                  1256,
                  "Obarreddieresiscyrillic",
                  1258,
                  "Obreve",
                  334,
                  "Ocaron",
                  465,
                  "Ocenteredtilde",
                  415,
                  "Ocircle",
                  9412,
                  "Ocircumflex",
                  212,
                  "Ocircumflexacute",
                  7888,
                  "Ocircumflexdotbelow",
                  7896,
                  "Ocircumflexgrave",
                  7890,
                  "Ocircumflexhookabove",
                  7892,
                  "Ocircumflexsmall",
                  63476,
                  "Ocircumflextilde",
                  7894,
                  "Ocyrillic",
                  1054,
                  "Odblacute",
                  336,
                  "Odblgrave",
                  524,
                  "Odieresis",
                  214,
                  "Odieresiscyrillic",
                  1254,
                  "Odieresissmall",
                  63478,
                  "Odotbelow",
                  7884,
                  "Ogoneksmall",
                  63227,
                  "Ograve",
                  210,
                  "Ogravesmall",
                  63474,
                  "Oharmenian",
                  1365,
                  "Ohm",
                  8486,
                  "Ohookabove",
                  7886,
                  "Ohorn",
                  416,
                  "Ohornacute",
                  7898,
                  "Ohorndotbelow",
                  7906,
                  "Ohorngrave",
                  7900,
                  "Ohornhookabove",
                  7902,
                  "Ohorntilde",
                  7904,
                  "Ohungarumlaut",
                  336,
                  "Oi",
                  418,
                  "Oinvertedbreve",
                  526,
                  "Omacron",
                  332,
                  "Omacronacute",
                  7762,
                  "Omacrongrave",
                  7760,
                  "Omega",
                  8486,
                  "Omegacyrillic",
                  1120,
                  "Omegagreek",
                  937,
                  "Omegaroundcyrillic",
                  1146,
                  "Omegatitlocyrillic",
                  1148,
                  "Omegatonos",
                  911,
                  "Omicron",
                  927,
                  "Omicrontonos",
                  908,
                  "Omonospace",
                  65327,
                  "Oneroman",
                  8544,
                  "Oogonek",
                  490,
                  "Oogonekmacron",
                  492,
                  "Oopen",
                  390,
                  "Oslash",
                  216,
                  "Oslashacute",
                  510,
                  "Oslashsmall",
                  63480,
                  "Osmall",
                  63343,
                  "Ostrokeacute",
                  510,
                  "Otcyrillic",
                  1150,
                  "Otilde",
                  213,
                  "Otildeacute",
                  7756,
                  "Otildedieresis",
                  7758,
                  "Otildesmall",
                  63477,
                  "P",
                  80,
                  "Pacute",
                  7764,
                  "Pcircle",
                  9413,
                  "Pdotaccent",
                  7766,
                  "Pecyrillic",
                  1055,
                  "Peharmenian",
                  1354,
                  "Pemiddlehookcyrillic",
                  1190,
                  "Phi",
                  934,
                  "Phook",
                  420,
                  "Pi",
                  928,
                  "Piwrarmenian",
                  1363,
                  "Pmonospace",
                  65328,
                  "Psi",
                  936,
                  "Psicyrillic",
                  1136,
                  "Psmall",
                  63344,
                  "Q",
                  81,
                  "Qcircle",
                  9414,
                  "Qmonospace",
                  65329,
                  "Qsmall",
                  63345,
                  "R",
                  82,
                  "Raarmenian",
                  1356,
                  "Racute",
                  340,
                  "Rcaron",
                  344,
                  "Rcedilla",
                  342,
                  "Rcircle",
                  9415,
                  "Rcommaaccent",
                  342,
                  "Rdblgrave",
                  528,
                  "Rdotaccent",
                  7768,
                  "Rdotbelow",
                  7770,
                  "Rdotbelowmacron",
                  7772,
                  "Reharmenian",
                  1360,
                  "Rfraktur",
                  8476,
                  "Rho",
                  929,
                  "Ringsmall",
                  63228,
                  "Rinvertedbreve",
                  530,
                  "Rlinebelow",
                  7774,
                  "Rmonospace",
                  65330,
                  "Rsmall",
                  63346,
                  "Rsmallinverted",
                  641,
                  "Rsmallinvertedsuperior",
                  694,
                  "S",
                  83,
                  "SF010000",
                  9484,
                  "SF020000",
                  9492,
                  "SF030000",
                  9488,
                  "SF040000",
                  9496,
                  "SF050000",
                  9532,
                  "SF060000",
                  9516,
                  "SF070000",
                  9524,
                  "SF080000",
                  9500,
                  "SF090000",
                  9508,
                  "SF100000",
                  9472,
                  "SF110000",
                  9474,
                  "SF190000",
                  9569,
                  "SF200000",
                  9570,
                  "SF210000",
                  9558,
                  "SF220000",
                  9557,
                  "SF230000",
                  9571,
                  "SF240000",
                  9553,
                  "SF250000",
                  9559,
                  "SF260000",
                  9565,
                  "SF270000",
                  9564,
                  "SF280000",
                  9563,
                  "SF360000",
                  9566,
                  "SF370000",
                  9567,
                  "SF380000",
                  9562,
                  "SF390000",
                  9556,
                  "SF400000",
                  9577,
                  "SF410000",
                  9574,
                  "SF420000",
                  9568,
                  "SF430000",
                  9552,
                  "SF440000",
                  9580,
                  "SF450000",
                  9575,
                  "SF460000",
                  9576,
                  "SF470000",
                  9572,
                  "SF480000",
                  9573,
                  "SF490000",
                  9561,
                  "SF500000",
                  9560,
                  "SF510000",
                  9554,
                  "SF520000",
                  9555,
                  "SF530000",
                  9579,
                  "SF540000",
                  9578,
                  "Sacute",
                  346,
                  "Sacutedotaccent",
                  7780,
                  "Sampigreek",
                  992,
                  "Scaron",
                  352,
                  "Scarondotaccent",
                  7782,
                  "Scaronsmall",
                  63229,
                  "Scedilla",
                  350,
                  "Schwa",
                  399,
                  "Schwacyrillic",
                  1240,
                  "Schwadieresiscyrillic",
                  1242,
                  "Scircle",
                  9416,
                  "Scircumflex",
                  348,
                  "Scommaaccent",
                  536,
                  "Sdotaccent",
                  7776,
                  "Sdotbelow",
                  7778,
                  "Sdotbelowdotaccent",
                  7784,
                  "Seharmenian",
                  1357,
                  "Sevenroman",
                  8550,
                  "Shaarmenian",
                  1351,
                  "Shacyrillic",
                  1064,
                  "Shchacyrillic",
                  1065,
                  "Sheicoptic",
                  994,
                  "Shhacyrillic",
                  1210,
                  "Shimacoptic",
                  1004,
                  "Sigma",
                  931,
                  "Sixroman",
                  8549,
                  "Smonospace",
                  65331,
                  "Softsigncyrillic",
                  1068,
                  "Ssmall",
                  63347,
                  "Stigmagreek",
                  986,
                  "T",
                  84,
                  "Tau",
                  932,
                  "Tbar",
                  358,
                  "Tcaron",
                  356,
                  "Tcedilla",
                  354,
                  "Tcircle",
                  9417,
                  "Tcircumflexbelow",
                  7792,
                  "Tcommaaccent",
                  354,
                  "Tdotaccent",
                  7786,
                  "Tdotbelow",
                  7788,
                  "Tecyrillic",
                  1058,
                  "Tedescendercyrillic",
                  1196,
                  "Tenroman",
                  8553,
                  "Tetsecyrillic",
                  1204,
                  "Theta",
                  920,
                  "Thook",
                  428,
                  "Thorn",
                  222,
                  "Thornsmall",
                  63486,
                  "Threeroman",
                  8546,
                  "Tildesmall",
                  63230,
                  "Tiwnarmenian",
                  1359,
                  "Tlinebelow",
                  7790,
                  "Tmonospace",
                  65332,
                  "Toarmenian",
                  1337,
                  "Tonefive",
                  444,
                  "Tonesix",
                  388,
                  "Tonetwo",
                  423,
                  "Tretroflexhook",
                  430,
                  "Tsecyrillic",
                  1062,
                  "Tshecyrillic",
                  1035,
                  "Tsmall",
                  63348,
                  "Twelveroman",
                  8555,
                  "Tworoman",
                  8545,
                  "U",
                  85,
                  "Uacute",
                  218,
                  "Uacutesmall",
                  63482,
                  "Ubreve",
                  364,
                  "Ucaron",
                  467,
                  "Ucircle",
                  9418,
                  "Ucircumflex",
                  219,
                  "Ucircumflexbelow",
                  7798,
                  "Ucircumflexsmall",
                  63483,
                  "Ucyrillic",
                  1059,
                  "Udblacute",
                  368,
                  "Udblgrave",
                  532,
                  "Udieresis",
                  220,
                  "Udieresisacute",
                  471,
                  "Udieresisbelow",
                  7794,
                  "Udieresiscaron",
                  473,
                  "Udieresiscyrillic",
                  1264,
                  "Udieresisgrave",
                  475,
                  "Udieresismacron",
                  469,
                  "Udieresissmall",
                  63484,
                  "Udotbelow",
                  7908,
                  "Ugrave",
                  217,
                  "Ugravesmall",
                  63481,
                  "Uhookabove",
                  7910,
                  "Uhorn",
                  431,
                  "Uhornacute",
                  7912,
                  "Uhorndotbelow",
                  7920,
                  "Uhorngrave",
                  7914,
                  "Uhornhookabove",
                  7916,
                  "Uhorntilde",
                  7918,
                  "Uhungarumlaut",
                  368,
                  "Uhungarumlautcyrillic",
                  1266,
                  "Uinvertedbreve",
                  534,
                  "Ukcyrillic",
                  1144,
                  "Umacron",
                  362,
                  "Umacroncyrillic",
                  1262,
                  "Umacrondieresis",
                  7802,
                  "Umonospace",
                  65333,
                  "Uogonek",
                  370,
                  "Upsilon",
                  933,
                  "Upsilon1",
                  978,
                  "Upsilonacutehooksymbolgreek",
                  979,
                  "Upsilonafrican",
                  433,
                  "Upsilondieresis",
                  939,
                  "Upsilondieresishooksymbolgreek",
                  980,
                  "Upsilonhooksymbol",
                  978,
                  "Upsilontonos",
                  910,
                  "Uring",
                  366,
                  "Ushortcyrillic",
                  1038,
                  "Usmall",
                  63349,
                  "Ustraightcyrillic",
                  1198,
                  "Ustraightstrokecyrillic",
                  1200,
                  "Utilde",
                  360,
                  "Utildeacute",
                  7800,
                  "Utildebelow",
                  7796,
                  "V",
                  86,
                  "Vcircle",
                  9419,
                  "Vdotbelow",
                  7806,
                  "Vecyrillic",
                  1042,
                  "Vewarmenian",
                  1358,
                  "Vhook",
                  434,
                  "Vmonospace",
                  65334,
                  "Voarmenian",
                  1352,
                  "Vsmall",
                  63350,
                  "Vtilde",
                  7804,
                  "W",
                  87,
                  "Wacute",
                  7810,
                  "Wcircle",
                  9420,
                  "Wcircumflex",
                  372,
                  "Wdieresis",
                  7812,
                  "Wdotaccent",
                  7814,
                  "Wdotbelow",
                  7816,
                  "Wgrave",
                  7808,
                  "Wmonospace",
                  65335,
                  "Wsmall",
                  63351,
                  "X",
                  88,
                  "Xcircle",
                  9421,
                  "Xdieresis",
                  7820,
                  "Xdotaccent",
                  7818,
                  "Xeharmenian",
                  1341,
                  "Xi",
                  926,
                  "Xmonospace",
                  65336,
                  "Xsmall",
                  63352,
                  "Y",
                  89,
                  "Yacute",
                  221,
                  "Yacutesmall",
                  63485,
                  "Yatcyrillic",
                  1122,
                  "Ycircle",
                  9422,
                  "Ycircumflex",
                  374,
                  "Ydieresis",
                  376,
                  "Ydieresissmall",
                  63487,
                  "Ydotaccent",
                  7822,
                  "Ydotbelow",
                  7924,
                  "Yericyrillic",
                  1067,
                  "Yerudieresiscyrillic",
                  1272,
                  "Ygrave",
                  7922,
                  "Yhook",
                  435,
                  "Yhookabove",
                  7926,
                  "Yiarmenian",
                  1349,
                  "Yicyrillic",
                  1031,
                  "Yiwnarmenian",
                  1362,
                  "Ymonospace",
                  65337,
                  "Ysmall",
                  63353,
                  "Ytilde",
                  7928,
                  "Yusbigcyrillic",
                  1130,
                  "Yusbigiotifiedcyrillic",
                  1132,
                  "Yuslittlecyrillic",
                  1126,
                  "Yuslittleiotifiedcyrillic",
                  1128,
                  "Z",
                  90,
                  "Zaarmenian",
                  1334,
                  "Zacute",
                  377,
                  "Zcaron",
                  381,
                  "Zcaronsmall",
                  63231,
                  "Zcircle",
                  9423,
                  "Zcircumflex",
                  7824,
                  "Zdot",
                  379,
                  "Zdotaccent",
                  379,
                  "Zdotbelow",
                  7826,
                  "Zecyrillic",
                  1047,
                  "Zedescendercyrillic",
                  1176,
                  "Zedieresiscyrillic",
                  1246,
                  "Zeta",
                  918,
                  "Zhearmenian",
                  1338,
                  "Zhebrevecyrillic",
                  1217,
                  "Zhecyrillic",
                  1046,
                  "Zhedescendercyrillic",
                  1174,
                  "Zhedieresiscyrillic",
                  1244,
                  "Zlinebelow",
                  7828,
                  "Zmonospace",
                  65338,
                  "Zsmall",
                  63354,
                  "Zstroke",
                  437,
                  "a",
                  97,
                  "aabengali",
                  2438,
                  "aacute",
                  225,
                  "aadeva",
                  2310,
                  "aagujarati",
                  2694,
                  "aagurmukhi",
                  2566,
                  "aamatragurmukhi",
                  2622,
                  "aarusquare",
                  13059,
                  "aavowelsignbengali",
                  2494,
                  "aavowelsigndeva",
                  2366,
                  "aavowelsigngujarati",
                  2750,
                  "abbreviationmarkarmenian",
                  1375,
                  "abbreviationsigndeva",
                  2416,
                  "abengali",
                  2437,
                  "abopomofo",
                  12570,
                  "abreve",
                  259,
                  "abreveacute",
                  7855,
                  "abrevecyrillic",
                  1233,
                  "abrevedotbelow",
                  7863,
                  "abrevegrave",
                  7857,
                  "abrevehookabove",
                  7859,
                  "abrevetilde",
                  7861,
                  "acaron",
                  462,
                  "acircle",
                  9424,
                  "acircumflex",
                  226,
                  "acircumflexacute",
                  7845,
                  "acircumflexdotbelow",
                  7853,
                  "acircumflexgrave",
                  7847,
                  "acircumflexhookabove",
                  7849,
                  "acircumflextilde",
                  7851,
                  "acute",
                  180,
                  "acutebelowcmb",
                  791,
                  "acutecmb",
                  769,
                  "acutecomb",
                  769,
                  "acutedeva",
                  2388,
                  "acutelowmod",
                  719,
                  "acutetonecmb",
                  833,
                  "acyrillic",
                  1072,
                  "adblgrave",
                  513,
                  "addakgurmukhi",
                  2673,
                  "adeva",
                  2309,
                  "adieresis",
                  228,
                  "adieresiscyrillic",
                  1235,
                  "adieresismacron",
                  479,
                  "adotbelow",
                  7841,
                  "adotmacron",
                  481,
                  "ae",
                  230,
                  "aeacute",
                  509,
                  "aekorean",
                  12624,
                  "aemacron",
                  483,
                  "afii00208",
                  8213,
                  "afii08941",
                  8356,
                  "afii10017",
                  1040,
                  "afii10018",
                  1041,
                  "afii10019",
                  1042,
                  "afii10020",
                  1043,
                  "afii10021",
                  1044,
                  "afii10022",
                  1045,
                  "afii10023",
                  1025,
                  "afii10024",
                  1046,
                  "afii10025",
                  1047,
                  "afii10026",
                  1048,
                  "afii10027",
                  1049,
                  "afii10028",
                  1050,
                  "afii10029",
                  1051,
                  "afii10030",
                  1052,
                  "afii10031",
                  1053,
                  "afii10032",
                  1054,
                  "afii10033",
                  1055,
                  "afii10034",
                  1056,
                  "afii10035",
                  1057,
                  "afii10036",
                  1058,
                  "afii10037",
                  1059,
                  "afii10038",
                  1060,
                  "afii10039",
                  1061,
                  "afii10040",
                  1062,
                  "afii10041",
                  1063,
                  "afii10042",
                  1064,
                  "afii10043",
                  1065,
                  "afii10044",
                  1066,
                  "afii10045",
                  1067,
                  "afii10046",
                  1068,
                  "afii10047",
                  1069,
                  "afii10048",
                  1070,
                  "afii10049",
                  1071,
                  "afii10050",
                  1168,
                  "afii10051",
                  1026,
                  "afii10052",
                  1027,
                  "afii10053",
                  1028,
                  "afii10054",
                  1029,
                  "afii10055",
                  1030,
                  "afii10056",
                  1031,
                  "afii10057",
                  1032,
                  "afii10058",
                  1033,
                  "afii10059",
                  1034,
                  "afii10060",
                  1035,
                  "afii10061",
                  1036,
                  "afii10062",
                  1038,
                  "afii10063",
                  63172,
                  "afii10064",
                  63173,
                  "afii10065",
                  1072,
                  "afii10066",
                  1073,
                  "afii10067",
                  1074,
                  "afii10068",
                  1075,
                  "afii10069",
                  1076,
                  "afii10070",
                  1077,
                  "afii10071",
                  1105,
                  "afii10072",
                  1078,
                  "afii10073",
                  1079,
                  "afii10074",
                  1080,
                  "afii10075",
                  1081,
                  "afii10076",
                  1082,
                  "afii10077",
                  1083,
                  "afii10078",
                  1084,
                  "afii10079",
                  1085,
                  "afii10080",
                  1086,
                  "afii10081",
                  1087,
                  "afii10082",
                  1088,
                  "afii10083",
                  1089,
                  "afii10084",
                  1090,
                  "afii10085",
                  1091,
                  "afii10086",
                  1092,
                  "afii10087",
                  1093,
                  "afii10088",
                  1094,
                  "afii10089",
                  1095,
                  "afii10090",
                  1096,
                  "afii10091",
                  1097,
                  "afii10092",
                  1098,
                  "afii10093",
                  1099,
                  "afii10094",
                  1100,
                  "afii10095",
                  1101,
                  "afii10096",
                  1102,
                  "afii10097",
                  1103,
                  "afii10098",
                  1169,
                  "afii10099",
                  1106,
                  "afii10100",
                  1107,
                  "afii10101",
                  1108,
                  "afii10102",
                  1109,
                  "afii10103",
                  1110,
                  "afii10104",
                  1111,
                  "afii10105",
                  1112,
                  "afii10106",
                  1113,
                  "afii10107",
                  1114,
                  "afii10108",
                  1115,
                  "afii10109",
                  1116,
                  "afii10110",
                  1118,
                  "afii10145",
                  1039,
                  "afii10146",
                  1122,
                  "afii10147",
                  1138,
                  "afii10148",
                  1140,
                  "afii10192",
                  63174,
                  "afii10193",
                  1119,
                  "afii10194",
                  1123,
                  "afii10195",
                  1139,
                  "afii10196",
                  1141,
                  "afii10831",
                  63175,
                  "afii10832",
                  63176,
                  "afii10846",
                  1241,
                  "afii299",
                  8206,
                  "afii300",
                  8207,
                  "afii301",
                  8205,
                  "afii57381",
                  1642,
                  "afii57388",
                  1548,
                  "afii57392",
                  1632,
                  "afii57393",
                  1633,
                  "afii57394",
                  1634,
                  "afii57395",
                  1635,
                  "afii57396",
                  1636,
                  "afii57397",
                  1637,
                  "afii57398",
                  1638,
                  "afii57399",
                  1639,
                  "afii57400",
                  1640,
                  "afii57401",
                  1641,
                  "afii57403",
                  1563,
                  "afii57407",
                  1567,
                  "afii57409",
                  1569,
                  "afii57410",
                  1570,
                  "afii57411",
                  1571,
                  "afii57412",
                  1572,
                  "afii57413",
                  1573,
                  "afii57414",
                  1574,
                  "afii57415",
                  1575,
                  "afii57416",
                  1576,
                  "afii57417",
                  1577,
                  "afii57418",
                  1578,
                  "afii57419",
                  1579,
                  "afii57420",
                  1580,
                  "afii57421",
                  1581,
                  "afii57422",
                  1582,
                  "afii57423",
                  1583,
                  "afii57424",
                  1584,
                  "afii57425",
                  1585,
                  "afii57426",
                  1586,
                  "afii57427",
                  1587,
                  "afii57428",
                  1588,
                  "afii57429",
                  1589,
                  "afii57430",
                  1590,
                  "afii57431",
                  1591,
                  "afii57432",
                  1592,
                  "afii57433",
                  1593,
                  "afii57434",
                  1594,
                  "afii57440",
                  1600,
                  "afii57441",
                  1601,
                  "afii57442",
                  1602,
                  "afii57443",
                  1603,
                  "afii57444",
                  1604,
                  "afii57445",
                  1605,
                  "afii57446",
                  1606,
                  "afii57448",
                  1608,
                  "afii57449",
                  1609,
                  "afii57450",
                  1610,
                  "afii57451",
                  1611,
                  "afii57452",
                  1612,
                  "afii57453",
                  1613,
                  "afii57454",
                  1614,
                  "afii57455",
                  1615,
                  "afii57456",
                  1616,
                  "afii57457",
                  1617,
                  "afii57458",
                  1618,
                  "afii57470",
                  1607,
                  "afii57505",
                  1700,
                  "afii57506",
                  1662,
                  "afii57507",
                  1670,
                  "afii57508",
                  1688,
                  "afii57509",
                  1711,
                  "afii57511",
                  1657,
                  "afii57512",
                  1672,
                  "afii57513",
                  1681,
                  "afii57514",
                  1722,
                  "afii57519",
                  1746,
                  "afii57534",
                  1749,
                  "afii57636",
                  8362,
                  "afii57645",
                  1470,
                  "afii57658",
                  1475,
                  "afii57664",
                  1488,
                  "afii57665",
                  1489,
                  "afii57666",
                  1490,
                  "afii57667",
                  1491,
                  "afii57668",
                  1492,
                  "afii57669",
                  1493,
                  "afii57670",
                  1494,
                  "afii57671",
                  1495,
                  "afii57672",
                  1496,
                  "afii57673",
                  1497,
                  "afii57674",
                  1498,
                  "afii57675",
                  1499,
                  "afii57676",
                  1500,
                  "afii57677",
                  1501,
                  "afii57678",
                  1502,
                  "afii57679",
                  1503,
                  "afii57680",
                  1504,
                  "afii57681",
                  1505,
                  "afii57682",
                  1506,
                  "afii57683",
                  1507,
                  "afii57684",
                  1508,
                  "afii57685",
                  1509,
                  "afii57686",
                  1510,
                  "afii57687",
                  1511,
                  "afii57688",
                  1512,
                  "afii57689",
                  1513,
                  "afii57690",
                  1514,
                  "afii57694",
                  64298,
                  "afii57695",
                  64299,
                  "afii57700",
                  64331,
                  "afii57705",
                  64287,
                  "afii57716",
                  1520,
                  "afii57717",
                  1521,
                  "afii57718",
                  1522,
                  "afii57723",
                  64309,
                  "afii57793",
                  1460,
                  "afii57794",
                  1461,
                  "afii57795",
                  1462,
                  "afii57796",
                  1467,
                  "afii57797",
                  1464,
                  "afii57798",
                  1463,
                  "afii57799",
                  1456,
                  "afii57800",
                  1458,
                  "afii57801",
                  1457,
                  "afii57802",
                  1459,
                  "afii57803",
                  1474,
                  "afii57804",
                  1473,
                  "afii57806",
                  1465,
                  "afii57807",
                  1468,
                  "afii57839",
                  1469,
                  "afii57841",
                  1471,
                  "afii57842",
                  1472,
                  "afii57929",
                  700,
                  "afii61248",
                  8453,
                  "afii61289",
                  8467,
                  "afii61352",
                  8470,
                  "afii61573",
                  8236,
                  "afii61574",
                  8237,
                  "afii61575",
                  8238,
                  "afii61664",
                  8204,
                  "afii63167",
                  1645,
                  "afii64937",
                  701,
                  "agrave",
                  224,
                  "agujarati",
                  2693,
                  "agurmukhi",
                  2565,
                  "ahiragana",
                  12354,
                  "ahookabove",
                  7843,
                  "aibengali",
                  2448,
                  "aibopomofo",
                  12574,
                  "aideva",
                  2320,
                  "aiecyrillic",
                  1237,
                  "aigujarati",
                  2704,
                  "aigurmukhi",
                  2576,
                  "aimatragurmukhi",
                  2632,
                  "ainarabic",
                  1593,
                  "ainfinalarabic",
                  65226,
                  "aininitialarabic",
                  65227,
                  "ainmedialarabic",
                  65228,
                  "ainvertedbreve",
                  515,
                  "aivowelsignbengali",
                  2504,
                  "aivowelsigndeva",
                  2376,
                  "aivowelsigngujarati",
                  2760,
                  "akatakana",
                  12450,
                  "akatakanahalfwidth",
                  65393,
                  "akorean",
                  12623,
                  "alef",
                  1488,
                  "alefarabic",
                  1575,
                  "alefdageshhebrew",
                  64304,
                  "aleffinalarabic",
                  65166,
                  "alefhamzaabovearabic",
                  1571,
                  "alefhamzaabovefinalarabic",
                  65156,
                  "alefhamzabelowarabic",
                  1573,
                  "alefhamzabelowfinalarabic",
                  65160,
                  "alefhebrew",
                  1488,
                  "aleflamedhebrew",
                  64335,
                  "alefmaddaabovearabic",
                  1570,
                  "alefmaddaabovefinalarabic",
                  65154,
                  "alefmaksuraarabic",
                  1609,
                  "alefmaksurafinalarabic",
                  65264,
                  "alefmaksurainitialarabic",
                  65267,
                  "alefmaksuramedialarabic",
                  65268,
                  "alefpatahhebrew",
                  64302,
                  "alefqamatshebrew",
                  64303,
                  "aleph",
                  8501,
                  "allequal",
                  8780,
                  "alpha",
                  945,
                  "alphatonos",
                  940,
                  "amacron",
                  257,
                  "amonospace",
                  65345,
                  "ampersand",
                  38,
                  "ampersandmonospace",
                  65286,
                  "ampersandsmall",
                  63270,
                  "amsquare",
                  13250,
                  "anbopomofo",
                  12578,
                  "angbopomofo",
                  12580,
                  "angbracketleft",
                  12296,
                  "angbracketright",
                  12297,
                  "angkhankhuthai",
                  3674,
                  "angle",
                  8736,
                  "anglebracketleft",
                  12296,
                  "anglebracketleftvertical",
                  65087,
                  "anglebracketright",
                  12297,
                  "anglebracketrightvertical",
                  65088,
                  "angleleft",
                  9001,
                  "angleright",
                  9002,
                  "angstrom",
                  8491,
                  "anoteleia",
                  903,
                  "anudattadeva",
                  2386,
                  "anusvarabengali",
                  2434,
                  "anusvaradeva",
                  2306,
                  "anusvaragujarati",
                  2690,
                  "aogonek",
                  261,
                  "apaatosquare",
                  13056,
                  "aparen",
                  9372,
                  "apostrophearmenian",
                  1370,
                  "apostrophemod",
                  700,
                  "apple",
                  63743,
                  "approaches",
                  8784,
                  "approxequal",
                  8776,
                  "approxequalorimage",
                  8786,
                  "approximatelyequal",
                  8773,
                  "araeaekorean",
                  12686,
                  "araeakorean",
                  12685,
                  "arc",
                  8978,
                  "arighthalfring",
                  7834,
                  "aring",
                  229,
                  "aringacute",
                  507,
                  "aringbelow",
                  7681,
                  "arrowboth",
                  8596,
                  "arrowdashdown",
                  8675,
                  "arrowdashleft",
                  8672,
                  "arrowdashright",
                  8674,
                  "arrowdashup",
                  8673,
                  "arrowdblboth",
                  8660,
                  "arrowdbldown",
                  8659,
                  "arrowdblleft",
                  8656,
                  "arrowdblright",
                  8658,
                  "arrowdblup",
                  8657,
                  "arrowdown",
                  8595,
                  "arrowdownleft",
                  8601,
                  "arrowdownright",
                  8600,
                  "arrowdownwhite",
                  8681,
                  "arrowheaddownmod",
                  709,
                  "arrowheadleftmod",
                  706,
                  "arrowheadrightmod",
                  707,
                  "arrowheadupmod",
                  708,
                  "arrowhorizex",
                  63719,
                  "arrowleft",
                  8592,
                  "arrowleftdbl",
                  8656,
                  "arrowleftdblstroke",
                  8653,
                  "arrowleftoverright",
                  8646,
                  "arrowleftwhite",
                  8678,
                  "arrowright",
                  8594,
                  "arrowrightdblstroke",
                  8655,
                  "arrowrightheavy",
                  10142,
                  "arrowrightoverleft",
                  8644,
                  "arrowrightwhite",
                  8680,
                  "arrowtableft",
                  8676,
                  "arrowtabright",
                  8677,
                  "arrowup",
                  8593,
                  "arrowupdn",
                  8597,
                  "arrowupdnbse",
                  8616,
                  "arrowupdownbase",
                  8616,
                  "arrowupleft",
                  8598,
                  "arrowupleftofdown",
                  8645,
                  "arrowupright",
                  8599,
                  "arrowupwhite",
                  8679,
                  "arrowvertex",
                  63718,
                  "asciicircum",
                  94,
                  "asciicircummonospace",
                  65342,
                  "asciitilde",
                  126,
                  "asciitildemonospace",
                  65374,
                  "ascript",
                  593,
                  "ascriptturned",
                  594,
                  "asmallhiragana",
                  12353,
                  "asmallkatakana",
                  12449,
                  "asmallkatakanahalfwidth",
                  65383,
                  "asterisk",
                  42,
                  "asteriskaltonearabic",
                  1645,
                  "asteriskarabic",
                  1645,
                  "asteriskmath",
                  8727,
                  "asteriskmonospace",
                  65290,
                  "asterisksmall",
                  65121,
                  "asterism",
                  8258,
                  "asuperior",
                  63209,
                  "asymptoticallyequal",
                  8771,
                  "at",
                  64,
                  "atilde",
                  227,
                  "atmonospace",
                  65312,
                  "atsmall",
                  65131,
                  "aturned",
                  592,
                  "aubengali",
                  2452,
                  "aubopomofo",
                  12576,
                  "audeva",
                  2324,
                  "augujarati",
                  2708,
                  "augurmukhi",
                  2580,
                  "aulengthmarkbengali",
                  2519,
                  "aumatragurmukhi",
                  2636,
                  "auvowelsignbengali",
                  2508,
                  "auvowelsigndeva",
                  2380,
                  "auvowelsigngujarati",
                  2764,
                  "avagrahadeva",
                  2365,
                  "aybarmenian",
                  1377,
                  "ayin",
                  1506,
                  "ayinaltonehebrew",
                  64288,
                  "ayinhebrew",
                  1506,
                  "b",
                  98,
                  "babengali",
                  2476,
                  "backslash",
                  92,
                  "backslashmonospace",
                  65340,
                  "badeva",
                  2348,
                  "bagujarati",
                  2732,
                  "bagurmukhi",
                  2604,
                  "bahiragana",
                  12400,
                  "bahtthai",
                  3647,
                  "bakatakana",
                  12496,
                  "bar",
                  124,
                  "barmonospace",
                  65372,
                  "bbopomofo",
                  12549,
                  "bcircle",
                  9425,
                  "bdotaccent",
                  7683,
                  "bdotbelow",
                  7685,
                  "beamedsixteenthnotes",
                  9836,
                  "because",
                  8757,
                  "becyrillic",
                  1073,
                  "beharabic",
                  1576,
                  "behfinalarabic",
                  65168,
                  "behinitialarabic",
                  65169,
                  "behiragana",
                  12409,
                  "behmedialarabic",
                  65170,
                  "behmeeminitialarabic",
                  64671,
                  "behmeemisolatedarabic",
                  64520,
                  "behnoonfinalarabic",
                  64621,
                  "bekatakana",
                  12505,
                  "benarmenian",
                  1378,
                  "bet",
                  1489,
                  "beta",
                  946,
                  "betasymbolgreek",
                  976,
                  "betdagesh",
                  64305,
                  "betdageshhebrew",
                  64305,
                  "bethebrew",
                  1489,
                  "betrafehebrew",
                  64332,
                  "bhabengali",
                  2477,
                  "bhadeva",
                  2349,
                  "bhagujarati",
                  2733,
                  "bhagurmukhi",
                  2605,
                  "bhook",
                  595,
                  "bihiragana",
                  12403,
                  "bikatakana",
                  12499,
                  "bilabialclick",
                  664,
                  "bindigurmukhi",
                  2562,
                  "birusquare",
                  13105,
                  "blackcircle",
                  9679,
                  "blackdiamond",
                  9670,
                  "blackdownpointingtriangle",
                  9660,
                  "blackleftpointingpointer",
                  9668,
                  "blackleftpointingtriangle",
                  9664,
                  "blacklenticularbracketleft",
                  12304,
                  "blacklenticularbracketleftvertical",
                  65083,
                  "blacklenticularbracketright",
                  12305,
                  "blacklenticularbracketrightvertical",
                  65084,
                  "blacklowerlefttriangle",
                  9699,
                  "blacklowerrighttriangle",
                  9698,
                  "blackrectangle",
                  9644,
                  "blackrightpointingpointer",
                  9658,
                  "blackrightpointingtriangle",
                  9654,
                  "blacksmallsquare",
                  9642,
                  "blacksmilingface",
                  9787,
                  "blacksquare",
                  9632,
                  "blackstar",
                  9733,
                  "blackupperlefttriangle",
                  9700,
                  "blackupperrighttriangle",
                  9701,
                  "blackuppointingsmalltriangle",
                  9652,
                  "blackuppointingtriangle",
                  9650,
                  "blank",
                  9251,
                  "blinebelow",
                  7687,
                  "block",
                  9608,
                  "bmonospace",
                  65346,
                  "bobaimaithai",
                  3610,
                  "bohiragana",
                  12412,
                  "bokatakana",
                  12508,
                  "bparen",
                  9373,
                  "bqsquare",
                  13251,
                  "braceex",
                  63732,
                  "braceleft",
                  123,
                  "braceleftbt",
                  63731,
                  "braceleftmid",
                  63730,
                  "braceleftmonospace",
                  65371,
                  "braceleftsmall",
                  65115,
                  "bracelefttp",
                  63729,
                  "braceleftvertical",
                  65079,
                  "braceright",
                  125,
                  "bracerightbt",
                  63742,
                  "bracerightmid",
                  63741,
                  "bracerightmonospace",
                  65373,
                  "bracerightsmall",
                  65116,
                  "bracerighttp",
                  63740,
                  "bracerightvertical",
                  65080,
                  "bracketleft",
                  91,
                  "bracketleftbt",
                  63728,
                  "bracketleftex",
                  63727,
                  "bracketleftmonospace",
                  65339,
                  "bracketlefttp",
                  63726,
                  "bracketright",
                  93,
                  "bracketrightbt",
                  63739,
                  "bracketrightex",
                  63738,
                  "bracketrightmonospace",
                  65341,
                  "bracketrighttp",
                  63737,
                  "breve",
                  728,
                  "brevebelowcmb",
                  814,
                  "brevecmb",
                  774,
                  "breveinvertedbelowcmb",
                  815,
                  "breveinvertedcmb",
                  785,
                  "breveinverteddoublecmb",
                  865,
                  "bridgebelowcmb",
                  810,
                  "bridgeinvertedbelowcmb",
                  826,
                  "brokenbar",
                  166,
                  "bstroke",
                  384,
                  "bsuperior",
                  63210,
                  "btopbar",
                  387,
                  "buhiragana",
                  12406,
                  "bukatakana",
                  12502,
                  "bullet",
                  8226,
                  "bulletinverse",
                  9688,
                  "bulletoperator",
                  8729,
                  "bullseye",
                  9678,
                  "c",
                  99,
                  "caarmenian",
                  1390,
                  "cabengali",
                  2458,
                  "cacute",
                  263,
                  "cadeva",
                  2330,
                  "cagujarati",
                  2714,
                  "cagurmukhi",
                  2586,
                  "calsquare",
                  13192,
                  "candrabindubengali",
                  2433,
                  "candrabinducmb",
                  784,
                  "candrabindudeva",
                  2305,
                  "candrabindugujarati",
                  2689,
                  "capslock",
                  8682,
                  "careof",
                  8453,
                  "caron",
                  711,
                  "caronbelowcmb",
                  812,
                  "caroncmb",
                  780,
                  "carriagereturn",
                  8629,
                  "cbopomofo",
                  12568,
                  "ccaron",
                  269,
                  "ccedilla",
                  231,
                  "ccedillaacute",
                  7689,
                  "ccircle",
                  9426,
                  "ccircumflex",
                  265,
                  "ccurl",
                  597,
                  "cdot",
                  267,
                  "cdotaccent",
                  267,
                  "cdsquare",
                  13253,
                  "cedilla",
                  184,
                  "cedillacmb",
                  807,
                  "cent",
                  162,
                  "centigrade",
                  8451,
                  "centinferior",
                  63199,
                  "centmonospace",
                  65504,
                  "centoldstyle",
                  63394,
                  "centsuperior",
                  63200,
                  "chaarmenian",
                  1401,
                  "chabengali",
                  2459,
                  "chadeva",
                  2331,
                  "chagujarati",
                  2715,
                  "chagurmukhi",
                  2587,
                  "chbopomofo",
                  12564,
                  "cheabkhasiancyrillic",
                  1213,
                  "checkmark",
                  10003,
                  "checyrillic",
                  1095,
                  "chedescenderabkhasiancyrillic",
                  1215,
                  "chedescendercyrillic",
                  1207,
                  "chedieresiscyrillic",
                  1269,
                  "cheharmenian",
                  1395,
                  "chekhakassiancyrillic",
                  1228,
                  "cheverticalstrokecyrillic",
                  1209,
                  "chi",
                  967,
                  "chieuchacirclekorean",
                  12919,
                  "chieuchaparenkorean",
                  12823,
                  "chieuchcirclekorean",
                  12905,
                  "chieuchkorean",
                  12618,
                  "chieuchparenkorean",
                  12809,
                  "chochangthai",
                  3594,
                  "chochanthai",
                  3592,
                  "chochingthai",
                  3593,
                  "chochoethai",
                  3596,
                  "chook",
                  392,
                  "cieucacirclekorean",
                  12918,
                  "cieucaparenkorean",
                  12822,
                  "cieuccirclekorean",
                  12904,
                  "cieuckorean",
                  12616,
                  "cieucparenkorean",
                  12808,
                  "cieucuparenkorean",
                  12828,
                  "circle",
                  9675,
                  "circlecopyrt",
                  169,
                  "circlemultiply",
                  8855,
                  "circleot",
                  8857,
                  "circleplus",
                  8853,
                  "circlepostalmark",
                  12342,
                  "circlewithlefthalfblack",
                  9680,
                  "circlewithrighthalfblack",
                  9681,
                  "circumflex",
                  710,
                  "circumflexbelowcmb",
                  813,
                  "circumflexcmb",
                  770,
                  "clear",
                  8999,
                  "clickalveolar",
                  450,
                  "clickdental",
                  448,
                  "clicklateral",
                  449,
                  "clickretroflex",
                  451,
                  "club",
                  9827,
                  "clubsuitblack",
                  9827,
                  "clubsuitwhite",
                  9831,
                  "cmcubedsquare",
                  13220,
                  "cmonospace",
                  65347,
                  "cmsquaredsquare",
                  13216,
                  "coarmenian",
                  1409,
                  "colon",
                  58,
                  "colonmonetary",
                  8353,
                  "colonmonospace",
                  65306,
                  "colonsign",
                  8353,
                  "colonsmall",
                  65109,
                  "colontriangularhalfmod",
                  721,
                  "colontriangularmod",
                  720,
                  "comma",
                  44,
                  "commaabovecmb",
                  787,
                  "commaaboverightcmb",
                  789,
                  "commaaccent",
                  63171,
                  "commaarabic",
                  1548,
                  "commaarmenian",
                  1373,
                  "commainferior",
                  63201,
                  "commamonospace",
                  65292,
                  "commareversedabovecmb",
                  788,
                  "commareversedmod",
                  701,
                  "commasmall",
                  65104,
                  "commasuperior",
                  63202,
                  "commaturnedabovecmb",
                  786,
                  "commaturnedmod",
                  699,
                  "compass",
                  9788,
                  "congruent",
                  8773,
                  "contourintegral",
                  8750,
                  "control",
                  8963,
                  "controlACK",
                  6,
                  "controlBEL",
                  7,
                  "controlBS",
                  8,
                  "controlCAN",
                  24,
                  "controlCR",
                  13,
                  "controlDC1",
                  17,
                  "controlDC2",
                  18,
                  "controlDC3",
                  19,
                  "controlDC4",
                  20,
                  "controlDEL",
                  127,
                  "controlDLE",
                  16,
                  "controlEM",
                  25,
                  "controlENQ",
                  5,
                  "controlEOT",
                  4,
                  "controlESC",
                  27,
                  "controlETB",
                  23,
                  "controlETX",
                  3,
                  "controlFF",
                  12,
                  "controlFS",
                  28,
                  "controlGS",
                  29,
                  "controlHT",
                  9,
                  "controlLF",
                  10,
                  "controlNAK",
                  21,
                  "controlNULL",
                  0,
                  "controlRS",
                  30,
                  "controlSI",
                  15,
                  "controlSO",
                  14,
                  "controlSOT",
                  2,
                  "controlSTX",
                  1,
                  "controlSUB",
                  26,
                  "controlSYN",
                  22,
                  "controlUS",
                  31,
                  "controlVT",
                  11,
                  "copyright",
                  169,
                  "copyrightsans",
                  63721,
                  "copyrightserif",
                  63193,
                  "cornerbracketleft",
                  12300,
                  "cornerbracketlefthalfwidth",
                  65378,
                  "cornerbracketleftvertical",
                  65089,
                  "cornerbracketright",
                  12301,
                  "cornerbracketrighthalfwidth",
                  65379,
                  "cornerbracketrightvertical",
                  65090,
                  "corporationsquare",
                  13183,
                  "cosquare",
                  13255,
                  "coverkgsquare",
                  13254,
                  "cparen",
                  9374,
                  "cruzeiro",
                  8354,
                  "cstretched",
                  663,
                  "curlyand",
                  8911,
                  "curlyor",
                  8910,
                  "currency",
                  164,
                  "cyrBreve",
                  63185,
                  "cyrFlex",
                  63186,
                  "cyrbreve",
                  63188,
                  "cyrflex",
                  63189,
                  "d",
                  100,
                  "daarmenian",
                  1380,
                  "dabengali",
                  2470,
                  "dadarabic",
                  1590,
                  "dadeva",
                  2342,
                  "dadfinalarabic",
                  65214,
                  "dadinitialarabic",
                  65215,
                  "dadmedialarabic",
                  65216,
                  "dagesh",
                  1468,
                  "dageshhebrew",
                  1468,
                  "dagger",
                  8224,
                  "daggerdbl",
                  8225,
                  "dagujarati",
                  2726,
                  "dagurmukhi",
                  2598,
                  "dahiragana",
                  12384,
                  "dakatakana",
                  12480,
                  "dalarabic",
                  1583,
                  "dalet",
                  1491,
                  "daletdagesh",
                  64307,
                  "daletdageshhebrew",
                  64307,
                  "dalethebrew",
                  1491,
                  "dalfinalarabic",
                  65194,
                  "dammaarabic",
                  1615,
                  "dammalowarabic",
                  1615,
                  "dammatanaltonearabic",
                  1612,
                  "dammatanarabic",
                  1612,
                  "danda",
                  2404,
                  "dargahebrew",
                  1447,
                  "dargalefthebrew",
                  1447,
                  "dasiapneumatacyrilliccmb",
                  1157,
                  "dblGrave",
                  63187,
                  "dblanglebracketleft",
                  12298,
                  "dblanglebracketleftvertical",
                  65085,
                  "dblanglebracketright",
                  12299,
                  "dblanglebracketrightvertical",
                  65086,
                  "dblarchinvertedbelowcmb",
                  811,
                  "dblarrowleft",
                  8660,
                  "dblarrowright",
                  8658,
                  "dbldanda",
                  2405,
                  "dblgrave",
                  63190,
                  "dblgravecmb",
                  783,
                  "dblintegral",
                  8748,
                  "dbllowline",
                  8215,
                  "dbllowlinecmb",
                  819,
                  "dbloverlinecmb",
                  831,
                  "dblprimemod",
                  698,
                  "dblverticalbar",
                  8214,
                  "dblverticallineabovecmb",
                  782,
                  "dbopomofo",
                  12553,
                  "dbsquare",
                  13256,
                  "dcaron",
                  271,
                  "dcedilla",
                  7697,
                  "dcircle",
                  9427,
                  "dcircumflexbelow",
                  7699,
                  "dcroat",
                  273,
                  "ddabengali",
                  2465,
                  "ddadeva",
                  2337,
                  "ddagujarati",
                  2721,
                  "ddagurmukhi",
                  2593,
                  "ddalarabic",
                  1672,
                  "ddalfinalarabic",
                  64393,
                  "dddhadeva",
                  2396,
                  "ddhabengali",
                  2466,
                  "ddhadeva",
                  2338,
                  "ddhagujarati",
                  2722,
                  "ddhagurmukhi",
                  2594,
                  "ddotaccent",
                  7691,
                  "ddotbelow",
                  7693,
                  "decimalseparatorarabic",
                  1643,
                  "decimalseparatorpersian",
                  1643,
                  "decyrillic",
                  1076,
                  "degree",
                  176,
                  "dehihebrew",
                  1453,
                  "dehiragana",
                  12391,
                  "deicoptic",
                  1007,
                  "dekatakana",
                  12487,
                  "deleteleft",
                  9003,
                  "deleteright",
                  8998,
                  "delta",
                  948,
                  "deltaturned",
                  397,
                  "denominatorminusonenumeratorbengali",
                  2552,
                  "dezh",
                  676,
                  "dhabengali",
                  2471,
                  "dhadeva",
                  2343,
                  "dhagujarati",
                  2727,
                  "dhagurmukhi",
                  2599,
                  "dhook",
                  599,
                  "dialytikatonos",
                  901,
                  "dialytikatonoscmb",
                  836,
                  "diamond",
                  9830,
                  "diamondsuitwhite",
                  9826,
                  "dieresis",
                  168,
                  "dieresisacute",
                  63191,
                  "dieresisbelowcmb",
                  804,
                  "dieresiscmb",
                  776,
                  "dieresisgrave",
                  63192,
                  "dieresistonos",
                  901,
                  "dihiragana",
                  12386,
                  "dikatakana",
                  12482,
                  "dittomark",
                  12291,
                  "divide",
                  247,
                  "divides",
                  8739,
                  "divisionslash",
                  8725,
                  "djecyrillic",
                  1106,
                  "dkshade",
                  9619,
                  "dlinebelow",
                  7695,
                  "dlsquare",
                  13207,
                  "dmacron",
                  273,
                  "dmonospace",
                  65348,
                  "dnblock",
                  9604,
                  "dochadathai",
                  3598,
                  "dodekthai",
                  3604,
                  "dohiragana",
                  12393,
                  "dokatakana",
                  12489,
                  "dollar",
                  36,
                  "dollarinferior",
                  63203,
                  "dollarmonospace",
                  65284,
                  "dollaroldstyle",
                  63268,
                  "dollarsmall",
                  65129,
                  "dollarsuperior",
                  63204,
                  "dong",
                  8363,
                  "dorusquare",
                  13094,
                  "dotaccent",
                  729,
                  "dotaccentcmb",
                  775,
                  "dotbelowcmb",
                  803,
                  "dotbelowcomb",
                  803,
                  "dotkatakana",
                  12539,
                  "dotlessi",
                  305,
                  "dotlessj",
                  63166,
                  "dotlessjstrokehook",
                  644,
                  "dotmath",
                  8901,
                  "dottedcircle",
                  9676,
                  "doubleyodpatah",
                  64287,
                  "doubleyodpatahhebrew",
                  64287,
                  "downtackbelowcmb",
                  798,
                  "downtackmod",
                  725,
                  "dparen",
                  9375,
                  "dsuperior",
                  63211,
                  "dtail",
                  598,
                  "dtopbar",
                  396,
                  "duhiragana",
                  12389,
                  "dukatakana",
                  12485,
                  "dz",
                  499,
                  "dzaltone",
                  675,
                  "dzcaron",
                  454,
                  "dzcurl",
                  677,
                  "dzeabkhasiancyrillic",
                  1249,
                  "dzecyrillic",
                  1109,
                  "dzhecyrillic",
                  1119,
                  "e",
                  101,
                  "eacute",
                  233,
                  "earth",
                  9793,
                  "ebengali",
                  2447,
                  "ebopomofo",
                  12572,
                  "ebreve",
                  277,
                  "ecandradeva",
                  2317,
                  "ecandragujarati",
                  2701,
                  "ecandravowelsigndeva",
                  2373,
                  "ecandravowelsigngujarati",
                  2757,
                  "ecaron",
                  283,
                  "ecedillabreve",
                  7709,
                  "echarmenian",
                  1381,
                  "echyiwnarmenian",
                  1415,
                  "ecircle",
                  9428,
                  "ecircumflex",
                  234,
                  "ecircumflexacute",
                  7871,
                  "ecircumflexbelow",
                  7705,
                  "ecircumflexdotbelow",
                  7879,
                  "ecircumflexgrave",
                  7873,
                  "ecircumflexhookabove",
                  7875,
                  "ecircumflextilde",
                  7877,
                  "ecyrillic",
                  1108,
                  "edblgrave",
                  517,
                  "edeva",
                  2319,
                  "edieresis",
                  235,
                  "edot",
                  279,
                  "edotaccent",
                  279,
                  "edotbelow",
                  7865,
                  "eegurmukhi",
                  2575,
                  "eematragurmukhi",
                  2631,
                  "efcyrillic",
                  1092,
                  "egrave",
                  232,
                  "egujarati",
                  2703,
                  "eharmenian",
                  1383,
                  "ehbopomofo",
                  12573,
                  "ehiragana",
                  12360,
                  "ehookabove",
                  7867,
                  "eibopomofo",
                  12575,
                  "eight",
                  56,
                  "eightarabic",
                  1640,
                  "eightbengali",
                  2542,
                  "eightcircle",
                  9319,
                  "eightcircleinversesansserif",
                  10129,
                  "eightdeva",
                  2414,
                  "eighteencircle",
                  9329,
                  "eighteenparen",
                  9349,
                  "eighteenperiod",
                  9369,
                  "eightgujarati",
                  2798,
                  "eightgurmukhi",
                  2670,
                  "eighthackarabic",
                  1640,
                  "eighthangzhou",
                  12328,
                  "eighthnotebeamed",
                  9835,
                  "eightideographicparen",
                  12839,
                  "eightinferior",
                  8328,
                  "eightmonospace",
                  65304,
                  "eightoldstyle",
                  63288,
                  "eightparen",
                  9339,
                  "eightperiod",
                  9359,
                  "eightpersian",
                  1784,
                  "eightroman",
                  8567,
                  "eightsuperior",
                  8312,
                  "eightthai",
                  3672,
                  "einvertedbreve",
                  519,
                  "eiotifiedcyrillic",
                  1125,
                  "ekatakana",
                  12456,
                  "ekatakanahalfwidth",
                  65396,
                  "ekonkargurmukhi",
                  2676,
                  "ekorean",
                  12628,
                  "elcyrillic",
                  1083,
                  "element",
                  8712,
                  "elevencircle",
                  9322,
                  "elevenparen",
                  9342,
                  "elevenperiod",
                  9362,
                  "elevenroman",
                  8570,
                  "ellipsis",
                  8230,
                  "ellipsisvertical",
                  8942,
                  "emacron",
                  275,
                  "emacronacute",
                  7703,
                  "emacrongrave",
                  7701,
                  "emcyrillic",
                  1084,
                  "emdash",
                  8212,
                  "emdashvertical",
                  65073,
                  "emonospace",
                  65349,
                  "emphasismarkarmenian",
                  1371,
                  "emptyset",
                  8709,
                  "enbopomofo",
                  12579,
                  "encyrillic",
                  1085,
                  "endash",
                  8211,
                  "endashvertical",
                  65074,
                  "endescendercyrillic",
                  1187,
                  "eng",
                  331,
                  "engbopomofo",
                  12581,
                  "enghecyrillic",
                  1189,
                  "enhookcyrillic",
                  1224,
                  "enspace",
                  8194,
                  "eogonek",
                  281,
                  "eokorean",
                  12627,
                  "eopen",
                  603,
                  "eopenclosed",
                  666,
                  "eopenreversed",
                  604,
                  "eopenreversedclosed",
                  606,
                  "eopenreversedhook",
                  605,
                  "eparen",
                  9376,
                  "epsilon",
                  949,
                  "epsilontonos",
                  941,
                  "equal",
                  61,
                  "equalmonospace",
                  65309,
                  "equalsmall",
                  65126,
                  "equalsuperior",
                  8316,
                  "equivalence",
                  8801,
                  "erbopomofo",
                  12582,
                  "ercyrillic",
                  1088,
                  "ereversed",
                  600,
                  "ereversedcyrillic",
                  1101,
                  "escyrillic",
                  1089,
                  "esdescendercyrillic",
                  1195,
                  "esh",
                  643,
                  "eshcurl",
                  646,
                  "eshortdeva",
                  2318,
                  "eshortvowelsigndeva",
                  2374,
                  "eshreversedloop",
                  426,
                  "eshsquatreversed",
                  645,
                  "esmallhiragana",
                  12359,
                  "esmallkatakana",
                  12455,
                  "esmallkatakanahalfwidth",
                  65386,
                  "estimated",
                  8494,
                  "esuperior",
                  63212,
                  "eta",
                  951,
                  "etarmenian",
                  1384,
                  "etatonos",
                  942,
                  "eth",
                  240,
                  "etilde",
                  7869,
                  "etildebelow",
                  7707,
                  "etnahtafoukhhebrew",
                  1425,
                  "etnahtafoukhlefthebrew",
                  1425,
                  "etnahtahebrew",
                  1425,
                  "etnahtalefthebrew",
                  1425,
                  "eturned",
                  477,
                  "eukorean",
                  12641,
                  "euro",
                  8364,
                  "evowelsignbengali",
                  2503,
                  "evowelsigndeva",
                  2375,
                  "evowelsigngujarati",
                  2759,
                  "exclam",
                  33,
                  "exclamarmenian",
                  1372,
                  "exclamdbl",
                  8252,
                  "exclamdown",
                  161,
                  "exclamdownsmall",
                  63393,
                  "exclammonospace",
                  65281,
                  "exclamsmall",
                  63265,
                  "existential",
                  8707,
                  "ezh",
                  658,
                  "ezhcaron",
                  495,
                  "ezhcurl",
                  659,
                  "ezhreversed",
                  441,
                  "ezhtail",
                  442,
                  "f",
                  102,
                  "fadeva",
                  2398,
                  "fagurmukhi",
                  2654,
                  "fahrenheit",
                  8457,
                  "fathaarabic",
                  1614,
                  "fathalowarabic",
                  1614,
                  "fathatanarabic",
                  1611,
                  "fbopomofo",
                  12552,
                  "fcircle",
                  9429,
                  "fdotaccent",
                  7711,
                  "feharabic",
                  1601,
                  "feharmenian",
                  1414,
                  "fehfinalarabic",
                  65234,
                  "fehinitialarabic",
                  65235,
                  "fehmedialarabic",
                  65236,
                  "feicoptic",
                  997,
                  "female",
                  9792,
                  "ff",
                  64256,
                  "f_f",
                  64256,
                  "ffi",
                  64259,
                  "ffl",
                  64260,
                  "fi",
                  64257,
                  "fifteencircle",
                  9326,
                  "fifteenparen",
                  9346,
                  "fifteenperiod",
                  9366,
                  "figuredash",
                  8210,
                  "filledbox",
                  9632,
                  "filledrect",
                  9644,
                  "finalkaf",
                  1498,
                  "finalkafdagesh",
                  64314,
                  "finalkafdageshhebrew",
                  64314,
                  "finalkafhebrew",
                  1498,
                  "finalmem",
                  1501,
                  "finalmemhebrew",
                  1501,
                  "finalnun",
                  1503,
                  "finalnunhebrew",
                  1503,
                  "finalpe",
                  1507,
                  "finalpehebrew",
                  1507,
                  "finaltsadi",
                  1509,
                  "finaltsadihebrew",
                  1509,
                  "firsttonechinese",
                  713,
                  "fisheye",
                  9673,
                  "fitacyrillic",
                  1139,
                  "five",
                  53,
                  "fivearabic",
                  1637,
                  "fivebengali",
                  2539,
                  "fivecircle",
                  9316,
                  "fivecircleinversesansserif",
                  10126,
                  "fivedeva",
                  2411,
                  "fiveeighths",
                  8541,
                  "fivegujarati",
                  2795,
                  "fivegurmukhi",
                  2667,
                  "fivehackarabic",
                  1637,
                  "fivehangzhou",
                  12325,
                  "fiveideographicparen",
                  12836,
                  "fiveinferior",
                  8325,
                  "fivemonospace",
                  65301,
                  "fiveoldstyle",
                  63285,
                  "fiveparen",
                  9336,
                  "fiveperiod",
                  9356,
                  "fivepersian",
                  1781,
                  "fiveroman",
                  8564,
                  "fivesuperior",
                  8309,
                  "fivethai",
                  3669,
                  "fl",
                  64258,
                  "florin",
                  402,
                  "fmonospace",
                  65350,
                  "fmsquare",
                  13209,
                  "fofanthai",
                  3615,
                  "fofathai",
                  3613,
                  "fongmanthai",
                  3663,
                  "forall",
                  8704,
                  "four",
                  52,
                  "fourarabic",
                  1636,
                  "fourbengali",
                  2538,
                  "fourcircle",
                  9315,
                  "fourcircleinversesansserif",
                  10125,
                  "fourdeva",
                  2410,
                  "fourgujarati",
                  2794,
                  "fourgurmukhi",
                  2666,
                  "fourhackarabic",
                  1636,
                  "fourhangzhou",
                  12324,
                  "fourideographicparen",
                  12835,
                  "fourinferior",
                  8324,
                  "fourmonospace",
                  65300,
                  "fournumeratorbengali",
                  2551,
                  "fouroldstyle",
                  63284,
                  "fourparen",
                  9335,
                  "fourperiod",
                  9355,
                  "fourpersian",
                  1780,
                  "fourroman",
                  8563,
                  "foursuperior",
                  8308,
                  "fourteencircle",
                  9325,
                  "fourteenparen",
                  9345,
                  "fourteenperiod",
                  9365,
                  "fourthai",
                  3668,
                  "fourthtonechinese",
                  715,
                  "fparen",
                  9377,
                  "fraction",
                  8260,
                  "franc",
                  8355,
                  "g",
                  103,
                  "gabengali",
                  2455,
                  "gacute",
                  501,
                  "gadeva",
                  2327,
                  "gafarabic",
                  1711,
                  "gaffinalarabic",
                  64403,
                  "gafinitialarabic",
                  64404,
                  "gafmedialarabic",
                  64405,
                  "gagujarati",
                  2711,
                  "gagurmukhi",
                  2583,
                  "gahiragana",
                  12364,
                  "gakatakana",
                  12460,
                  "gamma",
                  947,
                  "gammalatinsmall",
                  611,
                  "gammasuperior",
                  736,
                  "gangiacoptic",
                  1003,
                  "gbopomofo",
                  12557,
                  "gbreve",
                  287,
                  "gcaron",
                  487,
                  "gcedilla",
                  291,
                  "gcircle",
                  9430,
                  "gcircumflex",
                  285,
                  "gcommaaccent",
                  291,
                  "gdot",
                  289,
                  "gdotaccent",
                  289,
                  "gecyrillic",
                  1075,
                  "gehiragana",
                  12370,
                  "gekatakana",
                  12466,
                  "geometricallyequal",
                  8785,
                  "gereshaccenthebrew",
                  1436,
                  "gereshhebrew",
                  1523,
                  "gereshmuqdamhebrew",
                  1437,
                  "germandbls",
                  223,
                  "gershayimaccenthebrew",
                  1438,
                  "gershayimhebrew",
                  1524,
                  "getamark",
                  12307,
                  "ghabengali",
                  2456,
                  "ghadarmenian",
                  1394,
                  "ghadeva",
                  2328,
                  "ghagujarati",
                  2712,
                  "ghagurmukhi",
                  2584,
                  "ghainarabic",
                  1594,
                  "ghainfinalarabic",
                  65230,
                  "ghaininitialarabic",
                  65231,
                  "ghainmedialarabic",
                  65232,
                  "ghemiddlehookcyrillic",
                  1173,
                  "ghestrokecyrillic",
                  1171,
                  "gheupturncyrillic",
                  1169,
                  "ghhadeva",
                  2394,
                  "ghhagurmukhi",
                  2650,
                  "ghook",
                  608,
                  "ghzsquare",
                  13203,
                  "gihiragana",
                  12366,
                  "gikatakana",
                  12462,
                  "gimarmenian",
                  1379,
                  "gimel",
                  1490,
                  "gimeldagesh",
                  64306,
                  "gimeldageshhebrew",
                  64306,
                  "gimelhebrew",
                  1490,
                  "gjecyrillic",
                  1107,
                  "glottalinvertedstroke",
                  446,
                  "glottalstop",
                  660,
                  "glottalstopinverted",
                  662,
                  "glottalstopmod",
                  704,
                  "glottalstopreversed",
                  661,
                  "glottalstopreversedmod",
                  705,
                  "glottalstopreversedsuperior",
                  740,
                  "glottalstopstroke",
                  673,
                  "glottalstopstrokereversed",
                  674,
                  "gmacron",
                  7713,
                  "gmonospace",
                  65351,
                  "gohiragana",
                  12372,
                  "gokatakana",
                  12468,
                  "gparen",
                  9378,
                  "gpasquare",
                  13228,
                  "gradient",
                  8711,
                  "grave",
                  96,
                  "gravebelowcmb",
                  790,
                  "gravecmb",
                  768,
                  "gravecomb",
                  768,
                  "gravedeva",
                  2387,
                  "gravelowmod",
                  718,
                  "gravemonospace",
                  65344,
                  "gravetonecmb",
                  832,
                  "greater",
                  62,
                  "greaterequal",
                  8805,
                  "greaterequalorless",
                  8923,
                  "greatermonospace",
                  65310,
                  "greaterorequivalent",
                  8819,
                  "greaterorless",
                  8823,
                  "greateroverequal",
                  8807,
                  "greatersmall",
                  65125,
                  "gscript",
                  609,
                  "gstroke",
                  485,
                  "guhiragana",
                  12368,
                  "guillemotleft",
                  171,
                  "guillemotright",
                  187,
                  "guilsinglleft",
                  8249,
                  "guilsinglright",
                  8250,
                  "gukatakana",
                  12464,
                  "guramusquare",
                  13080,
                  "gysquare",
                  13257,
                  "h",
                  104,
                  "haabkhasiancyrillic",
                  1193,
                  "haaltonearabic",
                  1729,
                  "habengali",
                  2489,
                  "hadescendercyrillic",
                  1203,
                  "hadeva",
                  2361,
                  "hagujarati",
                  2745,
                  "hagurmukhi",
                  2617,
                  "haharabic",
                  1581,
                  "hahfinalarabic",
                  65186,
                  "hahinitialarabic",
                  65187,
                  "hahiragana",
                  12399,
                  "hahmedialarabic",
                  65188,
                  "haitusquare",
                  13098,
                  "hakatakana",
                  12495,
                  "hakatakanahalfwidth",
                  65418,
                  "halantgurmukhi",
                  2637,
                  "hamzaarabic",
                  1569,
                  "hamzalowarabic",
                  1569,
                  "hangulfiller",
                  12644,
                  "hardsigncyrillic",
                  1098,
                  "harpoonleftbarbup",
                  8636,
                  "harpoonrightbarbup",
                  8640,
                  "hasquare",
                  13258,
                  "hatafpatah",
                  1458,
                  "hatafpatah16",
                  1458,
                  "hatafpatah23",
                  1458,
                  "hatafpatah2f",
                  1458,
                  "hatafpatahhebrew",
                  1458,
                  "hatafpatahnarrowhebrew",
                  1458,
                  "hatafpatahquarterhebrew",
                  1458,
                  "hatafpatahwidehebrew",
                  1458,
                  "hatafqamats",
                  1459,
                  "hatafqamats1b",
                  1459,
                  "hatafqamats28",
                  1459,
                  "hatafqamats34",
                  1459,
                  "hatafqamatshebrew",
                  1459,
                  "hatafqamatsnarrowhebrew",
                  1459,
                  "hatafqamatsquarterhebrew",
                  1459,
                  "hatafqamatswidehebrew",
                  1459,
                  "hatafsegol",
                  1457,
                  "hatafsegol17",
                  1457,
                  "hatafsegol24",
                  1457,
                  "hatafsegol30",
                  1457,
                  "hatafsegolhebrew",
                  1457,
                  "hatafsegolnarrowhebrew",
                  1457,
                  "hatafsegolquarterhebrew",
                  1457,
                  "hatafsegolwidehebrew",
                  1457,
                  "hbar",
                  295,
                  "hbopomofo",
                  12559,
                  "hbrevebelow",
                  7723,
                  "hcedilla",
                  7721,
                  "hcircle",
                  9431,
                  "hcircumflex",
                  293,
                  "hdieresis",
                  7719,
                  "hdotaccent",
                  7715,
                  "hdotbelow",
                  7717,
                  "he",
                  1492,
                  "heart",
                  9829,
                  "heartsuitblack",
                  9829,
                  "heartsuitwhite",
                  9825,
                  "hedagesh",
                  64308,
                  "hedageshhebrew",
                  64308,
                  "hehaltonearabic",
                  1729,
                  "heharabic",
                  1607,
                  "hehebrew",
                  1492,
                  "hehfinalaltonearabic",
                  64423,
                  "hehfinalalttwoarabic",
                  65258,
                  "hehfinalarabic",
                  65258,
                  "hehhamzaabovefinalarabic",
                  64421,
                  "hehhamzaaboveisolatedarabic",
                  64420,
                  "hehinitialaltonearabic",
                  64424,
                  "hehinitialarabic",
                  65259,
                  "hehiragana",
                  12408,
                  "hehmedialaltonearabic",
                  64425,
                  "hehmedialarabic",
                  65260,
                  "heiseierasquare",
                  13179,
                  "hekatakana",
                  12504,
                  "hekatakanahalfwidth",
                  65421,
                  "hekutaarusquare",
                  13110,
                  "henghook",
                  615,
                  "herutusquare",
                  13113,
                  "het",
                  1495,
                  "hethebrew",
                  1495,
                  "hhook",
                  614,
                  "hhooksuperior",
                  689,
                  "hieuhacirclekorean",
                  12923,
                  "hieuhaparenkorean",
                  12827,
                  "hieuhcirclekorean",
                  12909,
                  "hieuhkorean",
                  12622,
                  "hieuhparenkorean",
                  12813,
                  "hihiragana",
                  12402,
                  "hikatakana",
                  12498,
                  "hikatakanahalfwidth",
                  65419,
                  "hiriq",
                  1460,
                  "hiriq14",
                  1460,
                  "hiriq21",
                  1460,
                  "hiriq2d",
                  1460,
                  "hiriqhebrew",
                  1460,
                  "hiriqnarrowhebrew",
                  1460,
                  "hiriqquarterhebrew",
                  1460,
                  "hiriqwidehebrew",
                  1460,
                  "hlinebelow",
                  7830,
                  "hmonospace",
                  65352,
                  "hoarmenian",
                  1392,
                  "hohipthai",
                  3627,
                  "hohiragana",
                  12411,
                  "hokatakana",
                  12507,
                  "hokatakanahalfwidth",
                  65422,
                  "holam",
                  1465,
                  "holam19",
                  1465,
                  "holam26",
                  1465,
                  "holam32",
                  1465,
                  "holamhebrew",
                  1465,
                  "holamnarrowhebrew",
                  1465,
                  "holamquarterhebrew",
                  1465,
                  "holamwidehebrew",
                  1465,
                  "honokhukthai",
                  3630,
                  "hookabovecomb",
                  777,
                  "hookcmb",
                  777,
                  "hookpalatalizedbelowcmb",
                  801,
                  "hookretroflexbelowcmb",
                  802,
                  "hoonsquare",
                  13122,
                  "horicoptic",
                  1001,
                  "horizontalbar",
                  8213,
                  "horncmb",
                  795,
                  "hotsprings",
                  9832,
                  "house",
                  8962,
                  "hparen",
                  9379,
                  "hsuperior",
                  688,
                  "hturned",
                  613,
                  "huhiragana",
                  12405,
                  "huiitosquare",
                  13107,
                  "hukatakana",
                  12501,
                  "hukatakanahalfwidth",
                  65420,
                  "hungarumlaut",
                  733,
                  "hungarumlautcmb",
                  779,
                  "hv",
                  405,
                  "hyphen",
                  45,
                  "hypheninferior",
                  63205,
                  "hyphenmonospace",
                  65293,
                  "hyphensmall",
                  65123,
                  "hyphensuperior",
                  63206,
                  "hyphentwo",
                  8208,
                  "i",
                  105,
                  "iacute",
                  237,
                  "iacyrillic",
                  1103,
                  "ibengali",
                  2439,
                  "ibopomofo",
                  12583,
                  "ibreve",
                  301,
                  "icaron",
                  464,
                  "icircle",
                  9432,
                  "icircumflex",
                  238,
                  "icyrillic",
                  1110,
                  "idblgrave",
                  521,
                  "ideographearthcircle",
                  12943,
                  "ideographfirecircle",
                  12939,
                  "ideographicallianceparen",
                  12863,
                  "ideographiccallparen",
                  12858,
                  "ideographiccentrecircle",
                  12965,
                  "ideographicclose",
                  12294,
                  "ideographiccomma",
                  12289,
                  "ideographiccommaleft",
                  65380,
                  "ideographiccongratulationparen",
                  12855,
                  "ideographiccorrectcircle",
                  12963,
                  "ideographicearthparen",
                  12847,
                  "ideographicenterpriseparen",
                  12861,
                  "ideographicexcellentcircle",
                  12957,
                  "ideographicfestivalparen",
                  12864,
                  "ideographicfinancialcircle",
                  12950,
                  "ideographicfinancialparen",
                  12854,
                  "ideographicfireparen",
                  12843,
                  "ideographichaveparen",
                  12850,
                  "ideographichighcircle",
                  12964,
                  "ideographiciterationmark",
                  12293,
                  "ideographiclaborcircle",
                  12952,
                  "ideographiclaborparen",
                  12856,
                  "ideographicleftcircle",
                  12967,
                  "ideographiclowcircle",
                  12966,
                  "ideographicmedicinecircle",
                  12969,
                  "ideographicmetalparen",
                  12846,
                  "ideographicmoonparen",
                  12842,
                  "ideographicnameparen",
                  12852,
                  "ideographicperiod",
                  12290,
                  "ideographicprintcircle",
                  12958,
                  "ideographicreachparen",
                  12867,
                  "ideographicrepresentparen",
                  12857,
                  "ideographicresourceparen",
                  12862,
                  "ideographicrightcircle",
                  12968,
                  "ideographicsecretcircle",
                  12953,
                  "ideographicselfparen",
                  12866,
                  "ideographicsocietyparen",
                  12851,
                  "ideographicspace",
                  12288,
                  "ideographicspecialparen",
                  12853,
                  "ideographicstockparen",
                  12849,
                  "ideographicstudyparen",
                  12859,
                  "ideographicsunparen",
                  12848,
                  "ideographicsuperviseparen",
                  12860,
                  "ideographicwaterparen",
                  12844,
                  "ideographicwoodparen",
                  12845,
                  "ideographiczero",
                  12295,
                  "ideographmetalcircle",
                  12942,
                  "ideographmooncircle",
                  12938,
                  "ideographnamecircle",
                  12948,
                  "ideographsuncircle",
                  12944,
                  "ideographwatercircle",
                  12940,
                  "ideographwoodcircle",
                  12941,
                  "ideva",
                  2311,
                  "idieresis",
                  239,
                  "idieresisacute",
                  7727,
                  "idieresiscyrillic",
                  1253,
                  "idotbelow",
                  7883,
                  "iebrevecyrillic",
                  1239,
                  "iecyrillic",
                  1077,
                  "ieungacirclekorean",
                  12917,
                  "ieungaparenkorean",
                  12821,
                  "ieungcirclekorean",
                  12903,
                  "ieungkorean",
                  12615,
                  "ieungparenkorean",
                  12807,
                  "igrave",
                  236,
                  "igujarati",
                  2695,
                  "igurmukhi",
                  2567,
                  "ihiragana",
                  12356,
                  "ihookabove",
                  7881,
                  "iibengali",
                  2440,
                  "iicyrillic",
                  1080,
                  "iideva",
                  2312,
                  "iigujarati",
                  2696,
                  "iigurmukhi",
                  2568,
                  "iimatragurmukhi",
                  2624,
                  "iinvertedbreve",
                  523,
                  "iishortcyrillic",
                  1081,
                  "iivowelsignbengali",
                  2496,
                  "iivowelsigndeva",
                  2368,
                  "iivowelsigngujarati",
                  2752,
                  "ij",
                  307,
                  "ikatakana",
                  12452,
                  "ikatakanahalfwidth",
                  65394,
                  "ikorean",
                  12643,
                  "ilde",
                  732,
                  "iluyhebrew",
                  1452,
                  "imacron",
                  299,
                  "imacroncyrillic",
                  1251,
                  "imageorapproximatelyequal",
                  8787,
                  "imatragurmukhi",
                  2623,
                  "imonospace",
                  65353,
                  "increment",
                  8710,
                  "infinity",
                  8734,
                  "iniarmenian",
                  1387,
                  "integral",
                  8747,
                  "integralbottom",
                  8993,
                  "integralbt",
                  8993,
                  "integralex",
                  63733,
                  "integraltop",
                  8992,
                  "integraltp",
                  8992,
                  "intersection",
                  8745,
                  "intisquare",
                  13061,
                  "invbullet",
                  9688,
                  "invcircle",
                  9689,
                  "invsmileface",
                  9787,
                  "iocyrillic",
                  1105,
                  "iogonek",
                  303,
                  "iota",
                  953,
                  "iotadieresis",
                  970,
                  "iotadieresistonos",
                  912,
                  "iotalatin",
                  617,
                  "iotatonos",
                  943,
                  "iparen",
                  9380,
                  "irigurmukhi",
                  2674,
                  "ismallhiragana",
                  12355,
                  "ismallkatakana",
                  12451,
                  "ismallkatakanahalfwidth",
                  65384,
                  "issharbengali",
                  2554,
                  "istroke",
                  616,
                  "isuperior",
                  63213,
                  "iterationhiragana",
                  12445,
                  "iterationkatakana",
                  12541,
                  "itilde",
                  297,
                  "itildebelow",
                  7725,
                  "iubopomofo",
                  12585,
                  "iucyrillic",
                  1102,
                  "ivowelsignbengali",
                  2495,
                  "ivowelsigndeva",
                  2367,
                  "ivowelsigngujarati",
                  2751,
                  "izhitsacyrillic",
                  1141,
                  "izhitsadblgravecyrillic",
                  1143,
                  "j",
                  106,
                  "jaarmenian",
                  1393,
                  "jabengali",
                  2460,
                  "jadeva",
                  2332,
                  "jagujarati",
                  2716,
                  "jagurmukhi",
                  2588,
                  "jbopomofo",
                  12560,
                  "jcaron",
                  496,
                  "jcircle",
                  9433,
                  "jcircumflex",
                  309,
                  "jcrossedtail",
                  669,
                  "jdotlessstroke",
                  607,
                  "jecyrillic",
                  1112,
                  "jeemarabic",
                  1580,
                  "jeemfinalarabic",
                  65182,
                  "jeeminitialarabic",
                  65183,
                  "jeemmedialarabic",
                  65184,
                  "jeharabic",
                  1688,
                  "jehfinalarabic",
                  64395,
                  "jhabengali",
                  2461,
                  "jhadeva",
                  2333,
                  "jhagujarati",
                  2717,
                  "jhagurmukhi",
                  2589,
                  "jheharmenian",
                  1403,
                  "jis",
                  12292,
                  "jmonospace",
                  65354,
                  "jparen",
                  9381,
                  "jsuperior",
                  690,
                  "k",
                  107,
                  "kabashkircyrillic",
                  1185,
                  "kabengali",
                  2453,
                  "kacute",
                  7729,
                  "kacyrillic",
                  1082,
                  "kadescendercyrillic",
                  1179,
                  "kadeva",
                  2325,
                  "kaf",
                  1499,
                  "kafarabic",
                  1603,
                  "kafdagesh",
                  64315,
                  "kafdageshhebrew",
                  64315,
                  "kaffinalarabic",
                  65242,
                  "kafhebrew",
                  1499,
                  "kafinitialarabic",
                  65243,
                  "kafmedialarabic",
                  65244,
                  "kafrafehebrew",
                  64333,
                  "kagujarati",
                  2709,
                  "kagurmukhi",
                  2581,
                  "kahiragana",
                  12363,
                  "kahookcyrillic",
                  1220,
                  "kakatakana",
                  12459,
                  "kakatakanahalfwidth",
                  65398,
                  "kappa",
                  954,
                  "kappasymbolgreek",
                  1008,
                  "kapyeounmieumkorean",
                  12657,
                  "kapyeounphieuphkorean",
                  12676,
                  "kapyeounpieupkorean",
                  12664,
                  "kapyeounssangpieupkorean",
                  12665,
                  "karoriisquare",
                  13069,
                  "kashidaautoarabic",
                  1600,
                  "kashidaautonosidebearingarabic",
                  1600,
                  "kasmallkatakana",
                  12533,
                  "kasquare",
                  13188,
                  "kasraarabic",
                  1616,
                  "kasratanarabic",
                  1613,
                  "kastrokecyrillic",
                  1183,
                  "katahiraprolongmarkhalfwidth",
                  65392,
                  "kaverticalstrokecyrillic",
                  1181,
                  "kbopomofo",
                  12558,
                  "kcalsquare",
                  13193,
                  "kcaron",
                  489,
                  "kcedilla",
                  311,
                  "kcircle",
                  9434,
                  "kcommaaccent",
                  311,
                  "kdotbelow",
                  7731,
                  "keharmenian",
                  1412,
                  "kehiragana",
                  12369,
                  "kekatakana",
                  12465,
                  "kekatakanahalfwidth",
                  65401,
                  "kenarmenian",
                  1391,
                  "kesmallkatakana",
                  12534,
                  "kgreenlandic",
                  312,
                  "khabengali",
                  2454,
                  "khacyrillic",
                  1093,
                  "khadeva",
                  2326,
                  "khagujarati",
                  2710,
                  "khagurmukhi",
                  2582,
                  "khaharabic",
                  1582,
                  "khahfinalarabic",
                  65190,
                  "khahinitialarabic",
                  65191,
                  "khahmedialarabic",
                  65192,
                  "kheicoptic",
                  999,
                  "khhadeva",
                  2393,
                  "khhagurmukhi",
                  2649,
                  "khieukhacirclekorean",
                  12920,
                  "khieukhaparenkorean",
                  12824,
                  "khieukhcirclekorean",
                  12906,
                  "khieukhkorean",
                  12619,
                  "khieukhparenkorean",
                  12810,
                  "khokhaithai",
                  3586,
                  "khokhonthai",
                  3589,
                  "khokhuatthai",
                  3587,
                  "khokhwaithai",
                  3588,
                  "khomutthai",
                  3675,
                  "khook",
                  409,
                  "khorakhangthai",
                  3590,
                  "khzsquare",
                  13201,
                  "kihiragana",
                  12365,
                  "kikatakana",
                  12461,
                  "kikatakanahalfwidth",
                  65399,
                  "kiroguramusquare",
                  13077,
                  "kiromeetorusquare",
                  13078,
                  "kirosquare",
                  13076,
                  "kiyeokacirclekorean",
                  12910,
                  "kiyeokaparenkorean",
                  12814,
                  "kiyeokcirclekorean",
                  12896,
                  "kiyeokkorean",
                  12593,
                  "kiyeokparenkorean",
                  12800,
                  "kiyeoksioskorean",
                  12595,
                  "kjecyrillic",
                  1116,
                  "klinebelow",
                  7733,
                  "klsquare",
                  13208,
                  "kmcubedsquare",
                  13222,
                  "kmonospace",
                  65355,
                  "kmsquaredsquare",
                  13218,
                  "kohiragana",
                  12371,
                  "kohmsquare",
                  13248,
                  "kokaithai",
                  3585,
                  "kokatakana",
                  12467,
                  "kokatakanahalfwidth",
                  65402,
                  "kooposquare",
                  13086,
                  "koppacyrillic",
                  1153,
                  "koreanstandardsymbol",
                  12927,
                  "koroniscmb",
                  835,
                  "kparen",
                  9382,
                  "kpasquare",
                  13226,
                  "ksicyrillic",
                  1135,
                  "ktsquare",
                  13263,
                  "kturned",
                  670,
                  "kuhiragana",
                  12367,
                  "kukatakana",
                  12463,
                  "kukatakanahalfwidth",
                  65400,
                  "kvsquare",
                  13240,
                  "kwsquare",
                  13246,
                  "l",
                  108,
                  "labengali",
                  2482,
                  "lacute",
                  314,
                  "ladeva",
                  2354,
                  "lagujarati",
                  2738,
                  "lagurmukhi",
                  2610,
                  "lakkhangyaothai",
                  3653,
                  "lamaleffinalarabic",
                  65276,
                  "lamalefhamzaabovefinalarabic",
                  65272,
                  "lamalefhamzaaboveisolatedarabic",
                  65271,
                  "lamalefhamzabelowfinalarabic",
                  65274,
                  "lamalefhamzabelowisolatedarabic",
                  65273,
                  "lamalefisolatedarabic",
                  65275,
                  "lamalefmaddaabovefinalarabic",
                  65270,
                  "lamalefmaddaaboveisolatedarabic",
                  65269,
                  "lamarabic",
                  1604,
                  "lambda",
                  955,
                  "lambdastroke",
                  411,
                  "lamed",
                  1500,
                  "lameddagesh",
                  64316,
                  "lameddageshhebrew",
                  64316,
                  "lamedhebrew",
                  1500,
                  "lamfinalarabic",
                  65246,
                  "lamhahinitialarabic",
                  64714,
                  "laminitialarabic",
                  65247,
                  "lamjeeminitialarabic",
                  64713,
                  "lamkhahinitialarabic",
                  64715,
                  "lamlamhehisolatedarabic",
                  65010,
                  "lammedialarabic",
                  65248,
                  "lammeemhahinitialarabic",
                  64904,
                  "lammeeminitialarabic",
                  64716,
                  "largecircle",
                  9711,
                  "lbar",
                  410,
                  "lbelt",
                  620,
                  "lbopomofo",
                  12556,
                  "lcaron",
                  318,
                  "lcedilla",
                  316,
                  "lcircle",
                  9435,
                  "lcircumflexbelow",
                  7741,
                  "lcommaaccent",
                  316,
                  "ldot",
                  320,
                  "ldotaccent",
                  320,
                  "ldotbelow",
                  7735,
                  "ldotbelowmacron",
                  7737,
                  "leftangleabovecmb",
                  794,
                  "lefttackbelowcmb",
                  792,
                  "less",
                  60,
                  "lessequal",
                  8804,
                  "lessequalorgreater",
                  8922,
                  "lessmonospace",
                  65308,
                  "lessorequivalent",
                  8818,
                  "lessorgreater",
                  8822,
                  "lessoverequal",
                  8806,
                  "lesssmall",
                  65124,
                  "lezh",
                  622,
                  "lfblock",
                  9612,
                  "lhookretroflex",
                  621,
                  "lira",
                  8356,
                  "liwnarmenian",
                  1388,
                  "lj",
                  457,
                  "ljecyrillic",
                  1113,
                  "ll",
                  63168,
                  "lladeva",
                  2355,
                  "llagujarati",
                  2739,
                  "llinebelow",
                  7739,
                  "llladeva",
                  2356,
                  "llvocalicbengali",
                  2529,
                  "llvocalicdeva",
                  2401,
                  "llvocalicvowelsignbengali",
                  2531,
                  "llvocalicvowelsigndeva",
                  2403,
                  "lmiddletilde",
                  619,
                  "lmonospace",
                  65356,
                  "lmsquare",
                  13264,
                  "lochulathai",
                  3628,
                  "logicaland",
                  8743,
                  "logicalnot",
                  172,
                  "logicalnotreversed",
                  8976,
                  "logicalor",
                  8744,
                  "lolingthai",
                  3621,
                  "longs",
                  383,
                  "lowlinecenterline",
                  65102,
                  "lowlinecmb",
                  818,
                  "lowlinedashed",
                  65101,
                  "lozenge",
                  9674,
                  "lparen",
                  9383,
                  "lslash",
                  322,
                  "lsquare",
                  8467,
                  "lsuperior",
                  63214,
                  "ltshade",
                  9617,
                  "luthai",
                  3622,
                  "lvocalicbengali",
                  2444,
                  "lvocalicdeva",
                  2316,
                  "lvocalicvowelsignbengali",
                  2530,
                  "lvocalicvowelsigndeva",
                  2402,
                  "lxsquare",
                  13267,
                  "m",
                  109,
                  "mabengali",
                  2478,
                  "macron",
                  175,
                  "macronbelowcmb",
                  817,
                  "macroncmb",
                  772,
                  "macronlowmod",
                  717,
                  "macronmonospace",
                  65507,
                  "macute",
                  7743,
                  "madeva",
                  2350,
                  "magujarati",
                  2734,
                  "magurmukhi",
                  2606,
                  "mahapakhhebrew",
                  1444,
                  "mahapakhlefthebrew",
                  1444,
                  "mahiragana",
                  12414,
                  "maichattawalowleftthai",
                  63637,
                  "maichattawalowrightthai",
                  63636,
                  "maichattawathai",
                  3659,
                  "maichattawaupperleftthai",
                  63635,
                  "maieklowleftthai",
                  63628,
                  "maieklowrightthai",
                  63627,
                  "maiekthai",
                  3656,
                  "maiekupperleftthai",
                  63626,
                  "maihanakatleftthai",
                  63620,
                  "maihanakatthai",
                  3633,
                  "maitaikhuleftthai",
                  63625,
                  "maitaikhuthai",
                  3655,
                  "maitholowleftthai",
                  63631,
                  "maitholowrightthai",
                  63630,
                  "maithothai",
                  3657,
                  "maithoupperleftthai",
                  63629,
                  "maitrilowleftthai",
                  63634,
                  "maitrilowrightthai",
                  63633,
                  "maitrithai",
                  3658,
                  "maitriupperleftthai",
                  63632,
                  "maiyamokthai",
                  3654,
                  "makatakana",
                  12510,
                  "makatakanahalfwidth",
                  65423,
                  "male",
                  9794,
                  "mansyonsquare",
                  13127,
                  "maqafhebrew",
                  1470,
                  "mars",
                  9794,
                  "masoracirclehebrew",
                  1455,
                  "masquare",
                  13187,
                  "mbopomofo",
                  12551,
                  "mbsquare",
                  13268,
                  "mcircle",
                  9436,
                  "mcubedsquare",
                  13221,
                  "mdotaccent",
                  7745,
                  "mdotbelow",
                  7747,
                  "meemarabic",
                  1605,
                  "meemfinalarabic",
                  65250,
                  "meeminitialarabic",
                  65251,
                  "meemmedialarabic",
                  65252,
                  "meemmeeminitialarabic",
                  64721,
                  "meemmeemisolatedarabic",
                  64584,
                  "meetorusquare",
                  13133,
                  "mehiragana",
                  12417,
                  "meizierasquare",
                  13182,
                  "mekatakana",
                  12513,
                  "mekatakanahalfwidth",
                  65426,
                  "mem",
                  1502,
                  "memdagesh",
                  64318,
                  "memdageshhebrew",
                  64318,
                  "memhebrew",
                  1502,
                  "menarmenian",
                  1396,
                  "merkhahebrew",
                  1445,
                  "merkhakefulahebrew",
                  1446,
                  "merkhakefulalefthebrew",
                  1446,
                  "merkhalefthebrew",
                  1445,
                  "mhook",
                  625,
                  "mhzsquare",
                  13202,
                  "middledotkatakanahalfwidth",
                  65381,
                  "middot",
                  183,
                  "mieumacirclekorean",
                  12914,
                  "mieumaparenkorean",
                  12818,
                  "mieumcirclekorean",
                  12900,
                  "mieumkorean",
                  12609,
                  "mieumpansioskorean",
                  12656,
                  "mieumparenkorean",
                  12804,
                  "mieumpieupkorean",
                  12654,
                  "mieumsioskorean",
                  12655,
                  "mihiragana",
                  12415,
                  "mikatakana",
                  12511,
                  "mikatakanahalfwidth",
                  65424,
                  "minus",
                  8722,
                  "minusbelowcmb",
                  800,
                  "minuscircle",
                  8854,
                  "minusmod",
                  727,
                  "minusplus",
                  8723,
                  "minute",
                  8242,
                  "miribaarusquare",
                  13130,
                  "mirisquare",
                  13129,
                  "mlonglegturned",
                  624,
                  "mlsquare",
                  13206,
                  "mmcubedsquare",
                  13219,
                  "mmonospace",
                  65357,
                  "mmsquaredsquare",
                  13215,
                  "mohiragana",
                  12418,
                  "mohmsquare",
                  13249,
                  "mokatakana",
                  12514,
                  "mokatakanahalfwidth",
                  65427,
                  "molsquare",
                  13270,
                  "momathai",
                  3617,
                  "moverssquare",
                  13223,
                  "moverssquaredsquare",
                  13224,
                  "mparen",
                  9384,
                  "mpasquare",
                  13227,
                  "mssquare",
                  13235,
                  "msuperior",
                  63215,
                  "mturned",
                  623,
                  "mu",
                  181,
                  "mu1",
                  181,
                  "muasquare",
                  13186,
                  "muchgreater",
                  8811,
                  "muchless",
                  8810,
                  "mufsquare",
                  13196,
                  "mugreek",
                  956,
                  "mugsquare",
                  13197,
                  "muhiragana",
                  12416,
                  "mukatakana",
                  12512,
                  "mukatakanahalfwidth",
                  65425,
                  "mulsquare",
                  13205,
                  "multiply",
                  215,
                  "mumsquare",
                  13211,
                  "munahhebrew",
                  1443,
                  "munahlefthebrew",
                  1443,
                  "musicalnote",
                  9834,
                  "musicalnotedbl",
                  9835,
                  "musicflatsign",
                  9837,
                  "musicsharpsign",
                  9839,
                  "mussquare",
                  13234,
                  "muvsquare",
                  13238,
                  "muwsquare",
                  13244,
                  "mvmegasquare",
                  13241,
                  "mvsquare",
                  13239,
                  "mwmegasquare",
                  13247,
                  "mwsquare",
                  13245,
                  "n",
                  110,
                  "nabengali",
                  2472,
                  "nabla",
                  8711,
                  "nacute",
                  324,
                  "nadeva",
                  2344,
                  "nagujarati",
                  2728,
                  "nagurmukhi",
                  2600,
                  "nahiragana",
                  12394,
                  "nakatakana",
                  12490,
                  "nakatakanahalfwidth",
                  65413,
                  "napostrophe",
                  329,
                  "nasquare",
                  13185,
                  "nbopomofo",
                  12555,
                  "nbspace",
                  160,
                  "ncaron",
                  328,
                  "ncedilla",
                  326,
                  "ncircle",
                  9437,
                  "ncircumflexbelow",
                  7755,
                  "ncommaaccent",
                  326,
                  "ndotaccent",
                  7749,
                  "ndotbelow",
                  7751,
                  "nehiragana",
                  12397,
                  "nekatakana",
                  12493,
                  "nekatakanahalfwidth",
                  65416,
                  "newsheqelsign",
                  8362,
                  "nfsquare",
                  13195,
                  "ngabengali",
                  2457,
                  "ngadeva",
                  2329,
                  "ngagujarati",
                  2713,
                  "ngagurmukhi",
                  2585,
                  "ngonguthai",
                  3591,
                  "nhiragana",
                  12435,
                  "nhookleft",
                  626,
                  "nhookretroflex",
                  627,
                  "nieunacirclekorean",
                  12911,
                  "nieunaparenkorean",
                  12815,
                  "nieuncieuckorean",
                  12597,
                  "nieuncirclekorean",
                  12897,
                  "nieunhieuhkorean",
                  12598,
                  "nieunkorean",
                  12596,
                  "nieunpansioskorean",
                  12648,
                  "nieunparenkorean",
                  12801,
                  "nieunsioskorean",
                  12647,
                  "nieuntikeutkorean",
                  12646,
                  "nihiragana",
                  12395,
                  "nikatakana",
                  12491,
                  "nikatakanahalfwidth",
                  65414,
                  "nikhahitleftthai",
                  63641,
                  "nikhahitthai",
                  3661,
                  "nine",
                  57,
                  "ninearabic",
                  1641,
                  "ninebengali",
                  2543,
                  "ninecircle",
                  9320,
                  "ninecircleinversesansserif",
                  10130,
                  "ninedeva",
                  2415,
                  "ninegujarati",
                  2799,
                  "ninegurmukhi",
                  2671,
                  "ninehackarabic",
                  1641,
                  "ninehangzhou",
                  12329,
                  "nineideographicparen",
                  12840,
                  "nineinferior",
                  8329,
                  "ninemonospace",
                  65305,
                  "nineoldstyle",
                  63289,
                  "nineparen",
                  9340,
                  "nineperiod",
                  9360,
                  "ninepersian",
                  1785,
                  "nineroman",
                  8568,
                  "ninesuperior",
                  8313,
                  "nineteencircle",
                  9330,
                  "nineteenparen",
                  9350,
                  "nineteenperiod",
                  9370,
                  "ninethai",
                  3673,
                  "nj",
                  460,
                  "njecyrillic",
                  1114,
                  "nkatakana",
                  12531,
                  "nkatakanahalfwidth",
                  65437,
                  "nlegrightlong",
                  414,
                  "nlinebelow",
                  7753,
                  "nmonospace",
                  65358,
                  "nmsquare",
                  13210,
                  "nnabengali",
                  2467,
                  "nnadeva",
                  2339,
                  "nnagujarati",
                  2723,
                  "nnagurmukhi",
                  2595,
                  "nnnadeva",
                  2345,
                  "nohiragana",
                  12398,
                  "nokatakana",
                  12494,
                  "nokatakanahalfwidth",
                  65417,
                  "nonbreakingspace",
                  160,
                  "nonenthai",
                  3603,
                  "nonuthai",
                  3609,
                  "noonarabic",
                  1606,
                  "noonfinalarabic",
                  65254,
                  "noonghunnaarabic",
                  1722,
                  "noonghunnafinalarabic",
                  64415,
                  "nooninitialarabic",
                  65255,
                  "noonjeeminitialarabic",
                  64722,
                  "noonjeemisolatedarabic",
                  64587,
                  "noonmedialarabic",
                  65256,
                  "noonmeeminitialarabic",
                  64725,
                  "noonmeemisolatedarabic",
                  64590,
                  "noonnoonfinalarabic",
                  64653,
                  "notcontains",
                  8716,
                  "notelement",
                  8713,
                  "notelementof",
                  8713,
                  "notequal",
                  8800,
                  "notgreater",
                  8815,
                  "notgreaternorequal",
                  8817,
                  "notgreaternorless",
                  8825,
                  "notidentical",
                  8802,
                  "notless",
                  8814,
                  "notlessnorequal",
                  8816,
                  "notparallel",
                  8742,
                  "notprecedes",
                  8832,
                  "notsubset",
                  8836,
                  "notsucceeds",
                  8833,
                  "notsuperset",
                  8837,
                  "nowarmenian",
                  1398,
                  "nparen",
                  9385,
                  "nssquare",
                  13233,
                  "nsuperior",
                  8319,
                  "ntilde",
                  241,
                  "nu",
                  957,
                  "nuhiragana",
                  12396,
                  "nukatakana",
                  12492,
                  "nukatakanahalfwidth",
                  65415,
                  "nuktabengali",
                  2492,
                  "nuktadeva",
                  2364,
                  "nuktagujarati",
                  2748,
                  "nuktagurmukhi",
                  2620,
                  "numbersign",
                  35,
                  "numbersignmonospace",
                  65283,
                  "numbersignsmall",
                  65119,
                  "numeralsigngreek",
                  884,
                  "numeralsignlowergreek",
                  885,
                  "numero",
                  8470,
                  "nun",
                  1504,
                  "nundagesh",
                  64320,
                  "nundageshhebrew",
                  64320,
                  "nunhebrew",
                  1504,
                  "nvsquare",
                  13237,
                  "nwsquare",
                  13243,
                  "nyabengali",
                  2462,
                  "nyadeva",
                  2334,
                  "nyagujarati",
                  2718,
                  "nyagurmukhi",
                  2590,
                  "o",
                  111,
                  "oacute",
                  243,
                  "oangthai",
                  3629,
                  "obarred",
                  629,
                  "obarredcyrillic",
                  1257,
                  "obarreddieresiscyrillic",
                  1259,
                  "obengali",
                  2451,
                  "obopomofo",
                  12571,
                  "obreve",
                  335,
                  "ocandradeva",
                  2321,
                  "ocandragujarati",
                  2705,
                  "ocandravowelsigndeva",
                  2377,
                  "ocandravowelsigngujarati",
                  2761,
                  "ocaron",
                  466,
                  "ocircle",
                  9438,
                  "ocircumflex",
                  244,
                  "ocircumflexacute",
                  7889,
                  "ocircumflexdotbelow",
                  7897,
                  "ocircumflexgrave",
                  7891,
                  "ocircumflexhookabove",
                  7893,
                  "ocircumflextilde",
                  7895,
                  "ocyrillic",
                  1086,
                  "odblacute",
                  337,
                  "odblgrave",
                  525,
                  "odeva",
                  2323,
                  "odieresis",
                  246,
                  "odieresiscyrillic",
                  1255,
                  "odotbelow",
                  7885,
                  "oe",
                  339,
                  "oekorean",
                  12634,
                  "ogonek",
                  731,
                  "ogonekcmb",
                  808,
                  "ograve",
                  242,
                  "ogujarati",
                  2707,
                  "oharmenian",
                  1413,
                  "ohiragana",
                  12362,
                  "ohookabove",
                  7887,
                  "ohorn",
                  417,
                  "ohornacute",
                  7899,
                  "ohorndotbelow",
                  7907,
                  "ohorngrave",
                  7901,
                  "ohornhookabove",
                  7903,
                  "ohorntilde",
                  7905,
                  "ohungarumlaut",
                  337,
                  "oi",
                  419,
                  "oinvertedbreve",
                  527,
                  "okatakana",
                  12458,
                  "okatakanahalfwidth",
                  65397,
                  "okorean",
                  12631,
                  "olehebrew",
                  1451,
                  "omacron",
                  333,
                  "omacronacute",
                  7763,
                  "omacrongrave",
                  7761,
                  "omdeva",
                  2384,
                  "omega",
                  969,
                  "omega1",
                  982,
                  "omegacyrillic",
                  1121,
                  "omegalatinclosed",
                  631,
                  "omegaroundcyrillic",
                  1147,
                  "omegatitlocyrillic",
                  1149,
                  "omegatonos",
                  974,
                  "omgujarati",
                  2768,
                  "omicron",
                  959,
                  "omicrontonos",
                  972,
                  "omonospace",
                  65359,
                  "one",
                  49,
                  "onearabic",
                  1633,
                  "onebengali",
                  2535,
                  "onecircle",
                  9312,
                  "onecircleinversesansserif",
                  10122,
                  "onedeva",
                  2407,
                  "onedotenleader",
                  8228,
                  "oneeighth",
                  8539,
                  "onefitted",
                  63196,
                  "onegujarati",
                  2791,
                  "onegurmukhi",
                  2663,
                  "onehackarabic",
                  1633,
                  "onehalf",
                  189,
                  "onehangzhou",
                  12321,
                  "oneideographicparen",
                  12832,
                  "oneinferior",
                  8321,
                  "onemonospace",
                  65297,
                  "onenumeratorbengali",
                  2548,
                  "oneoldstyle",
                  63281,
                  "oneparen",
                  9332,
                  "oneperiod",
                  9352,
                  "onepersian",
                  1777,
                  "onequarter",
                  188,
                  "oneroman",
                  8560,
                  "onesuperior",
                  185,
                  "onethai",
                  3665,
                  "onethird",
                  8531,
                  "oogonek",
                  491,
                  "oogonekmacron",
                  493,
                  "oogurmukhi",
                  2579,
                  "oomatragurmukhi",
                  2635,
                  "oopen",
                  596,
                  "oparen",
                  9386,
                  "openbullet",
                  9702,
                  "option",
                  8997,
                  "ordfeminine",
                  170,
                  "ordmasculine",
                  186,
                  "orthogonal",
                  8735,
                  "oshortdeva",
                  2322,
                  "oshortvowelsigndeva",
                  2378,
                  "oslash",
                  248,
                  "oslashacute",
                  511,
                  "osmallhiragana",
                  12361,
                  "osmallkatakana",
                  12457,
                  "osmallkatakanahalfwidth",
                  65387,
                  "ostrokeacute",
                  511,
                  "osuperior",
                  63216,
                  "otcyrillic",
                  1151,
                  "otilde",
                  245,
                  "otildeacute",
                  7757,
                  "otildedieresis",
                  7759,
                  "oubopomofo",
                  12577,
                  "overline",
                  8254,
                  "overlinecenterline",
                  65098,
                  "overlinecmb",
                  773,
                  "overlinedashed",
                  65097,
                  "overlinedblwavy",
                  65100,
                  "overlinewavy",
                  65099,
                  "overscore",
                  175,
                  "ovowelsignbengali",
                  2507,
                  "ovowelsigndeva",
                  2379,
                  "ovowelsigngujarati",
                  2763,
                  "p",
                  112,
                  "paampssquare",
                  13184,
                  "paasentosquare",
                  13099,
                  "pabengali",
                  2474,
                  "pacute",
                  7765,
                  "padeva",
                  2346,
                  "pagedown",
                  8671,
                  "pageup",
                  8670,
                  "pagujarati",
                  2730,
                  "pagurmukhi",
                  2602,
                  "pahiragana",
                  12401,
                  "paiyannoithai",
                  3631,
                  "pakatakana",
                  12497,
                  "palatalizationcyrilliccmb",
                  1156,
                  "palochkacyrillic",
                  1216,
                  "pansioskorean",
                  12671,
                  "paragraph",
                  182,
                  "parallel",
                  8741,
                  "parenleft",
                  40,
                  "parenleftaltonearabic",
                  64830,
                  "parenleftbt",
                  63725,
                  "parenleftex",
                  63724,
                  "parenleftinferior",
                  8333,
                  "parenleftmonospace",
                  65288,
                  "parenleftsmall",
                  65113,
                  "parenleftsuperior",
                  8317,
                  "parenlefttp",
                  63723,
                  "parenleftvertical",
                  65077,
                  "parenright",
                  41,
                  "parenrightaltonearabic",
                  64831,
                  "parenrightbt",
                  63736,
                  "parenrightex",
                  63735,
                  "parenrightinferior",
                  8334,
                  "parenrightmonospace",
                  65289,
                  "parenrightsmall",
                  65114,
                  "parenrightsuperior",
                  8318,
                  "parenrighttp",
                  63734,
                  "parenrightvertical",
                  65078,
                  "partialdiff",
                  8706,
                  "paseqhebrew",
                  1472,
                  "pashtahebrew",
                  1433,
                  "pasquare",
                  13225,
                  "patah",
                  1463,
                  "patah11",
                  1463,
                  "patah1d",
                  1463,
                  "patah2a",
                  1463,
                  "patahhebrew",
                  1463,
                  "patahnarrowhebrew",
                  1463,
                  "patahquarterhebrew",
                  1463,
                  "patahwidehebrew",
                  1463,
                  "pazerhebrew",
                  1441,
                  "pbopomofo",
                  12550,
                  "pcircle",
                  9439,
                  "pdotaccent",
                  7767,
                  "pe",
                  1508,
                  "pecyrillic",
                  1087,
                  "pedagesh",
                  64324,
                  "pedageshhebrew",
                  64324,
                  "peezisquare",
                  13115,
                  "pefinaldageshhebrew",
                  64323,
                  "peharabic",
                  1662,
                  "peharmenian",
                  1402,
                  "pehebrew",
                  1508,
                  "pehfinalarabic",
                  64343,
                  "pehinitialarabic",
                  64344,
                  "pehiragana",
                  12410,
                  "pehmedialarabic",
                  64345,
                  "pekatakana",
                  12506,
                  "pemiddlehookcyrillic",
                  1191,
                  "perafehebrew",
                  64334,
                  "percent",
                  37,
                  "percentarabic",
                  1642,
                  "percentmonospace",
                  65285,
                  "percentsmall",
                  65130,
                  "period",
                  46,
                  "periodarmenian",
                  1417,
                  "periodcentered",
                  183,
                  "periodhalfwidth",
                  65377,
                  "periodinferior",
                  63207,
                  "periodmonospace",
                  65294,
                  "periodsmall",
                  65106,
                  "periodsuperior",
                  63208,
                  "perispomenigreekcmb",
                  834,
                  "perpendicular",
                  8869,
                  "perthousand",
                  8240,
                  "peseta",
                  8359,
                  "pfsquare",
                  13194,
                  "phabengali",
                  2475,
                  "phadeva",
                  2347,
                  "phagujarati",
                  2731,
                  "phagurmukhi",
                  2603,
                  "phi",
                  966,
                  "phi1",
                  981,
                  "phieuphacirclekorean",
                  12922,
                  "phieuphaparenkorean",
                  12826,
                  "phieuphcirclekorean",
                  12908,
                  "phieuphkorean",
                  12621,
                  "phieuphparenkorean",
                  12812,
                  "philatin",
                  632,
                  "phinthuthai",
                  3642,
                  "phisymbolgreek",
                  981,
                  "phook",
                  421,
                  "phophanthai",
                  3614,
                  "phophungthai",
                  3612,
                  "phosamphaothai",
                  3616,
                  "pi",
                  960,
                  "pieupacirclekorean",
                  12915,
                  "pieupaparenkorean",
                  12819,
                  "pieupcieuckorean",
                  12662,
                  "pieupcirclekorean",
                  12901,
                  "pieupkiyeokkorean",
                  12658,
                  "pieupkorean",
                  12610,
                  "pieupparenkorean",
                  12805,
                  "pieupsioskiyeokkorean",
                  12660,
                  "pieupsioskorean",
                  12612,
                  "pieupsiostikeutkorean",
                  12661,
                  "pieupthieuthkorean",
                  12663,
                  "pieuptikeutkorean",
                  12659,
                  "pihiragana",
                  12404,
                  "pikatakana",
                  12500,
                  "pisymbolgreek",
                  982,
                  "piwrarmenian",
                  1411,
                  "plus",
                  43,
                  "plusbelowcmb",
                  799,
                  "pluscircle",
                  8853,
                  "plusminus",
                  177,
                  "plusmod",
                  726,
                  "plusmonospace",
                  65291,
                  "plussmall",
                  65122,
                  "plussuperior",
                  8314,
                  "pmonospace",
                  65360,
                  "pmsquare",
                  13272,
                  "pohiragana",
                  12413,
                  "pointingindexdownwhite",
                  9759,
                  "pointingindexleftwhite",
                  9756,
                  "pointingindexrightwhite",
                  9758,
                  "pointingindexupwhite",
                  9757,
                  "pokatakana",
                  12509,
                  "poplathai",
                  3611,
                  "postalmark",
                  12306,
                  "postalmarkface",
                  12320,
                  "pparen",
                  9387,
                  "precedes",
                  8826,
                  "prescription",
                  8478,
                  "primemod",
                  697,
                  "primereversed",
                  8245,
                  "product",
                  8719,
                  "projective",
                  8965,
                  "prolongedkana",
                  12540,
                  "propellor",
                  8984,
                  "propersubset",
                  8834,
                  "propersuperset",
                  8835,
                  "proportion",
                  8759,
                  "proportional",
                  8733,
                  "psi",
                  968,
                  "psicyrillic",
                  1137,
                  "psilipneumatacyrilliccmb",
                  1158,
                  "pssquare",
                  13232,
                  "puhiragana",
                  12407,
                  "pukatakana",
                  12503,
                  "pvsquare",
                  13236,
                  "pwsquare",
                  13242,
                  "q",
                  113,
                  "qadeva",
                  2392,
                  "qadmahebrew",
                  1448,
                  "qafarabic",
                  1602,
                  "qaffinalarabic",
                  65238,
                  "qafinitialarabic",
                  65239,
                  "qafmedialarabic",
                  65240,
                  "qamats",
                  1464,
                  "qamats10",
                  1464,
                  "qamats1a",
                  1464,
                  "qamats1c",
                  1464,
                  "qamats27",
                  1464,
                  "qamats29",
                  1464,
                  "qamats33",
                  1464,
                  "qamatsde",
                  1464,
                  "qamatshebrew",
                  1464,
                  "qamatsnarrowhebrew",
                  1464,
                  "qamatsqatanhebrew",
                  1464,
                  "qamatsqatannarrowhebrew",
                  1464,
                  "qamatsqatanquarterhebrew",
                  1464,
                  "qamatsqatanwidehebrew",
                  1464,
                  "qamatsquarterhebrew",
                  1464,
                  "qamatswidehebrew",
                  1464,
                  "qarneyparahebrew",
                  1439,
                  "qbopomofo",
                  12561,
                  "qcircle",
                  9440,
                  "qhook",
                  672,
                  "qmonospace",
                  65361,
                  "qof",
                  1511,
                  "qofdagesh",
                  64327,
                  "qofdageshhebrew",
                  64327,
                  "qofhebrew",
                  1511,
                  "qparen",
                  9388,
                  "quarternote",
                  9833,
                  "qubuts",
                  1467,
                  "qubuts18",
                  1467,
                  "qubuts25",
                  1467,
                  "qubuts31",
                  1467,
                  "qubutshebrew",
                  1467,
                  "qubutsnarrowhebrew",
                  1467,
                  "qubutsquarterhebrew",
                  1467,
                  "qubutswidehebrew",
                  1467,
                  "question",
                  63,
                  "questionarabic",
                  1567,
                  "questionarmenian",
                  1374,
                  "questiondown",
                  191,
                  "questiondownsmall",
                  63423,
                  "questiongreek",
                  894,
                  "questionmonospace",
                  65311,
                  "questionsmall",
                  63295,
                  "quotedbl",
                  34,
                  "quotedblbase",
                  8222,
                  "quotedblleft",
                  8220,
                  "quotedblmonospace",
                  65282,
                  "quotedblprime",
                  12318,
                  "quotedblprimereversed",
                  12317,
                  "quotedblright",
                  8221,
                  "quoteleft",
                  8216,
                  "quoteleftreversed",
                  8219,
                  "quotereversed",
                  8219,
                  "quoteright",
                  8217,
                  "quoterightn",
                  329,
                  "quotesinglbase",
                  8218,
                  "quotesingle",
                  39,
                  "quotesinglemonospace",
                  65287,
                  "r",
                  114,
                  "raarmenian",
                  1404,
                  "rabengali",
                  2480,
                  "racute",
                  341,
                  "radeva",
                  2352,
                  "radical",
                  8730,
                  "radicalex",
                  63717,
                  "radoverssquare",
                  13230,
                  "radoverssquaredsquare",
                  13231,
                  "radsquare",
                  13229,
                  "rafe",
                  1471,
                  "rafehebrew",
                  1471,
                  "ragujarati",
                  2736,
                  "ragurmukhi",
                  2608,
                  "rahiragana",
                  12425,
                  "rakatakana",
                  12521,
                  "rakatakanahalfwidth",
                  65431,
                  "ralowerdiagonalbengali",
                  2545,
                  "ramiddlediagonalbengali",
                  2544,
                  "ramshorn",
                  612,
                  "ratio",
                  8758,
                  "rbopomofo",
                  12566,
                  "rcaron",
                  345,
                  "rcedilla",
                  343,
                  "rcircle",
                  9441,
                  "rcommaaccent",
                  343,
                  "rdblgrave",
                  529,
                  "rdotaccent",
                  7769,
                  "rdotbelow",
                  7771,
                  "rdotbelowmacron",
                  7773,
                  "referencemark",
                  8251,
                  "reflexsubset",
                  8838,
                  "reflexsuperset",
                  8839,
                  "registered",
                  174,
                  "registersans",
                  63720,
                  "registerserif",
                  63194,
                  "reharabic",
                  1585,
                  "reharmenian",
                  1408,
                  "rehfinalarabic",
                  65198,
                  "rehiragana",
                  12428,
                  "rekatakana",
                  12524,
                  "rekatakanahalfwidth",
                  65434,
                  "resh",
                  1512,
                  "reshdageshhebrew",
                  64328,
                  "reshhebrew",
                  1512,
                  "reversedtilde",
                  8765,
                  "reviahebrew",
                  1431,
                  "reviamugrashhebrew",
                  1431,
                  "revlogicalnot",
                  8976,
                  "rfishhook",
                  638,
                  "rfishhookreversed",
                  639,
                  "rhabengali",
                  2525,
                  "rhadeva",
                  2397,
                  "rho",
                  961,
                  "rhook",
                  637,
                  "rhookturned",
                  635,
                  "rhookturnedsuperior",
                  693,
                  "rhosymbolgreek",
                  1009,
                  "rhotichookmod",
                  734,
                  "rieulacirclekorean",
                  12913,
                  "rieulaparenkorean",
                  12817,
                  "rieulcirclekorean",
                  12899,
                  "rieulhieuhkorean",
                  12608,
                  "rieulkiyeokkorean",
                  12602,
                  "rieulkiyeoksioskorean",
                  12649,
                  "rieulkorean",
                  12601,
                  "rieulmieumkorean",
                  12603,
                  "rieulpansioskorean",
                  12652,
                  "rieulparenkorean",
                  12803,
                  "rieulphieuphkorean",
                  12607,
                  "rieulpieupkorean",
                  12604,
                  "rieulpieupsioskorean",
                  12651,
                  "rieulsioskorean",
                  12605,
                  "rieulthieuthkorean",
                  12606,
                  "rieultikeutkorean",
                  12650,
                  "rieulyeorinhieuhkorean",
                  12653,
                  "rightangle",
                  8735,
                  "righttackbelowcmb",
                  793,
                  "righttriangle",
                  8895,
                  "rihiragana",
                  12426,
                  "rikatakana",
                  12522,
                  "rikatakanahalfwidth",
                  65432,
                  "ring",
                  730,
                  "ringbelowcmb",
                  805,
                  "ringcmb",
                  778,
                  "ringhalfleft",
                  703,
                  "ringhalfleftarmenian",
                  1369,
                  "ringhalfleftbelowcmb",
                  796,
                  "ringhalfleftcentered",
                  723,
                  "ringhalfright",
                  702,
                  "ringhalfrightbelowcmb",
                  825,
                  "ringhalfrightcentered",
                  722,
                  "rinvertedbreve",
                  531,
                  "rittorusquare",
                  13137,
                  "rlinebelow",
                  7775,
                  "rlongleg",
                  636,
                  "rlonglegturned",
                  634,
                  "rmonospace",
                  65362,
                  "rohiragana",
                  12429,
                  "rokatakana",
                  12525,
                  "rokatakanahalfwidth",
                  65435,
                  "roruathai",
                  3619,
                  "rparen",
                  9389,
                  "rrabengali",
                  2524,
                  "rradeva",
                  2353,
                  "rragurmukhi",
                  2652,
                  "rreharabic",
                  1681,
                  "rrehfinalarabic",
                  64397,
                  "rrvocalicbengali",
                  2528,
                  "rrvocalicdeva",
                  2400,
                  "rrvocalicgujarati",
                  2784,
                  "rrvocalicvowelsignbengali",
                  2500,
                  "rrvocalicvowelsigndeva",
                  2372,
                  "rrvocalicvowelsigngujarati",
                  2756,
                  "rsuperior",
                  63217,
                  "rtblock",
                  9616,
                  "rturned",
                  633,
                  "rturnedsuperior",
                  692,
                  "ruhiragana",
                  12427,
                  "rukatakana",
                  12523,
                  "rukatakanahalfwidth",
                  65433,
                  "rupeemarkbengali",
                  2546,
                  "rupeesignbengali",
                  2547,
                  "rupiah",
                  63197,
                  "ruthai",
                  3620,
                  "rvocalicbengali",
                  2443,
                  "rvocalicdeva",
                  2315,
                  "rvocalicgujarati",
                  2699,
                  "rvocalicvowelsignbengali",
                  2499,
                  "rvocalicvowelsigndeva",
                  2371,
                  "rvocalicvowelsigngujarati",
                  2755,
                  "s",
                  115,
                  "sabengali",
                  2488,
                  "sacute",
                  347,
                  "sacutedotaccent",
                  7781,
                  "sadarabic",
                  1589,
                  "sadeva",
                  2360,
                  "sadfinalarabic",
                  65210,
                  "sadinitialarabic",
                  65211,
                  "sadmedialarabic",
                  65212,
                  "sagujarati",
                  2744,
                  "sagurmukhi",
                  2616,
                  "sahiragana",
                  12373,
                  "sakatakana",
                  12469,
                  "sakatakanahalfwidth",
                  65403,
                  "sallallahoualayhewasallamarabic",
                  65018,
                  "samekh",
                  1505,
                  "samekhdagesh",
                  64321,
                  "samekhdageshhebrew",
                  64321,
                  "samekhhebrew",
                  1505,
                  "saraaathai",
                  3634,
                  "saraaethai",
                  3649,
                  "saraaimaimalaithai",
                  3652,
                  "saraaimaimuanthai",
                  3651,
                  "saraamthai",
                  3635,
                  "saraathai",
                  3632,
                  "saraethai",
                  3648,
                  "saraiileftthai",
                  63622,
                  "saraiithai",
                  3637,
                  "saraileftthai",
                  63621,
                  "saraithai",
                  3636,
                  "saraothai",
                  3650,
                  "saraueeleftthai",
                  63624,
                  "saraueethai",
                  3639,
                  "saraueleftthai",
                  63623,
                  "sarauethai",
                  3638,
                  "sarauthai",
                  3640,
                  "sarauuthai",
                  3641,
                  "sbopomofo",
                  12569,
                  "scaron",
                  353,
                  "scarondotaccent",
                  7783,
                  "scedilla",
                  351,
                  "schwa",
                  601,
                  "schwacyrillic",
                  1241,
                  "schwadieresiscyrillic",
                  1243,
                  "schwahook",
                  602,
                  "scircle",
                  9442,
                  "scircumflex",
                  349,
                  "scommaaccent",
                  537,
                  "sdotaccent",
                  7777,
                  "sdotbelow",
                  7779,
                  "sdotbelowdotaccent",
                  7785,
                  "seagullbelowcmb",
                  828,
                  "second",
                  8243,
                  "secondtonechinese",
                  714,
                  "section",
                  167,
                  "seenarabic",
                  1587,
                  "seenfinalarabic",
                  65202,
                  "seeninitialarabic",
                  65203,
                  "seenmedialarabic",
                  65204,
                  "segol",
                  1462,
                  "segol13",
                  1462,
                  "segol1f",
                  1462,
                  "segol2c",
                  1462,
                  "segolhebrew",
                  1462,
                  "segolnarrowhebrew",
                  1462,
                  "segolquarterhebrew",
                  1462,
                  "segoltahebrew",
                  1426,
                  "segolwidehebrew",
                  1462,
                  "seharmenian",
                  1405,
                  "sehiragana",
                  12379,
                  "sekatakana",
                  12475,
                  "sekatakanahalfwidth",
                  65406,
                  "semicolon",
                  59,
                  "semicolonarabic",
                  1563,
                  "semicolonmonospace",
                  65307,
                  "semicolonsmall",
                  65108,
                  "semivoicedmarkkana",
                  12444,
                  "semivoicedmarkkanahalfwidth",
                  65439,
                  "sentisquare",
                  13090,
                  "sentosquare",
                  13091,
                  "seven",
                  55,
                  "sevenarabic",
                  1639,
                  "sevenbengali",
                  2541,
                  "sevencircle",
                  9318,
                  "sevencircleinversesansserif",
                  10128,
                  "sevendeva",
                  2413,
                  "seveneighths",
                  8542,
                  "sevengujarati",
                  2797,
                  "sevengurmukhi",
                  2669,
                  "sevenhackarabic",
                  1639,
                  "sevenhangzhou",
                  12327,
                  "sevenideographicparen",
                  12838,
                  "seveninferior",
                  8327,
                  "sevenmonospace",
                  65303,
                  "sevenoldstyle",
                  63287,
                  "sevenparen",
                  9338,
                  "sevenperiod",
                  9358,
                  "sevenpersian",
                  1783,
                  "sevenroman",
                  8566,
                  "sevensuperior",
                  8311,
                  "seventeencircle",
                  9328,
                  "seventeenparen",
                  9348,
                  "seventeenperiod",
                  9368,
                  "seventhai",
                  3671,
                  "sfthyphen",
                  173,
                  "shaarmenian",
                  1399,
                  "shabengali",
                  2486,
                  "shacyrillic",
                  1096,
                  "shaddaarabic",
                  1617,
                  "shaddadammaarabic",
                  64609,
                  "shaddadammatanarabic",
                  64606,
                  "shaddafathaarabic",
                  64608,
                  "shaddakasraarabic",
                  64610,
                  "shaddakasratanarabic",
                  64607,
                  "shade",
                  9618,
                  "shadedark",
                  9619,
                  "shadelight",
                  9617,
                  "shademedium",
                  9618,
                  "shadeva",
                  2358,
                  "shagujarati",
                  2742,
                  "shagurmukhi",
                  2614,
                  "shalshelethebrew",
                  1427,
                  "shbopomofo",
                  12565,
                  "shchacyrillic",
                  1097,
                  "sheenarabic",
                  1588,
                  "sheenfinalarabic",
                  65206,
                  "sheeninitialarabic",
                  65207,
                  "sheenmedialarabic",
                  65208,
                  "sheicoptic",
                  995,
                  "sheqel",
                  8362,
                  "sheqelhebrew",
                  8362,
                  "sheva",
                  1456,
                  "sheva115",
                  1456,
                  "sheva15",
                  1456,
                  "sheva22",
                  1456,
                  "sheva2e",
                  1456,
                  "shevahebrew",
                  1456,
                  "shevanarrowhebrew",
                  1456,
                  "shevaquarterhebrew",
                  1456,
                  "shevawidehebrew",
                  1456,
                  "shhacyrillic",
                  1211,
                  "shimacoptic",
                  1005,
                  "shin",
                  1513,
                  "shindagesh",
                  64329,
                  "shindageshhebrew",
                  64329,
                  "shindageshshindot",
                  64300,
                  "shindageshshindothebrew",
                  64300,
                  "shindageshsindot",
                  64301,
                  "shindageshsindothebrew",
                  64301,
                  "shindothebrew",
                  1473,
                  "shinhebrew",
                  1513,
                  "shinshindot",
                  64298,
                  "shinshindothebrew",
                  64298,
                  "shinsindot",
                  64299,
                  "shinsindothebrew",
                  64299,
                  "shook",
                  642,
                  "sigma",
                  963,
                  "sigma1",
                  962,
                  "sigmafinal",
                  962,
                  "sigmalunatesymbolgreek",
                  1010,
                  "sihiragana",
                  12375,
                  "sikatakana",
                  12471,
                  "sikatakanahalfwidth",
                  65404,
                  "siluqhebrew",
                  1469,
                  "siluqlefthebrew",
                  1469,
                  "similar",
                  8764,
                  "sindothebrew",
                  1474,
                  "siosacirclekorean",
                  12916,
                  "siosaparenkorean",
                  12820,
                  "sioscieuckorean",
                  12670,
                  "sioscirclekorean",
                  12902,
                  "sioskiyeokkorean",
                  12666,
                  "sioskorean",
                  12613,
                  "siosnieunkorean",
                  12667,
                  "siosparenkorean",
                  12806,
                  "siospieupkorean",
                  12669,
                  "siostikeutkorean",
                  12668,
                  "six",
                  54,
                  "sixarabic",
                  1638,
                  "sixbengali",
                  2540,
                  "sixcircle",
                  9317,
                  "sixcircleinversesansserif",
                  10127,
                  "sixdeva",
                  2412,
                  "sixgujarati",
                  2796,
                  "sixgurmukhi",
                  2668,
                  "sixhackarabic",
                  1638,
                  "sixhangzhou",
                  12326,
                  "sixideographicparen",
                  12837,
                  "sixinferior",
                  8326,
                  "sixmonospace",
                  65302,
                  "sixoldstyle",
                  63286,
                  "sixparen",
                  9337,
                  "sixperiod",
                  9357,
                  "sixpersian",
                  1782,
                  "sixroman",
                  8565,
                  "sixsuperior",
                  8310,
                  "sixteencircle",
                  9327,
                  "sixteencurrencydenominatorbengali",
                  2553,
                  "sixteenparen",
                  9347,
                  "sixteenperiod",
                  9367,
                  "sixthai",
                  3670,
                  "slash",
                  47,
                  "slashmonospace",
                  65295,
                  "slong",
                  383,
                  "slongdotaccent",
                  7835,
                  "smileface",
                  9786,
                  "smonospace",
                  65363,
                  "sofpasuqhebrew",
                  1475,
                  "softhyphen",
                  173,
                  "softsigncyrillic",
                  1100,
                  "sohiragana",
                  12381,
                  "sokatakana",
                  12477,
                  "sokatakanahalfwidth",
                  65407,
                  "soliduslongoverlaycmb",
                  824,
                  "solidusshortoverlaycmb",
                  823,
                  "sorusithai",
                  3625,
                  "sosalathai",
                  3624,
                  "sosothai",
                  3595,
                  "sosuathai",
                  3626,
                  "space",
                  32,
                  "spacehackarabic",
                  32,
                  "spade",
                  9824,
                  "spadesuitblack",
                  9824,
                  "spadesuitwhite",
                  9828,
                  "sparen",
                  9390,
                  "squarebelowcmb",
                  827,
                  "squarecc",
                  13252,
                  "squarecm",
                  13213,
                  "squarediagonalcrosshatchfill",
                  9641,
                  "squarehorizontalfill",
                  9636,
                  "squarekg",
                  13199,
                  "squarekm",
                  13214,
                  "squarekmcapital",
                  13262,
                  "squareln",
                  13265,
                  "squarelog",
                  13266,
                  "squaremg",
                  13198,
                  "squaremil",
                  13269,
                  "squaremm",
                  13212,
                  "squaremsquared",
                  13217,
                  "squareorthogonalcrosshatchfill",
                  9638,
                  "squareupperlefttolowerrightfill",
                  9639,
                  "squareupperrighttolowerleftfill",
                  9640,
                  "squareverticalfill",
                  9637,
                  "squarewhitewithsmallblack",
                  9635,
                  "srsquare",
                  13275,
                  "ssabengali",
                  2487,
                  "ssadeva",
                  2359,
                  "ssagujarati",
                  2743,
                  "ssangcieuckorean",
                  12617,
                  "ssanghieuhkorean",
                  12677,
                  "ssangieungkorean",
                  12672,
                  "ssangkiyeokkorean",
                  12594,
                  "ssangnieunkorean",
                  12645,
                  "ssangpieupkorean",
                  12611,
                  "ssangsioskorean",
                  12614,
                  "ssangtikeutkorean",
                  12600,
                  "ssuperior",
                  63218,
                  "sterling",
                  163,
                  "sterlingmonospace",
                  65505,
                  "strokelongoverlaycmb",
                  822,
                  "strokeshortoverlaycmb",
                  821,
                  "subset",
                  8834,
                  "subsetnotequal",
                  8842,
                  "subsetorequal",
                  8838,
                  "succeeds",
                  8827,
                  "suchthat",
                  8715,
                  "suhiragana",
                  12377,
                  "sukatakana",
                  12473,
                  "sukatakanahalfwidth",
                  65405,
                  "sukunarabic",
                  1618,
                  "summation",
                  8721,
                  "sun",
                  9788,
                  "superset",
                  8835,
                  "supersetnotequal",
                  8843,
                  "supersetorequal",
                  8839,
                  "svsquare",
                  13276,
                  "syouwaerasquare",
                  13180,
                  "t",
                  116,
                  "tabengali",
                  2468,
                  "tackdown",
                  8868,
                  "tackleft",
                  8867,
                  "tadeva",
                  2340,
                  "tagujarati",
                  2724,
                  "tagurmukhi",
                  2596,
                  "taharabic",
                  1591,
                  "tahfinalarabic",
                  65218,
                  "tahinitialarabic",
                  65219,
                  "tahiragana",
                  12383,
                  "tahmedialarabic",
                  65220,
                  "taisyouerasquare",
                  13181,
                  "takatakana",
                  12479,
                  "takatakanahalfwidth",
                  65408,
                  "tatweelarabic",
                  1600,
                  "tau",
                  964,
                  "tav",
                  1514,
                  "tavdages",
                  64330,
                  "tavdagesh",
                  64330,
                  "tavdageshhebrew",
                  64330,
                  "tavhebrew",
                  1514,
                  "tbar",
                  359,
                  "tbopomofo",
                  12554,
                  "tcaron",
                  357,
                  "tccurl",
                  680,
                  "tcedilla",
                  355,
                  "tcheharabic",
                  1670,
                  "tchehfinalarabic",
                  64379,
                  "tchehinitialarabic",
                  64380,
                  "tchehmedialarabic",
                  64381,
                  "tcircle",
                  9443,
                  "tcircumflexbelow",
                  7793,
                  "tcommaaccent",
                  355,
                  "tdieresis",
                  7831,
                  "tdotaccent",
                  7787,
                  "tdotbelow",
                  7789,
                  "tecyrillic",
                  1090,
                  "tedescendercyrillic",
                  1197,
                  "teharabic",
                  1578,
                  "tehfinalarabic",
                  65174,
                  "tehhahinitialarabic",
                  64674,
                  "tehhahisolatedarabic",
                  64524,
                  "tehinitialarabic",
                  65175,
                  "tehiragana",
                  12390,
                  "tehjeeminitialarabic",
                  64673,
                  "tehjeemisolatedarabic",
                  64523,
                  "tehmarbutaarabic",
                  1577,
                  "tehmarbutafinalarabic",
                  65172,
                  "tehmedialarabic",
                  65176,
                  "tehmeeminitialarabic",
                  64676,
                  "tehmeemisolatedarabic",
                  64526,
                  "tehnoonfinalarabic",
                  64627,
                  "tekatakana",
                  12486,
                  "tekatakanahalfwidth",
                  65411,
                  "telephone",
                  8481,
                  "telephoneblack",
                  9742,
                  "telishagedolahebrew",
                  1440,
                  "telishaqetanahebrew",
                  1449,
                  "tencircle",
                  9321,
                  "tenideographicparen",
                  12841,
                  "tenparen",
                  9341,
                  "tenperiod",
                  9361,
                  "tenroman",
                  8569,
                  "tesh",
                  679,
                  "tet",
                  1496,
                  "tetdagesh",
                  64312,
                  "tetdageshhebrew",
                  64312,
                  "tethebrew",
                  1496,
                  "tetsecyrillic",
                  1205,
                  "tevirhebrew",
                  1435,
                  "tevirlefthebrew",
                  1435,
                  "thabengali",
                  2469,
                  "thadeva",
                  2341,
                  "thagujarati",
                  2725,
                  "thagurmukhi",
                  2597,
                  "thalarabic",
                  1584,
                  "thalfinalarabic",
                  65196,
                  "thanthakhatlowleftthai",
                  63640,
                  "thanthakhatlowrightthai",
                  63639,
                  "thanthakhatthai",
                  3660,
                  "thanthakhatupperleftthai",
                  63638,
                  "theharabic",
                  1579,
                  "thehfinalarabic",
                  65178,
                  "thehinitialarabic",
                  65179,
                  "thehmedialarabic",
                  65180,
                  "thereexists",
                  8707,
                  "therefore",
                  8756,
                  "theta",
                  952,
                  "theta1",
                  977,
                  "thetasymbolgreek",
                  977,
                  "thieuthacirclekorean",
                  12921,
                  "thieuthaparenkorean",
                  12825,
                  "thieuthcirclekorean",
                  12907,
                  "thieuthkorean",
                  12620,
                  "thieuthparenkorean",
                  12811,
                  "thirteencircle",
                  9324,
                  "thirteenparen",
                  9344,
                  "thirteenperiod",
                  9364,
                  "thonangmonthothai",
                  3601,
                  "thook",
                  429,
                  "thophuthaothai",
                  3602,
                  "thorn",
                  254,
                  "thothahanthai",
                  3607,
                  "thothanthai",
                  3600,
                  "thothongthai",
                  3608,
                  "thothungthai",
                  3606,
                  "thousandcyrillic",
                  1154,
                  "thousandsseparatorarabic",
                  1644,
                  "thousandsseparatorpersian",
                  1644,
                  "three",
                  51,
                  "threearabic",
                  1635,
                  "threebengali",
                  2537,
                  "threecircle",
                  9314,
                  "threecircleinversesansserif",
                  10124,
                  "threedeva",
                  2409,
                  "threeeighths",
                  8540,
                  "threegujarati",
                  2793,
                  "threegurmukhi",
                  2665,
                  "threehackarabic",
                  1635,
                  "threehangzhou",
                  12323,
                  "threeideographicparen",
                  12834,
                  "threeinferior",
                  8323,
                  "threemonospace",
                  65299,
                  "threenumeratorbengali",
                  2550,
                  "threeoldstyle",
                  63283,
                  "threeparen",
                  9334,
                  "threeperiod",
                  9354,
                  "threepersian",
                  1779,
                  "threequarters",
                  190,
                  "threequartersemdash",
                  63198,
                  "threeroman",
                  8562,
                  "threesuperior",
                  179,
                  "threethai",
                  3667,
                  "thzsquare",
                  13204,
                  "tihiragana",
                  12385,
                  "tikatakana",
                  12481,
                  "tikatakanahalfwidth",
                  65409,
                  "tikeutacirclekorean",
                  12912,
                  "tikeutaparenkorean",
                  12816,
                  "tikeutcirclekorean",
                  12898,
                  "tikeutkorean",
                  12599,
                  "tikeutparenkorean",
                  12802,
                  "tilde",
                  732,
                  "tildebelowcmb",
                  816,
                  "tildecmb",
                  771,
                  "tildecomb",
                  771,
                  "tildedoublecmb",
                  864,
                  "tildeoperator",
                  8764,
                  "tildeoverlaycmb",
                  820,
                  "tildeverticalcmb",
                  830,
                  "timescircle",
                  8855,
                  "tipehahebrew",
                  1430,
                  "tipehalefthebrew",
                  1430,
                  "tippigurmukhi",
                  2672,
                  "titlocyrilliccmb",
                  1155,
                  "tiwnarmenian",
                  1407,
                  "tlinebelow",
                  7791,
                  "tmonospace",
                  65364,
                  "toarmenian",
                  1385,
                  "tohiragana",
                  12392,
                  "tokatakana",
                  12488,
                  "tokatakanahalfwidth",
                  65412,
                  "tonebarextrahighmod",
                  741,
                  "tonebarextralowmod",
                  745,
                  "tonebarhighmod",
                  742,
                  "tonebarlowmod",
                  744,
                  "tonebarmidmod",
                  743,
                  "tonefive",
                  445,
                  "tonesix",
                  389,
                  "tonetwo",
                  424,
                  "tonos",
                  900,
                  "tonsquare",
                  13095,
                  "topatakthai",
                  3599,
                  "tortoiseshellbracketleft",
                  12308,
                  "tortoiseshellbracketleftsmall",
                  65117,
                  "tortoiseshellbracketleftvertical",
                  65081,
                  "tortoiseshellbracketright",
                  12309,
                  "tortoiseshellbracketrightsmall",
                  65118,
                  "tortoiseshellbracketrightvertical",
                  65082,
                  "totaothai",
                  3605,
                  "tpalatalhook",
                  427,
                  "tparen",
                  9391,
                  "trademark",
                  8482,
                  "trademarksans",
                  63722,
                  "trademarkserif",
                  63195,
                  "tretroflexhook",
                  648,
                  "triagdn",
                  9660,
                  "triaglf",
                  9668,
                  "triagrt",
                  9658,
                  "triagup",
                  9650,
                  "ts",
                  678,
                  "tsadi",
                  1510,
                  "tsadidagesh",
                  64326,
                  "tsadidageshhebrew",
                  64326,
                  "tsadihebrew",
                  1510,
                  "tsecyrillic",
                  1094,
                  "tsere",
                  1461,
                  "tsere12",
                  1461,
                  "tsere1e",
                  1461,
                  "tsere2b",
                  1461,
                  "tserehebrew",
                  1461,
                  "tserenarrowhebrew",
                  1461,
                  "tserequarterhebrew",
                  1461,
                  "tserewidehebrew",
                  1461,
                  "tshecyrillic",
                  1115,
                  "tsuperior",
                  63219,
                  "ttabengali",
                  2463,
                  "ttadeva",
                  2335,
                  "ttagujarati",
                  2719,
                  "ttagurmukhi",
                  2591,
                  "tteharabic",
                  1657,
                  "ttehfinalarabic",
                  64359,
                  "ttehinitialarabic",
                  64360,
                  "ttehmedialarabic",
                  64361,
                  "tthabengali",
                  2464,
                  "tthadeva",
                  2336,
                  "tthagujarati",
                  2720,
                  "tthagurmukhi",
                  2592,
                  "tturned",
                  647,
                  "tuhiragana",
                  12388,
                  "tukatakana",
                  12484,
                  "tukatakanahalfwidth",
                  65410,
                  "tusmallhiragana",
                  12387,
                  "tusmallkatakana",
                  12483,
                  "tusmallkatakanahalfwidth",
                  65391,
                  "twelvecircle",
                  9323,
                  "twelveparen",
                  9343,
                  "twelveperiod",
                  9363,
                  "twelveroman",
                  8571,
                  "twentycircle",
                  9331,
                  "twentyhangzhou",
                  21316,
                  "twentyparen",
                  9351,
                  "twentyperiod",
                  9371,
                  "two",
                  50,
                  "twoarabic",
                  1634,
                  "twobengali",
                  2536,
                  "twocircle",
                  9313,
                  "twocircleinversesansserif",
                  10123,
                  "twodeva",
                  2408,
                  "twodotenleader",
                  8229,
                  "twodotleader",
                  8229,
                  "twodotleadervertical",
                  65072,
                  "twogujarati",
                  2792,
                  "twogurmukhi",
                  2664,
                  "twohackarabic",
                  1634,
                  "twohangzhou",
                  12322,
                  "twoideographicparen",
                  12833,
                  "twoinferior",
                  8322,
                  "twomonospace",
                  65298,
                  "twonumeratorbengali",
                  2549,
                  "twooldstyle",
                  63282,
                  "twoparen",
                  9333,
                  "twoperiod",
                  9353,
                  "twopersian",
                  1778,
                  "tworoman",
                  8561,
                  "twostroke",
                  443,
                  "twosuperior",
                  178,
                  "twothai",
                  3666,
                  "twothirds",
                  8532,
                  "u",
                  117,
                  "uacute",
                  250,
                  "ubar",
                  649,
                  "ubengali",
                  2441,
                  "ubopomofo",
                  12584,
                  "ubreve",
                  365,
                  "ucaron",
                  468,
                  "ucircle",
                  9444,
                  "ucircumflex",
                  251,
                  "ucircumflexbelow",
                  7799,
                  "ucyrillic",
                  1091,
                  "udattadeva",
                  2385,
                  "udblacute",
                  369,
                  "udblgrave",
                  533,
                  "udeva",
                  2313,
                  "udieresis",
                  252,
                  "udieresisacute",
                  472,
                  "udieresisbelow",
                  7795,
                  "udieresiscaron",
                  474,
                  "udieresiscyrillic",
                  1265,
                  "udieresisgrave",
                  476,
                  "udieresismacron",
                  470,
                  "udotbelow",
                  7909,
                  "ugrave",
                  249,
                  "ugujarati",
                  2697,
                  "ugurmukhi",
                  2569,
                  "uhiragana",
                  12358,
                  "uhookabove",
                  7911,
                  "uhorn",
                  432,
                  "uhornacute",
                  7913,
                  "uhorndotbelow",
                  7921,
                  "uhorngrave",
                  7915,
                  "uhornhookabove",
                  7917,
                  "uhorntilde",
                  7919,
                  "uhungarumlaut",
                  369,
                  "uhungarumlautcyrillic",
                  1267,
                  "uinvertedbreve",
                  535,
                  "ukatakana",
                  12454,
                  "ukatakanahalfwidth",
                  65395,
                  "ukcyrillic",
                  1145,
                  "ukorean",
                  12636,
                  "umacron",
                  363,
                  "umacroncyrillic",
                  1263,
                  "umacrondieresis",
                  7803,
                  "umatragurmukhi",
                  2625,
                  "umonospace",
                  65365,
                  "underscore",
                  95,
                  "underscoredbl",
                  8215,
                  "underscoremonospace",
                  65343,
                  "underscorevertical",
                  65075,
                  "underscorewavy",
                  65103,
                  "union",
                  8746,
                  "universal",
                  8704,
                  "uogonek",
                  371,
                  "uparen",
                  9392,
                  "upblock",
                  9600,
                  "upperdothebrew",
                  1476,
                  "upsilon",
                  965,
                  "upsilondieresis",
                  971,
                  "upsilondieresistonos",
                  944,
                  "upsilonlatin",
                  650,
                  "upsilontonos",
                  973,
                  "uptackbelowcmb",
                  797,
                  "uptackmod",
                  724,
                  "uragurmukhi",
                  2675,
                  "uring",
                  367,
                  "ushortcyrillic",
                  1118,
                  "usmallhiragana",
                  12357,
                  "usmallkatakana",
                  12453,
                  "usmallkatakanahalfwidth",
                  65385,
                  "ustraightcyrillic",
                  1199,
                  "ustraightstrokecyrillic",
                  1201,
                  "utilde",
                  361,
                  "utildeacute",
                  7801,
                  "utildebelow",
                  7797,
                  "uubengali",
                  2442,
                  "uudeva",
                  2314,
                  "uugujarati",
                  2698,
                  "uugurmukhi",
                  2570,
                  "uumatragurmukhi",
                  2626,
                  "uuvowelsignbengali",
                  2498,
                  "uuvowelsigndeva",
                  2370,
                  "uuvowelsigngujarati",
                  2754,
                  "uvowelsignbengali",
                  2497,
                  "uvowelsigndeva",
                  2369,
                  "uvowelsigngujarati",
                  2753,
                  "v",
                  118,
                  "vadeva",
                  2357,
                  "vagujarati",
                  2741,
                  "vagurmukhi",
                  2613,
                  "vakatakana",
                  12535,
                  "vav",
                  1493,
                  "vavdagesh",
                  64309,
                  "vavdagesh65",
                  64309,
                  "vavdageshhebrew",
                  64309,
                  "vavhebrew",
                  1493,
                  "vavholam",
                  64331,
                  "vavholamhebrew",
                  64331,
                  "vavvavhebrew",
                  1520,
                  "vavyodhebrew",
                  1521,
                  "vcircle",
                  9445,
                  "vdotbelow",
                  7807,
                  "vecyrillic",
                  1074,
                  "veharabic",
                  1700,
                  "vehfinalarabic",
                  64363,
                  "vehinitialarabic",
                  64364,
                  "vehmedialarabic",
                  64365,
                  "vekatakana",
                  12537,
                  "venus",
                  9792,
                  "verticalbar",
                  124,
                  "verticallineabovecmb",
                  781,
                  "verticallinebelowcmb",
                  809,
                  "verticallinelowmod",
                  716,
                  "verticallinemod",
                  712,
                  "vewarmenian",
                  1406,
                  "vhook",
                  651,
                  "vikatakana",
                  12536,
                  "viramabengali",
                  2509,
                  "viramadeva",
                  2381,
                  "viramagujarati",
                  2765,
                  "visargabengali",
                  2435,
                  "visargadeva",
                  2307,
                  "visargagujarati",
                  2691,
                  "vmonospace",
                  65366,
                  "voarmenian",
                  1400,
                  "voicediterationhiragana",
                  12446,
                  "voicediterationkatakana",
                  12542,
                  "voicedmarkkana",
                  12443,
                  "voicedmarkkanahalfwidth",
                  65438,
                  "vokatakana",
                  12538,
                  "vparen",
                  9393,
                  "vtilde",
                  7805,
                  "vturned",
                  652,
                  "vuhiragana",
                  12436,
                  "vukatakana",
                  12532,
                  "w",
                  119,
                  "wacute",
                  7811,
                  "waekorean",
                  12633,
                  "wahiragana",
                  12431,
                  "wakatakana",
                  12527,
                  "wakatakanahalfwidth",
                  65436,
                  "wakorean",
                  12632,
                  "wasmallhiragana",
                  12430,
                  "wasmallkatakana",
                  12526,
                  "wattosquare",
                  13143,
                  "wavedash",
                  12316,
                  "wavyunderscorevertical",
                  65076,
                  "wawarabic",
                  1608,
                  "wawfinalarabic",
                  65262,
                  "wawhamzaabovearabic",
                  1572,
                  "wawhamzaabovefinalarabic",
                  65158,
                  "wbsquare",
                  13277,
                  "wcircle",
                  9446,
                  "wcircumflex",
                  373,
                  "wdieresis",
                  7813,
                  "wdotaccent",
                  7815,
                  "wdotbelow",
                  7817,
                  "wehiragana",
                  12433,
                  "weierstrass",
                  8472,
                  "wekatakana",
                  12529,
                  "wekorean",
                  12638,
                  "weokorean",
                  12637,
                  "wgrave",
                  7809,
                  "whitebullet",
                  9702,
                  "whitecircle",
                  9675,
                  "whitecircleinverse",
                  9689,
                  "whitecornerbracketleft",
                  12302,
                  "whitecornerbracketleftvertical",
                  65091,
                  "whitecornerbracketright",
                  12303,
                  "whitecornerbracketrightvertical",
                  65092,
                  "whitediamond",
                  9671,
                  "whitediamondcontainingblacksmalldiamond",
                  9672,
                  "whitedownpointingsmalltriangle",
                  9663,
                  "whitedownpointingtriangle",
                  9661,
                  "whiteleftpointingsmalltriangle",
                  9667,
                  "whiteleftpointingtriangle",
                  9665,
                  "whitelenticularbracketleft",
                  12310,
                  "whitelenticularbracketright",
                  12311,
                  "whiterightpointingsmalltriangle",
                  9657,
                  "whiterightpointingtriangle",
                  9655,
                  "whitesmallsquare",
                  9643,
                  "whitesmilingface",
                  9786,
                  "whitesquare",
                  9633,
                  "whitestar",
                  9734,
                  "whitetelephone",
                  9743,
                  "whitetortoiseshellbracketleft",
                  12312,
                  "whitetortoiseshellbracketright",
                  12313,
                  "whiteuppointingsmalltriangle",
                  9653,
                  "whiteuppointingtriangle",
                  9651,
                  "wihiragana",
                  12432,
                  "wikatakana",
                  12528,
                  "wikorean",
                  12639,
                  "wmonospace",
                  65367,
                  "wohiragana",
                  12434,
                  "wokatakana",
                  12530,
                  "wokatakanahalfwidth",
                  65382,
                  "won",
                  8361,
                  "wonmonospace",
                  65510,
                  "wowaenthai",
                  3623,
                  "wparen",
                  9394,
                  "wring",
                  7832,
                  "wsuperior",
                  695,
                  "wturned",
                  653,
                  "wynn",
                  447,
                  "x",
                  120,
                  "xabovecmb",
                  829,
                  "xbopomofo",
                  12562,
                  "xcircle",
                  9447,
                  "xdieresis",
                  7821,
                  "xdotaccent",
                  7819,
                  "xeharmenian",
                  1389,
                  "xi",
                  958,
                  "xmonospace",
                  65368,
                  "xparen",
                  9395,
                  "xsuperior",
                  739,
                  "y",
                  121,
                  "yaadosquare",
                  13134,
                  "yabengali",
                  2479,
                  "yacute",
                  253,
                  "yadeva",
                  2351,
                  "yaekorean",
                  12626,
                  "yagujarati",
                  2735,
                  "yagurmukhi",
                  2607,
                  "yahiragana",
                  12420,
                  "yakatakana",
                  12516,
                  "yakatakanahalfwidth",
                  65428,
                  "yakorean",
                  12625,
                  "yamakkanthai",
                  3662,
                  "yasmallhiragana",
                  12419,
                  "yasmallkatakana",
                  12515,
                  "yasmallkatakanahalfwidth",
                  65388,
                  "yatcyrillic",
                  1123,
                  "ycircle",
                  9448,
                  "ycircumflex",
                  375,
                  "ydieresis",
                  255,
                  "ydotaccent",
                  7823,
                  "ydotbelow",
                  7925,
                  "yeharabic",
                  1610,
                  "yehbarreearabic",
                  1746,
                  "yehbarreefinalarabic",
                  64431,
                  "yehfinalarabic",
                  65266,
                  "yehhamzaabovearabic",
                  1574,
                  "yehhamzaabovefinalarabic",
                  65162,
                  "yehhamzaaboveinitialarabic",
                  65163,
                  "yehhamzaabovemedialarabic",
                  65164,
                  "yehinitialarabic",
                  65267,
                  "yehmedialarabic",
                  65268,
                  "yehmeeminitialarabic",
                  64733,
                  "yehmeemisolatedarabic",
                  64600,
                  "yehnoonfinalarabic",
                  64660,
                  "yehthreedotsbelowarabic",
                  1745,
                  "yekorean",
                  12630,
                  "yen",
                  165,
                  "yenmonospace",
                  65509,
                  "yeokorean",
                  12629,
                  "yeorinhieuhkorean",
                  12678,
                  "yerahbenyomohebrew",
                  1450,
                  "yerahbenyomolefthebrew",
                  1450,
                  "yericyrillic",
                  1099,
                  "yerudieresiscyrillic",
                  1273,
                  "yesieungkorean",
                  12673,
                  "yesieungpansioskorean",
                  12675,
                  "yesieungsioskorean",
                  12674,
                  "yetivhebrew",
                  1434,
                  "ygrave",
                  7923,
                  "yhook",
                  436,
                  "yhookabove",
                  7927,
                  "yiarmenian",
                  1397,
                  "yicyrillic",
                  1111,
                  "yikorean",
                  12642,
                  "yinyang",
                  9775,
                  "yiwnarmenian",
                  1410,
                  "ymonospace",
                  65369,
                  "yod",
                  1497,
                  "yoddagesh",
                  64313,
                  "yoddageshhebrew",
                  64313,
                  "yodhebrew",
                  1497,
                  "yodyodhebrew",
                  1522,
                  "yodyodpatahhebrew",
                  64287,
                  "yohiragana",
                  12424,
                  "yoikorean",
                  12681,
                  "yokatakana",
                  12520,
                  "yokatakanahalfwidth",
                  65430,
                  "yokorean",
                  12635,
                  "yosmallhiragana",
                  12423,
                  "yosmallkatakana",
                  12519,
                  "yosmallkatakanahalfwidth",
                  65390,
                  "yotgreek",
                  1011,
                  "yoyaekorean",
                  12680,
                  "yoyakorean",
                  12679,
                  "yoyakthai",
                  3618,
                  "yoyingthai",
                  3597,
                  "yparen",
                  9396,
                  "ypogegrammeni",
                  890,
                  "ypogegrammenigreekcmb",
                  837,
                  "yr",
                  422,
                  "yring",
                  7833,
                  "ysuperior",
                  696,
                  "ytilde",
                  7929,
                  "yturned",
                  654,
                  "yuhiragana",
                  12422,
                  "yuikorean",
                  12684,
                  "yukatakana",
                  12518,
                  "yukatakanahalfwidth",
                  65429,
                  "yukorean",
                  12640,
                  "yusbigcyrillic",
                  1131,
                  "yusbigiotifiedcyrillic",
                  1133,
                  "yuslittlecyrillic",
                  1127,
                  "yuslittleiotifiedcyrillic",
                  1129,
                  "yusmallhiragana",
                  12421,
                  "yusmallkatakana",
                  12517,
                  "yusmallkatakanahalfwidth",
                  65389,
                  "yuyekorean",
                  12683,
                  "yuyeokorean",
                  12682,
                  "yyabengali",
                  2527,
                  "yyadeva",
                  2399,
                  "z",
                  122,
                  "zaarmenian",
                  1382,
                  "zacute",
                  378,
                  "zadeva",
                  2395,
                  "zagurmukhi",
                  2651,
                  "zaharabic",
                  1592,
                  "zahfinalarabic",
                  65222,
                  "zahinitialarabic",
                  65223,
                  "zahiragana",
                  12374,
                  "zahmedialarabic",
                  65224,
                  "zainarabic",
                  1586,
                  "zainfinalarabic",
                  65200,
                  "zakatakana",
                  12470,
                  "zaqefgadolhebrew",
                  1429,
                  "zaqefqatanhebrew",
                  1428,
                  "zarqahebrew",
                  1432,
                  "zayin",
                  1494,
                  "zayindagesh",
                  64310,
                  "zayindageshhebrew",
                  64310,
                  "zayinhebrew",
                  1494,
                  "zbopomofo",
                  12567,
                  "zcaron",
                  382,
                  "zcircle",
                  9449,
                  "zcircumflex",
                  7825,
                  "zcurl",
                  657,
                  "zdot",
                  380,
                  "zdotaccent",
                  380,
                  "zdotbelow",
                  7827,
                  "zecyrillic",
                  1079,
                  "zedescendercyrillic",
                  1177,
                  "zedieresiscyrillic",
                  1247,
                  "zehiragana",
                  12380,
                  "zekatakana",
                  12476,
                  "zero",
                  48,
                  "zeroarabic",
                  1632,
                  "zerobengali",
                  2534,
                  "zerodeva",
                  2406,
                  "zerogujarati",
                  2790,
                  "zerogurmukhi",
                  2662,
                  "zerohackarabic",
                  1632,
                  "zeroinferior",
                  8320,
                  "zeromonospace",
                  65296,
                  "zerooldstyle",
                  63280,
                  "zeropersian",
                  1776,
                  "zerosuperior",
                  8304,
                  "zerothai",
                  3664,
                  "zerowidthjoiner",
                  65279,
                  "zerowidthnonjoiner",
                  8204,
                  "zerowidthspace",
                  8203,
                  "zeta",
                  950,
                  "zhbopomofo",
                  12563,
                  "zhearmenian",
                  1386,
                  "zhebrevecyrillic",
                  1218,
                  "zhecyrillic",
                  1078,
                  "zhedescendercyrillic",
                  1175,
                  "zhedieresiscyrillic",
                  1245,
                  "zihiragana",
                  12376,
                  "zikatakana",
                  12472,
                  "zinorhebrew",
                  1454,
                  "zlinebelow",
                  7829,
                  "zmonospace",
                  65370,
                  "zohiragana",
                  12382,
                  "zokatakana",
                  12478,
                  "zparen",
                  9397,
                  "zretroflexhook",
                  656,
                  "zstroke",
                  438,
                  "zuhiragana",
                  12378,
                  "zukatakana",
                  12474,
                  ".notdef",
                  0,
                  "angbracketleftbig",
                  9001,
                  "angbracketleftBig",
                  9001,
                  "angbracketleftbigg",
                  9001,
                  "angbracketleftBigg",
                  9001,
                  "angbracketrightBig",
                  9002,
                  "angbracketrightbig",
                  9002,
                  "angbracketrightBigg",
                  9002,
                  "angbracketrightbigg",
                  9002,
                  "arrowhookleft",
                  8618,
                  "arrowhookright",
                  8617,
                  "arrowlefttophalf",
                  8636,
                  "arrowleftbothalf",
                  8637,
                  "arrownortheast",
                  8599,
                  "arrownorthwest",
                  8598,
                  "arrowrighttophalf",
                  8640,
                  "arrowrightbothalf",
                  8641,
                  "arrowsoutheast",
                  8600,
                  "arrowsouthwest",
                  8601,
                  "backslashbig",
                  8726,
                  "backslashBig",
                  8726,
                  "backslashBigg",
                  8726,
                  "backslashbigg",
                  8726,
                  "bardbl",
                  8214,
                  "bracehtipdownleft",
                  65079,
                  "bracehtipdownright",
                  65079,
                  "bracehtipupleft",
                  65080,
                  "bracehtipupright",
                  65080,
                  "braceleftBig",
                  123,
                  "braceleftbig",
                  123,
                  "braceleftbigg",
                  123,
                  "braceleftBigg",
                  123,
                  "bracerightBig",
                  125,
                  "bracerightbig",
                  125,
                  "bracerightbigg",
                  125,
                  "bracerightBigg",
                  125,
                  "bracketleftbig",
                  91,
                  "bracketleftBig",
                  91,
                  "bracketleftbigg",
                  91,
                  "bracketleftBigg",
                  91,
                  "bracketrightBig",
                  93,
                  "bracketrightbig",
                  93,
                  "bracketrightbigg",
                  93,
                  "bracketrightBigg",
                  93,
                  "ceilingleftbig",
                  8968,
                  "ceilingleftBig",
                  8968,
                  "ceilingleftBigg",
                  8968,
                  "ceilingleftbigg",
                  8968,
                  "ceilingrightbig",
                  8969,
                  "ceilingrightBig",
                  8969,
                  "ceilingrightbigg",
                  8969,
                  "ceilingrightBigg",
                  8969,
                  "circledotdisplay",
                  8857,
                  "circledottext",
                  8857,
                  "circlemultiplydisplay",
                  8855,
                  "circlemultiplytext",
                  8855,
                  "circleplusdisplay",
                  8853,
                  "circleplustext",
                  8853,
                  "contintegraldisplay",
                  8750,
                  "contintegraltext",
                  8750,
                  "coproductdisplay",
                  8720,
                  "coproducttext",
                  8720,
                  "floorleftBig",
                  8970,
                  "floorleftbig",
                  8970,
                  "floorleftbigg",
                  8970,
                  "floorleftBigg",
                  8970,
                  "floorrightbig",
                  8971,
                  "floorrightBig",
                  8971,
                  "floorrightBigg",
                  8971,
                  "floorrightbigg",
                  8971,
                  "hatwide",
                  770,
                  "hatwider",
                  770,
                  "hatwidest",
                  770,
                  "intercal",
                  7488,
                  "integraldisplay",
                  8747,
                  "integraltext",
                  8747,
                  "intersectiondisplay",
                  8898,
                  "intersectiontext",
                  8898,
                  "logicalanddisplay",
                  8743,
                  "logicalandtext",
                  8743,
                  "logicalordisplay",
                  8744,
                  "logicalortext",
                  8744,
                  "parenleftBig",
                  40,
                  "parenleftbig",
                  40,
                  "parenleftBigg",
                  40,
                  "parenleftbigg",
                  40,
                  "parenrightBig",
                  41,
                  "parenrightbig",
                  41,
                  "parenrightBigg",
                  41,
                  "parenrightbigg",
                  41,
                  "prime",
                  8242,
                  "productdisplay",
                  8719,
                  "producttext",
                  8719,
                  "radicalbig",
                  8730,
                  "radicalBig",
                  8730,
                  "radicalBigg",
                  8730,
                  "radicalbigg",
                  8730,
                  "radicalbt",
                  8730,
                  "radicaltp",
                  8730,
                  "radicalvertex",
                  8730,
                  "slashbig",
                  47,
                  "slashBig",
                  47,
                  "slashBigg",
                  47,
                  "slashbigg",
                  47,
                  "summationdisplay",
                  8721,
                  "summationtext",
                  8721,
                  "tildewide",
                  732,
                  "tildewider",
                  732,
                  "tildewidest",
                  732,
                  "uniondisplay",
                  8899,
                  "unionmultidisplay",
                  8846,
                  "unionmultitext",
                  8846,
                  "unionsqdisplay",
                  8852,
                  "unionsqtext",
                  8852,
                  "uniontext",
                  8899,
                  "vextenddouble",
                  8741,
                  "vextendsingle",
                  8739
                ];
              });
              const getDingbatsGlyphsUnicode = (0, _core_utils_js__WEBPACK_IMPORTED_MODULE_0__.getArrayLookupTableFactory)(function() {
                return [
                  "space",
                  32,
                  "a1",
                  9985,
                  "a2",
                  9986,
                  "a202",
                  9987,
                  "a3",
                  9988,
                  "a4",
                  9742,
                  "a5",
                  9990,
                  "a119",
                  9991,
                  "a118",
                  9992,
                  "a117",
                  9993,
                  "a11",
                  9755,
                  "a12",
                  9758,
                  "a13",
                  9996,
                  "a14",
                  9997,
                  "a15",
                  9998,
                  "a16",
                  9999,
                  "a105",
                  1e4,
                  "a17",
                  10001,
                  "a18",
                  10002,
                  "a19",
                  10003,
                  "a20",
                  10004,
                  "a21",
                  10005,
                  "a22",
                  10006,
                  "a23",
                  10007,
                  "a24",
                  10008,
                  "a25",
                  10009,
                  "a26",
                  10010,
                  "a27",
                  10011,
                  "a28",
                  10012,
                  "a6",
                  10013,
                  "a7",
                  10014,
                  "a8",
                  10015,
                  "a9",
                  10016,
                  "a10",
                  10017,
                  "a29",
                  10018,
                  "a30",
                  10019,
                  "a31",
                  10020,
                  "a32",
                  10021,
                  "a33",
                  10022,
                  "a34",
                  10023,
                  "a35",
                  9733,
                  "a36",
                  10025,
                  "a37",
                  10026,
                  "a38",
                  10027,
                  "a39",
                  10028,
                  "a40",
                  10029,
                  "a41",
                  10030,
                  "a42",
                  10031,
                  "a43",
                  10032,
                  "a44",
                  10033,
                  "a45",
                  10034,
                  "a46",
                  10035,
                  "a47",
                  10036,
                  "a48",
                  10037,
                  "a49",
                  10038,
                  "a50",
                  10039,
                  "a51",
                  10040,
                  "a52",
                  10041,
                  "a53",
                  10042,
                  "a54",
                  10043,
                  "a55",
                  10044,
                  "a56",
                  10045,
                  "a57",
                  10046,
                  "a58",
                  10047,
                  "a59",
                  10048,
                  "a60",
                  10049,
                  "a61",
                  10050,
                  "a62",
                  10051,
                  "a63",
                  10052,
                  "a64",
                  10053,
                  "a65",
                  10054,
                  "a66",
                  10055,
                  "a67",
                  10056,
                  "a68",
                  10057,
                  "a69",
                  10058,
                  "a70",
                  10059,
                  "a71",
                  9679,
                  "a72",
                  10061,
                  "a73",
                  9632,
                  "a74",
                  10063,
                  "a203",
                  10064,
                  "a75",
                  10065,
                  "a204",
                  10066,
                  "a76",
                  9650,
                  "a77",
                  9660,
                  "a78",
                  9670,
                  "a79",
                  10070,
                  "a81",
                  9687,
                  "a82",
                  10072,
                  "a83",
                  10073,
                  "a84",
                  10074,
                  "a97",
                  10075,
                  "a98",
                  10076,
                  "a99",
                  10077,
                  "a100",
                  10078,
                  "a101",
                  10081,
                  "a102",
                  10082,
                  "a103",
                  10083,
                  "a104",
                  10084,
                  "a106",
                  10085,
                  "a107",
                  10086,
                  "a108",
                  10087,
                  "a112",
                  9827,
                  "a111",
                  9830,
                  "a110",
                  9829,
                  "a109",
                  9824,
                  "a120",
                  9312,
                  "a121",
                  9313,
                  "a122",
                  9314,
                  "a123",
                  9315,
                  "a124",
                  9316,
                  "a125",
                  9317,
                  "a126",
                  9318,
                  "a127",
                  9319,
                  "a128",
                  9320,
                  "a129",
                  9321,
                  "a130",
                  10102,
                  "a131",
                  10103,
                  "a132",
                  10104,
                  "a133",
                  10105,
                  "a134",
                  10106,
                  "a135",
                  10107,
                  "a136",
                  10108,
                  "a137",
                  10109,
                  "a138",
                  10110,
                  "a139",
                  10111,
                  "a140",
                  10112,
                  "a141",
                  10113,
                  "a142",
                  10114,
                  "a143",
                  10115,
                  "a144",
                  10116,
                  "a145",
                  10117,
                  "a146",
                  10118,
                  "a147",
                  10119,
                  "a148",
                  10120,
                  "a149",
                  10121,
                  "a150",
                  10122,
                  "a151",
                  10123,
                  "a152",
                  10124,
                  "a153",
                  10125,
                  "a154",
                  10126,
                  "a155",
                  10127,
                  "a156",
                  10128,
                  "a157",
                  10129,
                  "a158",
                  10130,
                  "a159",
                  10131,
                  "a160",
                  10132,
                  "a161",
                  8594,
                  "a163",
                  8596,
                  "a164",
                  8597,
                  "a196",
                  10136,
                  "a165",
                  10137,
                  "a192",
                  10138,
                  "a166",
                  10139,
                  "a167",
                  10140,
                  "a168",
                  10141,
                  "a169",
                  10142,
                  "a170",
                  10143,
                  "a171",
                  10144,
                  "a172",
                  10145,
                  "a173",
                  10146,
                  "a162",
                  10147,
                  "a174",
                  10148,
                  "a175",
                  10149,
                  "a176",
                  10150,
                  "a177",
                  10151,
                  "a178",
                  10152,
                  "a179",
                  10153,
                  "a193",
                  10154,
                  "a180",
                  10155,
                  "a199",
                  10156,
                  "a181",
                  10157,
                  "a200",
                  10158,
                  "a182",
                  10159,
                  "a201",
                  10161,
                  "a183",
                  10162,
                  "a184",
                  10163,
                  "a197",
                  10164,
                  "a185",
                  10165,
                  "a194",
                  10166,
                  "a198",
                  10167,
                  "a186",
                  10168,
                  "a195",
                  10169,
                  "a187",
                  10170,
                  "a188",
                  10171,
                  "a189",
                  10172,
                  "a190",
                  10173,
                  "a191",
                  10174,
                  "a89",
                  10088,
                  "a90",
                  10089,
                  "a93",
                  10090,
                  "a94",
                  10091,
                  "a91",
                  10092,
                  "a92",
                  10093,
                  "a205",
                  10094,
                  "a85",
                  10095,
                  "a206",
                  10096,
                  "a86",
                  10097,
                  "a87",
                  10098,
                  "a88",
                  10099,
                  "a95",
                  10100,
                  "a96",
                  10101,
                  ".notdef",
                  0
                ];
              });
            },
            /* 165 */
            /***/
            (__unused_webpack_module, __webpack_exports__2, __w_pdfjs_require__2) => {
              __w_pdfjs_require__2.r(__webpack_exports__2);
              __w_pdfjs_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "clearUnicodeCaches": () => (
                  /* binding */
                  clearUnicodeCaches
                ),
                /* harmony export */
                "getCharUnicodeCategory": () => (
                  /* binding */
                  getCharUnicodeCategory
                ),
                /* harmony export */
                "getNormalizedUnicodes": () => (
                  /* binding */
                  getNormalizedUnicodes
                ),
                /* harmony export */
                "getUnicodeForGlyph": () => (
                  /* binding */
                  getUnicodeForGlyph
                ),
                /* harmony export */
                "getUnicodeRangeFor": () => (
                  /* binding */
                  getUnicodeRangeFor
                ),
                /* harmony export */
                "mapSpecialUnicodeValues": () => (
                  /* binding */
                  mapSpecialUnicodeValues
                ),
                /* harmony export */
                "reverseIfRtl": () => (
                  /* binding */
                  reverseIfRtl
                )
                /* harmony export */
              });
              var _core_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __w_pdfjs_require__2(131);
              const getSpecialPUASymbols = (0, _core_utils_js__WEBPACK_IMPORTED_MODULE_0__.getLookupTableFactory)(function(t) {
                t[63721] = 169;
                t[63193] = 169;
                t[63720] = 174;
                t[63194] = 174;
                t[63722] = 8482;
                t[63195] = 8482;
                t[63729] = 9127;
                t[63730] = 9128;
                t[63731] = 9129;
                t[63740] = 9131;
                t[63741] = 9132;
                t[63742] = 9133;
                t[63726] = 9121;
                t[63727] = 9122;
                t[63728] = 9123;
                t[63737] = 9124;
                t[63738] = 9125;
                t[63739] = 9126;
                t[63723] = 9115;
                t[63724] = 9116;
                t[63725] = 9117;
                t[63734] = 9118;
                t[63735] = 9119;
                t[63736] = 9120;
              });
              function mapSpecialUnicodeValues(code) {
                if (code >= 65520 && code <= 65535) {
                  return 0;
                } else if (code >= 62976 && code <= 63743) {
                  return getSpecialPUASymbols()[code] || code;
                } else if (code === 173) {
                  return 45;
                }
                return code;
              }
              __name(mapSpecialUnicodeValues, "mapSpecialUnicodeValues");
              function getUnicodeForGlyph(name, glyphsUnicodeMap) {
                let unicode = glyphsUnicodeMap[name];
                if (unicode !== void 0) {
                  return unicode;
                }
                if (!name) {
                  return -1;
                }
                if (name[0] === "u") {
                  const nameLen = name.length;
                  let hexStr;
                  if (nameLen === 7 && name[1] === "n" && name[2] === "i") {
                    hexStr = name.substring(3);
                  } else if (nameLen >= 5 && nameLen <= 7) {
                    hexStr = name.substring(1);
                  } else {
                    return -1;
                  }
                  if (hexStr === hexStr.toUpperCase()) {
                    unicode = parseInt(hexStr, 16);
                    if (unicode >= 0) {
                      return unicode;
                    }
                  }
                }
                return -1;
              }
              __name(getUnicodeForGlyph, "getUnicodeForGlyph");
              const UnicodeRanges = [
                {
                  begin: 0,
                  end: 127
                },
                {
                  begin: 128,
                  end: 255
                },
                {
                  begin: 256,
                  end: 383
                },
                {
                  begin: 384,
                  end: 591
                },
                {
                  begin: 592,
                  end: 687
                },
                {
                  begin: 688,
                  end: 767
                },
                {
                  begin: 768,
                  end: 879
                },
                {
                  begin: 880,
                  end: 1023
                },
                {
                  begin: 11392,
                  end: 11519
                },
                {
                  begin: 1024,
                  end: 1279
                },
                {
                  begin: 1328,
                  end: 1423
                },
                {
                  begin: 1424,
                  end: 1535
                },
                {
                  begin: 42240,
                  end: 42559
                },
                {
                  begin: 1536,
                  end: 1791
                },
                {
                  begin: 1984,
                  end: 2047
                },
                {
                  begin: 2304,
                  end: 2431
                },
                {
                  begin: 2432,
                  end: 2559
                },
                {
                  begin: 2560,
                  end: 2687
                },
                {
                  begin: 2688,
                  end: 2815
                },
                {
                  begin: 2816,
                  end: 2943
                },
                {
                  begin: 2944,
                  end: 3071
                },
                {
                  begin: 3072,
                  end: 3199
                },
                {
                  begin: 3200,
                  end: 3327
                },
                {
                  begin: 3328,
                  end: 3455
                },
                {
                  begin: 3584,
                  end: 3711
                },
                {
                  begin: 3712,
                  end: 3839
                },
                {
                  begin: 4256,
                  end: 4351
                },
                {
                  begin: 6912,
                  end: 7039
                },
                {
                  begin: 4352,
                  end: 4607
                },
                {
                  begin: 7680,
                  end: 7935
                },
                {
                  begin: 7936,
                  end: 8191
                },
                {
                  begin: 8192,
                  end: 8303
                },
                {
                  begin: 8304,
                  end: 8351
                },
                {
                  begin: 8352,
                  end: 8399
                },
                {
                  begin: 8400,
                  end: 8447
                },
                {
                  begin: 8448,
                  end: 8527
                },
                {
                  begin: 8528,
                  end: 8591
                },
                {
                  begin: 8592,
                  end: 8703
                },
                {
                  begin: 8704,
                  end: 8959
                },
                {
                  begin: 8960,
                  end: 9215
                },
                {
                  begin: 9216,
                  end: 9279
                },
                {
                  begin: 9280,
                  end: 9311
                },
                {
                  begin: 9312,
                  end: 9471
                },
                {
                  begin: 9472,
                  end: 9599
                },
                {
                  begin: 9600,
                  end: 9631
                },
                {
                  begin: 9632,
                  end: 9727
                },
                {
                  begin: 9728,
                  end: 9983
                },
                {
                  begin: 9984,
                  end: 10175
                },
                {
                  begin: 12288,
                  end: 12351
                },
                {
                  begin: 12352,
                  end: 12447
                },
                {
                  begin: 12448,
                  end: 12543
                },
                {
                  begin: 12544,
                  end: 12591
                },
                {
                  begin: 12592,
                  end: 12687
                },
                {
                  begin: 43072,
                  end: 43135
                },
                {
                  begin: 12800,
                  end: 13055
                },
                {
                  begin: 13056,
                  end: 13311
                },
                {
                  begin: 44032,
                  end: 55215
                },
                {
                  begin: 55296,
                  end: 57343
                },
                {
                  begin: 67840,
                  end: 67871
                },
                {
                  begin: 19968,
                  end: 40959
                },
                {
                  begin: 57344,
                  end: 63743
                },
                {
                  begin: 12736,
                  end: 12783
                },
                {
                  begin: 64256,
                  end: 64335
                },
                {
                  begin: 64336,
                  end: 65023
                },
                {
                  begin: 65056,
                  end: 65071
                },
                {
                  begin: 65040,
                  end: 65055
                },
                {
                  begin: 65104,
                  end: 65135
                },
                {
                  begin: 65136,
                  end: 65279
                },
                {
                  begin: 65280,
                  end: 65519
                },
                {
                  begin: 65520,
                  end: 65535
                },
                {
                  begin: 3840,
                  end: 4095
                },
                {
                  begin: 1792,
                  end: 1871
                },
                {
                  begin: 1920,
                  end: 1983
                },
                {
                  begin: 3456,
                  end: 3583
                },
                {
                  begin: 4096,
                  end: 4255
                },
                {
                  begin: 4608,
                  end: 4991
                },
                {
                  begin: 5024,
                  end: 5119
                },
                {
                  begin: 5120,
                  end: 5759
                },
                {
                  begin: 5760,
                  end: 5791
                },
                {
                  begin: 5792,
                  end: 5887
                },
                {
                  begin: 6016,
                  end: 6143
                },
                {
                  begin: 6144,
                  end: 6319
                },
                {
                  begin: 10240,
                  end: 10495
                },
                {
                  begin: 40960,
                  end: 42127
                },
                {
                  begin: 5888,
                  end: 5919
                },
                {
                  begin: 66304,
                  end: 66351
                },
                {
                  begin: 66352,
                  end: 66383
                },
                {
                  begin: 66560,
                  end: 66639
                },
                {
                  begin: 118784,
                  end: 119039
                },
                {
                  begin: 119808,
                  end: 120831
                },
                {
                  begin: 1044480,
                  end: 1048573
                },
                {
                  begin: 65024,
                  end: 65039
                },
                {
                  begin: 917504,
                  end: 917631
                },
                {
                  begin: 6400,
                  end: 6479
                },
                {
                  begin: 6480,
                  end: 6527
                },
                {
                  begin: 6528,
                  end: 6623
                },
                {
                  begin: 6656,
                  end: 6687
                },
                {
                  begin: 11264,
                  end: 11359
                },
                {
                  begin: 11568,
                  end: 11647
                },
                {
                  begin: 19904,
                  end: 19967
                },
                {
                  begin: 43008,
                  end: 43055
                },
                {
                  begin: 65536,
                  end: 65663
                },
                {
                  begin: 65856,
                  end: 65935
                },
                {
                  begin: 66432,
                  end: 66463
                },
                {
                  begin: 66464,
                  end: 66527
                },
                {
                  begin: 66640,
                  end: 66687
                },
                {
                  begin: 66688,
                  end: 66735
                },
                {
                  begin: 67584,
                  end: 67647
                },
                {
                  begin: 68096,
                  end: 68191
                },
                {
                  begin: 119552,
                  end: 119647
                },
                {
                  begin: 73728,
                  end: 74751
                },
                {
                  begin: 119648,
                  end: 119679
                },
                {
                  begin: 7040,
                  end: 7103
                },
                {
                  begin: 7168,
                  end: 7247
                },
                {
                  begin: 7248,
                  end: 7295
                },
                {
                  begin: 43136,
                  end: 43231
                },
                {
                  begin: 43264,
                  end: 43311
                },
                {
                  begin: 43312,
                  end: 43359
                },
                {
                  begin: 43520,
                  end: 43615
                },
                {
                  begin: 65936,
                  end: 65999
                },
                {
                  begin: 66e3,
                  end: 66047
                },
                {
                  begin: 66208,
                  end: 66271
                },
                {
                  begin: 127024,
                  end: 127135
                }
              ];
              function getUnicodeRangeFor(value) {
                for (let i = 0, ii = UnicodeRanges.length; i < ii; i++) {
                  const range = UnicodeRanges[i];
                  if (value >= range.begin && value < range.end) {
                    return i;
                  }
                }
                return -1;
              }
              __name(getUnicodeRangeFor, "getUnicodeRangeFor");
              function isRTLRangeFor(value) {
                let range = UnicodeRanges[13];
                if (value >= range.begin && value < range.end) {
                  return true;
                }
                range = UnicodeRanges[11];
                if (value >= range.begin && value < range.end) {
                  return true;
                }
                return false;
              }
              __name(isRTLRangeFor, "isRTLRangeFor");
              const getNormalizedUnicodes = (0, _core_utils_js__WEBPACK_IMPORTED_MODULE_0__.getArrayLookupTableFactory)(function() {
                return [
                  "Â¨",
                  " Ì",
                  "Â¯",
                  " Ì",
                  "Â´",
                  " Ì",
                  "Âµ",
                  "Î¼",
                  "Â¸",
                  " Ì§",
                  "Ä²",
                  "IJ",
                  "Ä³",
                  "ij",
                  "Ä¿",
                  "LÂ·",
                  "Å",
                  "lÂ·",
                  "Å",
                  "Ê¼n",
                  "Å¿",
                  "s",
                  "Ç",
                  "DÅ½",
                  "Ç",
                  "DÅ¾",
                  "Ç",
                  "dÅ¾",
                  "Ç",
                  "LJ",
                  "Ç",
                  "Lj",
                  "Ç",
                  "lj",
                  "Ç",
                  "NJ",
                  "Ç",
                  "Nj",
                  "Ç",
                  "nj",
                  "Ç±",
                  "DZ",
                  "Ç²",
                  "Dz",
                  "Ç³",
                  "dz",
                  "Ë",
                  " Ì",
                  "Ë",
                  " Ì",
                  "Ë",
                  " Ì",
                  "Ë",
                  " Ì¨",
                  "Ë",
                  " Ì",
                  "Ë",
                  " Ì",
                  "Íº",
                  " Í",
                  "Î",
                  " Ì",
                  "Ï",
                  "Î²",
                  "Ï",
                  "Î¸",
                  "Ï",
                  "Î¥",
                  "Ï",
                  "Ï",
                  "Ï",
                  "Ï",
                  "Ï°",
                  "Îº",
                  "Ï±",
                  "Ï",
                  "Ï²",
                  "Ï",
                  "Ï´",
                  "Î",
                  "Ïµ",
                  "Îµ",
                  "Ï¹",
                  "Î£",
                  "Ö",
                  "Õ¥Ö",
                  "Ùµ",
                  "Ø§Ù´",
                  "Ù¶",
                  "ÙÙ´",
                  "Ù·",
                  "ÛÙ´",
                  "Ù¸",
                  "ÙÙ´",
                  "à¸³",
                  "à¹à¸²",
                  "àº³",
                  "à»àº²",
                  "à»",
                  "àº«àº",
                  "à»",
                  "àº«àº¡",
                  "à½·",
                  "à¾²à¾",
                  "à½¹",
                  "à¾³à¾",
                  "áº",
                  "aÊ¾",
                  "á¾½",
                  " Ì",
                  "á¾¿",
                  " Ì",
                  "á¿",
                  " Í",
                  "á¿¾",
                  " Ì",
                  "â",
                  " ",
                  "â",
                  " ",
                  "â",
                  " ",
                  "â",
                  " ",
                  "â",
                  " ",
                  "â",
                  " ",
                  "â",
                  " ",
                  "â",
                  " ",
                  "â",
                  " Ì³",
                  "â¤",
                  ".",
                  "â¥",
                  "..",
                  "â¦",
                  "...",
                  "â³",
                  "â²â²",
                  "â´",
                  "â²â²â²",
                  "â¶",
                  "âµâµ",
                  "â·",
                  "âµâµâµ",
                  "â¼",
                  "!!",
                  "â¾",
                  " Ì",
                  "â",
                  "??",
                  "â",
                  "?!",
                  "â",
                  "!?",
                  "â",
                  "â²â²â²â²",
                  "â",
                  " ",
                  "â¨",
                  "Rs",
                  "â",
                  "a/c",
                  "â",
                  "a/s",
                  "â",
                  "Â°C",
                  "â",
                  "c/o",
                  "â",
                  "c/u",
                  "â",
                  "Æ",
                  "â",
                  "Â°F",
                  "â",
                  "No",
                  "â¡",
                  "TEL",
                  "âµ",
                  "×",
                  "â¶",
                  "×",
                  "â·",
                  "×",
                  "â¸",
                  "×",
                  "â»",
                  "FAX",
                  "â ",
                  "I",
                  "â¡",
                  "II",
                  "â¢",
                  "III",
                  "â£",
                  "IV",
                  "â¤",
                  "V",
                  "â¥",
                  "VI",
                  "â¦",
                  "VII",
                  "â§",
                  "VIII",
                  "â¨",
                  "IX",
                  "â©",
                  "X",
                  "âª",
                  "XI",
                  "â«",
                  "XII",
                  "â¬",
                  "L",
                  "â­",
                  "C",
                  "â®",
                  "D",
                  "â¯",
                  "M",
                  "â°",
                  "i",
                  "â±",
                  "ii",
                  "â²",
                  "iii",
                  "â³",
                  "iv",
                  "â´",
                  "v",
                  "âµ",
                  "vi",
                  "â¶",
                  "vii",
                  "â·",
                  "viii",
                  "â¸",
                  "ix",
                  "â¹",
                  "x",
                  "âº",
                  "xi",
                  "â»",
                  "xii",
                  "â¼",
                  "l",
                  "â½",
                  "c",
                  "â¾",
                  "d",
                  "â¿",
                  "m",
                  "â¬",
                  "â«â«",
                  "â­",
                  "â«â«â«",
                  "â¯",
                  "â®â®",
                  "â°",
                  "â®â®â®",
                  "â´",
                  "(1)",
                  "âµ",
                  "(2)",
                  "â¶",
                  "(3)",
                  "â·",
                  "(4)",
                  "â¸",
                  "(5)",
                  "â¹",
                  "(6)",
                  "âº",
                  "(7)",
                  "â»",
                  "(8)",
                  "â¼",
                  "(9)",
                  "â½",
                  "(10)",
                  "â¾",
                  "(11)",
                  "â¿",
                  "(12)",
                  "â",
                  "(13)",
                  "â",
                  "(14)",
                  "â",
                  "(15)",
                  "â",
                  "(16)",
                  "â",
                  "(17)",
                  "â",
                  "(18)",
                  "â",
                  "(19)",
                  "â",
                  "(20)",
                  "â",
                  "1.",
                  "â",
                  "2.",
                  "â",
                  "3.",
                  "â",
                  "4.",
                  "â",
                  "5.",
                  "â",
                  "6.",
                  "â",
                  "7.",
                  "â",
                  "8.",
                  "â",
                  "9.",
                  "â",
                  "10.",
                  "â",
                  "11.",
                  "â",
                  "12.",
                  "â",
                  "13.",
                  "â",
                  "14.",
                  "â",
                  "15.",
                  "â",
                  "16.",
                  "â",
                  "17.",
                  "â",
                  "18.",
                  "â",
                  "19.",
                  "â",
                  "20.",
                  "â",
                  "(a)",
                  "â",
                  "(b)",
                  "â",
                  "(c)",
                  "â",
                  "(d)",
                  "â ",
                  "(e)",
                  "â¡",
                  "(f)",
                  "â¢",
                  "(g)",
                  "â£",
                  "(h)",
                  "â¤",
                  "(i)",
                  "â¥",
                  "(j)",
                  "â¦",
                  "(k)",
                  "â§",
                  "(l)",
                  "â¨",
                  "(m)",
                  "â©",
                  "(n)",
                  "âª",
                  "(o)",
                  "â«",
                  "(p)",
                  "â¬",
                  "(q)",
                  "â­",
                  "(r)",
                  "â®",
                  "(s)",
                  "â¯",
                  "(t)",
                  "â°",
                  "(u)",
                  "â±",
                  "(v)",
                  "â²",
                  "(w)",
                  "â³",
                  "(x)",
                  "â´",
                  "(y)",
                  "âµ",
                  "(z)",
                  "â¨",
                  "â«â«â«â«",
                  "â©´",
                  "::=",
                  "â©µ",
                  "==",
                  "â©¶",
                  "===",
                  "âº",
                  "æ¯",
                  "â»³",
                  "é¾",
                  "â¼",
                  "ä¸",
                  "â¼",
                  "ä¸¨",
                  "â¼",
                  "ä¸¶",
                  "â¼",
                  "ä¸¿",
                  "â¼",
                  "ä¹",
                  "â¼",
                  "äº",
                  "â¼",
                  "äº",
                  "â¼",
                  "äº ",
                  "â¼",
                  "äºº",
                  "â¼",
                  "å¿",
                  "â¼",
                  "å¥",
                  "â¼",
                  "å«",
                  "â¼",
                  "å",
                  "â¼",
                  "å",
                  "â¼",
                  "å«",
                  "â¼",
                  "å ",
                  "â¼",
                  "åµ",
                  "â¼",
                  "å",
                  "â¼",
                  "å",
                  "â¼",
                  "å¹",
                  "â¼",
                  "å",
                  "â¼",
                  "å",
                  "â¼",
                  "å¸",
                  "â¼",
                  "å",
                  "â¼",
                  "å",
                  "â¼",
                  "å©",
                  "â¼",
                  "å",
                  "â¼",
                  "å¶",
                  "â¼",
                  "å",
                  "â¼",
                  "å£",
                  "â¼",
                  "å",
                  "â¼",
                  "å",
                  "â¼ ",
                  "å£«",
                  "â¼¡",
                  "å¤",
                  "â¼¢",
                  "å¤",
                  "â¼£",
                  "å¤",
                  "â¼¤",
                  "å¤§",
                  "â¼¥",
                  "å¥³",
                  "â¼¦",
                  "å­",
                  "â¼§",
                  "å®",
                  "â¼¨",
                  "å¯¸",
                  "â¼©",
                  "å°",
                  "â¼ª",
                  "å°¢",
                  "â¼«",
                  "å°¸",
                  "â¼¬",
                  "å±®",
                  "â¼­",
                  "å±±",
                  "â¼®",
                  "å·",
                  "â¼¯",
                  "å·¥",
                  "â¼°",
                  "å·±",
                  "â¼±",
                  "å·¾",
                  "â¼²",
                  "å¹²",
                  "â¼³",
                  "å¹º",
                  "â¼´",
                  "å¹¿",
                  "â¼µ",
                  "å»´",
                  "â¼¶",
                  "å»¾",
                  "â¼·",
                  "å¼",
                  "â¼¸",
                  "å¼",
                  "â¼¹",
                  "å½",
                  "â¼º",
                  "å½¡",
                  "â¼»",
                  "å½³",
                  "â¼¼",
                  "å¿",
                  "â¼½",
                  "æ",
                  "â¼¾",
                  "æ¶",
                  "â¼¿",
                  "æ",
                  "â½",
                  "æ¯",
                  "â½",
                  "æ´",
                  "â½",
                  "æ",
                  "â½",
                  "æ",
                  "â½",
                  "æ¤",
                  "â½",
                  "æ¹",
                  "â½",
                  "æ ",
                  "â½",
                  "æ¥",
                  "â½",
                  "æ°",
                  "â½",
                  "æ",
                  "â½",
                  "æ¨",
                  "â½",
                  "æ¬ ",
                  "â½",
                  "æ­¢",
                  "â½",
                  "æ­¹",
                  "â½",
                  "æ®³",
                  "â½",
                  "æ¯",
                  "â½",
                  "æ¯",
                  "â½",
                  "æ¯",
                  "â½",
                  "æ°",
                  "â½",
                  "æ°",
                  "â½",
                  "æ°´",
                  "â½",
                  "ç«",
                  "â½",
                  "çª",
                  "â½",
                  "ç¶",
                  "â½",
                  "ç»",
                  "â½",
                  "ç¿",
                  "â½",
                  "ç",
                  "â½",
                  "ç",
                  "â½",
                  "ç",
                  "â½",
                  "ç¬",
                  "â½",
                  "ç",
                  "â½",
                  "ç",
                  "â½ ",
                  "ç",
                  "â½¡",
                  "ç¦",
                  "â½¢",
                  "ç",
                  "â½£",
                  "ç",
                  "â½¤",
                  "ç¨",
                  "â½¥",
                  "ç°",
                  "â½¦",
                  "ç",
                  "â½§",
                  "ç",
                  "â½¨",
                  "ç¶",
                  "â½©",
                  "ç½",
                  "â½ª",
                  "ç®",
                  "â½«",
                  "ç¿",
                  "â½¬",
                  "ç®",
                  "â½­",
                  "ç",
                  "â½®",
                  "ç¢",
                  "â½¯",
                  "ç³",
                  "â½°",
                  "ç¤º",
                  "â½±",
                  "ç¦¸",
                  "â½²",
                  "ç¦¾",
                  "â½³",
                  "ç©´",
                  "â½´",
                  "ç«",
                  "â½µ",
                  "ç«¹",
                  "â½¶",
                  "ç±³",
                  "â½·",
                  "ç³¸",
                  "â½¸",
                  "ç¼¶",
                  "â½¹",
                  "ç½",
                  "â½º",
                  "ç¾",
                  "â½»",
                  "ç¾½",
                  "â½¼",
                  "è",
                  "â½½",
                  "è",
                  "â½¾",
                  "è",
                  "â½¿",
                  "è³",
                  "â¾",
                  "è¿",
                  "â¾",
                  "è",
                  "â¾",
                  "è£",
                  "â¾",
                  "èª",
                  "â¾",
                  "è³",
                  "â¾",
                  "è¼",
                  "â¾",
                  "è",
                  "â¾",
                  "è",
                  "â¾",
                  "è",
                  "â¾",
                  "è®",
                  "â¾",
                  "è²",
                  "â¾",
                  "è¸",
                  "â¾",
                  "è",
                  "â¾",
                  "è«",
                  "â¾",
                  "è¡",
                  "â¾",
                  "è¡",
                  "â¾",
                  "è¡£",
                  "â¾",
                  "è¥¾",
                  "â¾",
                  "è¦",
                  "â¾",
                  "è§",
                  "â¾",
                  "è¨",
                  "â¾",
                  "è°·",
                  "â¾",
                  "è±",
                  "â¾",
                  "è±",
                  "â¾",
                  "è±¸",
                  "â¾",
                  "è²",
                  "â¾",
                  "èµ¤",
                  "â¾",
                  "èµ°",
                  "â¾",
                  "è¶³",
                  "â¾",
                  "èº«",
                  "â¾",
                  "è»",
                  "â¾",
                  "è¾",
                  "â¾ ",
                  "è¾°",
                  "â¾¡",
                  "è¾µ",
                  "â¾¢",
                  "é",
                  "â¾£",
                  "é",
                  "â¾¤",
                  "é",
                  "â¾¥",
                  "é",
                  "â¾¦",
                  "é",
                  "â¾§",
                  "é·",
                  "â¾¨",
                  "é",
                  "â¾©",
                  "é",
                  "â¾ª",
                  "é¶",
                  "â¾«",
                  "é¹",
                  "â¾¬",
                  "é¨",
                  "â¾­",
                  "é",
                  "â¾®",
                  "é",
                  "â¾¯",
                  "é¢",
                  "â¾°",
                  "é©",
                  "â¾±",
                  "é",
                  "â¾²",
                  "é­",
                  "â¾³",
                  "é³",
                  "â¾´",
                  "é ",
                  "â¾µ",
                  "é¢¨",
                  "â¾¶",
                  "é£",
                  "â¾·",
                  "é£",
                  "â¾¸",
                  "é¦",
                  "â¾¹",
                  "é¦",
                  "â¾º",
                  "é¦¬",
                  "â¾»",
                  "éª¨",
                  "â¾¼",
                  "é«",
                  "â¾½",
                  "é«",
                  "â¾¾",
                  "é¬¥",
                  "â¾¿",
                  "é¬¯",
                  "â¿",
                  "é¬²",
                  "â¿",
                  "é¬¼",
                  "â¿",
                  "é­",
                  "â¿",
                  "é³¥",
                  "â¿",
                  "é¹µ",
                  "â¿",
                  "é¹¿",
                  "â¿",
                  "éº¥",
                  "â¿",
                  "éº»",
                  "â¿",
                  "é»",
                  "â¿",
                  "é»",
                  "â¿",
                  "é»",
                  "â¿",
                  "é»¹",
                  "â¿",
                  "é»½",
                  "â¿",
                  "é¼",
                  "â¿",
                  "é¼",
                  "â¿",
                  "é¼ ",
                  "â¿",
                  "é¼»",
                  "â¿",
                  "é½",
                  "â¿",
                  "é½",
                  "â¿",
                  "é¾",
                  "â¿",
                  "é¾",
                  "â¿",
                  "é¾ ",
                  "ã¶",
                  "ã",
                  "ã¸",
                  "å",
                  "ã¹",
                  "å",
                  "ãº",
                  "å",
                  "ã",
                  " ã",
                  "ã",
                  " ã",
                  "ã±",
                  "á",
                  "ã²",
                  "á",
                  "ã³",
                  "áª",
                  "ã´",
                  "á",
                  "ãµ",
                  "á¬",
                  "ã¶",
                  "á­",
                  "ã·",
                  "á",
                  "ã¸",
                  "á",
                  "ã¹",
                  "á",
                  "ãº",
                  "á°",
                  "ã»",
                  "á±",
                  "ã¼",
                  "á²",
                  "ã½",
                  "á³",
                  "ã¾",
                  "á´",
                  "ã¿",
                  "áµ",
                  "ã",
                  "á",
                  "ã",
                  "á",
                  "ã",
                  "á",
                  "ã",
                  "á",
                  "ã",
                  "á¡",
                  "ã",
                  "á",
                  "ã",
                  "á",
                  "ã",
                  "á",
                  "ã",
                  "á",
                  "ã",
                  "á",
                  "ã",
                  "á",
                  "ã",
                  "á",
                  "ã",
                  "á",
                  "ã",
                  "á",
                  "ã",
                  "á",
                  "ã",
                  "á¡",
                  "ã",
                  "á¢",
                  "ã",
                  "á£",
                  "ã",
                  "á¤",
                  "ã",
                  "á¥",
                  "ã",
                  "á¦",
                  "ã",
                  "á§",
                  "ã",
                  "á¨",
                  "ã",
                  "á©",
                  "ã",
                  "áª",
                  "ã",
                  "á«",
                  "ã",
                  "á¬",
                  "ã",
                  "á­",
                  "ã",
                  "á®",
                  "ã",
                  "á¯",
                  "ã",
                  "á°",
                  "ã",
                  "á±",
                  "ã ",
                  "á²",
                  "ã¡",
                  "á³",
                  "ã¢",
                  "á´",
                  "ã£",
                  "áµ",
                  "ã¤",
                  "á ",
                  "ã¥",
                  "á",
                  "ã¦",
                  "á",
                  "ã§",
                  "á",
                  "ã¨",
                  "á",
                  "ã©",
                  "á",
                  "ãª",
                  "á",
                  "ã«",
                  "á",
                  "ã¬",
                  "á",
                  "ã­",
                  "á",
                  "ã®",
                  "á",
                  "ã¯",
                  "á",
                  "ã°",
                  "á",
                  "ã±",
                  "á",
                  "ã²",
                  "á",
                  "ã³",
                  "á ",
                  "ã´",
                  "á¢",
                  "ãµ",
                  "á£",
                  "ã¶",
                  "á§",
                  "ã·",
                  "á©",
                  "ã¸",
                  "á«",
                  "ã¹",
                  "á¬",
                  "ãº",
                  "á­",
                  "ã»",
                  "á®",
                  "ã¼",
                  "á¯",
                  "ã½",
                  "á²",
                  "ã¾",
                  "á¶",
                  "ã¿",
                  "á",
                  "ã",
                  "á",
                  "ã",
                  "á",
                  "ã",
                  "á±",
                  "ã",
                  "á²",
                  "ã",
                  "á",
                  "ã",
                  "á",
                  "ã",
                  "á",
                  "ã",
                  "á",
                  "ã",
                  "á",
                  "ã",
                  "á",
                  "ã",
                  "á",
                  "ã",
                  "á",
                  "ã",
                  "á",
                  "ã",
                  "á",
                  "ã",
                  "á¡",
                  "ã",
                  "(á)",
                  "ã",
                  "(á)",
                  "ã",
                  "(á)",
                  "ã",
                  "(á)",
                  "ã",
                  "(á)",
                  "ã",
                  "(á)",
                  "ã",
                  "(á)",
                  "ã",
                  "(á)",
                  "ã",
                  "(á)",
                  "ã",
                  "(á)",
                  "ã",
                  "(á)",
                  "ã",
                  "(á)",
                  "ã",
                  "(á)",
                  "ã",
                  "(á)",
                  "ã",
                  "(áá¡)",
                  "ã",
                  "(áá¡)",
                  "ã",
                  "(áá¡)",
                  "ã",
                  "(áá¡)",
                  "ã",
                  "(áá¡)",
                  "ã",
                  "(áá¡)",
                  "ã",
                  "(áá¡)",
                  "ã",
                  "(áá¡)",
                  "ã",
                  "(áá¡)",
                  "ã",
                  "(áá¡)",
                  "ã",
                  "(áá¡)",
                  "ã",
                  "(áá¡)",
                  "ã",
                  "(áá¡)",
                  "ã",
                  "(áá¡)",
                  "ã",
                  "(áá®)",
                  "ã",
                  "(áá©áá¥á«)",
                  "ã",
                  "(áá©áá®)",
                  "ã ",
                  "(ä¸)",
                  "ã¡",
                  "(äº)",
                  "ã¢",
                  "(ä¸)",
                  "ã£",
                  "(å)",
                  "ã¤",
                  "(äº)",
                  "ã¥",
                  "(å­)",
                  "ã¦",
                  "(ä¸)",
                  "ã§",
                  "(å«)",
                  "ã¨",
                  "(ä¹)",
                  "ã©",
                  "(å)",
                  "ãª",
                  "(æ)",
                  "ã«",
                  "(ç«)",
                  "ã¬",
                  "(æ°´)",
                  "ã­",
                  "(æ¨)",
                  "ã®",
                  "(é)",
                  "ã¯",
                  "(å)",
                  "ã°",
                  "(æ¥)",
                  "ã±",
                  "(æ ª)",
                  "ã²",
                  "(æ)",
                  "ã³",
                  "(ç¤¾)",
                  "ã´",
                  "(å)",
                  "ãµ",
                  "(ç¹)",
                  "ã¶",
                  "(è²¡)",
                  "ã·",
                  "(ç¥)",
                  "ã¸",
                  "(å´)",
                  "ã¹",
                  "(ä»£)",
                  "ãº",
                  "(å¼)",
                  "ã»",
                  "(å­¦)",
                  "ã¼",
                  "(ç£)",
                  "ã½",
                  "(ä¼)",
                  "ã¾",
                  "(è³)",
                  "ã¿",
                  "(å)",
                  "ã",
                  "(ç¥­)",
                  "ã",
                  "(ä¼)",
                  "ã",
                  "(èª)",
                  "ã",
                  "(è³)",
                  "ã",
                  "1æ",
                  "ã",
                  "2æ",
                  "ã",
                  "3æ",
                  "ã",
                  "4æ",
                  "ã",
                  "5æ",
                  "ã",
                  "6æ",
                  "ã",
                  "7æ",
                  "ã",
                  "8æ",
                  "ã",
                  "9æ",
                  "ã",
                  "10æ",
                  "ã",
                  "11æ",
                  "ã",
                  "12æ",
                  "ã",
                  "0ç¹",
                  "ã",
                  "1ç¹",
                  "ã",
                  "2ç¹",
                  "ã",
                  "3ç¹",
                  "ã",
                  "4ç¹",
                  "ã",
                  "5ç¹",
                  "ã",
                  "6ç¹",
                  "ã",
                  "7ç¹",
                  "ã ",
                  "8ç¹",
                  "ã¡",
                  "9ç¹",
                  "ã¢",
                  "10ç¹",
                  "ã£",
                  "11ç¹",
                  "ã¤",
                  "12ç¹",
                  "ã¥",
                  "13ç¹",
                  "ã¦",
                  "14ç¹",
                  "ã§",
                  "15ç¹",
                  "ã¨",
                  "16ç¹",
                  "ã©",
                  "17ç¹",
                  "ãª",
                  "18ç¹",
                  "ã«",
                  "19ç¹",
                  "ã¬",
                  "20ç¹",
                  "ã­",
                  "21ç¹",
                  "ã®",
                  "22ç¹",
                  "ã¯",
                  "23ç¹",
                  "ã°",
                  "24ç¹",
                  "ã ",
                  "1æ¥",
                  "ã¡",
                  "2æ¥",
                  "ã¢",
                  "3æ¥",
                  "ã£",
                  "4æ¥",
                  "ã¤",
                  "5æ¥",
                  "ã¥",
                  "6æ¥",
                  "ã¦",
                  "7æ¥",
                  "ã§",
                  "8æ¥",
                  "ã¨",
                  "9æ¥",
                  "ã©",
                  "10æ¥",
                  "ãª",
                  "11æ¥",
                  "ã«",
                  "12æ¥",
                  "ã¬",
                  "13æ¥",
                  "ã­",
                  "14æ¥",
                  "ã®",
                  "15æ¥",
                  "ã¯",
                  "16æ¥",
                  "ã°",
                  "17æ¥",
                  "ã±",
                  "18æ¥",
                  "ã²",
                  "19æ¥",
                  "ã³",
                  "20æ¥",
                  "ã´",
                  "21æ¥",
                  "ãµ",
                  "22æ¥",
                  "ã¶",
                  "23æ¥",
                  "ã·",
                  "24æ¥",
                  "ã¸",
                  "25æ¥",
                  "ã¹",
                  "26æ¥",
                  "ãº",
                  "27æ¥",
                  "ã»",
                  "28æ¥",
                  "ã¼",
                  "29æ¥",
                  "ã½",
                  "30æ¥",
                  "ã¾",
                  "31æ¥",
                  "ï¬",
                  "ff",
                  "ï¬",
                  "fi",
                  "ï¬",
                  "fl",
                  "ï¬",
                  "ffi",
                  "ï¬",
                  "ffl",
                  "ï¬",
                  "Å¿t",
                  "ï¬",
                  "st",
                  "ï¬",
                  "Õ´Õ¶",
                  "ï¬",
                  "Õ´Õ¥",
                  "ï¬",
                  "Õ´Õ«",
                  "ï¬",
                  "Õ¾Õ¶",
                  "ï¬",
                  "Õ´Õ­",
                  "ï­",
                  "××",
                  "ï­",
                  "Ù±",
                  "ï­",
                  "Ù±",
                  "ï­",
                  "Ù»",
                  "ï­",
                  "Ù»",
                  "ï­",
                  "Ù»",
                  "ï­",
                  "Ù»",
                  "ï­",
                  "Ù¾",
                  "ï­",
                  "Ù¾",
                  "ï­",
                  "Ù¾",
                  "ï­",
                  "Ù¾",
                  "ï­",
                  "Ú",
                  "ï­",
                  "Ú",
                  "ï­",
                  "Ú",
                  "ï­",
                  "Ú",
                  "ï­",
                  "Ùº",
                  "ï­",
                  "Ùº",
                  "ï­ ",
                  "Ùº",
                  "ï­¡",
                  "Ùº",
                  "ï­¢",
                  "Ù¿",
                  "ï­£",
                  "Ù¿",
                  "ï­¤",
                  "Ù¿",
                  "ï­¥",
                  "Ù¿",
                  "ï­¦",
                  "Ù¹",
                  "ï­§",
                  "Ù¹",
                  "ï­¨",
                  "Ù¹",
                  "ï­©",
                  "Ù¹",
                  "ï­ª",
                  "Ú¤",
                  "ï­«",
                  "Ú¤",
                  "ï­¬",
                  "Ú¤",
                  "ï­­",
                  "Ú¤",
                  "ï­®",
                  "Ú¦",
                  "ï­¯",
                  "Ú¦",
                  "ï­°",
                  "Ú¦",
                  "ï­±",
                  "Ú¦",
                  "ï­²",
                  "Ú",
                  "ï­³",
                  "Ú",
                  "ï­´",
                  "Ú",
                  "ï­µ",
                  "Ú",
                  "ï­¶",
                  "Ú",
                  "ï­·",
                  "Ú",
                  "ï­¸",
                  "Ú",
                  "ï­¹",
                  "Ú",
                  "ï­º",
                  "Ú",
                  "ï­»",
                  "Ú",
                  "ï­¼",
                  "Ú",
                  "ï­½",
                  "Ú",
                  "ï­¾",
                  "Ú",
                  "ï­¿",
                  "Ú",
                  "ï®",
                  "Ú",
                  "ï®",
                  "Ú",
                  "ï®",
                  "Ú",
                  "ï®",
                  "Ú",
                  "ï®",
                  "Ú",
                  "ï®",
                  "Ú",
                  "ï®",
                  "Ú",
                  "ï®",
                  "Ú",
                  "ï®",
                  "Ú",
                  "ï®",
                  "Ú",
                  "ï®",
                  "Ú",
                  "ï®",
                  "Ú",
                  "ï®",
                  "Ú",
                  "ï®",
                  "Ú",
                  "ï®",
                  "Ú©",
                  "ï®",
                  "Ú©",
                  "ï®",
                  "Ú©",
                  "ï®",
                  "Ú©",
                  "ï®",
                  "Ú¯",
                  "ï®",
                  "Ú¯",
                  "ï®",
                  "Ú¯",
                  "ï®",
                  "Ú¯",
                  "ï®",
                  "Ú³",
                  "ï®",
                  "Ú³",
                  "ï®",
                  "Ú³",
                  "ï®",
                  "Ú³",
                  "ï®",
                  "Ú±",
                  "ï®",
                  "Ú±",
                  "ï®",
                  "Ú±",
                  "ï®",
                  "Ú±",
                  "ï®",
                  "Úº",
                  "ï®",
                  "Úº",
                  "ï® ",
                  "Ú»",
                  "ï®¡",
                  "Ú»",
                  "ï®¢",
                  "Ú»",
                  "ï®£",
                  "Ú»",
                  "ï®¤",
                  "Û",
                  "ï®¥",
                  "Û",
                  "ï®¦",
                  "Û",
                  "ï®§",
                  "Û",
                  "ï®¨",
                  "Û",
                  "ï®©",
                  "Û",
                  "ï®ª",
                  "Ú¾",
                  "ï®«",
                  "Ú¾",
                  "ï®¬",
                  "Ú¾",
                  "ï®­",
                  "Ú¾",
                  "ï®®",
                  "Û",
                  "ï®¯",
                  "Û",
                  "ï®°",
                  "Û",
                  "ï®±",
                  "Û",
                  "ï¯",
                  "Ú­",
                  "ï¯",
                  "Ú­",
                  "ï¯",
                  "Ú­",
                  "ï¯",
                  "Ú­",
                  "ï¯",
                  "Û",
                  "ï¯",
                  "Û",
                  "ï¯",
                  "Û",
                  "ï¯",
                  "Û",
                  "ï¯",
                  "Û",
                  "ï¯",
                  "Û",
                  "ï¯",
                  "Ù·",
                  "ï¯",
                  "Û",
                  "ï¯",
                  "Û",
                  "ï¯ ",
                  "Û",
                  "ï¯¡",
                  "Û",
                  "ï¯¢",
                  "Û",
                  "ï¯£",
                  "Û",
                  "ï¯¤",
                  "Û",
                  "ï¯¥",
                  "Û",
                  "ï¯¦",
                  "Û",
                  "ï¯§",
                  "Û",
                  "ï¯¨",
                  "Ù",
                  "ï¯©",
                  "Ù",
                  "ï¯ª",
                  "Ø¦Ø§",
                  "ï¯«",
                  "Ø¦Ø§",
                  "ï¯¬",
                  "Ø¦Û",
                  "ï¯­",
                  "Ø¦Û",
                  "ï¯®",
                  "Ø¦Ù",
                  "ï¯¯",
                  "Ø¦Ù",
                  "ï¯°",
                  "Ø¦Û",
                  "ï¯±",
                  "Ø¦Û",
                  "ï¯²",
                  "Ø¦Û",
                  "ï¯³",
                  "Ø¦Û",
                  "ï¯´",
                  "Ø¦Û",
                  "ï¯µ",
                  "Ø¦Û",
                  "ï¯¶",
                  "Ø¦Û",
                  "ï¯·",
                  "Ø¦Û",
                  "ï¯¸",
                  "Ø¦Û",
                  "ï¯¹",
                  "Ø¦Ù",
                  "ï¯º",
                  "Ø¦Ù",
                  "ï¯»",
                  "Ø¦Ù",
                  "ï¯¼",
                  "Û",
                  "ï¯½",
                  "Û",
                  "ï¯¾",
                  "Û",
                  "ï¯¿",
                  "Û",
                  "ï°",
                  "Ø¦Ø¬",
                  "ï°",
                  "Ø¦Ø­",
                  "ï°",
                  "Ø¦Ù",
                  "ï°",
                  "Ø¦Ù",
                  "ï°",
                  "Ø¦Ù",
                  "ï°",
                  "Ø¨Ø¬",
                  "ï°",
                  "Ø¨Ø­",
                  "ï°",
                  "Ø¨Ø®",
                  "ï°",
                  "Ø¨Ù",
                  "ï°",
                  "Ø¨Ù",
                  "ï°",
                  "Ø¨Ù",
                  "ï°",
                  "ØªØ¬",
                  "ï°",
                  "ØªØ­",
                  "ï°",
                  "ØªØ®",
                  "ï°",
                  "ØªÙ",
                  "ï°",
                  "ØªÙ",
                  "ï°",
                  "ØªÙ",
                  "ï°",
                  "Ø«Ø¬",
                  "ï°",
                  "Ø«Ù",
                  "ï°",
                  "Ø«Ù",
                  "ï°",
                  "Ø«Ù",
                  "ï°",
                  "Ø¬Ø­",
                  "ï°",
                  "Ø¬Ù",
                  "ï°",
                  "Ø­Ø¬",
                  "ï°",
                  "Ø­Ù",
                  "ï°",
                  "Ø®Ø¬",
                  "ï°",
                  "Ø®Ø­",
                  "ï°",
                  "Ø®Ù",
                  "ï°",
                  "Ø³Ø¬",
                  "ï°",
                  "Ø³Ø­",
                  "ï°",
                  "Ø³Ø®",
                  "ï°",
                  "Ø³Ù",
                  "ï° ",
                  "ØµØ­",
                  "ï°¡",
                  "ØµÙ",
                  "ï°¢",
                  "Ø¶Ø¬",
                  "ï°£",
                  "Ø¶Ø­",
                  "ï°¤",
                  "Ø¶Ø®",
                  "ï°¥",
                  "Ø¶Ù",
                  "ï°¦",
                  "Ø·Ø­",
                  "ï°§",
                  "Ø·Ù",
                  "ï°¨",
                  "Ø¸Ù",
                  "ï°©",
                  "Ø¹Ø¬",
                  "ï°ª",
                  "Ø¹Ù",
                  "ï°«",
                  "ØºØ¬",
                  "ï°¬",
                  "ØºÙ",
                  "ï°­",
                  "ÙØ¬",
                  "ï°®",
                  "ÙØ­",
                  "ï°¯",
                  "ÙØ®",
                  "ï°°",
                  "ÙÙ",
                  "ï°±",
                  "ÙÙ",
                  "ï°²",
                  "ÙÙ",
                  "ï°³",
                  "ÙØ­",
                  "ï°´",
                  "ÙÙ",
                  "ï°µ",
                  "ÙÙ",
                  "ï°¶",
                  "ÙÙ",
                  "ï°·",
                  "ÙØ§",
                  "ï°¸",
                  "ÙØ¬",
                  "ï°¹",
                  "ÙØ­",
                  "ï°º",
                  "ÙØ®",
                  "ï°»",
                  "ÙÙ",
                  "ï°¼",
                  "ÙÙ",
                  "ï°½",
                  "ÙÙ",
                  "ï°¾",
                  "ÙÙ",
                  "ï°¿",
                  "ÙØ¬",
                  "ï±",
                  "ÙØ­",
                  "ï±",
                  "ÙØ®",
                  "ï±",
                  "ÙÙ",
                  "ï±",
                  "ÙÙ",
                  "ï±",
                  "ÙÙ",
                  "ï±",
                  "ÙØ¬",
                  "ï±",
                  "ÙØ­",
                  "ï±",
                  "ÙØ®",
                  "ï±",
                  "ÙÙ",
                  "ï±",
                  "ÙÙ",
                  "ï±",
                  "ÙÙ",
                  "ï±",
                  "ÙØ¬",
                  "ï±",
                  "ÙØ­",
                  "ï±",
                  "ÙØ®",
                  "ï±",
                  "ÙÙ",
                  "ï±",
                  "ÙÙ",
                  "ï±",
                  "ÙÙ",
                  "ï±",
                  "ÙØ¬",
                  "ï±",
                  "ÙÙ",
                  "ï±",
                  "ÙÙ",
                  "ï±",
                  "ÙÙ",
                  "ï±",
                  "ÙØ¬",
                  "ï±",
                  "ÙØ­",
                  "ï±",
                  "ÙØ®",
                  "ï±",
                  "ÙÙ",
                  "ï±",
                  "ÙÙ",
                  "ï±",
                  "ÙÙ",
                  "ï±",
                  "Ø°Ù°",
                  "ï±",
                  "Ø±Ù°",
                  "ï±",
                  "ÙÙ°",
                  "ï±",
                  " ÙÙ",
                  "ï±",
                  " ÙÙ",
                  "ï± ",
                  " ÙÙ",
                  "ï±¡",
                  " ÙÙ",
                  "ï±¢",
                  " ÙÙ",
                  "ï±£",
                  " ÙÙ°",
                  "ï±¤",
                  "Ø¦Ø±",
                  "ï±¥",
                  "Ø¦Ø²",
                  "ï±¦",
                  "Ø¦Ù",
                  "ï±§",
                  "Ø¦Ù",
                  "ï±¨",
                  "Ø¦Ù",
                  "ï±©",
                  "Ø¦Ù",
                  "ï±ª",
                  "Ø¨Ø±",
                  "ï±«",
                  "Ø¨Ø²",
                  "ï±¬",
                  "Ø¨Ù",
                  "ï±­",
                  "Ø¨Ù",
                  "ï±®",
                  "Ø¨Ù",
                  "ï±¯",
                  "Ø¨Ù",
                  "ï±°",
                  "ØªØ±",
                  "ï±±",
                  "ØªØ²",
                  "ï±²",
                  "ØªÙ",
                  "ï±³",
                  "ØªÙ",
                  "ï±´",
                  "ØªÙ",
                  "ï±µ",
                  "ØªÙ",
                  "ï±¶",
                  "Ø«Ø±",
                  "ï±·",
                  "Ø«Ø²",
                  "ï±¸",
                  "Ø«Ù",
                  "ï±¹",
                  "Ø«Ù",
                  "ï±º",
                  "Ø«Ù",
                  "ï±»",
                  "Ø«Ù",
                  "ï±¼",
                  "ÙÙ",
                  "ï±½",
                  "ÙÙ",
                  "ï±¾",
                  "ÙÙ",
                  "ï±¿",
                  "ÙÙ",
                  "ï²",
                  "ÙØ§",
                  "ï²",
                  "ÙÙ",
                  "ï²",
                  "ÙÙ",
                  "ï²",
                  "ÙÙ",
                  "ï²",
                  "ÙÙ",
                  "ï²",
                  "ÙÙ",
                  "ï²",
                  "ÙÙ",
                  "ï²",
                  "ÙÙ",
                  "ï²",
                  "ÙØ§",
                  "ï²",
                  "ÙÙ",
                  "ï²",
                  "ÙØ±",
                  "ï²",
                  "ÙØ²",
                  "ï²",
                  "ÙÙ",
                  "ï²",
                  "ÙÙ",
                  "ï²",
                  "ÙÙ",
                  "ï²",
                  "ÙÙ",
                  "ï²",
                  "ÙÙ°",
                  "ï²",
                  "ÙØ±",
                  "ï²",
                  "ÙØ²",
                  "ï²",
                  "ÙÙ",
                  "ï²",
                  "ÙÙ",
                  "ï²",
                  "ÙÙ",
                  "ï²",
                  "ÙÙ",
                  "ï²",
                  "Ø¦Ø¬",
                  "ï²",
                  "Ø¦Ø­",
                  "ï²",
                  "Ø¦Ø®",
                  "ï²",
                  "Ø¦Ù",
                  "ï²",
                  "Ø¦Ù",
                  "ï²",
                  "Ø¨Ø¬",
                  "ï²",
                  "Ø¨Ø­",
                  "ï²",
                  "Ø¨Ø®",
                  "ï²",
                  "Ø¨Ù",
                  "ï² ",
                  "Ø¨Ù",
                  "ï²¡",
                  "ØªØ¬",
                  "ï²¢",
                  "ØªØ­",
                  "ï²£",
                  "ØªØ®",
                  "ï²¤",
                  "ØªÙ",
                  "ï²¥",
                  "ØªÙ",
                  "ï²¦",
                  "Ø«Ù",
                  "ï²§",
                  "Ø¬Ø­",
                  "ï²¨",
                  "Ø¬Ù",
                  "ï²©",
                  "Ø­Ø¬",
                  "ï²ª",
                  "Ø­Ù",
                  "ï²«",
                  "Ø®Ø¬",
                  "ï²¬",
                  "Ø®Ù",
                  "ï²­",
                  "Ø³Ø¬",
                  "ï²®",
                  "Ø³Ø­",
                  "ï²¯",
                  "Ø³Ø®",
                  "ï²°",
                  "Ø³Ù",
                  "ï²±",
                  "ØµØ­",
                  "ï²²",
                  "ØµØ®",
                  "ï²³",
                  "ØµÙ",
                  "ï²´",
                  "Ø¶Ø¬",
                  "ï²µ",
                  "Ø¶Ø­",
                  "ï²¶",
                  "Ø¶Ø®",
                  "ï²·",
                  "Ø¶Ù",
                  "ï²¸",
                  "Ø·Ø­",
                  "ï²¹",
                  "Ø¸Ù",
                  "ï²º",
                  "Ø¹Ø¬",
                  "ï²»",
                  "Ø¹Ù",
                  "ï²¼",
                  "ØºØ¬",
                  "ï²½",
                  "ØºÙ",
                  "ï²¾",
                  "ÙØ¬",
                  "ï²¿",
                  "ÙØ­",
                  "ï³",
                  "ÙØ®",
                  "ï³",
                  "ÙÙ",
                  "ï³",
                  "ÙØ­",
                  "ï³",
                  "ÙÙ",
                  "ï³",
                  "ÙØ¬",
                  "ï³",
                  "ÙØ­",
                  "ï³",
                  "ÙØ®",
                  "ï³",
                  "ÙÙ",
                  "ï³",
                  "ÙÙ",
                  "ï³",
                  "ÙØ¬",
                  "ï³",
                  "ÙØ­",
                  "ï³",
                  "ÙØ®",
                  "ï³",
                  "ÙÙ",
                  "ï³",
                  "ÙÙ",
                  "ï³",
                  "ÙØ¬",
                  "ï³",
                  "ÙØ­",
                  "ï³",
                  "ÙØ®",
                  "ï³",
                  "ÙÙ",
                  "ï³",
                  "ÙØ¬",
                  "ï³",
                  "ÙØ­",
                  "ï³",
                  "ÙØ®",
                  "ï³",
                  "ÙÙ",
                  "ï³",
                  "ÙÙ",
                  "ï³",
                  "ÙØ¬",
                  "ï³",
                  "ÙÙ",
                  "ï³",
                  "ÙÙ°",
                  "ï³",
                  "ÙØ¬",
                  "ï³",
                  "ÙØ­",
                  "ï³",
                  "ÙØ®",
                  "ï³",
                  "ÙÙ",
                  "ï³",
                  "ÙÙ",
                  "ï³",
                  "Ø¦Ù",
                  "ï³ ",
                  "Ø¦Ù",
                  "ï³¡",
                  "Ø¨Ù",
                  "ï³¢",
                  "Ø¨Ù",
                  "ï³£",
                  "ØªÙ",
                  "ï³¤",
                  "ØªÙ",
                  "ï³¥",
                  "Ø«Ù",
                  "ï³¦",
                  "Ø«Ù",
                  "ï³§",
                  "Ø³Ù",
                  "ï³¨",
                  "Ø³Ù",
                  "ï³©",
                  "Ø´Ù",
                  "ï³ª",
                  "Ø´Ù",
                  "ï³«",
                  "ÙÙ",
                  "ï³¬",
                  "ÙÙ",
                  "ï³­",
                  "ÙÙ",
                  "ï³®",
                  "ÙÙ",
                  "ï³¯",
                  "ÙÙ",
                  "ï³°",
                  "ÙÙ",
                  "ï³±",
                  "ÙÙ",
                  "ï³²",
                  "ÙÙÙ",
                  "ï³³",
                  "ÙÙÙ",
                  "ï³´",
                  "ÙÙÙ",
                  "ï³µ",
                  "Ø·Ù",
                  "ï³¶",
                  "Ø·Ù",
                  "ï³·",
                  "Ø¹Ù",
                  "ï³¸",
                  "Ø¹Ù",
                  "ï³¹",
                  "ØºÙ",
                  "ï³º",
                  "ØºÙ",
                  "ï³»",
                  "Ø³Ù",
                  "ï³¼",
                  "Ø³Ù",
                  "ï³½",
                  "Ø´Ù",
                  "ï³¾",
                  "Ø´Ù",
                  "ï³¿",
                  "Ø­Ù",
                  "ï´",
                  "Ø­Ù",
                  "ï´",
                  "Ø¬Ù",
                  "ï´",
                  "Ø¬Ù",
                  "ï´",
                  "Ø®Ù",
                  "ï´",
                  "Ø®Ù",
                  "ï´",
                  "ØµÙ",
                  "ï´",
                  "ØµÙ",
                  "ï´",
                  "Ø¶Ù",
                  "ï´",
                  "Ø¶Ù",
                  "ï´",
                  "Ø´Ø¬",
                  "ï´",
                  "Ø´Ø­",
                  "ï´",
                  "Ø´Ø®",
                  "ï´",
                  "Ø´Ù",
                  "ï´",
                  "Ø´Ø±",
                  "ï´",
                  "Ø³Ø±",
                  "ï´",
                  "ØµØ±",
                  "ï´",
                  "Ø¶Ø±",
                  "ï´",
                  "Ø·Ù",
                  "ï´",
                  "Ø·Ù",
                  "ï´",
                  "Ø¹Ù",
                  "ï´",
                  "Ø¹Ù",
                  "ï´",
                  "ØºÙ",
                  "ï´",
                  "ØºÙ",
                  "ï´",
                  "Ø³Ù",
                  "ï´",
                  "Ø³Ù",
                  "ï´",
                  "Ø´Ù",
                  "ï´",
                  "Ø´Ù",
                  "ï´",
                  "Ø­Ù",
                  "ï´",
                  "Ø­Ù",
                  "ï´",
                  "Ø¬Ù",
                  "ï´",
                  "Ø¬Ù",
                  "ï´",
                  "Ø®Ù",
                  "ï´ ",
                  "Ø®Ù",
                  "ï´¡",
                  "ØµÙ",
                  "ï´¢",
                  "ØµÙ",
                  "ï´£",
                  "Ø¶Ù",
                  "ï´¤",
                  "Ø¶Ù",
                  "ï´¥",
                  "Ø´Ø¬",
                  "ï´¦",
                  "Ø´Ø­",
                  "ï´§",
                  "Ø´Ø®",
                  "ï´¨",
                  "Ø´Ù",
                  "ï´©",
                  "Ø´Ø±",
                  "ï´ª",
                  "Ø³Ø±",
                  "ï´«",
                  "ØµØ±",
                  "ï´¬",
                  "Ø¶Ø±",
                  "ï´­",
                  "Ø´Ø¬",
                  "ï´®",
                  "Ø´Ø­",
                  "ï´¯",
                  "Ø´Ø®",
                  "ï´°",
                  "Ø´Ù",
                  "ï´±",
                  "Ø³Ù",
                  "ï´²",
                  "Ø´Ù",
                  "ï´³",
                  "Ø·Ù",
                  "ï´´",
                  "Ø³Ø¬",
                  "ï´µ",
                  "Ø³Ø­",
                  "ï´¶",
                  "Ø³Ø®",
                  "ï´·",
                  "Ø´Ø¬",
                  "ï´¸",
                  "Ø´Ø­",
                  "ï´¹",
                  "Ø´Ø®",
                  "ï´º",
                  "Ø·Ù",
                  "ï´»",
                  "Ø¸Ù",
                  "ï´¼",
                  "Ø§Ù",
                  "ï´½",
                  "Ø§Ù",
                  "ïµ",
                  "ØªØ¬Ù",
                  "ïµ",
                  "ØªØ­Ø¬",
                  "ïµ",
                  "ØªØ­Ø¬",
                  "ïµ",
                  "ØªØ­Ù",
                  "ïµ",
                  "ØªØ®Ù",
                  "ïµ",
                  "ØªÙØ¬",
                  "ïµ",
                  "ØªÙØ­",
                  "ïµ",
                  "ØªÙØ®",
                  "ïµ",
                  "Ø¬ÙØ­",
                  "ïµ",
                  "Ø¬ÙØ­",
                  "ïµ",
                  "Ø­ÙÙ",
                  "ïµ",
                  "Ø­ÙÙ",
                  "ïµ",
                  "Ø³Ø­Ø¬",
                  "ïµ",
                  "Ø³Ø¬Ø­",
                  "ïµ",
                  "Ø³Ø¬Ù",
                  "ïµ",
                  "Ø³ÙØ­",
                  "ïµ ",
                  "Ø³ÙØ­",
                  "ïµ¡",
                  "Ø³ÙØ¬",
                  "ïµ¢",
                  "Ø³ÙÙ",
                  "ïµ£",
                  "Ø³ÙÙ",
                  "ïµ¤",
                  "ØµØ­Ø­",
                  "ïµ¥",
                  "ØµØ­Ø­",
                  "ïµ¦",
                  "ØµÙÙ",
                  "ïµ§",
                  "Ø´Ø­Ù",
                  "ïµ¨",
                  "Ø´Ø­Ù",
                  "ïµ©",
                  "Ø´Ø¬Ù",
                  "ïµª",
                  "Ø´ÙØ®",
                  "ïµ«",
                  "Ø´ÙØ®",
                  "ïµ¬",
                  "Ø´ÙÙ",
                  "ïµ­",
                  "Ø´ÙÙ",
                  "ïµ®",
                  "Ø¶Ø­Ù",
                  "ïµ¯",
                  "Ø¶Ø®Ù",
                  "ïµ°",
                  "Ø¶Ø®Ù",
                  "ïµ±",
                  "Ø·ÙØ­",
                  "ïµ²",
                  "Ø·ÙØ­",
                  "ïµ³",
                  "Ø·ÙÙ",
                  "ïµ´",
                  "Ø·ÙÙ",
                  "ïµµ",
                  "Ø¹Ø¬Ù",
                  "ïµ¶",
                  "Ø¹ÙÙ",
                  "ïµ·",
                  "Ø¹ÙÙ",
                  "ïµ¸",
                  "Ø¹ÙÙ",
                  "ïµ¹",
                  "ØºÙÙ",
                  "ïµº",
                  "ØºÙÙ",
                  "ïµ»",
                  "ØºÙÙ",
                  "ïµ¼",
                  "ÙØ®Ù",
                  "ïµ½",
                  "ÙØ®Ù",
                  "ïµ¾",
                  "ÙÙØ­",
                  "ïµ¿",
                  "ÙÙÙ",
                  "ï¶",
                  "ÙØ­Ù",
                  "ï¶",
                  "ÙØ­Ù",
                  "ï¶",
                  "ÙØ­Ù",
                  "ï¶",
                  "ÙØ¬Ø¬",
                  "ï¶",
                  "ÙØ¬Ø¬",
                  "ï¶",
                  "ÙØ®Ù",
                  "ï¶",
                  "ÙØ®Ù",
                  "ï¶",
                  "ÙÙØ­",
                  "ï¶",
                  "ÙÙØ­",
                  "ï¶",
                  "ÙØ­Ø¬",
                  "ï¶",
                  "ÙØ­Ù",
                  "ï¶",
                  "ÙØ­Ù",
                  "ï¶",
                  "ÙØ¬Ø­",
                  "ï¶",
                  "ÙØ¬Ù",
                  "ï¶",
                  "ÙØ®Ø¬",
                  "ï¶",
                  "ÙØ®Ù",
                  "ï¶",
                  "ÙØ¬Ø®",
                  "ï¶",
                  "ÙÙØ¬",
                  "ï¶",
                  "ÙÙÙ",
                  "ï¶",
                  "ÙØ­Ù",
                  "ï¶",
                  "ÙØ­Ù",
                  "ï¶",
                  "ÙØ¬Ù",
                  "ï¶",
                  "ÙØ¬Ù",
                  "ï¶",
                  "ÙØ¬Ù",
                  "ï¶",
                  "ÙÙÙ",
                  "ï¶",
                  "ÙÙÙ",
                  "ï¶",
                  "ÙÙÙ",
                  "ï¶",
                  "ÙÙÙ",
                  "ï¶",
                  "Ø¨Ø®Ù",
                  "ï¶",
                  "ØªØ¬Ù",
                  "ï¶ ",
                  "ØªØ¬Ù",
                  "ï¶¡",
                  "ØªØ®Ù",
                  "ï¶¢",
                  "ØªØ®Ù",
                  "ï¶£",
                  "ØªÙÙ",
                  "ï¶¤",
                  "ØªÙÙ",
                  "ï¶¥",
                  "Ø¬ÙÙ",
                  "ï¶¦",
                  "Ø¬Ø­Ù",
                  "ï¶§",
                  "Ø¬ÙÙ",
                  "ï¶¨",
                  "Ø³Ø®Ù",
                  "ï¶©",
                  "ØµØ­Ù",
                  "ï¶ª",
                  "Ø´Ø­Ù",
                  "ï¶«",
                  "Ø¶Ø­Ù",
                  "ï¶¬",
                  "ÙØ¬Ù",
                  "ï¶­",
                  "ÙÙÙ",
                  "ï¶®",
                  "ÙØ­Ù",
                  "ï¶¯",
                  "ÙØ¬Ù",
                  "ï¶°",
                  "ÙÙÙ",
                  "ï¶±",
                  "ÙÙÙ",
                  "ï¶²",
                  "ÙÙÙ",
                  "ï¶³",
                  "ÙØ­Ù",
                  "ï¶´",
                  "ÙÙØ­",
                  "ï¶µ",
                  "ÙØ­Ù",
                  "ï¶¶",
                  "Ø¹ÙÙ",
                  "ï¶·",
                  "ÙÙÙ",
                  "ï¶¸",
                  "ÙØ¬Ø­",
                  "ï¶¹",
                  "ÙØ®Ù",
                  "ï¶º",
                  "ÙØ¬Ù",
                  "ï¶»",
                  "ÙÙÙ",
                  "ï¶¼",
                  "ÙØ¬Ù",
                  "ï¶½",
                  "ÙØ¬Ø­",
                  "ï¶¾",
                  "Ø¬Ø­Ù",
                  "ï¶¿",
                  "Ø­Ø¬Ù",
                  "ï·",
                  "ÙØ¬Ù",
                  "ï·",
                  "ÙÙÙ",
                  "ï·",
                  "Ø¨Ø­Ù",
                  "ï·",
                  "ÙÙÙ",
                  "ï·",
                  "Ø¹Ø¬Ù",
                  "ï·",
                  "ØµÙÙ",
                  "ï·",
                  "Ø³Ø®Ù",
                  "ï·",
                  "ÙØ¬Ù",
                  "ï¹",
                  "â¾",
                  "ï¹",
                  "â¾",
                  "ï¹",
                  "â¾",
                  "ï¹",
                  "â¾",
                  "ï¹",
                  "_",
                  "ï¹",
                  "_",
                  "ï¹",
                  "_",
                  "ïº",
                  "Ø¡",
                  "ïº",
                  "Ø¢",
                  "ïº",
                  "Ø¢",
                  "ïº",
                  "Ø£",
                  "ïº",
                  "Ø£",
                  "ïº",
                  "Ø¤",
                  "ïº",
                  "Ø¤",
                  "ïº",
                  "Ø¥",
                  "ïº",
                  "Ø¥",
                  "ïº",
                  "Ø¦",
                  "ïº",
                  "Ø¦",
                  "ïº",
                  "Ø¦",
                  "ïº",
                  "Ø¦",
                  "ïº",
                  "Ø§",
                  "ïº",
                  "Ø§",
                  "ïº",
                  "Ø¨",
                  "ïº",
                  "Ø¨",
                  "ïº",
                  "Ø¨",
                  "ïº",
                  "Ø¨",
                  "ïº",
                  "Ø©",
                  "ïº",
                  "Ø©",
                  "ïº",
                  "Øª",
                  "ïº",
                  "Øª",
                  "ïº",
                  "Øª",
                  "ïº",
                  "Øª",
                  "ïº",
                  "Ø«",
                  "ïº",
                  "Ø«",
                  "ïº",
                  "Ø«",
                  "ïº",
                  "Ø«",
                  "ïº",
                  "Ø¬",
                  "ïº",
                  "Ø¬",
                  "ïº",
                  "Ø¬",
                  "ïº ",
                  "Ø¬",
                  "ïº¡",
                  "Ø­",
                  "ïº¢",
                  "Ø­",
                  "ïº£",
                  "Ø­",
                  "ïº¤",
                  "Ø­",
                  "ïº¥",
                  "Ø®",
                  "ïº¦",
                  "Ø®",
                  "ïº§",
                  "Ø®",
                  "ïº¨",
                  "Ø®",
                  "ïº©",
                  "Ø¯",
                  "ïºª",
                  "Ø¯",
                  "ïº«",
                  "Ø°",
                  "ïº¬",
                  "Ø°",
                  "ïº­",
                  "Ø±",
                  "ïº®",
                  "Ø±",
                  "ïº¯",
                  "Ø²",
                  "ïº°",
                  "Ø²",
                  "ïº±",
                  "Ø³",
                  "ïº²",
                  "Ø³",
                  "ïº³",
                  "Ø³",
                  "ïº´",
                  "Ø³",
                  "ïºµ",
                  "Ø´",
                  "ïº¶",
                  "Ø´",
                  "ïº·",
                  "Ø´",
                  "ïº¸",
                  "Ø´",
                  "ïº¹",
                  "Øµ",
                  "ïºº",
                  "Øµ",
                  "ïº»",
                  "Øµ",
                  "ïº¼",
                  "Øµ",
                  "ïº½",
                  "Ø¶",
                  "ïº¾",
                  "Ø¶",
                  "ïº¿",
                  "Ø¶",
                  "ï»",
                  "Ø¶",
                  "ï»",
                  "Ø·",
                  "ï»",
                  "Ø·",
                  "ï»",
                  "Ø·",
                  "ï»",
                  "Ø·",
                  "ï»",
                  "Ø¸",
                  "ï»",
                  "Ø¸",
                  "ï»",
                  "Ø¸",
                  "ï»",
                  "Ø¸",
                  "ï»",
                  "Ø¹",
                  "ï»",
                  "Ø¹",
                  "ï»",
                  "Ø¹",
                  "ï»",
                  "Ø¹",
                  "ï»",
                  "Øº",
                  "ï»",
                  "Øº",
                  "ï»",
                  "Øº",
                  "ï»",
                  "Øº",
                  "ï»",
                  "Ù",
                  "ï»",
                  "Ù",
                  "ï»",
                  "Ù",
                  "ï»",
                  "Ù",
                  "ï»",
                  "Ù",
                  "ï»",
                  "Ù",
                  "ï»",
                  "Ù",
                  "ï»",
                  "Ù",
                  "ï»",
                  "Ù",
                  "ï»",
                  "Ù",
                  "ï»",
                  "Ù",
                  "ï»",
                  "Ù",
                  "ï»",
                  "Ù",
                  "ï»",
                  "Ù",
                  "ï»",
                  "Ù",
                  "ï» ",
                  "Ù",
                  "ï»¡",
                  "Ù",
                  "ï»¢",
                  "Ù",
                  "ï»£",
                  "Ù",
                  "ï»¤",
                  "Ù",
                  "ï»¥",
                  "Ù",
                  "ï»¦",
                  "Ù",
                  "ï»§",
                  "Ù",
                  "ï»¨",
                  "Ù",
                  "ï»©",
                  "Ù",
                  "ï»ª",
                  "Ù",
                  "ï»«",
                  "Ù",
                  "ï»¬",
                  "Ù",
                  "ï»­",
                  "Ù",
                  "ï»®",
                  "Ù",
                  "ï»¯",
                  "Ù",
                  "ï»°",
                  "Ù",
                  "ï»±",
                  "Ù",
                  "ï»²",
                  "Ù",
                  "ï»³",
                  "Ù",
                  "ï»´",
                  "Ù",
                  "ï»µ",
                  "ÙØ¢",
                  "ï»¶",
                  "ÙØ¢",
                  "ï»·",
                  "ÙØ£",
                  "ï»¸",
                  "ÙØ£",
                  "ï»¹",
                  "ÙØ¥",
                  "ï»º",
                  "ÙØ¥",
                  "ï»»",
                  "ÙØ§",
                  "ï»¼",
                  "ÙØ§"
                ];
              });
              function reverseIfRtl(chars) {
                const charsLength = chars.length;
                if (charsLength <= 1 || !isRTLRangeFor(chars.charCodeAt(0))) {
                  return chars;
                }
                const buf = [];
                for (let ii = charsLength - 1; ii >= 0; ii--) {
                  buf.push(chars[ii]);
                }
                return buf.join("");
              }
              __name(reverseIfRtl, "reverseIfRtl");
              const SpecialCharRegExp = new RegExp("^(\\s)|(\\p{Mn})|(\\p{Cf})$", "u");
              const CategoryCache = /* @__PURE__ */ new Map();
              function getCharUnicodeCategory(char) {
                const cachedCategory = CategoryCache.get(char);
                if (cachedCategory) {
                  return cachedCategory;
                }
                const groups = char.match(SpecialCharRegExp);
                const category = {
                  isWhitespace: !!(groups && groups[1]),
                  isZeroWidthDiacritic: !!(groups && groups[2]),
                  isInvisibleFormatMark: !!(groups && groups[3])
                };
                CategoryCache.set(char, category);
                return category;
              }
              __name(getCharUnicodeCategory, "getCharUnicodeCategory");
              function clearUnicodeCaches() {
                CategoryCache.clear();
              }
              __name(clearUnicodeCaches, "clearUnicodeCaches");
            },
            /* 166 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.getSerifFonts = exports2.getNonStdFontMap = exports2.getGlyphMapForStandardFonts = exports2.getFontNameToFileMap = void 0;
              exports2.getStandardFontName = getStandardFontName;
              exports2.getSymbolsFonts = exports2.getSupplementalGlyphMapForCalibri = exports2.getSupplementalGlyphMapForArialBlack = exports2.getStdFontMap = void 0;
              var _core_utils = __w_pdfjs_require__2(131);
              var _fonts_utils = __w_pdfjs_require__2(163);
              const getStdFontMap = (0, _core_utils.getLookupTableFactory)(function(t) {
                t["Times-Roman"] = "Times-Roman";
                t.Helvetica = "Helvetica";
                t.Courier = "Courier";
                t.Symbol = "Symbol";
                t["Times-Bold"] = "Times-Bold";
                t["Helvetica-Bold"] = "Helvetica-Bold";
                t["Courier-Bold"] = "Courier-Bold";
                t.ZapfDingbats = "ZapfDingbats";
                t["Times-Italic"] = "Times-Italic";
                t["Helvetica-Oblique"] = "Helvetica-Oblique";
                t["Courier-Oblique"] = "Courier-Oblique";
                t["Times-BoldItalic"] = "Times-BoldItalic";
                t["Helvetica-BoldOblique"] = "Helvetica-BoldOblique";
                t["Courier-BoldOblique"] = "Courier-BoldOblique";
                t.ArialNarrow = "Helvetica";
                t["ArialNarrow-Bold"] = "Helvetica-Bold";
                t["ArialNarrow-BoldItalic"] = "Helvetica-BoldOblique";
                t["ArialNarrow-Italic"] = "Helvetica-Oblique";
                t.ArialBlack = "Helvetica";
                t["ArialBlack-Bold"] = "Helvetica-Bold";
                t["ArialBlack-BoldItalic"] = "Helvetica-BoldOblique";
                t["ArialBlack-Italic"] = "Helvetica-Oblique";
                t["Arial-Black"] = "Helvetica";
                t["Arial-Black-Bold"] = "Helvetica-Bold";
                t["Arial-Black-BoldItalic"] = "Helvetica-BoldOblique";
                t["Arial-Black-Italic"] = "Helvetica-Oblique";
                t.Arial = "Helvetica";
                t["Arial-Bold"] = "Helvetica-Bold";
                t["Arial-BoldItalic"] = "Helvetica-BoldOblique";
                t["Arial-Italic"] = "Helvetica-Oblique";
                t.ArialMT = "Helvetica";
                t["Arial-BoldItalicMT"] = "Helvetica-BoldOblique";
                t["Arial-BoldMT"] = "Helvetica-Bold";
                t["Arial-ItalicMT"] = "Helvetica-Oblique";
                t.ArialUnicodeMS = "Helvetica";
                t["ArialUnicodeMS-Bold"] = "Helvetica-Bold";
                t["ArialUnicodeMS-BoldItalic"] = "Helvetica-BoldOblique";
                t["ArialUnicodeMS-Italic"] = "Helvetica-Oblique";
                t["Courier-BoldItalic"] = "Courier-BoldOblique";
                t["Courier-Italic"] = "Courier-Oblique";
                t.CourierNew = "Courier";
                t["CourierNew-Bold"] = "Courier-Bold";
                t["CourierNew-BoldItalic"] = "Courier-BoldOblique";
                t["CourierNew-Italic"] = "Courier-Oblique";
                t["CourierNewPS-BoldItalicMT"] = "Courier-BoldOblique";
                t["CourierNewPS-BoldMT"] = "Courier-Bold";
                t["CourierNewPS-ItalicMT"] = "Courier-Oblique";
                t.CourierNewPSMT = "Courier";
                t["Helvetica-BoldItalic"] = "Helvetica-BoldOblique";
                t["Helvetica-Italic"] = "Helvetica-Oblique";
                t["Symbol-Bold"] = "Symbol";
                t["Symbol-BoldItalic"] = "Symbol";
                t["Symbol-Italic"] = "Symbol";
                t.TimesNewRoman = "Times-Roman";
                t["TimesNewRoman-Bold"] = "Times-Bold";
                t["TimesNewRoman-BoldItalic"] = "Times-BoldItalic";
                t["TimesNewRoman-Italic"] = "Times-Italic";
                t.TimesNewRomanPS = "Times-Roman";
                t["TimesNewRomanPS-Bold"] = "Times-Bold";
                t["TimesNewRomanPS-BoldItalic"] = "Times-BoldItalic";
                t["TimesNewRomanPS-BoldItalicMT"] = "Times-BoldItalic";
                t["TimesNewRomanPS-BoldMT"] = "Times-Bold";
                t["TimesNewRomanPS-Italic"] = "Times-Italic";
                t["TimesNewRomanPS-ItalicMT"] = "Times-Italic";
                t.TimesNewRomanPSMT = "Times-Roman";
                t["TimesNewRomanPSMT-Bold"] = "Times-Bold";
                t["TimesNewRomanPSMT-BoldItalic"] = "Times-BoldItalic";
                t["TimesNewRomanPSMT-Italic"] = "Times-Italic";
              });
              exports2.getStdFontMap = getStdFontMap;
              const getFontNameToFileMap = (0, _core_utils.getLookupTableFactory)(function(t) {
                t.Courier = "FoxitFixed.pfb";
                t["Courier-Bold"] = "FoxitFixedBold.pfb";
                t["Courier-BoldOblique"] = "FoxitFixedBoldItalic.pfb";
                t["Courier-Oblique"] = "FoxitFixedItalic.pfb";
                t.Helvetica = "FoxitSans.pfb";
                t["Helvetica-Bold"] = "FoxitSansBold.pfb";
                t["Helvetica-BoldOblique"] = "FoxitSansBoldItalic.pfb";
                t["Helvetica-Oblique"] = "FoxitSansItalic.pfb";
                t["Times-Roman"] = "FoxitSerif.pfb";
                t["Times-Bold"] = "FoxitSerifBold.pfb";
                t["Times-BoldItalic"] = "FoxitSerifBoldItalic.pfb";
                t["Times-Italic"] = "FoxitSerifItalic.pfb";
                t.Symbol = "FoxitSymbol.pfb";
                t.ZapfDingbats = "FoxitDingbats.pfb";
                t["LiberationSans-Regular"] = "LiberationSans-Regular.ttf";
                t["LiberationSans-Bold"] = "LiberationSans-Bold.ttf";
                t["LiberationSans-Italic"] = "LiberationSans-Italic.ttf";
                t["LiberationSans-BoldItalic"] = "LiberationSans-BoldItalic.ttf";
              });
              exports2.getFontNameToFileMap = getFontNameToFileMap;
              const getNonStdFontMap = (0, _core_utils.getLookupTableFactory)(function(t) {
                t.Calibri = "Helvetica";
                t["Calibri-Bold"] = "Helvetica-Bold";
                t["Calibri-BoldItalic"] = "Helvetica-BoldOblique";
                t["Calibri-Italic"] = "Helvetica-Oblique";
                t.CenturyGothic = "Helvetica";
                t["CenturyGothic-Bold"] = "Helvetica-Bold";
                t["CenturyGothic-BoldItalic"] = "Helvetica-BoldOblique";
                t["CenturyGothic-Italic"] = "Helvetica-Oblique";
                t.ComicSansMS = "Comic Sans MS";
                t["ComicSansMS-Bold"] = "Comic Sans MS-Bold";
                t["ComicSansMS-BoldItalic"] = "Comic Sans MS-BoldItalic";
                t["ComicSansMS-Italic"] = "Comic Sans MS-Italic";
                t["ItcSymbol-Bold"] = "Helvetica-Bold";
                t["ItcSymbol-BoldItalic"] = "Helvetica-BoldOblique";
                t["ItcSymbol-Book"] = "Helvetica";
                t["ItcSymbol-BookItalic"] = "Helvetica-Oblique";
                t["ItcSymbol-Medium"] = "Helvetica";
                t["ItcSymbol-MediumItalic"] = "Helvetica-Oblique";
                t.LucidaConsole = "Courier";
                t["LucidaConsole-Bold"] = "Courier-Bold";
                t["LucidaConsole-BoldItalic"] = "Courier-BoldOblique";
                t["LucidaConsole-Italic"] = "Courier-Oblique";
                t["LucidaSans-Demi"] = "Helvetica-Bold";
                t["MS-Gothic"] = "MS Gothic";
                t["MS-Gothic-Bold"] = "MS Gothic-Bold";
                t["MS-Gothic-BoldItalic"] = "MS Gothic-BoldItalic";
                t["MS-Gothic-Italic"] = "MS Gothic-Italic";
                t["MS-Mincho"] = "MS Mincho";
                t["MS-Mincho-Bold"] = "MS Mincho-Bold";
                t["MS-Mincho-BoldItalic"] = "MS Mincho-BoldItalic";
                t["MS-Mincho-Italic"] = "MS Mincho-Italic";
                t["MS-PGothic"] = "MS PGothic";
                t["MS-PGothic-Bold"] = "MS PGothic-Bold";
                t["MS-PGothic-BoldItalic"] = "MS PGothic-BoldItalic";
                t["MS-PGothic-Italic"] = "MS PGothic-Italic";
                t["MS-PMincho"] = "MS PMincho";
                t["MS-PMincho-Bold"] = "MS PMincho-Bold";
                t["MS-PMincho-BoldItalic"] = "MS PMincho-BoldItalic";
                t["MS-PMincho-Italic"] = "MS PMincho-Italic";
                t.NuptialScript = "Times-Italic";
                t.SegoeUISymbol = "Helvetica";
                t.Wingdings = "ZapfDingbats";
                t["Wingdings-Regular"] = "ZapfDingbats";
              });
              exports2.getNonStdFontMap = getNonStdFontMap;
              const getSerifFonts = (0, _core_utils.getLookupTableFactory)(function(t) {
                t["Adobe Jenson"] = true;
                t["Adobe Text"] = true;
                t.Albertus = true;
                t.Aldus = true;
                t.Alexandria = true;
                t.Algerian = true;
                t["American Typewriter"] = true;
                t.Antiqua = true;
                t.Apex = true;
                t.Arno = true;
                t.Aster = true;
                t.Aurora = true;
                t.Baskerville = true;
                t.Bell = true;
                t.Bembo = true;
                t["Bembo Schoolbook"] = true;
                t.Benguiat = true;
                t["Berkeley Old Style"] = true;
                t["Bernhard Modern"] = true;
                t["Berthold City"] = true;
                t.Bodoni = true;
                t["Bauer Bodoni"] = true;
                t["Book Antiqua"] = true;
                t.Bookman = true;
                t["Bordeaux Roman"] = true;
                t["Californian FB"] = true;
                t.Calisto = true;
                t.Calvert = true;
                t.Capitals = true;
                t.Cambria = true;
                t.Cartier = true;
                t.Caslon = true;
                t.Catull = true;
                t.Centaur = true;
                t["Century Old Style"] = true;
                t["Century Schoolbook"] = true;
                t.Chaparral = true;
                t["Charis SIL"] = true;
                t.Cheltenham = true;
                t["Cholla Slab"] = true;
                t.Clarendon = true;
                t.Clearface = true;
                t.Cochin = true;
                t.Colonna = true;
                t["Computer Modern"] = true;
                t["Concrete Roman"] = true;
                t.Constantia = true;
                t["Cooper Black"] = true;
                t.Corona = true;
                t.Ecotype = true;
                t.Egyptienne = true;
                t.Elephant = true;
                t.Excelsior = true;
                t.Fairfield = true;
                t["FF Scala"] = true;
                t.Folkard = true;
                t.Footlight = true;
                t.FreeSerif = true;
                t["Friz Quadrata"] = true;
                t.Garamond = true;
                t.Gentium = true;
                t.Georgia = true;
                t.Gloucester = true;
                t["Goudy Old Style"] = true;
                t["Goudy Schoolbook"] = true;
                t["Goudy Pro Font"] = true;
                t.Granjon = true;
                t["Guardian Egyptian"] = true;
                t.Heather = true;
                t.Hercules = true;
                t["High Tower Text"] = true;
                t.Hiroshige = true;
                t["Hoefler Text"] = true;
                t["Humana Serif"] = true;
                t.Imprint = true;
                t["Ionic No. 5"] = true;
                t.Janson = true;
                t.Joanna = true;
                t.Korinna = true;
                t.Lexicon = true;
                t.LiberationSerif = true;
                t["Liberation Serif"] = true;
                t["Linux Libertine"] = true;
                t.Literaturnaya = true;
                t.Lucida = true;
                t["Lucida Bright"] = true;
                t.Melior = true;
                t.Memphis = true;
                t.Miller = true;
                t.Minion = true;
                t.Modern = true;
                t["Mona Lisa"] = true;
                t["Mrs Eaves"] = true;
                t["MS Serif"] = true;
                t["Museo Slab"] = true;
                t["New York"] = true;
                t["Nimbus Roman"] = true;
                t["NPS Rawlinson Roadway"] = true;
                t.NuptialScript = true;
                t.Palatino = true;
                t.Perpetua = true;
                t.Plantin = true;
                t["Plantin Schoolbook"] = true;
                t.Playbill = true;
                t["Poor Richard"] = true;
                t["Rawlinson Roadway"] = true;
                t.Renault = true;
                t.Requiem = true;
                t.Rockwell = true;
                t.Roman = true;
                t["Rotis Serif"] = true;
                t.Sabon = true;
                t.Scala = true;
                t.Seagull = true;
                t.Sistina = true;
                t.Souvenir = true;
                t.STIX = true;
                t["Stone Informal"] = true;
                t["Stone Serif"] = true;
                t.Sylfaen = true;
                t.Times = true;
                t.Trajan = true;
                t["TrinitÃ©"] = true;
                t["Trump Mediaeval"] = true;
                t.Utopia = true;
                t["Vale Type"] = true;
                t["Bitstream Vera"] = true;
                t["Vera Serif"] = true;
                t.Versailles = true;
                t.Wanted = true;
                t.Weiss = true;
                t["Wide Latin"] = true;
                t.Windsor = true;
                t.XITS = true;
              });
              exports2.getSerifFonts = getSerifFonts;
              const getSymbolsFonts = (0, _core_utils.getLookupTableFactory)(function(t) {
                t.Dingbats = true;
                t.Symbol = true;
                t.ZapfDingbats = true;
              });
              exports2.getSymbolsFonts = getSymbolsFonts;
              const getGlyphMapForStandardFonts = (0, _core_utils.getLookupTableFactory)(function(t) {
                t[2] = 10;
                t[3] = 32;
                t[4] = 33;
                t[5] = 34;
                t[6] = 35;
                t[7] = 36;
                t[8] = 37;
                t[9] = 38;
                t[10] = 39;
                t[11] = 40;
                t[12] = 41;
                t[13] = 42;
                t[14] = 43;
                t[15] = 44;
                t[16] = 45;
                t[17] = 46;
                t[18] = 47;
                t[19] = 48;
                t[20] = 49;
                t[21] = 50;
                t[22] = 51;
                t[23] = 52;
                t[24] = 53;
                t[25] = 54;
                t[26] = 55;
                t[27] = 56;
                t[28] = 57;
                t[29] = 58;
                t[30] = 894;
                t[31] = 60;
                t[32] = 61;
                t[33] = 62;
                t[34] = 63;
                t[35] = 64;
                t[36] = 65;
                t[37] = 66;
                t[38] = 67;
                t[39] = 68;
                t[40] = 69;
                t[41] = 70;
                t[42] = 71;
                t[43] = 72;
                t[44] = 73;
                t[45] = 74;
                t[46] = 75;
                t[47] = 76;
                t[48] = 77;
                t[49] = 78;
                t[50] = 79;
                t[51] = 80;
                t[52] = 81;
                t[53] = 82;
                t[54] = 83;
                t[55] = 84;
                t[56] = 85;
                t[57] = 86;
                t[58] = 87;
                t[59] = 88;
                t[60] = 89;
                t[61] = 90;
                t[62] = 91;
                t[63] = 92;
                t[64] = 93;
                t[65] = 94;
                t[66] = 95;
                t[67] = 96;
                t[68] = 97;
                t[69] = 98;
                t[70] = 99;
                t[71] = 100;
                t[72] = 101;
                t[73] = 102;
                t[74] = 103;
                t[75] = 104;
                t[76] = 105;
                t[77] = 106;
                t[78] = 107;
                t[79] = 108;
                t[80] = 109;
                t[81] = 110;
                t[82] = 111;
                t[83] = 112;
                t[84] = 113;
                t[85] = 114;
                t[86] = 115;
                t[87] = 116;
                t[88] = 117;
                t[89] = 118;
                t[90] = 119;
                t[91] = 120;
                t[92] = 121;
                t[93] = 122;
                t[94] = 123;
                t[95] = 124;
                t[96] = 125;
                t[97] = 126;
                t[98] = 196;
                t[99] = 197;
                t[100] = 199;
                t[101] = 201;
                t[102] = 209;
                t[103] = 214;
                t[104] = 220;
                t[105] = 225;
                t[106] = 224;
                t[107] = 226;
                t[108] = 228;
                t[109] = 227;
                t[110] = 229;
                t[111] = 231;
                t[112] = 233;
                t[113] = 232;
                t[114] = 234;
                t[115] = 235;
                t[116] = 237;
                t[117] = 236;
                t[118] = 238;
                t[119] = 239;
                t[120] = 241;
                t[121] = 243;
                t[122] = 242;
                t[123] = 244;
                t[124] = 246;
                t[125] = 245;
                t[126] = 250;
                t[127] = 249;
                t[128] = 251;
                t[129] = 252;
                t[130] = 8224;
                t[131] = 176;
                t[132] = 162;
                t[133] = 163;
                t[134] = 167;
                t[135] = 8226;
                t[136] = 182;
                t[137] = 223;
                t[138] = 174;
                t[139] = 169;
                t[140] = 8482;
                t[141] = 180;
                t[142] = 168;
                t[143] = 8800;
                t[144] = 198;
                t[145] = 216;
                t[146] = 8734;
                t[147] = 177;
                t[148] = 8804;
                t[149] = 8805;
                t[150] = 165;
                t[151] = 181;
                t[152] = 8706;
                t[153] = 8721;
                t[154] = 8719;
                t[156] = 8747;
                t[157] = 170;
                t[158] = 186;
                t[159] = 8486;
                t[160] = 230;
                t[161] = 248;
                t[162] = 191;
                t[163] = 161;
                t[164] = 172;
                t[165] = 8730;
                t[166] = 402;
                t[167] = 8776;
                t[168] = 8710;
                t[169] = 171;
                t[170] = 187;
                t[171] = 8230;
                t[200] = 193;
                t[203] = 205;
                t[210] = 218;
                t[223] = 711;
                t[224] = 321;
                t[225] = 322;
                t[226] = 352;
                t[227] = 353;
                t[228] = 381;
                t[229] = 382;
                t[233] = 221;
                t[234] = 253;
                t[252] = 263;
                t[253] = 268;
                t[254] = 269;
                t[258] = 258;
                t[260] = 260;
                t[261] = 261;
                t[265] = 280;
                t[266] = 281;
                t[267] = 282;
                t[268] = 283;
                t[269] = 313;
                t[275] = 323;
                t[276] = 324;
                t[278] = 328;
                t[283] = 344;
                t[284] = 345;
                t[285] = 346;
                t[286] = 347;
                t[292] = 367;
                t[295] = 377;
                t[296] = 378;
                t[298] = 380;
                t[305] = 963;
                t[306] = 964;
                t[307] = 966;
                t[308] = 8215;
                t[309] = 8252;
                t[310] = 8319;
                t[311] = 8359;
                t[312] = 8592;
                t[313] = 8593;
                t[337] = 9552;
                t[493] = 1039;
                t[494] = 1040;
                t[672] = 1488;
                t[673] = 1489;
                t[674] = 1490;
                t[675] = 1491;
                t[676] = 1492;
                t[677] = 1493;
                t[678] = 1494;
                t[679] = 1495;
                t[680] = 1496;
                t[681] = 1497;
                t[682] = 1498;
                t[683] = 1499;
                t[684] = 1500;
                t[685] = 1501;
                t[686] = 1502;
                t[687] = 1503;
                t[688] = 1504;
                t[689] = 1505;
                t[690] = 1506;
                t[691] = 1507;
                t[692] = 1508;
                t[693] = 1509;
                t[694] = 1510;
                t[695] = 1511;
                t[696] = 1512;
                t[697] = 1513;
                t[698] = 1514;
                t[705] = 1524;
                t[706] = 8362;
                t[710] = 64288;
                t[711] = 64298;
                t[759] = 1617;
                t[761] = 1776;
                t[763] = 1778;
                t[775] = 1652;
                t[777] = 1764;
                t[778] = 1780;
                t[779] = 1781;
                t[780] = 1782;
                t[782] = 771;
                t[783] = 64726;
                t[786] = 8363;
                t[788] = 8532;
                t[790] = 768;
                t[791] = 769;
                t[792] = 768;
                t[795] = 803;
                t[797] = 64336;
                t[798] = 64337;
                t[799] = 64342;
                t[800] = 64343;
                t[801] = 64344;
                t[802] = 64345;
                t[803] = 64362;
                t[804] = 64363;
                t[805] = 64364;
                t[2424] = 7821;
                t[2425] = 7822;
                t[2426] = 7823;
                t[2427] = 7824;
                t[2428] = 7825;
                t[2429] = 7826;
                t[2430] = 7827;
                t[2433] = 7682;
                t[2678] = 8045;
                t[2679] = 8046;
                t[2830] = 1552;
                t[2838] = 686;
                t[2840] = 751;
                t[2842] = 753;
                t[2843] = 754;
                t[2844] = 755;
                t[2846] = 757;
                t[2856] = 767;
                t[2857] = 848;
                t[2858] = 849;
                t[2862] = 853;
                t[2863] = 854;
                t[2864] = 855;
                t[2865] = 861;
                t[2866] = 862;
                t[2906] = 7460;
                t[2908] = 7462;
                t[2909] = 7463;
                t[2910] = 7464;
                t[2912] = 7466;
                t[2913] = 7467;
                t[2914] = 7468;
                t[2916] = 7470;
                t[2917] = 7471;
                t[2918] = 7472;
                t[2920] = 7474;
                t[2921] = 7475;
                t[2922] = 7476;
                t[2924] = 7478;
                t[2925] = 7479;
                t[2926] = 7480;
                t[2928] = 7482;
                t[2929] = 7483;
                t[2930] = 7484;
                t[2932] = 7486;
                t[2933] = 7487;
                t[2934] = 7488;
                t[2936] = 7490;
                t[2937] = 7491;
                t[2938] = 7492;
                t[2940] = 7494;
                t[2941] = 7495;
                t[2942] = 7496;
                t[2944] = 7498;
                t[2946] = 7500;
                t[2948] = 7502;
                t[2950] = 7504;
                t[2951] = 7505;
                t[2952] = 7506;
                t[2954] = 7508;
                t[2955] = 7509;
                t[2956] = 7510;
                t[2958] = 7512;
                t[2959] = 7513;
                t[2960] = 7514;
                t[2962] = 7516;
                t[2963] = 7517;
                t[2964] = 7518;
                t[2966] = 7520;
                t[2967] = 7521;
                t[2968] = 7522;
                t[2970] = 7524;
                t[2971] = 7525;
                t[2972] = 7526;
                t[2974] = 7528;
                t[2975] = 7529;
                t[2976] = 7530;
                t[2978] = 1537;
                t[2979] = 1538;
                t[2980] = 1539;
                t[2982] = 1549;
                t[2983] = 1551;
                t[2984] = 1552;
                t[2986] = 1554;
                t[2987] = 1555;
                t[2988] = 1556;
                t[2990] = 1623;
                t[2991] = 1624;
                t[2995] = 1775;
                t[2999] = 1791;
                t[3002] = 64290;
                t[3003] = 64291;
                t[3004] = 64292;
                t[3006] = 64294;
                t[3007] = 64295;
                t[3008] = 64296;
                t[3011] = 1900;
                t[3014] = 8223;
                t[3015] = 8244;
                t[3017] = 7532;
                t[3018] = 7533;
                t[3019] = 7534;
                t[3075] = 7590;
                t[3076] = 7591;
                t[3079] = 7594;
                t[3080] = 7595;
                t[3083] = 7598;
                t[3084] = 7599;
                t[3087] = 7602;
                t[3088] = 7603;
                t[3091] = 7606;
                t[3092] = 7607;
                t[3095] = 7610;
                t[3096] = 7611;
                t[3099] = 7614;
                t[3100] = 7615;
                t[3103] = 7618;
                t[3104] = 7619;
                t[3107] = 8337;
                t[3108] = 8338;
                t[3116] = 1884;
                t[3119] = 1885;
                t[3120] = 1885;
                t[3123] = 1886;
                t[3124] = 1886;
                t[3127] = 1887;
                t[3128] = 1887;
                t[3131] = 1888;
                t[3132] = 1888;
                t[3135] = 1889;
                t[3136] = 1889;
                t[3139] = 1890;
                t[3140] = 1890;
                t[3143] = 1891;
                t[3144] = 1891;
                t[3147] = 1892;
                t[3148] = 1892;
                t[3153] = 580;
                t[3154] = 581;
                t[3157] = 584;
                t[3158] = 585;
                t[3161] = 588;
                t[3162] = 589;
                t[3165] = 891;
                t[3166] = 892;
                t[3169] = 1274;
                t[3170] = 1275;
                t[3173] = 1278;
                t[3174] = 1279;
                t[3181] = 7622;
                t[3182] = 7623;
                t[3282] = 11799;
                t[3316] = 578;
                t[3379] = 42785;
                t[3393] = 1159;
                t[3416] = 8377;
              });
              exports2.getGlyphMapForStandardFonts = getGlyphMapForStandardFonts;
              const getSupplementalGlyphMapForArialBlack = (0, _core_utils.getLookupTableFactory)(function(t) {
                t[227] = 322;
                t[264] = 261;
                t[291] = 346;
              });
              exports2.getSupplementalGlyphMapForArialBlack = getSupplementalGlyphMapForArialBlack;
              const getSupplementalGlyphMapForCalibri = (0, _core_utils.getLookupTableFactory)(function(t) {
                t[1] = 32;
                t[4] = 65;
                t[6] = 193;
                t[17] = 66;
                t[18] = 67;
                t[21] = 268;
                t[24] = 68;
                t[28] = 69;
                t[30] = 201;
                t[32] = 282;
                t[38] = 70;
                t[39] = 71;
                t[44] = 72;
                t[47] = 73;
                t[49] = 205;
                t[58] = 74;
                t[60] = 75;
                t[62] = 76;
                t[68] = 77;
                t[69] = 78;
                t[75] = 79;
                t[87] = 80;
                t[89] = 81;
                t[90] = 82;
                t[92] = 344;
                t[94] = 83;
                t[97] = 352;
                t[100] = 84;
                t[104] = 85;
                t[115] = 86;
                t[116] = 87;
                t[121] = 88;
                t[122] = 89;
                t[124] = 221;
                t[127] = 90;
                t[129] = 381;
                t[258] = 97;
                t[260] = 225;
                t[268] = 261;
                t[271] = 98;
                t[272] = 99;
                t[273] = 263;
                t[275] = 269;
                t[282] = 100;
                t[286] = 101;
                t[288] = 233;
                t[290] = 283;
                t[295] = 281;
                t[296] = 102;
                t[336] = 103;
                t[346] = 104;
                t[349] = 105;
                t[351] = 237;
                t[361] = 106;
                t[364] = 107;
                t[367] = 108;
                t[371] = 322;
                t[373] = 109;
                t[374] = 110;
                t[381] = 111;
                t[383] = 243;
                t[393] = 112;
                t[395] = 113;
                t[396] = 114;
                t[398] = 345;
                t[400] = 115;
                t[401] = 347;
                t[403] = 353;
                t[410] = 116;
                t[437] = 117;
                t[448] = 118;
                t[449] = 119;
                t[454] = 120;
                t[455] = 121;
                t[457] = 253;
                t[460] = 122;
                t[462] = 382;
                t[463] = 380;
                t[853] = 44;
                t[855] = 58;
                t[856] = 46;
                t[876] = 47;
                t[878] = 45;
                t[882] = 45;
                t[894] = 40;
                t[895] = 41;
                t[896] = 91;
                t[897] = 93;
                t[923] = 64;
                t[1004] = 48;
                t[1005] = 49;
                t[1006] = 50;
                t[1007] = 51;
                t[1008] = 52;
                t[1009] = 53;
                t[1010] = 54;
                t[1011] = 55;
                t[1012] = 56;
                t[1013] = 57;
                t[1081] = 37;
                t[1085] = 43;
                t[1086] = 45;
              });
              exports2.getSupplementalGlyphMapForCalibri = getSupplementalGlyphMapForCalibri;
              function getStandardFontName(name) {
                const fontName = (0, _fonts_utils.normalizeFontName)(name);
                const stdFontMap = getStdFontMap();
                return stdFontMap[fontName];
              }
              __name(getStandardFontName, "getStandardFontName");
            },
            /* 167 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.ToUnicodeMap = exports2.IdentityToUnicodeMap = void 0;
              var _util = __w_pdfjs_require__2(2);
              const _ToUnicodeMap = class _ToUnicodeMap {
                constructor() {
                  let cmap = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
                  this._map = cmap;
                }
                get length() {
                  return this._map.length;
                }
                forEach(callback) {
                  for (const charCode in this._map) {
                    callback(charCode, this._map[charCode].charCodeAt(0));
                  }
                }
                has(i) {
                  return this._map[i] !== void 0;
                }
                get(i) {
                  return this._map[i];
                }
                charCodeOf(value) {
                  const map = this._map;
                  if (map.length <= 65536) {
                    return map.indexOf(value);
                  }
                  for (const charCode in map) {
                    if (map[charCode] === value) {
                      return charCode | 0;
                    }
                  }
                  return -1;
                }
                amend(map) {
                  for (const charCode in map) {
                    this._map[charCode] = map[charCode];
                  }
                }
              };
              __name(_ToUnicodeMap, "ToUnicodeMap");
              let ToUnicodeMap = _ToUnicodeMap;
              exports2.ToUnicodeMap = ToUnicodeMap;
              const _IdentityToUnicodeMap = class _IdentityToUnicodeMap {
                constructor(firstChar, lastChar) {
                  this.firstChar = firstChar;
                  this.lastChar = lastChar;
                }
                get length() {
                  return this.lastChar + 1 - this.firstChar;
                }
                forEach(callback) {
                  for (let i = this.firstChar, ii = this.lastChar; i <= ii; i++) {
                    callback(i, i);
                  }
                }
                has(i) {
                  return this.firstChar <= i && i <= this.lastChar;
                }
                get(i) {
                  if (this.firstChar <= i && i <= this.lastChar) {
                    return String.fromCharCode(i);
                  }
                  return void 0;
                }
                charCodeOf(v) {
                  return Number.isInteger(v) && v >= this.firstChar && v <= this.lastChar ? v : -1;
                }
                amend(map) {
                  (0, _util.unreachable)("Should not call amend()");
                }
              };
              __name(_IdentityToUnicodeMap, "IdentityToUnicodeMap");
              let IdentityToUnicodeMap = _IdentityToUnicodeMap;
              exports2.IdentityToUnicodeMap = IdentityToUnicodeMap;
            },
            /* 168 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.CFFFont = void 0;
              var _cff_parser = __w_pdfjs_require__2(160);
              var _fonts_utils = __w_pdfjs_require__2(163);
              var _util = __w_pdfjs_require__2(2);
              const _CFFFont = class _CFFFont {
                constructor(file, properties) {
                  this.properties = properties;
                  const parser = new _cff_parser.CFFParser(file, properties, _fonts_utils.SEAC_ANALYSIS_ENABLED);
                  this.cff = parser.parse();
                  this.cff.duplicateFirstGlyph();
                  const compiler = new _cff_parser.CFFCompiler(this.cff);
                  this.seacs = this.cff.seacs;
                  try {
                    this.data = compiler.compile();
                  } catch (e) {
                    (0, _util.warn)("Failed to compile font " + properties.loadedName);
                    this.data = file;
                  }
                  this._createBuiltInEncoding();
                }
                get numGlyphs() {
                  return this.cff.charStrings.count;
                }
                getCharset() {
                  return this.cff.charset.charset;
                }
                getGlyphMapping() {
                  const cff = this.cff;
                  const properties = this.properties;
                  const charsets = cff.charset.charset;
                  let charCodeToGlyphId;
                  let glyphId;
                  if (properties.composite) {
                    charCodeToGlyphId = /* @__PURE__ */ Object.create(null);
                    let charCode;
                    if (cff.isCIDFont) {
                      for (glyphId = 0; glyphId < charsets.length; glyphId++) {
                        const cid = charsets[glyphId];
                        charCode = properties.cMap.charCodeOf(cid);
                        charCodeToGlyphId[charCode] = glyphId;
                      }
                    } else {
                      for (glyphId = 0; glyphId < cff.charStrings.count; glyphId++) {
                        charCode = properties.cMap.charCodeOf(glyphId);
                        charCodeToGlyphId[charCode] = glyphId;
                      }
                    }
                    return charCodeToGlyphId;
                  }
                  let encoding = cff.encoding ? cff.encoding.encoding : null;
                  if (properties.isInternalFont) {
                    encoding = properties.defaultEncoding;
                  }
                  charCodeToGlyphId = (0, _fonts_utils.type1FontGlyphMapping)(properties, encoding, charsets);
                  return charCodeToGlyphId;
                }
                hasGlyphId(id) {
                  return this.cff.hasGlyphId(id);
                }
                _createBuiltInEncoding() {
                  const {
                    charset,
                    encoding
                  } = this.cff;
                  if (!charset || !encoding) {
                    return;
                  }
                  const charsets = charset.charset, encodings = encoding.encoding;
                  const map = [];
                  for (const charCode in encodings) {
                    const glyphId = encodings[charCode];
                    if (glyphId >= 0) {
                      const glyphName = charsets[glyphId];
                      if (glyphName) {
                        map[charCode] = glyphName;
                      }
                    }
                  }
                  if (map.length > 0) {
                    this.properties.builtInEncoding = map;
                  }
                }
              };
              __name(_CFFFont, "CFFFont");
              let CFFFont = _CFFFont;
              exports2.CFFFont = CFFFont;
            },
            /* 169 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.FontRendererFactory = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _cff_parser = __w_pdfjs_require__2(160);
              var _glyphlist = __w_pdfjs_require__2(164);
              var _encodings = __w_pdfjs_require__2(162);
              var _stream = __w_pdfjs_require__2(135);
              function getUint32(data, offset) {
                return (data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3]) >>> 0;
              }
              __name(getUint32, "getUint32");
              function getUint16(data, offset) {
                return data[offset] << 8 | data[offset + 1];
              }
              __name(getUint16, "getUint16");
              function getInt16(data, offset) {
                return (data[offset] << 24 | data[offset + 1] << 16) >> 16;
              }
              __name(getInt16, "getInt16");
              function getInt8(data, offset) {
                return data[offset] << 24 >> 24;
              }
              __name(getInt8, "getInt8");
              function getFloat214(data, offset) {
                return getInt16(data, offset) / 16384;
              }
              __name(getFloat214, "getFloat214");
              function getSubroutineBias(subrs) {
                const numSubrs = subrs.length;
                let bias = 32768;
                if (numSubrs < 1240) {
                  bias = 107;
                } else if (numSubrs < 33900) {
                  bias = 1131;
                }
                return bias;
              }
              __name(getSubroutineBias, "getSubroutineBias");
              function parseCmap(data, start, end) {
                const offset = getUint16(data, start + 2) === 1 ? getUint32(data, start + 8) : getUint32(data, start + 16);
                const format = getUint16(data, start + offset);
                let ranges, p, i;
                if (format === 4) {
                  getUint16(data, start + offset + 2);
                  const segCount = getUint16(data, start + offset + 6) >> 1;
                  p = start + offset + 14;
                  ranges = [];
                  for (i = 0; i < segCount; i++, p += 2) {
                    ranges[i] = {
                      end: getUint16(data, p)
                    };
                  }
                  p += 2;
                  for (i = 0; i < segCount; i++, p += 2) {
                    ranges[i].start = getUint16(data, p);
                  }
                  for (i = 0; i < segCount; i++, p += 2) {
                    ranges[i].idDelta = getUint16(data, p);
                  }
                  for (i = 0; i < segCount; i++, p += 2) {
                    let idOffset = getUint16(data, p);
                    if (idOffset === 0) {
                      continue;
                    }
                    ranges[i].ids = [];
                    for (let j = 0, jj = ranges[i].end - ranges[i].start + 1; j < jj; j++) {
                      ranges[i].ids[j] = getUint16(data, p + idOffset);
                      idOffset += 2;
                    }
                  }
                  return ranges;
                } else if (format === 12) {
                  const groups = getUint32(data, start + offset + 12);
                  p = start + offset + 16;
                  ranges = [];
                  for (i = 0; i < groups; i++) {
                    start = getUint32(data, p);
                    ranges.push({
                      start,
                      end: getUint32(data, p + 4),
                      idDelta: getUint32(data, p + 8) - start
                    });
                    p += 12;
                  }
                  return ranges;
                }
                throw new _util.FormatError(`unsupported cmap: ${format}`);
              }
              __name(parseCmap, "parseCmap");
              function parseCff(data, start, end, seacAnalysisEnabled) {
                const properties = {};
                const parser = new _cff_parser.CFFParser(new _stream.Stream(data, start, end - start), properties, seacAnalysisEnabled);
                const cff = parser.parse();
                return {
                  glyphs: cff.charStrings.objects,
                  subrs: cff.topDict.privateDict && cff.topDict.privateDict.subrsIndex && cff.topDict.privateDict.subrsIndex.objects,
                  gsubrs: cff.globalSubrIndex && cff.globalSubrIndex.objects,
                  isCFFCIDFont: cff.isCIDFont,
                  fdSelect: cff.fdSelect,
                  fdArray: cff.fdArray
                };
              }
              __name(parseCff, "parseCff");
              function parseGlyfTable(glyf, loca, isGlyphLocationsLong) {
                let itemSize, itemDecode;
                if (isGlyphLocationsLong) {
                  itemSize = 4;
                  itemDecode = getUint32;
                } else {
                  itemSize = 2;
                  itemDecode = /* @__PURE__ */ __name((data, offset) => 2 * getUint16(data, offset), "itemDecode");
                }
                const glyphs = [];
                let startOffset = itemDecode(loca, 0);
                for (let j = itemSize; j < loca.length; j += itemSize) {
                  const endOffset = itemDecode(loca, j);
                  glyphs.push(glyf.subarray(startOffset, endOffset));
                  startOffset = endOffset;
                }
                return glyphs;
              }
              __name(parseGlyfTable, "parseGlyfTable");
              function lookupCmap(ranges, unicode) {
                const code = unicode.codePointAt(0);
                let gid = 0, l = 0, r = ranges.length - 1;
                while (l < r) {
                  const c = l + r + 1 >> 1;
                  if (code < ranges[c].start) {
                    r = c - 1;
                  } else {
                    l = c;
                  }
                }
                if (ranges[l].start <= code && code <= ranges[l].end) {
                  gid = ranges[l].idDelta + (ranges[l].ids ? ranges[l].ids[code - ranges[l].start] : code) & 65535;
                }
                return {
                  charCode: code,
                  glyphId: gid
                };
              }
              __name(lookupCmap, "lookupCmap");
              function compileGlyf(code, cmds, font) {
                function moveTo(x2, y2) {
                  cmds.push({
                    cmd: "moveTo",
                    args: [x2, y2]
                  });
                }
                __name(moveTo, "moveTo");
                function lineTo(x2, y2) {
                  cmds.push({
                    cmd: "lineTo",
                    args: [x2, y2]
                  });
                }
                __name(lineTo, "lineTo");
                function quadraticCurveTo(xa, ya, x2, y2) {
                  cmds.push({
                    cmd: "quadraticCurveTo",
                    args: [xa, ya, x2, y2]
                  });
                }
                __name(quadraticCurveTo, "quadraticCurveTo");
                let i = 0;
                const numberOfContours = getInt16(code, i);
                let flags;
                let x = 0, y = 0;
                i += 10;
                if (numberOfContours < 0) {
                  do {
                    flags = getUint16(code, i);
                    const glyphIndex = getUint16(code, i + 2);
                    i += 4;
                    let arg1, arg2;
                    if (flags & 1) {
                      if (flags & 2) {
                        arg1 = getInt16(code, i);
                        arg2 = getInt16(code, i + 2);
                      } else {
                        arg1 = getUint16(code, i);
                        arg2 = getUint16(code, i + 2);
                      }
                      i += 4;
                    } else {
                      if (flags & 2) {
                        arg1 = getInt8(code, i++);
                        arg2 = getInt8(code, i++);
                      } else {
                        arg1 = code[i++];
                        arg2 = code[i++];
                      }
                    }
                    if (flags & 2) {
                      x = arg1;
                      y = arg2;
                    } else {
                      x = 0;
                      y = 0;
                    }
                    let scaleX = 1, scaleY = 1, scale01 = 0, scale10 = 0;
                    if (flags & 8) {
                      scaleX = scaleY = getFloat214(code, i);
                      i += 2;
                    } else if (flags & 64) {
                      scaleX = getFloat214(code, i);
                      scaleY = getFloat214(code, i + 2);
                      i += 4;
                    } else if (flags & 128) {
                      scaleX = getFloat214(code, i);
                      scale01 = getFloat214(code, i + 2);
                      scale10 = getFloat214(code, i + 4);
                      scaleY = getFloat214(code, i + 6);
                      i += 8;
                    }
                    const subglyph = font.glyphs[glyphIndex];
                    if (subglyph) {
                      cmds.push({
                        cmd: "save"
                      }, {
                        cmd: "transform",
                        args: [scaleX, scale01, scale10, scaleY, x, y]
                      });
                      compileGlyf(subglyph, cmds, font);
                      cmds.push({
                        cmd: "restore"
                      });
                    }
                  } while (flags & 32);
                } else {
                  const endPtsOfContours = [];
                  let j, jj;
                  for (j = 0; j < numberOfContours; j++) {
                    endPtsOfContours.push(getUint16(code, i));
                    i += 2;
                  }
                  const instructionLength = getUint16(code, i);
                  i += 2 + instructionLength;
                  const numberOfPoints = endPtsOfContours.at(-1) + 1;
                  const points = [];
                  while (points.length < numberOfPoints) {
                    flags = code[i++];
                    let repeat = 1;
                    if (flags & 8) {
                      repeat += code[i++];
                    }
                    while (repeat-- > 0) {
                      points.push({
                        flags
                      });
                    }
                  }
                  for (j = 0; j < numberOfPoints; j++) {
                    switch (points[j].flags & 18) {
                      case 0:
                        x += getInt16(code, i);
                        i += 2;
                        break;
                      case 2:
                        x -= code[i++];
                        break;
                      case 18:
                        x += code[i++];
                        break;
                    }
                    points[j].x = x;
                  }
                  for (j = 0; j < numberOfPoints; j++) {
                    switch (points[j].flags & 36) {
                      case 0:
                        y += getInt16(code, i);
                        i += 2;
                        break;
                      case 4:
                        y -= code[i++];
                        break;
                      case 36:
                        y += code[i++];
                        break;
                    }
                    points[j].y = y;
                  }
                  let startPoint = 0;
                  for (i = 0; i < numberOfContours; i++) {
                    const endPoint = endPtsOfContours[i];
                    const contour = points.slice(startPoint, endPoint + 1);
                    if (contour[0].flags & 1) {
                      contour.push(contour[0]);
                    } else if (contour.at(-1).flags & 1) {
                      contour.unshift(contour.at(-1));
                    } else {
                      const p = {
                        flags: 1,
                        x: (contour[0].x + contour.at(-1).x) / 2,
                        y: (contour[0].y + contour.at(-1).y) / 2
                      };
                      contour.unshift(p);
                      contour.push(p);
                    }
                    moveTo(contour[0].x, contour[0].y);
                    for (j = 1, jj = contour.length; j < jj; j++) {
                      if (contour[j].flags & 1) {
                        lineTo(contour[j].x, contour[j].y);
                      } else if (contour[j + 1].flags & 1) {
                        quadraticCurveTo(contour[j].x, contour[j].y, contour[j + 1].x, contour[j + 1].y);
                        j++;
                      } else {
                        quadraticCurveTo(contour[j].x, contour[j].y, (contour[j].x + contour[j + 1].x) / 2, (contour[j].y + contour[j + 1].y) / 2);
                      }
                    }
                    startPoint = endPoint + 1;
                  }
                }
              }
              __name(compileGlyf, "compileGlyf");
              function compileCharString(charStringCode, cmds, font, glyphId) {
                function moveTo(x2, y2) {
                  cmds.push({
                    cmd: "moveTo",
                    args: [x2, y2]
                  });
                }
                __name(moveTo, "moveTo");
                function lineTo(x2, y2) {
                  cmds.push({
                    cmd: "lineTo",
                    args: [x2, y2]
                  });
                }
                __name(lineTo, "lineTo");
                function bezierCurveTo(x1, y1, x2, y2, x3, y3) {
                  cmds.push({
                    cmd: "bezierCurveTo",
                    args: [x1, y1, x2, y2, x3, y3]
                  });
                }
                __name(bezierCurveTo, "bezierCurveTo");
                const stack = [];
                let x = 0, y = 0;
                let stems = 0;
                function parse(code) {
                  let i = 0;
                  while (i < code.length) {
                    let stackClean = false;
                    let v = code[i++];
                    let xa, xb, ya, yb, y1, y2, y3, n, subrCode;
                    switch (v) {
                      case 1:
                        stems += stack.length >> 1;
                        stackClean = true;
                        break;
                      case 3:
                        stems += stack.length >> 1;
                        stackClean = true;
                        break;
                      case 4:
                        y += stack.pop();
                        moveTo(x, y);
                        stackClean = true;
                        break;
                      case 5:
                        while (stack.length > 0) {
                          x += stack.shift();
                          y += stack.shift();
                          lineTo(x, y);
                        }
                        break;
                      case 6:
                        while (stack.length > 0) {
                          x += stack.shift();
                          lineTo(x, y);
                          if (stack.length === 0) {
                            break;
                          }
                          y += stack.shift();
                          lineTo(x, y);
                        }
                        break;
                      case 7:
                        while (stack.length > 0) {
                          y += stack.shift();
                          lineTo(x, y);
                          if (stack.length === 0) {
                            break;
                          }
                          x += stack.shift();
                          lineTo(x, y);
                        }
                        break;
                      case 8:
                        while (stack.length > 0) {
                          xa = x + stack.shift();
                          ya = y + stack.shift();
                          xb = xa + stack.shift();
                          yb = ya + stack.shift();
                          x = xb + stack.shift();
                          y = yb + stack.shift();
                          bezierCurveTo(xa, ya, xb, yb, x, y);
                        }
                        break;
                      case 10:
                        n = stack.pop();
                        subrCode = null;
                        if (font.isCFFCIDFont) {
                          const fdIndex = font.fdSelect.getFDIndex(glyphId);
                          if (fdIndex >= 0 && fdIndex < font.fdArray.length) {
                            const fontDict = font.fdArray[fdIndex];
                            let subrs;
                            if (fontDict.privateDict && fontDict.privateDict.subrsIndex) {
                              subrs = fontDict.privateDict.subrsIndex.objects;
                            }
                            if (subrs) {
                              n += getSubroutineBias(subrs);
                              subrCode = subrs[n];
                            }
                          } else {
                            (0, _util.warn)("Invalid fd index for glyph index.");
                          }
                        } else {
                          subrCode = font.subrs[n + font.subrsBias];
                        }
                        if (subrCode) {
                          parse(subrCode);
                        }
                        break;
                      case 11:
                        return;
                      case 12:
                        v = code[i++];
                        switch (v) {
                          case 34:
                            xa = x + stack.shift();
                            xb = xa + stack.shift();
                            y1 = y + stack.shift();
                            x = xb + stack.shift();
                            bezierCurveTo(xa, y, xb, y1, x, y1);
                            xa = x + stack.shift();
                            xb = xa + stack.shift();
                            x = xb + stack.shift();
                            bezierCurveTo(xa, y1, xb, y, x, y);
                            break;
                          case 35:
                            xa = x + stack.shift();
                            ya = y + stack.shift();
                            xb = xa + stack.shift();
                            yb = ya + stack.shift();
                            x = xb + stack.shift();
                            y = yb + stack.shift();
                            bezierCurveTo(xa, ya, xb, yb, x, y);
                            xa = x + stack.shift();
                            ya = y + stack.shift();
                            xb = xa + stack.shift();
                            yb = ya + stack.shift();
                            x = xb + stack.shift();
                            y = yb + stack.shift();
                            bezierCurveTo(xa, ya, xb, yb, x, y);
                            stack.pop();
                            break;
                          case 36:
                            xa = x + stack.shift();
                            y1 = y + stack.shift();
                            xb = xa + stack.shift();
                            y2 = y1 + stack.shift();
                            x = xb + stack.shift();
                            bezierCurveTo(xa, y1, xb, y2, x, y2);
                            xa = x + stack.shift();
                            xb = xa + stack.shift();
                            y3 = y2 + stack.shift();
                            x = xb + stack.shift();
                            bezierCurveTo(xa, y2, xb, y3, x, y);
                            break;
                          case 37:
                            const x0 = x, y0 = y;
                            xa = x + stack.shift();
                            ya = y + stack.shift();
                            xb = xa + stack.shift();
                            yb = ya + stack.shift();
                            x = xb + stack.shift();
                            y = yb + stack.shift();
                            bezierCurveTo(xa, ya, xb, yb, x, y);
                            xa = x + stack.shift();
                            ya = y + stack.shift();
                            xb = xa + stack.shift();
                            yb = ya + stack.shift();
                            x = xb;
                            y = yb;
                            if (Math.abs(x - x0) > Math.abs(y - y0)) {
                              x += stack.shift();
                            } else {
                              y += stack.shift();
                            }
                            bezierCurveTo(xa, ya, xb, yb, x, y);
                            break;
                          default:
                            throw new _util.FormatError(`unknown operator: 12 ${v}`);
                        }
                        break;
                      case 14:
                        if (stack.length >= 4) {
                          const achar = stack.pop();
                          const bchar = stack.pop();
                          y = stack.pop();
                          x = stack.pop();
                          cmds.push({
                            cmd: "save"
                          }, {
                            cmd: "translate",
                            args: [x, y]
                          });
                          let cmap = lookupCmap(font.cmap, String.fromCharCode(font.glyphNameMap[_encodings.StandardEncoding[achar]]));
                          compileCharString(font.glyphs[cmap.glyphId], cmds, font, cmap.glyphId);
                          cmds.push({
                            cmd: "restore"
                          });
                          cmap = lookupCmap(font.cmap, String.fromCharCode(font.glyphNameMap[_encodings.StandardEncoding[bchar]]));
                          compileCharString(font.glyphs[cmap.glyphId], cmds, font, cmap.glyphId);
                        }
                        return;
                      case 18:
                        stems += stack.length >> 1;
                        stackClean = true;
                        break;
                      case 19:
                        stems += stack.length >> 1;
                        i += stems + 7 >> 3;
                        stackClean = true;
                        break;
                      case 20:
                        stems += stack.length >> 1;
                        i += stems + 7 >> 3;
                        stackClean = true;
                        break;
                      case 21:
                        y += stack.pop();
                        x += stack.pop();
                        moveTo(x, y);
                        stackClean = true;
                        break;
                      case 22:
                        x += stack.pop();
                        moveTo(x, y);
                        stackClean = true;
                        break;
                      case 23:
                        stems += stack.length >> 1;
                        stackClean = true;
                        break;
                      case 24:
                        while (stack.length > 2) {
                          xa = x + stack.shift();
                          ya = y + stack.shift();
                          xb = xa + stack.shift();
                          yb = ya + stack.shift();
                          x = xb + stack.shift();
                          y = yb + stack.shift();
                          bezierCurveTo(xa, ya, xb, yb, x, y);
                        }
                        x += stack.shift();
                        y += stack.shift();
                        lineTo(x, y);
                        break;
                      case 25:
                        while (stack.length > 6) {
                          x += stack.shift();
                          y += stack.shift();
                          lineTo(x, y);
                        }
                        xa = x + stack.shift();
                        ya = y + stack.shift();
                        xb = xa + stack.shift();
                        yb = ya + stack.shift();
                        x = xb + stack.shift();
                        y = yb + stack.shift();
                        bezierCurveTo(xa, ya, xb, yb, x, y);
                        break;
                      case 26:
                        if (stack.length % 2) {
                          x += stack.shift();
                        }
                        while (stack.length > 0) {
                          xa = x;
                          ya = y + stack.shift();
                          xb = xa + stack.shift();
                          yb = ya + stack.shift();
                          x = xb;
                          y = yb + stack.shift();
                          bezierCurveTo(xa, ya, xb, yb, x, y);
                        }
                        break;
                      case 27:
                        if (stack.length % 2) {
                          y += stack.shift();
                        }
                        while (stack.length > 0) {
                          xa = x + stack.shift();
                          ya = y;
                          xb = xa + stack.shift();
                          yb = ya + stack.shift();
                          x = xb + stack.shift();
                          y = yb;
                          bezierCurveTo(xa, ya, xb, yb, x, y);
                        }
                        break;
                      case 28:
                        stack.push((code[i] << 24 | code[i + 1] << 16) >> 16);
                        i += 2;
                        break;
                      case 29:
                        n = stack.pop() + font.gsubrsBias;
                        subrCode = font.gsubrs[n];
                        if (subrCode) {
                          parse(subrCode);
                        }
                        break;
                      case 30:
                        while (stack.length > 0) {
                          xa = x;
                          ya = y + stack.shift();
                          xb = xa + stack.shift();
                          yb = ya + stack.shift();
                          x = xb + stack.shift();
                          y = yb + (stack.length === 1 ? stack.shift() : 0);
                          bezierCurveTo(xa, ya, xb, yb, x, y);
                          if (stack.length === 0) {
                            break;
                          }
                          xa = x + stack.shift();
                          ya = y;
                          xb = xa + stack.shift();
                          yb = ya + stack.shift();
                          y = yb + stack.shift();
                          x = xb + (stack.length === 1 ? stack.shift() : 0);
                          bezierCurveTo(xa, ya, xb, yb, x, y);
                        }
                        break;
                      case 31:
                        while (stack.length > 0) {
                          xa = x + stack.shift();
                          ya = y;
                          xb = xa + stack.shift();
                          yb = ya + stack.shift();
                          y = yb + stack.shift();
                          x = xb + (stack.length === 1 ? stack.shift() : 0);
                          bezierCurveTo(xa, ya, xb, yb, x, y);
                          if (stack.length === 0) {
                            break;
                          }
                          xa = x;
                          ya = y + stack.shift();
                          xb = xa + stack.shift();
                          yb = ya + stack.shift();
                          x = xb + stack.shift();
                          y = yb + (stack.length === 1 ? stack.shift() : 0);
                          bezierCurveTo(xa, ya, xb, yb, x, y);
                        }
                        break;
                      default:
                        if (v < 32) {
                          throw new _util.FormatError(`unknown operator: ${v}`);
                        }
                        if (v < 247) {
                          stack.push(v - 139);
                        } else if (v < 251) {
                          stack.push((v - 247) * 256 + code[i++] + 108);
                        } else if (v < 255) {
                          stack.push(-(v - 251) * 256 - code[i++] - 108);
                        } else {
                          stack.push((code[i] << 24 | code[i + 1] << 16 | code[i + 2] << 8 | code[i + 3]) / 65536);
                          i += 4;
                        }
                        break;
                    }
                    if (stackClean) {
                      stack.length = 0;
                    }
                  }
                }
                __name(parse, "parse");
                parse(charStringCode);
              }
              __name(compileCharString, "compileCharString");
              const NOOP = [];
              const _CompiledFont = class _CompiledFont {
                constructor(fontMatrix) {
                  if (this.constructor === _CompiledFont) {
                    (0, _util.unreachable)("Cannot initialize CompiledFont.");
                  }
                  this.fontMatrix = fontMatrix;
                  this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
                  this.compiledCharCodeToGlyphId = /* @__PURE__ */ Object.create(null);
                }
                getPathJs(unicode) {
                  const {
                    charCode,
                    glyphId
                  } = lookupCmap(this.cmap, unicode);
                  let fn = this.compiledGlyphs[glyphId];
                  if (!fn) {
                    try {
                      fn = this.compileGlyph(this.glyphs[glyphId], glyphId);
                      this.compiledGlyphs[glyphId] = fn;
                    } catch (ex) {
                      this.compiledGlyphs[glyphId] = NOOP;
                      if (this.compiledCharCodeToGlyphId[charCode] === void 0) {
                        this.compiledCharCodeToGlyphId[charCode] = glyphId;
                      }
                      throw ex;
                    }
                  }
                  if (this.compiledCharCodeToGlyphId[charCode] === void 0) {
                    this.compiledCharCodeToGlyphId[charCode] = glyphId;
                  }
                  return fn;
                }
                compileGlyph(code, glyphId) {
                  if (!code || code.length === 0 || code[0] === 14) {
                    return NOOP;
                  }
                  let fontMatrix = this.fontMatrix;
                  if (this.isCFFCIDFont) {
                    const fdIndex = this.fdSelect.getFDIndex(glyphId);
                    if (fdIndex >= 0 && fdIndex < this.fdArray.length) {
                      const fontDict = this.fdArray[fdIndex];
                      fontMatrix = fontDict.getByName("FontMatrix") || _util.FONT_IDENTITY_MATRIX;
                    } else {
                      (0, _util.warn)("Invalid fd index for glyph index.");
                    }
                  }
                  const cmds = [{
                    cmd: "save"
                  }, {
                    cmd: "transform",
                    args: fontMatrix.slice()
                  }, {
                    cmd: "scale",
                    args: ["size", "-size"]
                  }];
                  this.compileGlyphImpl(code, cmds, glyphId);
                  cmds.push({
                    cmd: "restore"
                  });
                  return cmds;
                }
                compileGlyphImpl() {
                  (0, _util.unreachable)("Children classes should implement this.");
                }
                hasBuiltPath(unicode) {
                  const {
                    charCode,
                    glyphId
                  } = lookupCmap(this.cmap, unicode);
                  return this.compiledGlyphs[glyphId] !== void 0 && this.compiledCharCodeToGlyphId[charCode] !== void 0;
                }
              };
              __name(_CompiledFont, "CompiledFont");
              let CompiledFont = _CompiledFont;
              const _TrueTypeCompiled = class _TrueTypeCompiled extends CompiledFont {
                constructor(glyphs, cmap, fontMatrix) {
                  super(fontMatrix || [488e-6, 0, 0, 488e-6, 0, 0]);
                  this.glyphs = glyphs;
                  this.cmap = cmap;
                }
                compileGlyphImpl(code, cmds) {
                  compileGlyf(code, cmds, this);
                }
              };
              __name(_TrueTypeCompiled, "TrueTypeCompiled");
              let TrueTypeCompiled = _TrueTypeCompiled;
              const _Type2Compiled = class _Type2Compiled extends CompiledFont {
                constructor(cffInfo, cmap, fontMatrix, glyphNameMap) {
                  super(fontMatrix || [1e-3, 0, 0, 1e-3, 0, 0]);
                  this.glyphs = cffInfo.glyphs;
                  this.gsubrs = cffInfo.gsubrs || [];
                  this.subrs = cffInfo.subrs || [];
                  this.cmap = cmap;
                  this.glyphNameMap = glyphNameMap || (0, _glyphlist.getGlyphsUnicode)();
                  this.gsubrsBias = getSubroutineBias(this.gsubrs);
                  this.subrsBias = getSubroutineBias(this.subrs);
                  this.isCFFCIDFont = cffInfo.isCFFCIDFont;
                  this.fdSelect = cffInfo.fdSelect;
                  this.fdArray = cffInfo.fdArray;
                }
                compileGlyphImpl(code, cmds, glyphId) {
                  compileCharString(code, cmds, this, glyphId);
                }
              };
              __name(_Type2Compiled, "Type2Compiled");
              let Type2Compiled = _Type2Compiled;
              const _FontRendererFactory = class _FontRendererFactory {
                static create(font, seacAnalysisEnabled) {
                  const data = new Uint8Array(font.data);
                  let cmap, glyf, loca, cff, indexToLocFormat, unitsPerEm;
                  const numTables = getUint16(data, 4);
                  for (let i = 0, p = 12; i < numTables; i++, p += 16) {
                    const tag = (0, _util.bytesToString)(data.subarray(p, p + 4));
                    const offset = getUint32(data, p + 8);
                    const length = getUint32(data, p + 12);
                    switch (tag) {
                      case "cmap":
                        cmap = parseCmap(data, offset);
                        break;
                      case "glyf":
                        glyf = data.subarray(offset, offset + length);
                        break;
                      case "loca":
                        loca = data.subarray(offset, offset + length);
                        break;
                      case "head":
                        unitsPerEm = getUint16(data, offset + 18);
                        indexToLocFormat = getUint16(data, offset + 50);
                        break;
                      case "CFF ":
                        cff = parseCff(data, offset, offset + length, seacAnalysisEnabled);
                        break;
                    }
                  }
                  if (glyf) {
                    const fontMatrix = !unitsPerEm ? font.fontMatrix : [1 / unitsPerEm, 0, 0, 1 / unitsPerEm, 0, 0];
                    return new TrueTypeCompiled(parseGlyfTable(glyf, loca, indexToLocFormat), cmap, fontMatrix);
                  }
                  return new Type2Compiled(cff, cmap, font.fontMatrix, font.glyphNameMap);
                }
              };
              __name(_FontRendererFactory, "FontRendererFactory");
              let FontRendererFactory = _FontRendererFactory;
              exports2.FontRendererFactory = FontRendererFactory;
            },
            /* 170 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.getMetrics = exports2.getFontBasicMetrics = void 0;
              var _core_utils = __w_pdfjs_require__2(131);
              const getMetrics = (0, _core_utils.getLookupTableFactory)(function(t) {
                t.Courier = 600;
                t["Courier-Bold"] = 600;
                t["Courier-BoldOblique"] = 600;
                t["Courier-Oblique"] = 600;
                t.Helvetica = (0, _core_utils.getLookupTableFactory)(function(t2) {
                  t2.space = 278;
                  t2.exclam = 278;
                  t2.quotedbl = 355;
                  t2.numbersign = 556;
                  t2.dollar = 556;
                  t2.percent = 889;
                  t2.ampersand = 667;
                  t2.quoteright = 222;
                  t2.parenleft = 333;
                  t2.parenright = 333;
                  t2.asterisk = 389;
                  t2.plus = 584;
                  t2.comma = 278;
                  t2.hyphen = 333;
                  t2.period = 278;
                  t2.slash = 278;
                  t2.zero = 556;
                  t2.one = 556;
                  t2.two = 556;
                  t2.three = 556;
                  t2.four = 556;
                  t2.five = 556;
                  t2.six = 556;
                  t2.seven = 556;
                  t2.eight = 556;
                  t2.nine = 556;
                  t2.colon = 278;
                  t2.semicolon = 278;
                  t2.less = 584;
                  t2.equal = 584;
                  t2.greater = 584;
                  t2.question = 556;
                  t2.at = 1015;
                  t2.A = 667;
                  t2.B = 667;
                  t2.C = 722;
                  t2.D = 722;
                  t2.E = 667;
                  t2.F = 611;
                  t2.G = 778;
                  t2.H = 722;
                  t2.I = 278;
                  t2.J = 500;
                  t2.K = 667;
                  t2.L = 556;
                  t2.M = 833;
                  t2.N = 722;
                  t2.O = 778;
                  t2.P = 667;
                  t2.Q = 778;
                  t2.R = 722;
                  t2.S = 667;
                  t2.T = 611;
                  t2.U = 722;
                  t2.V = 667;
                  t2.W = 944;
                  t2.X = 667;
                  t2.Y = 667;
                  t2.Z = 611;
                  t2.bracketleft = 278;
                  t2.backslash = 278;
                  t2.bracketright = 278;
                  t2.asciicircum = 469;
                  t2.underscore = 556;
                  t2.quoteleft = 222;
                  t2.a = 556;
                  t2.b = 556;
                  t2.c = 500;
                  t2.d = 556;
                  t2.e = 556;
                  t2.f = 278;
                  t2.g = 556;
                  t2.h = 556;
                  t2.i = 222;
                  t2.j = 222;
                  t2.k = 500;
                  t2.l = 222;
                  t2.m = 833;
                  t2.n = 556;
                  t2.o = 556;
                  t2.p = 556;
                  t2.q = 556;
                  t2.r = 333;
                  t2.s = 500;
                  t2.t = 278;
                  t2.u = 556;
                  t2.v = 500;
                  t2.w = 722;
                  t2.x = 500;
                  t2.y = 500;
                  t2.z = 500;
                  t2.braceleft = 334;
                  t2.bar = 260;
                  t2.braceright = 334;
                  t2.asciitilde = 584;
                  t2.exclamdown = 333;
                  t2.cent = 556;
                  t2.sterling = 556;
                  t2.fraction = 167;
                  t2.yen = 556;
                  t2.florin = 556;
                  t2.section = 556;
                  t2.currency = 556;
                  t2.quotesingle = 191;
                  t2.quotedblleft = 333;
                  t2.guillemotleft = 556;
                  t2.guilsinglleft = 333;
                  t2.guilsinglright = 333;
                  t2.fi = 500;
                  t2.fl = 500;
                  t2.endash = 556;
                  t2.dagger = 556;
                  t2.daggerdbl = 556;
                  t2.periodcentered = 278;
                  t2.paragraph = 537;
                  t2.bullet = 350;
                  t2.quotesinglbase = 222;
                  t2.quotedblbase = 333;
                  t2.quotedblright = 333;
                  t2.guillemotright = 556;
                  t2.ellipsis = 1e3;
                  t2.perthousand = 1e3;
                  t2.questiondown = 611;
                  t2.grave = 333;
                  t2.acute = 333;
                  t2.circumflex = 333;
                  t2.tilde = 333;
                  t2.macron = 333;
                  t2.breve = 333;
                  t2.dotaccent = 333;
                  t2.dieresis = 333;
                  t2.ring = 333;
                  t2.cedilla = 333;
                  t2.hungarumlaut = 333;
                  t2.ogonek = 333;
                  t2.caron = 333;
                  t2.emdash = 1e3;
                  t2.AE = 1e3;
                  t2.ordfeminine = 370;
                  t2.Lslash = 556;
                  t2.Oslash = 778;
                  t2.OE = 1e3;
                  t2.ordmasculine = 365;
                  t2.ae = 889;
                  t2.dotlessi = 278;
                  t2.lslash = 222;
                  t2.oslash = 611;
                  t2.oe = 944;
                  t2.germandbls = 611;
                  t2.Idieresis = 278;
                  t2.eacute = 556;
                  t2.abreve = 556;
                  t2.uhungarumlaut = 556;
                  t2.ecaron = 556;
                  t2.Ydieresis = 667;
                  t2.divide = 584;
                  t2.Yacute = 667;
                  t2.Acircumflex = 667;
                  t2.aacute = 556;
                  t2.Ucircumflex = 722;
                  t2.yacute = 500;
                  t2.scommaaccent = 500;
                  t2.ecircumflex = 556;
                  t2.Uring = 722;
                  t2.Udieresis = 722;
                  t2.aogonek = 556;
                  t2.Uacute = 722;
                  t2.uogonek = 556;
                  t2.Edieresis = 667;
                  t2.Dcroat = 722;
                  t2.commaaccent = 250;
                  t2.copyright = 737;
                  t2.Emacron = 667;
                  t2.ccaron = 500;
                  t2.aring = 556;
                  t2.Ncommaaccent = 722;
                  t2.lacute = 222;
                  t2.agrave = 556;
                  t2.Tcommaaccent = 611;
                  t2.Cacute = 722;
                  t2.atilde = 556;
                  t2.Edotaccent = 667;
                  t2.scaron = 500;
                  t2.scedilla = 500;
                  t2.iacute = 278;
                  t2.lozenge = 471;
                  t2.Rcaron = 722;
                  t2.Gcommaaccent = 778;
                  t2.ucircumflex = 556;
                  t2.acircumflex = 556;
                  t2.Amacron = 667;
                  t2.rcaron = 333;
                  t2.ccedilla = 500;
                  t2.Zdotaccent = 611;
                  t2.Thorn = 667;
                  t2.Omacron = 778;
                  t2.Racute = 722;
                  t2.Sacute = 667;
                  t2.dcaron = 643;
                  t2.Umacron = 722;
                  t2.uring = 556;
                  t2.threesuperior = 333;
                  t2.Ograve = 778;
                  t2.Agrave = 667;
                  t2.Abreve = 667;
                  t2.multiply = 584;
                  t2.uacute = 556;
                  t2.Tcaron = 611;
                  t2.partialdiff = 476;
                  t2.ydieresis = 500;
                  t2.Nacute = 722;
                  t2.icircumflex = 278;
                  t2.Ecircumflex = 667;
                  t2.adieresis = 556;
                  t2.edieresis = 556;
                  t2.cacute = 500;
                  t2.nacute = 556;
                  t2.umacron = 556;
                  t2.Ncaron = 722;
                  t2.Iacute = 278;
                  t2.plusminus = 584;
                  t2.brokenbar = 260;
                  t2.registered = 737;
                  t2.Gbreve = 778;
                  t2.Idotaccent = 278;
                  t2.summation = 600;
                  t2.Egrave = 667;
                  t2.racute = 333;
                  t2.omacron = 556;
                  t2.Zacute = 611;
                  t2.Zcaron = 611;
                  t2.greaterequal = 549;
                  t2.Eth = 722;
                  t2.Ccedilla = 722;
                  t2.lcommaaccent = 222;
                  t2.tcaron = 317;
                  t2.eogonek = 556;
                  t2.Uogonek = 722;
                  t2.Aacute = 667;
                  t2.Adieresis = 667;
                  t2.egrave = 556;
                  t2.zacute = 500;
                  t2.iogonek = 222;
                  t2.Oacute = 778;
                  t2.oacute = 556;
                  t2.amacron = 556;
                  t2.sacute = 500;
                  t2.idieresis = 278;
                  t2.Ocircumflex = 778;
                  t2.Ugrave = 722;
                  t2.Delta = 612;
                  t2.thorn = 556;
                  t2.twosuperior = 333;
                  t2.Odieresis = 778;
                  t2.mu = 556;
                  t2.igrave = 278;
                  t2.ohungarumlaut = 556;
                  t2.Eogonek = 667;
                  t2.dcroat = 556;
                  t2.threequarters = 834;
                  t2.Scedilla = 667;
                  t2.lcaron = 299;
                  t2.Kcommaaccent = 667;
                  t2.Lacute = 556;
                  t2.trademark = 1e3;
                  t2.edotaccent = 556;
                  t2.Igrave = 278;
                  t2.Imacron = 278;
                  t2.Lcaron = 556;
                  t2.onehalf = 834;
                  t2.lessequal = 549;
                  t2.ocircumflex = 556;
                  t2.ntilde = 556;
                  t2.Uhungarumlaut = 722;
                  t2.Eacute = 667;
                  t2.emacron = 556;
                  t2.gbreve = 556;
                  t2.onequarter = 834;
                  t2.Scaron = 667;
                  t2.Scommaaccent = 667;
                  t2.Ohungarumlaut = 778;
                  t2.degree = 400;
                  t2.ograve = 556;
                  t2.Ccaron = 722;
                  t2.ugrave = 556;
                  t2.radical = 453;
                  t2.Dcaron = 722;
                  t2.rcommaaccent = 333;
                  t2.Ntilde = 722;
                  t2.otilde = 556;
                  t2.Rcommaaccent = 722;
                  t2.Lcommaaccent = 556;
                  t2.Atilde = 667;
                  t2.Aogonek = 667;
                  t2.Aring = 667;
                  t2.Otilde = 778;
                  t2.zdotaccent = 500;
                  t2.Ecaron = 667;
                  t2.Iogonek = 278;
                  t2.kcommaaccent = 500;
                  t2.minus = 584;
                  t2.Icircumflex = 278;
                  t2.ncaron = 556;
                  t2.tcommaaccent = 278;
                  t2.logicalnot = 584;
                  t2.odieresis = 556;
                  t2.udieresis = 556;
                  t2.notequal = 549;
                  t2.gcommaaccent = 556;
                  t2.eth = 556;
                  t2.zcaron = 500;
                  t2.ncommaaccent = 556;
                  t2.onesuperior = 333;
                  t2.imacron = 278;
                  t2.Euro = 556;
                });
                t["Helvetica-Bold"] = (0, _core_utils.getLookupTableFactory)(function(t2) {
                  t2.space = 278;
                  t2.exclam = 333;
                  t2.quotedbl = 474;
                  t2.numbersign = 556;
                  t2.dollar = 556;
                  t2.percent = 889;
                  t2.ampersand = 722;
                  t2.quoteright = 278;
                  t2.parenleft = 333;
                  t2.parenright = 333;
                  t2.asterisk = 389;
                  t2.plus = 584;
                  t2.comma = 278;
                  t2.hyphen = 333;
                  t2.period = 278;
                  t2.slash = 278;
                  t2.zero = 556;
                  t2.one = 556;
                  t2.two = 556;
                  t2.three = 556;
                  t2.four = 556;
                  t2.five = 556;
                  t2.six = 556;
                  t2.seven = 556;
                  t2.eight = 556;
                  t2.nine = 556;
                  t2.colon = 333;
                  t2.semicolon = 333;
                  t2.less = 584;
                  t2.equal = 584;
                  t2.greater = 584;
                  t2.question = 611;
                  t2.at = 975;
                  t2.A = 722;
                  t2.B = 722;
                  t2.C = 722;
                  t2.D = 722;
                  t2.E = 667;
                  t2.F = 611;
                  t2.G = 778;
                  t2.H = 722;
                  t2.I = 278;
                  t2.J = 556;
                  t2.K = 722;
                  t2.L = 611;
                  t2.M = 833;
                  t2.N = 722;
                  t2.O = 778;
                  t2.P = 667;
                  t2.Q = 778;
                  t2.R = 722;
                  t2.S = 667;
                  t2.T = 611;
                  t2.U = 722;
                  t2.V = 667;
                  t2.W = 944;
                  t2.X = 667;
                  t2.Y = 667;
                  t2.Z = 611;
                  t2.bracketleft = 333;
                  t2.backslash = 278;
                  t2.bracketright = 333;
                  t2.asciicircum = 584;
                  t2.underscore = 556;
                  t2.quoteleft = 278;
                  t2.a = 556;
                  t2.b = 611;
                  t2.c = 556;
                  t2.d = 611;
                  t2.e = 556;
                  t2.f = 333;
                  t2.g = 611;
                  t2.h = 611;
                  t2.i = 278;
                  t2.j = 278;
                  t2.k = 556;
                  t2.l = 278;
                  t2.m = 889;
                  t2.n = 611;
                  t2.o = 611;
                  t2.p = 611;
                  t2.q = 611;
                  t2.r = 389;
                  t2.s = 556;
                  t2.t = 333;
                  t2.u = 611;
                  t2.v = 556;
                  t2.w = 778;
                  t2.x = 556;
                  t2.y = 556;
                  t2.z = 500;
                  t2.braceleft = 389;
                  t2.bar = 280;
                  t2.braceright = 389;
                  t2.asciitilde = 584;
                  t2.exclamdown = 333;
                  t2.cent = 556;
                  t2.sterling = 556;
                  t2.fraction = 167;
                  t2.yen = 556;
                  t2.florin = 556;
                  t2.section = 556;
                  t2.currency = 556;
                  t2.quotesingle = 238;
                  t2.quotedblleft = 500;
                  t2.guillemotleft = 556;
                  t2.guilsinglleft = 333;
                  t2.guilsinglright = 333;
                  t2.fi = 611;
                  t2.fl = 611;
                  t2.endash = 556;
                  t2.dagger = 556;
                  t2.daggerdbl = 556;
                  t2.periodcentered = 278;
                  t2.paragraph = 556;
                  t2.bullet = 350;
                  t2.quotesinglbase = 278;
                  t2.quotedblbase = 500;
                  t2.quotedblright = 500;
                  t2.guillemotright = 556;
                  t2.ellipsis = 1e3;
                  t2.perthousand = 1e3;
                  t2.questiondown = 611;
                  t2.grave = 333;
                  t2.acute = 333;
                  t2.circumflex = 333;
                  t2.tilde = 333;
                  t2.macron = 333;
                  t2.breve = 333;
                  t2.dotaccent = 333;
                  t2.dieresis = 333;
                  t2.ring = 333;
                  t2.cedilla = 333;
                  t2.hungarumlaut = 333;
                  t2.ogonek = 333;
                  t2.caron = 333;
                  t2.emdash = 1e3;
                  t2.AE = 1e3;
                  t2.ordfeminine = 370;
                  t2.Lslash = 611;
                  t2.Oslash = 778;
                  t2.OE = 1e3;
                  t2.ordmasculine = 365;
                  t2.ae = 889;
                  t2.dotlessi = 278;
                  t2.lslash = 278;
                  t2.oslash = 611;
                  t2.oe = 944;
                  t2.germandbls = 611;
                  t2.Idieresis = 278;
                  t2.eacute = 556;
                  t2.abreve = 556;
                  t2.uhungarumlaut = 611;
                  t2.ecaron = 556;
                  t2.Ydieresis = 667;
                  t2.divide = 584;
                  t2.Yacute = 667;
                  t2.Acircumflex = 722;
                  t2.aacute = 556;
                  t2.Ucircumflex = 722;
                  t2.yacute = 556;
                  t2.scommaaccent = 556;
                  t2.ecircumflex = 556;
                  t2.Uring = 722;
                  t2.Udieresis = 722;
                  t2.aogonek = 556;
                  t2.Uacute = 722;
                  t2.uogonek = 611;
                  t2.Edieresis = 667;
                  t2.Dcroat = 722;
                  t2.commaaccent = 250;
                  t2.copyright = 737;
                  t2.Emacron = 667;
                  t2.ccaron = 556;
                  t2.aring = 556;
                  t2.Ncommaaccent = 722;
                  t2.lacute = 278;
                  t2.agrave = 556;
                  t2.Tcommaaccent = 611;
                  t2.Cacute = 722;
                  t2.atilde = 556;
                  t2.Edotaccent = 667;
                  t2.scaron = 556;
                  t2.scedilla = 556;
                  t2.iacute = 278;
                  t2.lozenge = 494;
                  t2.Rcaron = 722;
                  t2.Gcommaaccent = 778;
                  t2.ucircumflex = 611;
                  t2.acircumflex = 556;
                  t2.Amacron = 722;
                  t2.rcaron = 389;
                  t2.ccedilla = 556;
                  t2.Zdotaccent = 611;
                  t2.Thorn = 667;
                  t2.Omacron = 778;
                  t2.Racute = 722;
                  t2.Sacute = 667;
                  t2.dcaron = 743;
                  t2.Umacron = 722;
                  t2.uring = 611;
                  t2.threesuperior = 333;
                  t2.Ograve = 778;
                  t2.Agrave = 722;
                  t2.Abreve = 722;
                  t2.multiply = 584;
                  t2.uacute = 611;
                  t2.Tcaron = 611;
                  t2.partialdiff = 494;
                  t2.ydieresis = 556;
                  t2.Nacute = 722;
                  t2.icircumflex = 278;
                  t2.Ecircumflex = 667;
                  t2.adieresis = 556;
                  t2.edieresis = 556;
                  t2.cacute = 556;
                  t2.nacute = 611;
                  t2.umacron = 611;
                  t2.Ncaron = 722;
                  t2.Iacute = 278;
                  t2.plusminus = 584;
                  t2.brokenbar = 280;
                  t2.registered = 737;
                  t2.Gbreve = 778;
                  t2.Idotaccent = 278;
                  t2.summation = 600;
                  t2.Egrave = 667;
                  t2.racute = 389;
                  t2.omacron = 611;
                  t2.Zacute = 611;
                  t2.Zcaron = 611;
                  t2.greaterequal = 549;
                  t2.Eth = 722;
                  t2.Ccedilla = 722;
                  t2.lcommaaccent = 278;
                  t2.tcaron = 389;
                  t2.eogonek = 556;
                  t2.Uogonek = 722;
                  t2.Aacute = 722;
                  t2.Adieresis = 722;
                  t2.egrave = 556;
                  t2.zacute = 500;
                  t2.iogonek = 278;
                  t2.Oacute = 778;
                  t2.oacute = 611;
                  t2.amacron = 556;
                  t2.sacute = 556;
                  t2.idieresis = 278;
                  t2.Ocircumflex = 778;
                  t2.Ugrave = 722;
                  t2.Delta = 612;
                  t2.thorn = 611;
                  t2.twosuperior = 333;
                  t2.Odieresis = 778;
                  t2.mu = 611;
                  t2.igrave = 278;
                  t2.ohungarumlaut = 611;
                  t2.Eogonek = 667;
                  t2.dcroat = 611;
                  t2.threequarters = 834;
                  t2.Scedilla = 667;
                  t2.lcaron = 400;
                  t2.Kcommaaccent = 722;
                  t2.Lacute = 611;
                  t2.trademark = 1e3;
                  t2.edotaccent = 556;
                  t2.Igrave = 278;
                  t2.Imacron = 278;
                  t2.Lcaron = 611;
                  t2.onehalf = 834;
                  t2.lessequal = 549;
                  t2.ocircumflex = 611;
                  t2.ntilde = 611;
                  t2.Uhungarumlaut = 722;
                  t2.Eacute = 667;
                  t2.emacron = 556;
                  t2.gbreve = 611;
                  t2.onequarter = 834;
                  t2.Scaron = 667;
                  t2.Scommaaccent = 667;
                  t2.Ohungarumlaut = 778;
                  t2.degree = 400;
                  t2.ograve = 611;
                  t2.Ccaron = 722;
                  t2.ugrave = 611;
                  t2.radical = 549;
                  t2.Dcaron = 722;
                  t2.rcommaaccent = 389;
                  t2.Ntilde = 722;
                  t2.otilde = 611;
                  t2.Rcommaaccent = 722;
                  t2.Lcommaaccent = 611;
                  t2.Atilde = 722;
                  t2.Aogonek = 722;
                  t2.Aring = 722;
                  t2.Otilde = 778;
                  t2.zdotaccent = 500;
                  t2.Ecaron = 667;
                  t2.Iogonek = 278;
                  t2.kcommaaccent = 556;
                  t2.minus = 584;
                  t2.Icircumflex = 278;
                  t2.ncaron = 611;
                  t2.tcommaaccent = 333;
                  t2.logicalnot = 584;
                  t2.odieresis = 611;
                  t2.udieresis = 611;
                  t2.notequal = 549;
                  t2.gcommaaccent = 611;
                  t2.eth = 611;
                  t2.zcaron = 500;
                  t2.ncommaaccent = 611;
                  t2.onesuperior = 333;
                  t2.imacron = 278;
                  t2.Euro = 556;
                });
                t["Helvetica-BoldOblique"] = (0, _core_utils.getLookupTableFactory)(function(t2) {
                  t2.space = 278;
                  t2.exclam = 333;
                  t2.quotedbl = 474;
                  t2.numbersign = 556;
                  t2.dollar = 556;
                  t2.percent = 889;
                  t2.ampersand = 722;
                  t2.quoteright = 278;
                  t2.parenleft = 333;
                  t2.parenright = 333;
                  t2.asterisk = 389;
                  t2.plus = 584;
                  t2.comma = 278;
                  t2.hyphen = 333;
                  t2.period = 278;
                  t2.slash = 278;
                  t2.zero = 556;
                  t2.one = 556;
                  t2.two = 556;
                  t2.three = 556;
                  t2.four = 556;
                  t2.five = 556;
                  t2.six = 556;
                  t2.seven = 556;
                  t2.eight = 556;
                  t2.nine = 556;
                  t2.colon = 333;
                  t2.semicolon = 333;
                  t2.less = 584;
                  t2.equal = 584;
                  t2.greater = 584;
                  t2.question = 611;
                  t2.at = 975;
                  t2.A = 722;
                  t2.B = 722;
                  t2.C = 722;
                  t2.D = 722;
                  t2.E = 667;
                  t2.F = 611;
                  t2.G = 778;
                  t2.H = 722;
                  t2.I = 278;
                  t2.J = 556;
                  t2.K = 722;
                  t2.L = 611;
                  t2.M = 833;
                  t2.N = 722;
                  t2.O = 778;
                  t2.P = 667;
                  t2.Q = 778;
                  t2.R = 722;
                  t2.S = 667;
                  t2.T = 611;
                  t2.U = 722;
                  t2.V = 667;
                  t2.W = 944;
                  t2.X = 667;
                  t2.Y = 667;
                  t2.Z = 611;
                  t2.bracketleft = 333;
                  t2.backslash = 278;
                  t2.bracketright = 333;
                  t2.asciicircum = 584;
                  t2.underscore = 556;
                  t2.quoteleft = 278;
                  t2.a = 556;
                  t2.b = 611;
                  t2.c = 556;
                  t2.d = 611;
                  t2.e = 556;
                  t2.f = 333;
                  t2.g = 611;
                  t2.h = 611;
                  t2.i = 278;
                  t2.j = 278;
                  t2.k = 556;
                  t2.l = 278;
                  t2.m = 889;
                  t2.n = 611;
                  t2.o = 611;
                  t2.p = 611;
                  t2.q = 611;
                  t2.r = 389;
                  t2.s = 556;
                  t2.t = 333;
                  t2.u = 611;
                  t2.v = 556;
                  t2.w = 778;
                  t2.x = 556;
                  t2.y = 556;
                  t2.z = 500;
                  t2.braceleft = 389;
                  t2.bar = 280;
                  t2.braceright = 389;
                  t2.asciitilde = 584;
                  t2.exclamdown = 333;
                  t2.cent = 556;
                  t2.sterling = 556;
                  t2.fraction = 167;
                  t2.yen = 556;
                  t2.florin = 556;
                  t2.section = 556;
                  t2.currency = 556;
                  t2.quotesingle = 238;
                  t2.quotedblleft = 500;
                  t2.guillemotleft = 556;
                  t2.guilsinglleft = 333;
                  t2.guilsinglright = 333;
                  t2.fi = 611;
                  t2.fl = 611;
                  t2.endash = 556;
                  t2.dagger = 556;
                  t2.daggerdbl = 556;
                  t2.periodcentered = 278;
                  t2.paragraph = 556;
                  t2.bullet = 350;
                  t2.quotesinglbase = 278;
                  t2.quotedblbase = 500;
                  t2.quotedblright = 500;
                  t2.guillemotright = 556;
                  t2.ellipsis = 1e3;
                  t2.perthousand = 1e3;
                  t2.questiondown = 611;
                  t2.grave = 333;
                  t2.acute = 333;
                  t2.circumflex = 333;
                  t2.tilde = 333;
                  t2.macron = 333;
                  t2.breve = 333;
                  t2.dotaccent = 333;
                  t2.dieresis = 333;
                  t2.ring = 333;
                  t2.cedilla = 333;
                  t2.hungarumlaut = 333;
                  t2.ogonek = 333;
                  t2.caron = 333;
                  t2.emdash = 1e3;
                  t2.AE = 1e3;
                  t2.ordfeminine = 370;
                  t2.Lslash = 611;
                  t2.Oslash = 778;
                  t2.OE = 1e3;
                  t2.ordmasculine = 365;
                  t2.ae = 889;
                  t2.dotlessi = 278;
                  t2.lslash = 278;
                  t2.oslash = 611;
                  t2.oe = 944;
                  t2.germandbls = 611;
                  t2.Idieresis = 278;
                  t2.eacute = 556;
                  t2.abreve = 556;
                  t2.uhungarumlaut = 611;
                  t2.ecaron = 556;
                  t2.Ydieresis = 667;
                  t2.divide = 584;
                  t2.Yacute = 667;
                  t2.Acircumflex = 722;
                  t2.aacute = 556;
                  t2.Ucircumflex = 722;
                  t2.yacute = 556;
                  t2.scommaaccent = 556;
                  t2.ecircumflex = 556;
                  t2.Uring = 722;
                  t2.Udieresis = 722;
                  t2.aogonek = 556;
                  t2.Uacute = 722;
                  t2.uogonek = 611;
                  t2.Edieresis = 667;
                  t2.Dcroat = 722;
                  t2.commaaccent = 250;
                  t2.copyright = 737;
                  t2.Emacron = 667;
                  t2.ccaron = 556;
                  t2.aring = 556;
                  t2.Ncommaaccent = 722;
                  t2.lacute = 278;
                  t2.agrave = 556;
                  t2.Tcommaaccent = 611;
                  t2.Cacute = 722;
                  t2.atilde = 556;
                  t2.Edotaccent = 667;
                  t2.scaron = 556;
                  t2.scedilla = 556;
                  t2.iacute = 278;
                  t2.lozenge = 494;
                  t2.Rcaron = 722;
                  t2.Gcommaaccent = 778;
                  t2.ucircumflex = 611;
                  t2.acircumflex = 556;
                  t2.Amacron = 722;
                  t2.rcaron = 389;
                  t2.ccedilla = 556;
                  t2.Zdotaccent = 611;
                  t2.Thorn = 667;
                  t2.Omacron = 778;
                  t2.Racute = 722;
                  t2.Sacute = 667;
                  t2.dcaron = 743;
                  t2.Umacron = 722;
                  t2.uring = 611;
                  t2.threesuperior = 333;
                  t2.Ograve = 778;
                  t2.Agrave = 722;
                  t2.Abreve = 722;
                  t2.multiply = 584;
                  t2.uacute = 611;
                  t2.Tcaron = 611;
                  t2.partialdiff = 494;
                  t2.ydieresis = 556;
                  t2.Nacute = 722;
                  t2.icircumflex = 278;
                  t2.Ecircumflex = 667;
                  t2.adieresis = 556;
                  t2.edieresis = 556;
                  t2.cacute = 556;
                  t2.nacute = 611;
                  t2.umacron = 611;
                  t2.Ncaron = 722;
                  t2.Iacute = 278;
                  t2.plusminus = 584;
                  t2.brokenbar = 280;
                  t2.registered = 737;
                  t2.Gbreve = 778;
                  t2.Idotaccent = 278;
                  t2.summation = 600;
                  t2.Egrave = 667;
                  t2.racute = 389;
                  t2.omacron = 611;
                  t2.Zacute = 611;
                  t2.Zcaron = 611;
                  t2.greaterequal = 549;
                  t2.Eth = 722;
                  t2.Ccedilla = 722;
                  t2.lcommaaccent = 278;
                  t2.tcaron = 389;
                  t2.eogonek = 556;
                  t2.Uogonek = 722;
                  t2.Aacute = 722;
                  t2.Adieresis = 722;
                  t2.egrave = 556;
                  t2.zacute = 500;
                  t2.iogonek = 278;
                  t2.Oacute = 778;
                  t2.oacute = 611;
                  t2.amacron = 556;
                  t2.sacute = 556;
                  t2.idieresis = 278;
                  t2.Ocircumflex = 778;
                  t2.Ugrave = 722;
                  t2.Delta = 612;
                  t2.thorn = 611;
                  t2.twosuperior = 333;
                  t2.Odieresis = 778;
                  t2.mu = 611;
                  t2.igrave = 278;
                  t2.ohungarumlaut = 611;
                  t2.Eogonek = 667;
                  t2.dcroat = 611;
                  t2.threequarters = 834;
                  t2.Scedilla = 667;
                  t2.lcaron = 400;
                  t2.Kcommaaccent = 722;
                  t2.Lacute = 611;
                  t2.trademark = 1e3;
                  t2.edotaccent = 556;
                  t2.Igrave = 278;
                  t2.Imacron = 278;
                  t2.Lcaron = 611;
                  t2.onehalf = 834;
                  t2.lessequal = 549;
                  t2.ocircumflex = 611;
                  t2.ntilde = 611;
                  t2.Uhungarumlaut = 722;
                  t2.Eacute = 667;
                  t2.emacron = 556;
                  t2.gbreve = 611;
                  t2.onequarter = 834;
                  t2.Scaron = 667;
                  t2.Scommaaccent = 667;
                  t2.Ohungarumlaut = 778;
                  t2.degree = 400;
                  t2.ograve = 611;
                  t2.Ccaron = 722;
                  t2.ugrave = 611;
                  t2.radical = 549;
                  t2.Dcaron = 722;
                  t2.rcommaaccent = 389;
                  t2.Ntilde = 722;
                  t2.otilde = 611;
                  t2.Rcommaaccent = 722;
                  t2.Lcommaaccent = 611;
                  t2.Atilde = 722;
                  t2.Aogonek = 722;
                  t2.Aring = 722;
                  t2.Otilde = 778;
                  t2.zdotaccent = 500;
                  t2.Ecaron = 667;
                  t2.Iogonek = 278;
                  t2.kcommaaccent = 556;
                  t2.minus = 584;
                  t2.Icircumflex = 278;
                  t2.ncaron = 611;
                  t2.tcommaaccent = 333;
                  t2.logicalnot = 584;
                  t2.odieresis = 611;
                  t2.udieresis = 611;
                  t2.notequal = 549;
                  t2.gcommaaccent = 611;
                  t2.eth = 611;
                  t2.zcaron = 500;
                  t2.ncommaaccent = 611;
                  t2.onesuperior = 333;
                  t2.imacron = 278;
                  t2.Euro = 556;
                });
                t["Helvetica-Oblique"] = (0, _core_utils.getLookupTableFactory)(function(t2) {
                  t2.space = 278;
                  t2.exclam = 278;
                  t2.quotedbl = 355;
                  t2.numbersign = 556;
                  t2.dollar = 556;
                  t2.percent = 889;
                  t2.ampersand = 667;
                  t2.quoteright = 222;
                  t2.parenleft = 333;
                  t2.parenright = 333;
                  t2.asterisk = 389;
                  t2.plus = 584;
                  t2.comma = 278;
                  t2.hyphen = 333;
                  t2.period = 278;
                  t2.slash = 278;
                  t2.zero = 556;
                  t2.one = 556;
                  t2.two = 556;
                  t2.three = 556;
                  t2.four = 556;
                  t2.five = 556;
                  t2.six = 556;
                  t2.seven = 556;
                  t2.eight = 556;
                  t2.nine = 556;
                  t2.colon = 278;
                  t2.semicolon = 278;
                  t2.less = 584;
                  t2.equal = 584;
                  t2.greater = 584;
                  t2.question = 556;
                  t2.at = 1015;
                  t2.A = 667;
                  t2.B = 667;
                  t2.C = 722;
                  t2.D = 722;
                  t2.E = 667;
                  t2.F = 611;
                  t2.G = 778;
                  t2.H = 722;
                  t2.I = 278;
                  t2.J = 500;
                  t2.K = 667;
                  t2.L = 556;
                  t2.M = 833;
                  t2.N = 722;
                  t2.O = 778;
                  t2.P = 667;
                  t2.Q = 778;
                  t2.R = 722;
                  t2.S = 667;
                  t2.T = 611;
                  t2.U = 722;
                  t2.V = 667;
                  t2.W = 944;
                  t2.X = 667;
                  t2.Y = 667;
                  t2.Z = 611;
                  t2.bracketleft = 278;
                  t2.backslash = 278;
                  t2.bracketright = 278;
                  t2.asciicircum = 469;
                  t2.underscore = 556;
                  t2.quoteleft = 222;
                  t2.a = 556;
                  t2.b = 556;
                  t2.c = 500;
                  t2.d = 556;
                  t2.e = 556;
                  t2.f = 278;
                  t2.g = 556;
                  t2.h = 556;
                  t2.i = 222;
                  t2.j = 222;
                  t2.k = 500;
                  t2.l = 222;
                  t2.m = 833;
                  t2.n = 556;
                  t2.o = 556;
                  t2.p = 556;
                  t2.q = 556;
                  t2.r = 333;
                  t2.s = 500;
                  t2.t = 278;
                  t2.u = 556;
                  t2.v = 500;
                  t2.w = 722;
                  t2.x = 500;
                  t2.y = 500;
                  t2.z = 500;
                  t2.braceleft = 334;
                  t2.bar = 260;
                  t2.braceright = 334;
                  t2.asciitilde = 584;
                  t2.exclamdown = 333;
                  t2.cent = 556;
                  t2.sterling = 556;
                  t2.fraction = 167;
                  t2.yen = 556;
                  t2.florin = 556;
                  t2.section = 556;
                  t2.currency = 556;
                  t2.quotesingle = 191;
                  t2.quotedblleft = 333;
                  t2.guillemotleft = 556;
                  t2.guilsinglleft = 333;
                  t2.guilsinglright = 333;
                  t2.fi = 500;
                  t2.fl = 500;
                  t2.endash = 556;
                  t2.dagger = 556;
                  t2.daggerdbl = 556;
                  t2.periodcentered = 278;
                  t2.paragraph = 537;
                  t2.bullet = 350;
                  t2.quotesinglbase = 222;
                  t2.quotedblbase = 333;
                  t2.quotedblright = 333;
                  t2.guillemotright = 556;
                  t2.ellipsis = 1e3;
                  t2.perthousand = 1e3;
                  t2.questiondown = 611;
                  t2.grave = 333;
                  t2.acute = 333;
                  t2.circumflex = 333;
                  t2.tilde = 333;
                  t2.macron = 333;
                  t2.breve = 333;
                  t2.dotaccent = 333;
                  t2.dieresis = 333;
                  t2.ring = 333;
                  t2.cedilla = 333;
                  t2.hungarumlaut = 333;
                  t2.ogonek = 333;
                  t2.caron = 333;
                  t2.emdash = 1e3;
                  t2.AE = 1e3;
                  t2.ordfeminine = 370;
                  t2.Lslash = 556;
                  t2.Oslash = 778;
                  t2.OE = 1e3;
                  t2.ordmasculine = 365;
                  t2.ae = 889;
                  t2.dotlessi = 278;
                  t2.lslash = 222;
                  t2.oslash = 611;
                  t2.oe = 944;
                  t2.germandbls = 611;
                  t2.Idieresis = 278;
                  t2.eacute = 556;
                  t2.abreve = 556;
                  t2.uhungarumlaut = 556;
                  t2.ecaron = 556;
                  t2.Ydieresis = 667;
                  t2.divide = 584;
                  t2.Yacute = 667;
                  t2.Acircumflex = 667;
                  t2.aacute = 556;
                  t2.Ucircumflex = 722;
                  t2.yacute = 500;
                  t2.scommaaccent = 500;
                  t2.ecircumflex = 556;
                  t2.Uring = 722;
                  t2.Udieresis = 722;
                  t2.aogonek = 556;
                  t2.Uacute = 722;
                  t2.uogonek = 556;
                  t2.Edieresis = 667;
                  t2.Dcroat = 722;
                  t2.commaaccent = 250;
                  t2.copyright = 737;
                  t2.Emacron = 667;
                  t2.ccaron = 500;
                  t2.aring = 556;
                  t2.Ncommaaccent = 722;
                  t2.lacute = 222;
                  t2.agrave = 556;
                  t2.Tcommaaccent = 611;
                  t2.Cacute = 722;
                  t2.atilde = 556;
                  t2.Edotaccent = 667;
                  t2.scaron = 500;
                  t2.scedilla = 500;
                  t2.iacute = 278;
                  t2.lozenge = 471;
                  t2.Rcaron = 722;
                  t2.Gcommaaccent = 778;
                  t2.ucircumflex = 556;
                  t2.acircumflex = 556;
                  t2.Amacron = 667;
                  t2.rcaron = 333;
                  t2.ccedilla = 500;
                  t2.Zdotaccent = 611;
                  t2.Thorn = 667;
                  t2.Omacron = 778;
                  t2.Racute = 722;
                  t2.Sacute = 667;
                  t2.dcaron = 643;
                  t2.Umacron = 722;
                  t2.uring = 556;
                  t2.threesuperior = 333;
                  t2.Ograve = 778;
                  t2.Agrave = 667;
                  t2.Abreve = 667;
                  t2.multiply = 584;
                  t2.uacute = 556;
                  t2.Tcaron = 611;
                  t2.partialdiff = 476;
                  t2.ydieresis = 500;
                  t2.Nacute = 722;
                  t2.icircumflex = 278;
                  t2.Ecircumflex = 667;
                  t2.adieresis = 556;
                  t2.edieresis = 556;
                  t2.cacute = 500;
                  t2.nacute = 556;
                  t2.umacron = 556;
                  t2.Ncaron = 722;
                  t2.Iacute = 278;
                  t2.plusminus = 584;
                  t2.brokenbar = 260;
                  t2.registered = 737;
                  t2.Gbreve = 778;
                  t2.Idotaccent = 278;
                  t2.summation = 600;
                  t2.Egrave = 667;
                  t2.racute = 333;
                  t2.omacron = 556;
                  t2.Zacute = 611;
                  t2.Zcaron = 611;
                  t2.greaterequal = 549;
                  t2.Eth = 722;
                  t2.Ccedilla = 722;
                  t2.lcommaaccent = 222;
                  t2.tcaron = 317;
                  t2.eogonek = 556;
                  t2.Uogonek = 722;
                  t2.Aacute = 667;
                  t2.Adieresis = 667;
                  t2.egrave = 556;
                  t2.zacute = 500;
                  t2.iogonek = 222;
                  t2.Oacute = 778;
                  t2.oacute = 556;
                  t2.amacron = 556;
                  t2.sacute = 500;
                  t2.idieresis = 278;
                  t2.Ocircumflex = 778;
                  t2.Ugrave = 722;
                  t2.Delta = 612;
                  t2.thorn = 556;
                  t2.twosuperior = 333;
                  t2.Odieresis = 778;
                  t2.mu = 556;
                  t2.igrave = 278;
                  t2.ohungarumlaut = 556;
                  t2.Eogonek = 667;
                  t2.dcroat = 556;
                  t2.threequarters = 834;
                  t2.Scedilla = 667;
                  t2.lcaron = 299;
                  t2.Kcommaaccent = 667;
                  t2.Lacute = 556;
                  t2.trademark = 1e3;
                  t2.edotaccent = 556;
                  t2.Igrave = 278;
                  t2.Imacron = 278;
                  t2.Lcaron = 556;
                  t2.onehalf = 834;
                  t2.lessequal = 549;
                  t2.ocircumflex = 556;
                  t2.ntilde = 556;
                  t2.Uhungarumlaut = 722;
                  t2.Eacute = 667;
                  t2.emacron = 556;
                  t2.gbreve = 556;
                  t2.onequarter = 834;
                  t2.Scaron = 667;
                  t2.Scommaaccent = 667;
                  t2.Ohungarumlaut = 778;
                  t2.degree = 400;
                  t2.ograve = 556;
                  t2.Ccaron = 722;
                  t2.ugrave = 556;
                  t2.radical = 453;
                  t2.Dcaron = 722;
                  t2.rcommaaccent = 333;
                  t2.Ntilde = 722;
                  t2.otilde = 556;
                  t2.Rcommaaccent = 722;
                  t2.Lcommaaccent = 556;
                  t2.Atilde = 667;
                  t2.Aogonek = 667;
                  t2.Aring = 667;
                  t2.Otilde = 778;
                  t2.zdotaccent = 500;
                  t2.Ecaron = 667;
                  t2.Iogonek = 278;
                  t2.kcommaaccent = 500;
                  t2.minus = 584;
                  t2.Icircumflex = 278;
                  t2.ncaron = 556;
                  t2.tcommaaccent = 278;
                  t2.logicalnot = 584;
                  t2.odieresis = 556;
                  t2.udieresis = 556;
                  t2.notequal = 549;
                  t2.gcommaaccent = 556;
                  t2.eth = 556;
                  t2.zcaron = 500;
                  t2.ncommaaccent = 556;
                  t2.onesuperior = 333;
                  t2.imacron = 278;
                  t2.Euro = 556;
                });
                t.Symbol = (0, _core_utils.getLookupTableFactory)(function(t2) {
                  t2.space = 250;
                  t2.exclam = 333;
                  t2.universal = 713;
                  t2.numbersign = 500;
                  t2.existential = 549;
                  t2.percent = 833;
                  t2.ampersand = 778;
                  t2.suchthat = 439;
                  t2.parenleft = 333;
                  t2.parenright = 333;
                  t2.asteriskmath = 500;
                  t2.plus = 549;
                  t2.comma = 250;
                  t2.minus = 549;
                  t2.period = 250;
                  t2.slash = 278;
                  t2.zero = 500;
                  t2.one = 500;
                  t2.two = 500;
                  t2.three = 500;
                  t2.four = 500;
                  t2.five = 500;
                  t2.six = 500;
                  t2.seven = 500;
                  t2.eight = 500;
                  t2.nine = 500;
                  t2.colon = 278;
                  t2.semicolon = 278;
                  t2.less = 549;
                  t2.equal = 549;
                  t2.greater = 549;
                  t2.question = 444;
                  t2.congruent = 549;
                  t2.Alpha = 722;
                  t2.Beta = 667;
                  t2.Chi = 722;
                  t2.Delta = 612;
                  t2.Epsilon = 611;
                  t2.Phi = 763;
                  t2.Gamma = 603;
                  t2.Eta = 722;
                  t2.Iota = 333;
                  t2.theta1 = 631;
                  t2.Kappa = 722;
                  t2.Lambda = 686;
                  t2.Mu = 889;
                  t2.Nu = 722;
                  t2.Omicron = 722;
                  t2.Pi = 768;
                  t2.Theta = 741;
                  t2.Rho = 556;
                  t2.Sigma = 592;
                  t2.Tau = 611;
                  t2.Upsilon = 690;
                  t2.sigma1 = 439;
                  t2.Omega = 768;
                  t2.Xi = 645;
                  t2.Psi = 795;
                  t2.Zeta = 611;
                  t2.bracketleft = 333;
                  t2.therefore = 863;
                  t2.bracketright = 333;
                  t2.perpendicular = 658;
                  t2.underscore = 500;
                  t2.radicalex = 500;
                  t2.alpha = 631;
                  t2.beta = 549;
                  t2.chi = 549;
                  t2.delta = 494;
                  t2.epsilon = 439;
                  t2.phi = 521;
                  t2.gamma = 411;
                  t2.eta = 603;
                  t2.iota = 329;
                  t2.phi1 = 603;
                  t2.kappa = 549;
                  t2.lambda = 549;
                  t2.mu = 576;
                  t2.nu = 521;
                  t2.omicron = 549;
                  t2.pi = 549;
                  t2.theta = 521;
                  t2.rho = 549;
                  t2.sigma = 603;
                  t2.tau = 439;
                  t2.upsilon = 576;
                  t2.omega1 = 713;
                  t2.omega = 686;
                  t2.xi = 493;
                  t2.psi = 686;
                  t2.zeta = 494;
                  t2.braceleft = 480;
                  t2.bar = 200;
                  t2.braceright = 480;
                  t2.similar = 549;
                  t2.Euro = 750;
                  t2.Upsilon1 = 620;
                  t2.minute = 247;
                  t2.lessequal = 549;
                  t2.fraction = 167;
                  t2.infinity = 713;
                  t2.florin = 500;
                  t2.club = 753;
                  t2.diamond = 753;
                  t2.heart = 753;
                  t2.spade = 753;
                  t2.arrowboth = 1042;
                  t2.arrowleft = 987;
                  t2.arrowup = 603;
                  t2.arrowright = 987;
                  t2.arrowdown = 603;
                  t2.degree = 400;
                  t2.plusminus = 549;
                  t2.second = 411;
                  t2.greaterequal = 549;
                  t2.multiply = 549;
                  t2.proportional = 713;
                  t2.partialdiff = 494;
                  t2.bullet = 460;
                  t2.divide = 549;
                  t2.notequal = 549;
                  t2.equivalence = 549;
                  t2.approxequal = 549;
                  t2.ellipsis = 1e3;
                  t2.arrowvertex = 603;
                  t2.arrowhorizex = 1e3;
                  t2.carriagereturn = 658;
                  t2.aleph = 823;
                  t2.Ifraktur = 686;
                  t2.Rfraktur = 795;
                  t2.weierstrass = 987;
                  t2.circlemultiply = 768;
                  t2.circleplus = 768;
                  t2.emptyset = 823;
                  t2.intersection = 768;
                  t2.union = 768;
                  t2.propersuperset = 713;
                  t2.reflexsuperset = 713;
                  t2.notsubset = 713;
                  t2.propersubset = 713;
                  t2.reflexsubset = 713;
                  t2.element = 713;
                  t2.notelement = 713;
                  t2.angle = 768;
                  t2.gradient = 713;
                  t2.registerserif = 790;
                  t2.copyrightserif = 790;
                  t2.trademarkserif = 890;
                  t2.product = 823;
                  t2.radical = 549;
                  t2.dotmath = 250;
                  t2.logicalnot = 713;
                  t2.logicaland = 603;
                  t2.logicalor = 603;
                  t2.arrowdblboth = 1042;
                  t2.arrowdblleft = 987;
                  t2.arrowdblup = 603;
                  t2.arrowdblright = 987;
                  t2.arrowdbldown = 603;
                  t2.lozenge = 494;
                  t2.angleleft = 329;
                  t2.registersans = 790;
                  t2.copyrightsans = 790;
                  t2.trademarksans = 786;
                  t2.summation = 713;
                  t2.parenlefttp = 384;
                  t2.parenleftex = 384;
                  t2.parenleftbt = 384;
                  t2.bracketlefttp = 384;
                  t2.bracketleftex = 384;
                  t2.bracketleftbt = 384;
                  t2.bracelefttp = 494;
                  t2.braceleftmid = 494;
                  t2.braceleftbt = 494;
                  t2.braceex = 494;
                  t2.angleright = 329;
                  t2.integral = 274;
                  t2.integraltp = 686;
                  t2.integralex = 686;
                  t2.integralbt = 686;
                  t2.parenrighttp = 384;
                  t2.parenrightex = 384;
                  t2.parenrightbt = 384;
                  t2.bracketrighttp = 384;
                  t2.bracketrightex = 384;
                  t2.bracketrightbt = 384;
                  t2.bracerighttp = 494;
                  t2.bracerightmid = 494;
                  t2.bracerightbt = 494;
                  t2.apple = 790;
                });
                t["Times-Roman"] = (0, _core_utils.getLookupTableFactory)(function(t2) {
                  t2.space = 250;
                  t2.exclam = 333;
                  t2.quotedbl = 408;
                  t2.numbersign = 500;
                  t2.dollar = 500;
                  t2.percent = 833;
                  t2.ampersand = 778;
                  t2.quoteright = 333;
                  t2.parenleft = 333;
                  t2.parenright = 333;
                  t2.asterisk = 500;
                  t2.plus = 564;
                  t2.comma = 250;
                  t2.hyphen = 333;
                  t2.period = 250;
                  t2.slash = 278;
                  t2.zero = 500;
                  t2.one = 500;
                  t2.two = 500;
                  t2.three = 500;
                  t2.four = 500;
                  t2.five = 500;
                  t2.six = 500;
                  t2.seven = 500;
                  t2.eight = 500;
                  t2.nine = 500;
                  t2.colon = 278;
                  t2.semicolon = 278;
                  t2.less = 564;
                  t2.equal = 564;
                  t2.greater = 564;
                  t2.question = 444;
                  t2.at = 921;
                  t2.A = 722;
                  t2.B = 667;
                  t2.C = 667;
                  t2.D = 722;
                  t2.E = 611;
                  t2.F = 556;
                  t2.G = 722;
                  t2.H = 722;
                  t2.I = 333;
                  t2.J = 389;
                  t2.K = 722;
                  t2.L = 611;
                  t2.M = 889;
                  t2.N = 722;
                  t2.O = 722;
                  t2.P = 556;
                  t2.Q = 722;
                  t2.R = 667;
                  t2.S = 556;
                  t2.T = 611;
                  t2.U = 722;
                  t2.V = 722;
                  t2.W = 944;
                  t2.X = 722;
                  t2.Y = 722;
                  t2.Z = 611;
                  t2.bracketleft = 333;
                  t2.backslash = 278;
                  t2.bracketright = 333;
                  t2.asciicircum = 469;
                  t2.underscore = 500;
                  t2.quoteleft = 333;
                  t2.a = 444;
                  t2.b = 500;
                  t2.c = 444;
                  t2.d = 500;
                  t2.e = 444;
                  t2.f = 333;
                  t2.g = 500;
                  t2.h = 500;
                  t2.i = 278;
                  t2.j = 278;
                  t2.k = 500;
                  t2.l = 278;
                  t2.m = 778;
                  t2.n = 500;
                  t2.o = 500;
                  t2.p = 500;
                  t2.q = 500;
                  t2.r = 333;
                  t2.s = 389;
                  t2.t = 278;
                  t2.u = 500;
                  t2.v = 500;
                  t2.w = 722;
                  t2.x = 500;
                  t2.y = 500;
                  t2.z = 444;
                  t2.braceleft = 480;
                  t2.bar = 200;
                  t2.braceright = 480;
                  t2.asciitilde = 541;
                  t2.exclamdown = 333;
                  t2.cent = 500;
                  t2.sterling = 500;
                  t2.fraction = 167;
                  t2.yen = 500;
                  t2.florin = 500;
                  t2.section = 500;
                  t2.currency = 500;
                  t2.quotesingle = 180;
                  t2.quotedblleft = 444;
                  t2.guillemotleft = 500;
                  t2.guilsinglleft = 333;
                  t2.guilsinglright = 333;
                  t2.fi = 556;
                  t2.fl = 556;
                  t2.endash = 500;
                  t2.dagger = 500;
                  t2.daggerdbl = 500;
                  t2.periodcentered = 250;
                  t2.paragraph = 453;
                  t2.bullet = 350;
                  t2.quotesinglbase = 333;
                  t2.quotedblbase = 444;
                  t2.quotedblright = 444;
                  t2.guillemotright = 500;
                  t2.ellipsis = 1e3;
                  t2.perthousand = 1e3;
                  t2.questiondown = 444;
                  t2.grave = 333;
                  t2.acute = 333;
                  t2.circumflex = 333;
                  t2.tilde = 333;
                  t2.macron = 333;
                  t2.breve = 333;
                  t2.dotaccent = 333;
                  t2.dieresis = 333;
                  t2.ring = 333;
                  t2.cedilla = 333;
                  t2.hungarumlaut = 333;
                  t2.ogonek = 333;
                  t2.caron = 333;
                  t2.emdash = 1e3;
                  t2.AE = 889;
                  t2.ordfeminine = 276;
                  t2.Lslash = 611;
                  t2.Oslash = 722;
                  t2.OE = 889;
                  t2.ordmasculine = 310;
                  t2.ae = 667;
                  t2.dotlessi = 278;
                  t2.lslash = 278;
                  t2.oslash = 500;
                  t2.oe = 722;
                  t2.germandbls = 500;
                  t2.Idieresis = 333;
                  t2.eacute = 444;
                  t2.abreve = 444;
                  t2.uhungarumlaut = 500;
                  t2.ecaron = 444;
                  t2.Ydieresis = 722;
                  t2.divide = 564;
                  t2.Yacute = 722;
                  t2.Acircumflex = 722;
                  t2.aacute = 444;
                  t2.Ucircumflex = 722;
                  t2.yacute = 500;
                  t2.scommaaccent = 389;
                  t2.ecircumflex = 444;
                  t2.Uring = 722;
                  t2.Udieresis = 722;
                  t2.aogonek = 444;
                  t2.Uacute = 722;
                  t2.uogonek = 500;
                  t2.Edieresis = 611;
                  t2.Dcroat = 722;
                  t2.commaaccent = 250;
                  t2.copyright = 760;
                  t2.Emacron = 611;
                  t2.ccaron = 444;
                  t2.aring = 444;
                  t2.Ncommaaccent = 722;
                  t2.lacute = 278;
                  t2.agrave = 444;
                  t2.Tcommaaccent = 611;
                  t2.Cacute = 667;
                  t2.atilde = 444;
                  t2.Edotaccent = 611;
                  t2.scaron = 389;
                  t2.scedilla = 389;
                  t2.iacute = 278;
                  t2.lozenge = 471;
                  t2.Rcaron = 667;
                  t2.Gcommaaccent = 722;
                  t2.ucircumflex = 500;
                  t2.acircumflex = 444;
                  t2.Amacron = 722;
                  t2.rcaron = 333;
                  t2.ccedilla = 444;
                  t2.Zdotaccent = 611;
                  t2.Thorn = 556;
                  t2.Omacron = 722;
                  t2.Racute = 667;
                  t2.Sacute = 556;
                  t2.dcaron = 588;
                  t2.Umacron = 722;
                  t2.uring = 500;
                  t2.threesuperior = 300;
                  t2.Ograve = 722;
                  t2.Agrave = 722;
                  t2.Abreve = 722;
                  t2.multiply = 564;
                  t2.uacute = 500;
                  t2.Tcaron = 611;
                  t2.partialdiff = 476;
                  t2.ydieresis = 500;
                  t2.Nacute = 722;
                  t2.icircumflex = 278;
                  t2.Ecircumflex = 611;
                  t2.adieresis = 444;
                  t2.edieresis = 444;
                  t2.cacute = 444;
                  t2.nacute = 500;
                  t2.umacron = 500;
                  t2.Ncaron = 722;
                  t2.Iacute = 333;
                  t2.plusminus = 564;
                  t2.brokenbar = 200;
                  t2.registered = 760;
                  t2.Gbreve = 722;
                  t2.Idotaccent = 333;
                  t2.summation = 600;
                  t2.Egrave = 611;
                  t2.racute = 333;
                  t2.omacron = 500;
                  t2.Zacute = 611;
                  t2.Zcaron = 611;
                  t2.greaterequal = 549;
                  t2.Eth = 722;
                  t2.Ccedilla = 667;
                  t2.lcommaaccent = 278;
                  t2.tcaron = 326;
                  t2.eogonek = 444;
                  t2.Uogonek = 722;
                  t2.Aacute = 722;
                  t2.Adieresis = 722;
                  t2.egrave = 444;
                  t2.zacute = 444;
                  t2.iogonek = 278;
                  t2.Oacute = 722;
                  t2.oacute = 500;
                  t2.amacron = 444;
                  t2.sacute = 389;
                  t2.idieresis = 278;
                  t2.Ocircumflex = 722;
                  t2.Ugrave = 722;
                  t2.Delta = 612;
                  t2.thorn = 500;
                  t2.twosuperior = 300;
                  t2.Odieresis = 722;
                  t2.mu = 500;
                  t2.igrave = 278;
                  t2.ohungarumlaut = 500;
                  t2.Eogonek = 611;
                  t2.dcroat = 500;
                  t2.threequarters = 750;
                  t2.Scedilla = 556;
                  t2.lcaron = 344;
                  t2.Kcommaaccent = 722;
                  t2.Lacute = 611;
                  t2.trademark = 980;
                  t2.edotaccent = 444;
                  t2.Igrave = 333;
                  t2.Imacron = 333;
                  t2.Lcaron = 611;
                  t2.onehalf = 750;
                  t2.lessequal = 549;
                  t2.ocircumflex = 500;
                  t2.ntilde = 500;
                  t2.Uhungarumlaut = 722;
                  t2.Eacute = 611;
                  t2.emacron = 444;
                  t2.gbreve = 500;
                  t2.onequarter = 750;
                  t2.Scaron = 556;
                  t2.Scommaaccent = 556;
                  t2.Ohungarumlaut = 722;
                  t2.degree = 400;
                  t2.ograve = 500;
                  t2.Ccaron = 667;
                  t2.ugrave = 500;
                  t2.radical = 453;
                  t2.Dcaron = 722;
                  t2.rcommaaccent = 333;
                  t2.Ntilde = 722;
                  t2.otilde = 500;
                  t2.Rcommaaccent = 667;
                  t2.Lcommaaccent = 611;
                  t2.Atilde = 722;
                  t2.Aogonek = 722;
                  t2.Aring = 722;
                  t2.Otilde = 722;
                  t2.zdotaccent = 444;
                  t2.Ecaron = 611;
                  t2.Iogonek = 333;
                  t2.kcommaaccent = 500;
                  t2.minus = 564;
                  t2.Icircumflex = 333;
                  t2.ncaron = 500;
                  t2.tcommaaccent = 278;
                  t2.logicalnot = 564;
                  t2.odieresis = 500;
                  t2.udieresis = 500;
                  t2.notequal = 549;
                  t2.gcommaaccent = 500;
                  t2.eth = 500;
                  t2.zcaron = 444;
                  t2.ncommaaccent = 500;
                  t2.onesuperior = 300;
                  t2.imacron = 278;
                  t2.Euro = 500;
                });
                t["Times-Bold"] = (0, _core_utils.getLookupTableFactory)(function(t2) {
                  t2.space = 250;
                  t2.exclam = 333;
                  t2.quotedbl = 555;
                  t2.numbersign = 500;
                  t2.dollar = 500;
                  t2.percent = 1e3;
                  t2.ampersand = 833;
                  t2.quoteright = 333;
                  t2.parenleft = 333;
                  t2.parenright = 333;
                  t2.asterisk = 500;
                  t2.plus = 570;
                  t2.comma = 250;
                  t2.hyphen = 333;
                  t2.period = 250;
                  t2.slash = 278;
                  t2.zero = 500;
                  t2.one = 500;
                  t2.two = 500;
                  t2.three = 500;
                  t2.four = 500;
                  t2.five = 500;
                  t2.six = 500;
                  t2.seven = 500;
                  t2.eight = 500;
                  t2.nine = 500;
                  t2.colon = 333;
                  t2.semicolon = 333;
                  t2.less = 570;
                  t2.equal = 570;
                  t2.greater = 570;
                  t2.question = 500;
                  t2.at = 930;
                  t2.A = 722;
                  t2.B = 667;
                  t2.C = 722;
                  t2.D = 722;
                  t2.E = 667;
                  t2.F = 611;
                  t2.G = 778;
                  t2.H = 778;
                  t2.I = 389;
                  t2.J = 500;
                  t2.K = 778;
                  t2.L = 667;
                  t2.M = 944;
                  t2.N = 722;
                  t2.O = 778;
                  t2.P = 611;
                  t2.Q = 778;
                  t2.R = 722;
                  t2.S = 556;
                  t2.T = 667;
                  t2.U = 722;
                  t2.V = 722;
                  t2.W = 1e3;
                  t2.X = 722;
                  t2.Y = 722;
                  t2.Z = 667;
                  t2.bracketleft = 333;
                  t2.backslash = 278;
                  t2.bracketright = 333;
                  t2.asciicircum = 581;
                  t2.underscore = 500;
                  t2.quoteleft = 333;
                  t2.a = 500;
                  t2.b = 556;
                  t2.c = 444;
                  t2.d = 556;
                  t2.e = 444;
                  t2.f = 333;
                  t2.g = 500;
                  t2.h = 556;
                  t2.i = 278;
                  t2.j = 333;
                  t2.k = 556;
                  t2.l = 278;
                  t2.m = 833;
                  t2.n = 556;
                  t2.o = 500;
                  t2.p = 556;
                  t2.q = 556;
                  t2.r = 444;
                  t2.s = 389;
                  t2.t = 333;
                  t2.u = 556;
                  t2.v = 500;
                  t2.w = 722;
                  t2.x = 500;
                  t2.y = 500;
                  t2.z = 444;
                  t2.braceleft = 394;
                  t2.bar = 220;
                  t2.braceright = 394;
                  t2.asciitilde = 520;
                  t2.exclamdown = 333;
                  t2.cent = 500;
                  t2.sterling = 500;
                  t2.fraction = 167;
                  t2.yen = 500;
                  t2.florin = 500;
                  t2.section = 500;
                  t2.currency = 500;
                  t2.quotesingle = 278;
                  t2.quotedblleft = 500;
                  t2.guillemotleft = 500;
                  t2.guilsinglleft = 333;
                  t2.guilsinglright = 333;
                  t2.fi = 556;
                  t2.fl = 556;
                  t2.endash = 500;
                  t2.dagger = 500;
                  t2.daggerdbl = 500;
                  t2.periodcentered = 250;
                  t2.paragraph = 540;
                  t2.bullet = 350;
                  t2.quotesinglbase = 333;
                  t2.quotedblbase = 500;
                  t2.quotedblright = 500;
                  t2.guillemotright = 500;
                  t2.ellipsis = 1e3;
                  t2.perthousand = 1e3;
                  t2.questiondown = 500;
                  t2.grave = 333;
                  t2.acute = 333;
                  t2.circumflex = 333;
                  t2.tilde = 333;
                  t2.macron = 333;
                  t2.breve = 333;
                  t2.dotaccent = 333;
                  t2.dieresis = 333;
                  t2.ring = 333;
                  t2.cedilla = 333;
                  t2.hungarumlaut = 333;
                  t2.ogonek = 333;
                  t2.caron = 333;
                  t2.emdash = 1e3;
                  t2.AE = 1e3;
                  t2.ordfeminine = 300;
                  t2.Lslash = 667;
                  t2.Oslash = 778;
                  t2.OE = 1e3;
                  t2.ordmasculine = 330;
                  t2.ae = 722;
                  t2.dotlessi = 278;
                  t2.lslash = 278;
                  t2.oslash = 500;
                  t2.oe = 722;
                  t2.germandbls = 556;
                  t2.Idieresis = 389;
                  t2.eacute = 444;
                  t2.abreve = 500;
                  t2.uhungarumlaut = 556;
                  t2.ecaron = 444;
                  t2.Ydieresis = 722;
                  t2.divide = 570;
                  t2.Yacute = 722;
                  t2.Acircumflex = 722;
                  t2.aacute = 500;
                  t2.Ucircumflex = 722;
                  t2.yacute = 500;
                  t2.scommaaccent = 389;
                  t2.ecircumflex = 444;
                  t2.Uring = 722;
                  t2.Udieresis = 722;
                  t2.aogonek = 500;
                  t2.Uacute = 722;
                  t2.uogonek = 556;
                  t2.Edieresis = 667;
                  t2.Dcroat = 722;
                  t2.commaaccent = 250;
                  t2.copyright = 747;
                  t2.Emacron = 667;
                  t2.ccaron = 444;
                  t2.aring = 500;
                  t2.Ncommaaccent = 722;
                  t2.lacute = 278;
                  t2.agrave = 500;
                  t2.Tcommaaccent = 667;
                  t2.Cacute = 722;
                  t2.atilde = 500;
                  t2.Edotaccent = 667;
                  t2.scaron = 389;
                  t2.scedilla = 389;
                  t2.iacute = 278;
                  t2.lozenge = 494;
                  t2.Rcaron = 722;
                  t2.Gcommaaccent = 778;
                  t2.ucircumflex = 556;
                  t2.acircumflex = 500;
                  t2.Amacron = 722;
                  t2.rcaron = 444;
                  t2.ccedilla = 444;
                  t2.Zdotaccent = 667;
                  t2.Thorn = 611;
                  t2.Omacron = 778;
                  t2.Racute = 722;
                  t2.Sacute = 556;
                  t2.dcaron = 672;
                  t2.Umacron = 722;
                  t2.uring = 556;
                  t2.threesuperior = 300;
                  t2.Ograve = 778;
                  t2.Agrave = 722;
                  t2.Abreve = 722;
                  t2.multiply = 570;
                  t2.uacute = 556;
                  t2.Tcaron = 667;
                  t2.partialdiff = 494;
                  t2.ydieresis = 500;
                  t2.Nacute = 722;
                  t2.icircumflex = 278;
                  t2.Ecircumflex = 667;
                  t2.adieresis = 500;
                  t2.edieresis = 444;
                  t2.cacute = 444;
                  t2.nacute = 556;
                  t2.umacron = 556;
                  t2.Ncaron = 722;
                  t2.Iacute = 389;
                  t2.plusminus = 570;
                  t2.brokenbar = 220;
                  t2.registered = 747;
                  t2.Gbreve = 778;
                  t2.Idotaccent = 389;
                  t2.summation = 600;
                  t2.Egrave = 667;
                  t2.racute = 444;
                  t2.omacron = 500;
                  t2.Zacute = 667;
                  t2.Zcaron = 667;
                  t2.greaterequal = 549;
                  t2.Eth = 722;
                  t2.Ccedilla = 722;
                  t2.lcommaaccent = 278;
                  t2.tcaron = 416;
                  t2.eogonek = 444;
                  t2.Uogonek = 722;
                  t2.Aacute = 722;
                  t2.Adieresis = 722;
                  t2.egrave = 444;
                  t2.zacute = 444;
                  t2.iogonek = 278;
                  t2.Oacute = 778;
                  t2.oacute = 500;
                  t2.amacron = 500;
                  t2.sacute = 389;
                  t2.idieresis = 278;
                  t2.Ocircumflex = 778;
                  t2.Ugrave = 722;
                  t2.Delta = 612;
                  t2.thorn = 556;
                  t2.twosuperior = 300;
                  t2.Odieresis = 778;
                  t2.mu = 556;
                  t2.igrave = 278;
                  t2.ohungarumlaut = 500;
                  t2.Eogonek = 667;
                  t2.dcroat = 556;
                  t2.threequarters = 750;
                  t2.Scedilla = 556;
                  t2.lcaron = 394;
                  t2.Kcommaaccent = 778;
                  t2.Lacute = 667;
                  t2.trademark = 1e3;
                  t2.edotaccent = 444;
                  t2.Igrave = 389;
                  t2.Imacron = 389;
                  t2.Lcaron = 667;
                  t2.onehalf = 750;
                  t2.lessequal = 549;
                  t2.ocircumflex = 500;
                  t2.ntilde = 556;
                  t2.Uhungarumlaut = 722;
                  t2.Eacute = 667;
                  t2.emacron = 444;
                  t2.gbreve = 500;
                  t2.onequarter = 750;
                  t2.Scaron = 556;
                  t2.Scommaaccent = 556;
                  t2.Ohungarumlaut = 778;
                  t2.degree = 400;
                  t2.ograve = 500;
                  t2.Ccaron = 722;
                  t2.ugrave = 556;
                  t2.radical = 549;
                  t2.Dcaron = 722;
                  t2.rcommaaccent = 444;
                  t2.Ntilde = 722;
                  t2.otilde = 500;
                  t2.Rcommaaccent = 722;
                  t2.Lcommaaccent = 667;
                  t2.Atilde = 722;
                  t2.Aogonek = 722;
                  t2.Aring = 722;
                  t2.Otilde = 778;
                  t2.zdotaccent = 444;
                  t2.Ecaron = 667;
                  t2.Iogonek = 389;
                  t2.kcommaaccent = 556;
                  t2.minus = 570;
                  t2.Icircumflex = 389;
                  t2.ncaron = 556;
                  t2.tcommaaccent = 333;
                  t2.logicalnot = 570;
                  t2.odieresis = 500;
                  t2.udieresis = 556;
                  t2.notequal = 549;
                  t2.gcommaaccent = 500;
                  t2.eth = 500;
                  t2.zcaron = 444;
                  t2.ncommaaccent = 556;
                  t2.onesuperior = 300;
                  t2.imacron = 278;
                  t2.Euro = 500;
                });
                t["Times-BoldItalic"] = (0, _core_utils.getLookupTableFactory)(function(t2) {
                  t2.space = 250;
                  t2.exclam = 389;
                  t2.quotedbl = 555;
                  t2.numbersign = 500;
                  t2.dollar = 500;
                  t2.percent = 833;
                  t2.ampersand = 778;
                  t2.quoteright = 333;
                  t2.parenleft = 333;
                  t2.parenright = 333;
                  t2.asterisk = 500;
                  t2.plus = 570;
                  t2.comma = 250;
                  t2.hyphen = 333;
                  t2.period = 250;
                  t2.slash = 278;
                  t2.zero = 500;
                  t2.one = 500;
                  t2.two = 500;
                  t2.three = 500;
                  t2.four = 500;
                  t2.five = 500;
                  t2.six = 500;
                  t2.seven = 500;
                  t2.eight = 500;
                  t2.nine = 500;
                  t2.colon = 333;
                  t2.semicolon = 333;
                  t2.less = 570;
                  t2.equal = 570;
                  t2.greater = 570;
                  t2.question = 500;
                  t2.at = 832;
                  t2.A = 667;
                  t2.B = 667;
                  t2.C = 667;
                  t2.D = 722;
                  t2.E = 667;
                  t2.F = 667;
                  t2.G = 722;
                  t2.H = 778;
                  t2.I = 389;
                  t2.J = 500;
                  t2.K = 667;
                  t2.L = 611;
                  t2.M = 889;
                  t2.N = 722;
                  t2.O = 722;
                  t2.P = 611;
                  t2.Q = 722;
                  t2.R = 667;
                  t2.S = 556;
                  t2.T = 611;
                  t2.U = 722;
                  t2.V = 667;
                  t2.W = 889;
                  t2.X = 667;
                  t2.Y = 611;
                  t2.Z = 611;
                  t2.bracketleft = 333;
                  t2.backslash = 278;
                  t2.bracketright = 333;
                  t2.asciicircum = 570;
                  t2.underscore = 500;
                  t2.quoteleft = 333;
                  t2.a = 500;
                  t2.b = 500;
                  t2.c = 444;
                  t2.d = 500;
                  t2.e = 444;
                  t2.f = 333;
                  t2.g = 500;
                  t2.h = 556;
                  t2.i = 278;
                  t2.j = 278;
                  t2.k = 500;
                  t2.l = 278;
                  t2.m = 778;
                  t2.n = 556;
                  t2.o = 500;
                  t2.p = 500;
                  t2.q = 500;
                  t2.r = 389;
                  t2.s = 389;
                  t2.t = 278;
                  t2.u = 556;
                  t2.v = 444;
                  t2.w = 667;
                  t2.x = 500;
                  t2.y = 444;
                  t2.z = 389;
                  t2.braceleft = 348;
                  t2.bar = 220;
                  t2.braceright = 348;
                  t2.asciitilde = 570;
                  t2.exclamdown = 389;
                  t2.cent = 500;
                  t2.sterling = 500;
                  t2.fraction = 167;
                  t2.yen = 500;
                  t2.florin = 500;
                  t2.section = 500;
                  t2.currency = 500;
                  t2.quotesingle = 278;
                  t2.quotedblleft = 500;
                  t2.guillemotleft = 500;
                  t2.guilsinglleft = 333;
                  t2.guilsinglright = 333;
                  t2.fi = 556;
                  t2.fl = 556;
                  t2.endash = 500;
                  t2.dagger = 500;
                  t2.daggerdbl = 500;
                  t2.periodcentered = 250;
                  t2.paragraph = 500;
                  t2.bullet = 350;
                  t2.quotesinglbase = 333;
                  t2.quotedblbase = 500;
                  t2.quotedblright = 500;
                  t2.guillemotright = 500;
                  t2.ellipsis = 1e3;
                  t2.perthousand = 1e3;
                  t2.questiondown = 500;
                  t2.grave = 333;
                  t2.acute = 333;
                  t2.circumflex = 333;
                  t2.tilde = 333;
                  t2.macron = 333;
                  t2.breve = 333;
                  t2.dotaccent = 333;
                  t2.dieresis = 333;
                  t2.ring = 333;
                  t2.cedilla = 333;
                  t2.hungarumlaut = 333;
                  t2.ogonek = 333;
                  t2.caron = 333;
                  t2.emdash = 1e3;
                  t2.AE = 944;
                  t2.ordfeminine = 266;
                  t2.Lslash = 611;
                  t2.Oslash = 722;
                  t2.OE = 944;
                  t2.ordmasculine = 300;
                  t2.ae = 722;
                  t2.dotlessi = 278;
                  t2.lslash = 278;
                  t2.oslash = 500;
                  t2.oe = 722;
                  t2.germandbls = 500;
                  t2.Idieresis = 389;
                  t2.eacute = 444;
                  t2.abreve = 500;
                  t2.uhungarumlaut = 556;
                  t2.ecaron = 444;
                  t2.Ydieresis = 611;
                  t2.divide = 570;
                  t2.Yacute = 611;
                  t2.Acircumflex = 667;
                  t2.aacute = 500;
                  t2.Ucircumflex = 722;
                  t2.yacute = 444;
                  t2.scommaaccent = 389;
                  t2.ecircumflex = 444;
                  t2.Uring = 722;
                  t2.Udieresis = 722;
                  t2.aogonek = 500;
                  t2.Uacute = 722;
                  t2.uogonek = 556;
                  t2.Edieresis = 667;
                  t2.Dcroat = 722;
                  t2.commaaccent = 250;
                  t2.copyright = 747;
                  t2.Emacron = 667;
                  t2.ccaron = 444;
                  t2.aring = 500;
                  t2.Ncommaaccent = 722;
                  t2.lacute = 278;
                  t2.agrave = 500;
                  t2.Tcommaaccent = 611;
                  t2.Cacute = 667;
                  t2.atilde = 500;
                  t2.Edotaccent = 667;
                  t2.scaron = 389;
                  t2.scedilla = 389;
                  t2.iacute = 278;
                  t2.lozenge = 494;
                  t2.Rcaron = 667;
                  t2.Gcommaaccent = 722;
                  t2.ucircumflex = 556;
                  t2.acircumflex = 500;
                  t2.Amacron = 667;
                  t2.rcaron = 389;
                  t2.ccedilla = 444;
                  t2.Zdotaccent = 611;
                  t2.Thorn = 611;
                  t2.Omacron = 722;
                  t2.Racute = 667;
                  t2.Sacute = 556;
                  t2.dcaron = 608;
                  t2.Umacron = 722;
                  t2.uring = 556;
                  t2.threesuperior = 300;
                  t2.Ograve = 722;
                  t2.Agrave = 667;
                  t2.Abreve = 667;
                  t2.multiply = 570;
                  t2.uacute = 556;
                  t2.Tcaron = 611;
                  t2.partialdiff = 494;
                  t2.ydieresis = 444;
                  t2.Nacute = 722;
                  t2.icircumflex = 278;
                  t2.Ecircumflex = 667;
                  t2.adieresis = 500;
                  t2.edieresis = 444;
                  t2.cacute = 444;
                  t2.nacute = 556;
                  t2.umacron = 556;
                  t2.Ncaron = 722;
                  t2.Iacute = 389;
                  t2.plusminus = 570;
                  t2.brokenbar = 220;
                  t2.registered = 747;
                  t2.Gbreve = 722;
                  t2.Idotaccent = 389;
                  t2.summation = 600;
                  t2.Egrave = 667;
                  t2.racute = 389;
                  t2.omacron = 500;
                  t2.Zacute = 611;
                  t2.Zcaron = 611;
                  t2.greaterequal = 549;
                  t2.Eth = 722;
                  t2.Ccedilla = 667;
                  t2.lcommaaccent = 278;
                  t2.tcaron = 366;
                  t2.eogonek = 444;
                  t2.Uogonek = 722;
                  t2.Aacute = 667;
                  t2.Adieresis = 667;
                  t2.egrave = 444;
                  t2.zacute = 389;
                  t2.iogonek = 278;
                  t2.Oacute = 722;
                  t2.oacute = 500;
                  t2.amacron = 500;
                  t2.sacute = 389;
                  t2.idieresis = 278;
                  t2.Ocircumflex = 722;
                  t2.Ugrave = 722;
                  t2.Delta = 612;
                  t2.thorn = 500;
                  t2.twosuperior = 300;
                  t2.Odieresis = 722;
                  t2.mu = 576;
                  t2.igrave = 278;
                  t2.ohungarumlaut = 500;
                  t2.Eogonek = 667;
                  t2.dcroat = 500;
                  t2.threequarters = 750;
                  t2.Scedilla = 556;
                  t2.lcaron = 382;
                  t2.Kcommaaccent = 667;
                  t2.Lacute = 611;
                  t2.trademark = 1e3;
                  t2.edotaccent = 444;
                  t2.Igrave = 389;
                  t2.Imacron = 389;
                  t2.Lcaron = 611;
                  t2.onehalf = 750;
                  t2.lessequal = 549;
                  t2.ocircumflex = 500;
                  t2.ntilde = 556;
                  t2.Uhungarumlaut = 722;
                  t2.Eacute = 667;
                  t2.emacron = 444;
                  t2.gbreve = 500;
                  t2.onequarter = 750;
                  t2.Scaron = 556;
                  t2.Scommaaccent = 556;
                  t2.Ohungarumlaut = 722;
                  t2.degree = 400;
                  t2.ograve = 500;
                  t2.Ccaron = 667;
                  t2.ugrave = 556;
                  t2.radical = 549;
                  t2.Dcaron = 722;
                  t2.rcommaaccent = 389;
                  t2.Ntilde = 722;
                  t2.otilde = 500;
                  t2.Rcommaaccent = 667;
                  t2.Lcommaaccent = 611;
                  t2.Atilde = 667;
                  t2.Aogonek = 667;
                  t2.Aring = 667;
                  t2.Otilde = 722;
                  t2.zdotaccent = 389;
                  t2.Ecaron = 667;
                  t2.Iogonek = 389;
                  t2.kcommaaccent = 500;
                  t2.minus = 606;
                  t2.Icircumflex = 389;
                  t2.ncaron = 556;
                  t2.tcommaaccent = 278;
                  t2.logicalnot = 606;
                  t2.odieresis = 500;
                  t2.udieresis = 556;
                  t2.notequal = 549;
                  t2.gcommaaccent = 500;
                  t2.eth = 500;
                  t2.zcaron = 389;
                  t2.ncommaaccent = 556;
                  t2.onesuperior = 300;
                  t2.imacron = 278;
                  t2.Euro = 500;
                });
                t["Times-Italic"] = (0, _core_utils.getLookupTableFactory)(function(t2) {
                  t2.space = 250;
                  t2.exclam = 333;
                  t2.quotedbl = 420;
                  t2.numbersign = 500;
                  t2.dollar = 500;
                  t2.percent = 833;
                  t2.ampersand = 778;
                  t2.quoteright = 333;
                  t2.parenleft = 333;
                  t2.parenright = 333;
                  t2.asterisk = 500;
                  t2.plus = 675;
                  t2.comma = 250;
                  t2.hyphen = 333;
                  t2.period = 250;
                  t2.slash = 278;
                  t2.zero = 500;
                  t2.one = 500;
                  t2.two = 500;
                  t2.three = 500;
                  t2.four = 500;
                  t2.five = 500;
                  t2.six = 500;
                  t2.seven = 500;
                  t2.eight = 500;
                  t2.nine = 500;
                  t2.colon = 333;
                  t2.semicolon = 333;
                  t2.less = 675;
                  t2.equal = 675;
                  t2.greater = 675;
                  t2.question = 500;
                  t2.at = 920;
                  t2.A = 611;
                  t2.B = 611;
                  t2.C = 667;
                  t2.D = 722;
                  t2.E = 611;
                  t2.F = 611;
                  t2.G = 722;
                  t2.H = 722;
                  t2.I = 333;
                  t2.J = 444;
                  t2.K = 667;
                  t2.L = 556;
                  t2.M = 833;
                  t2.N = 667;
                  t2.O = 722;
                  t2.P = 611;
                  t2.Q = 722;
                  t2.R = 611;
                  t2.S = 500;
                  t2.T = 556;
                  t2.U = 722;
                  t2.V = 611;
                  t2.W = 833;
                  t2.X = 611;
                  t2.Y = 556;
                  t2.Z = 556;
                  t2.bracketleft = 389;
                  t2.backslash = 278;
                  t2.bracketright = 389;
                  t2.asciicircum = 422;
                  t2.underscore = 500;
                  t2.quoteleft = 333;
                  t2.a = 500;
                  t2.b = 500;
                  t2.c = 444;
                  t2.d = 500;
                  t2.e = 444;
                  t2.f = 278;
                  t2.g = 500;
                  t2.h = 500;
                  t2.i = 278;
                  t2.j = 278;
                  t2.k = 444;
                  t2.l = 278;
                  t2.m = 722;
                  t2.n = 500;
                  t2.o = 500;
                  t2.p = 500;
                  t2.q = 500;
                  t2.r = 389;
                  t2.s = 389;
                  t2.t = 278;
                  t2.u = 500;
                  t2.v = 444;
                  t2.w = 667;
                  t2.x = 444;
                  t2.y = 444;
                  t2.z = 389;
                  t2.braceleft = 400;
                  t2.bar = 275;
                  t2.braceright = 400;
                  t2.asciitilde = 541;
                  t2.exclamdown = 389;
                  t2.cent = 500;
                  t2.sterling = 500;
                  t2.fraction = 167;
                  t2.yen = 500;
                  t2.florin = 500;
                  t2.section = 500;
                  t2.currency = 500;
                  t2.quotesingle = 214;
                  t2.quotedblleft = 556;
                  t2.guillemotleft = 500;
                  t2.guilsinglleft = 333;
                  t2.guilsinglright = 333;
                  t2.fi = 500;
                  t2.fl = 500;
                  t2.endash = 500;
                  t2.dagger = 500;
                  t2.daggerdbl = 500;
                  t2.periodcentered = 250;
                  t2.paragraph = 523;
                  t2.bullet = 350;
                  t2.quotesinglbase = 333;
                  t2.quotedblbase = 556;
                  t2.quotedblright = 556;
                  t2.guillemotright = 500;
                  t2.ellipsis = 889;
                  t2.perthousand = 1e3;
                  t2.questiondown = 500;
                  t2.grave = 333;
                  t2.acute = 333;
                  t2.circumflex = 333;
                  t2.tilde = 333;
                  t2.macron = 333;
                  t2.breve = 333;
                  t2.dotaccent = 333;
                  t2.dieresis = 333;
                  t2.ring = 333;
                  t2.cedilla = 333;
                  t2.hungarumlaut = 333;
                  t2.ogonek = 333;
                  t2.caron = 333;
                  t2.emdash = 889;
                  t2.AE = 889;
                  t2.ordfeminine = 276;
                  t2.Lslash = 556;
                  t2.Oslash = 722;
                  t2.OE = 944;
                  t2.ordmasculine = 310;
                  t2.ae = 667;
                  t2.dotlessi = 278;
                  t2.lslash = 278;
                  t2.oslash = 500;
                  t2.oe = 667;
                  t2.germandbls = 500;
                  t2.Idieresis = 333;
                  t2.eacute = 444;
                  t2.abreve = 500;
                  t2.uhungarumlaut = 500;
                  t2.ecaron = 444;
                  t2.Ydieresis = 556;
                  t2.divide = 675;
                  t2.Yacute = 556;
                  t2.Acircumflex = 611;
                  t2.aacute = 500;
                  t2.Ucircumflex = 722;
                  t2.yacute = 444;
                  t2.scommaaccent = 389;
                  t2.ecircumflex = 444;
                  t2.Uring = 722;
                  t2.Udieresis = 722;
                  t2.aogonek = 500;
                  t2.Uacute = 722;
                  t2.uogonek = 500;
                  t2.Edieresis = 611;
                  t2.Dcroat = 722;
                  t2.commaaccent = 250;
                  t2.copyright = 760;
                  t2.Emacron = 611;
                  t2.ccaron = 444;
                  t2.aring = 500;
                  t2.Ncommaaccent = 667;
                  t2.lacute = 278;
                  t2.agrave = 500;
                  t2.Tcommaaccent = 556;
                  t2.Cacute = 667;
                  t2.atilde = 500;
                  t2.Edotaccent = 611;
                  t2.scaron = 389;
                  t2.scedilla = 389;
                  t2.iacute = 278;
                  t2.lozenge = 471;
                  t2.Rcaron = 611;
                  t2.Gcommaaccent = 722;
                  t2.ucircumflex = 500;
                  t2.acircumflex = 500;
                  t2.Amacron = 611;
                  t2.rcaron = 389;
                  t2.ccedilla = 444;
                  t2.Zdotaccent = 556;
                  t2.Thorn = 611;
                  t2.Omacron = 722;
                  t2.Racute = 611;
                  t2.Sacute = 500;
                  t2.dcaron = 544;
                  t2.Umacron = 722;
                  t2.uring = 500;
                  t2.threesuperior = 300;
                  t2.Ograve = 722;
                  t2.Agrave = 611;
                  t2.Abreve = 611;
                  t2.multiply = 675;
                  t2.uacute = 500;
                  t2.Tcaron = 556;
                  t2.partialdiff = 476;
                  t2.ydieresis = 444;
                  t2.Nacute = 667;
                  t2.icircumflex = 278;
                  t2.Ecircumflex = 611;
                  t2.adieresis = 500;
                  t2.edieresis = 444;
                  t2.cacute = 444;
                  t2.nacute = 500;
                  t2.umacron = 500;
                  t2.Ncaron = 667;
                  t2.Iacute = 333;
                  t2.plusminus = 675;
                  t2.brokenbar = 275;
                  t2.registered = 760;
                  t2.Gbreve = 722;
                  t2.Idotaccent = 333;
                  t2.summation = 600;
                  t2.Egrave = 611;
                  t2.racute = 389;
                  t2.omacron = 500;
                  t2.Zacute = 556;
                  t2.Zcaron = 556;
                  t2.greaterequal = 549;
                  t2.Eth = 722;
                  t2.Ccedilla = 667;
                  t2.lcommaaccent = 278;
                  t2.tcaron = 300;
                  t2.eogonek = 444;
                  t2.Uogonek = 722;
                  t2.Aacute = 611;
                  t2.Adieresis = 611;
                  t2.egrave = 444;
                  t2.zacute = 389;
                  t2.iogonek = 278;
                  t2.Oacute = 722;
                  t2.oacute = 500;
                  t2.amacron = 500;
                  t2.sacute = 389;
                  t2.idieresis = 278;
                  t2.Ocircumflex = 722;
                  t2.Ugrave = 722;
                  t2.Delta = 612;
                  t2.thorn = 500;
                  t2.twosuperior = 300;
                  t2.Odieresis = 722;
                  t2.mu = 500;
                  t2.igrave = 278;
                  t2.ohungarumlaut = 500;
                  t2.Eogonek = 611;
                  t2.dcroat = 500;
                  t2.threequarters = 750;
                  t2.Scedilla = 500;
                  t2.lcaron = 300;
                  t2.Kcommaaccent = 667;
                  t2.Lacute = 556;
                  t2.trademark = 980;
                  t2.edotaccent = 444;
                  t2.Igrave = 333;
                  t2.Imacron = 333;
                  t2.Lcaron = 611;
                  t2.onehalf = 750;
                  t2.lessequal = 549;
                  t2.ocircumflex = 500;
                  t2.ntilde = 500;
                  t2.Uhungarumlaut = 722;
                  t2.Eacute = 611;
                  t2.emacron = 444;
                  t2.gbreve = 500;
                  t2.onequarter = 750;
                  t2.Scaron = 500;
                  t2.Scommaaccent = 500;
                  t2.Ohungarumlaut = 722;
                  t2.degree = 400;
                  t2.ograve = 500;
                  t2.Ccaron = 667;
                  t2.ugrave = 500;
                  t2.radical = 453;
                  t2.Dcaron = 722;
                  t2.rcommaaccent = 389;
                  t2.Ntilde = 667;
                  t2.otilde = 500;
                  t2.Rcommaaccent = 611;
                  t2.Lcommaaccent = 556;
                  t2.Atilde = 611;
                  t2.Aogonek = 611;
                  t2.Aring = 611;
                  t2.Otilde = 722;
                  t2.zdotaccent = 389;
                  t2.Ecaron = 611;
                  t2.Iogonek = 333;
                  t2.kcommaaccent = 444;
                  t2.minus = 675;
                  t2.Icircumflex = 333;
                  t2.ncaron = 500;
                  t2.tcommaaccent = 278;
                  t2.logicalnot = 675;
                  t2.odieresis = 500;
                  t2.udieresis = 500;
                  t2.notequal = 549;
                  t2.gcommaaccent = 500;
                  t2.eth = 500;
                  t2.zcaron = 389;
                  t2.ncommaaccent = 500;
                  t2.onesuperior = 300;
                  t2.imacron = 278;
                  t2.Euro = 500;
                });
                t.ZapfDingbats = (0, _core_utils.getLookupTableFactory)(function(t2) {
                  t2.space = 278;
                  t2.a1 = 974;
                  t2.a2 = 961;
                  t2.a202 = 974;
                  t2.a3 = 980;
                  t2.a4 = 719;
                  t2.a5 = 789;
                  t2.a119 = 790;
                  t2.a118 = 791;
                  t2.a117 = 690;
                  t2.a11 = 960;
                  t2.a12 = 939;
                  t2.a13 = 549;
                  t2.a14 = 855;
                  t2.a15 = 911;
                  t2.a16 = 933;
                  t2.a105 = 911;
                  t2.a17 = 945;
                  t2.a18 = 974;
                  t2.a19 = 755;
                  t2.a20 = 846;
                  t2.a21 = 762;
                  t2.a22 = 761;
                  t2.a23 = 571;
                  t2.a24 = 677;
                  t2.a25 = 763;
                  t2.a26 = 760;
                  t2.a27 = 759;
                  t2.a28 = 754;
                  t2.a6 = 494;
                  t2.a7 = 552;
                  t2.a8 = 537;
                  t2.a9 = 577;
                  t2.a10 = 692;
                  t2.a29 = 786;
                  t2.a30 = 788;
                  t2.a31 = 788;
                  t2.a32 = 790;
                  t2.a33 = 793;
                  t2.a34 = 794;
                  t2.a35 = 816;
                  t2.a36 = 823;
                  t2.a37 = 789;
                  t2.a38 = 841;
                  t2.a39 = 823;
                  t2.a40 = 833;
                  t2.a41 = 816;
                  t2.a42 = 831;
                  t2.a43 = 923;
                  t2.a44 = 744;
                  t2.a45 = 723;
                  t2.a46 = 749;
                  t2.a47 = 790;
                  t2.a48 = 792;
                  t2.a49 = 695;
                  t2.a50 = 776;
                  t2.a51 = 768;
                  t2.a52 = 792;
                  t2.a53 = 759;
                  t2.a54 = 707;
                  t2.a55 = 708;
                  t2.a56 = 682;
                  t2.a57 = 701;
                  t2.a58 = 826;
                  t2.a59 = 815;
                  t2.a60 = 789;
                  t2.a61 = 789;
                  t2.a62 = 707;
                  t2.a63 = 687;
                  t2.a64 = 696;
                  t2.a65 = 689;
                  t2.a66 = 786;
                  t2.a67 = 787;
                  t2.a68 = 713;
                  t2.a69 = 791;
                  t2.a70 = 785;
                  t2.a71 = 791;
                  t2.a72 = 873;
                  t2.a73 = 761;
                  t2.a74 = 762;
                  t2.a203 = 762;
                  t2.a75 = 759;
                  t2.a204 = 759;
                  t2.a76 = 892;
                  t2.a77 = 892;
                  t2.a78 = 788;
                  t2.a79 = 784;
                  t2.a81 = 438;
                  t2.a82 = 138;
                  t2.a83 = 277;
                  t2.a84 = 415;
                  t2.a97 = 392;
                  t2.a98 = 392;
                  t2.a99 = 668;
                  t2.a100 = 668;
                  t2.a89 = 390;
                  t2.a90 = 390;
                  t2.a93 = 317;
                  t2.a94 = 317;
                  t2.a91 = 276;
                  t2.a92 = 276;
                  t2.a205 = 509;
                  t2.a85 = 509;
                  t2.a206 = 410;
                  t2.a86 = 410;
                  t2.a87 = 234;
                  t2.a88 = 234;
                  t2.a95 = 334;
                  t2.a96 = 334;
                  t2.a101 = 732;
                  t2.a102 = 544;
                  t2.a103 = 544;
                  t2.a104 = 910;
                  t2.a106 = 667;
                  t2.a107 = 760;
                  t2.a108 = 760;
                  t2.a112 = 776;
                  t2.a111 = 595;
                  t2.a110 = 694;
                  t2.a109 = 626;
                  t2.a120 = 788;
                  t2.a121 = 788;
                  t2.a122 = 788;
                  t2.a123 = 788;
                  t2.a124 = 788;
                  t2.a125 = 788;
                  t2.a126 = 788;
                  t2.a127 = 788;
                  t2.a128 = 788;
                  t2.a129 = 788;
                  t2.a130 = 788;
                  t2.a131 = 788;
                  t2.a132 = 788;
                  t2.a133 = 788;
                  t2.a134 = 788;
                  t2.a135 = 788;
                  t2.a136 = 788;
                  t2.a137 = 788;
                  t2.a138 = 788;
                  t2.a139 = 788;
                  t2.a140 = 788;
                  t2.a141 = 788;
                  t2.a142 = 788;
                  t2.a143 = 788;
                  t2.a144 = 788;
                  t2.a145 = 788;
                  t2.a146 = 788;
                  t2.a147 = 788;
                  t2.a148 = 788;
                  t2.a149 = 788;
                  t2.a150 = 788;
                  t2.a151 = 788;
                  t2.a152 = 788;
                  t2.a153 = 788;
                  t2.a154 = 788;
                  t2.a155 = 788;
                  t2.a156 = 788;
                  t2.a157 = 788;
                  t2.a158 = 788;
                  t2.a159 = 788;
                  t2.a160 = 894;
                  t2.a161 = 838;
                  t2.a163 = 1016;
                  t2.a164 = 458;
                  t2.a196 = 748;
                  t2.a165 = 924;
                  t2.a192 = 748;
                  t2.a166 = 918;
                  t2.a167 = 927;
                  t2.a168 = 928;
                  t2.a169 = 928;
                  t2.a170 = 834;
                  t2.a171 = 873;
                  t2.a172 = 828;
                  t2.a173 = 924;
                  t2.a162 = 924;
                  t2.a174 = 917;
                  t2.a175 = 930;
                  t2.a176 = 931;
                  t2.a177 = 463;
                  t2.a178 = 883;
                  t2.a179 = 836;
                  t2.a193 = 836;
                  t2.a180 = 867;
                  t2.a199 = 867;
                  t2.a181 = 696;
                  t2.a200 = 696;
                  t2.a182 = 874;
                  t2.a201 = 874;
                  t2.a183 = 760;
                  t2.a184 = 946;
                  t2.a197 = 771;
                  t2.a185 = 865;
                  t2.a194 = 771;
                  t2.a198 = 888;
                  t2.a186 = 967;
                  t2.a195 = 888;
                  t2.a187 = 831;
                  t2.a188 = 873;
                  t2.a189 = 927;
                  t2.a190 = 970;
                  t2.a191 = 918;
                });
              });
              exports2.getMetrics = getMetrics;
              const getFontBasicMetrics = (0, _core_utils.getLookupTableFactory)(function(t) {
                t.Courier = {
                  ascent: 629,
                  descent: -157,
                  capHeight: 562,
                  xHeight: -426
                };
                t["Courier-Bold"] = {
                  ascent: 629,
                  descent: -157,
                  capHeight: 562,
                  xHeight: 439
                };
                t["Courier-Oblique"] = {
                  ascent: 629,
                  descent: -157,
                  capHeight: 562,
                  xHeight: 426
                };
                t["Courier-BoldOblique"] = {
                  ascent: 629,
                  descent: -157,
                  capHeight: 562,
                  xHeight: 426
                };
                t.Helvetica = {
                  ascent: 718,
                  descent: -207,
                  capHeight: 718,
                  xHeight: 523
                };
                t["Helvetica-Bold"] = {
                  ascent: 718,
                  descent: -207,
                  capHeight: 718,
                  xHeight: 532
                };
                t["Helvetica-Oblique"] = {
                  ascent: 718,
                  descent: -207,
                  capHeight: 718,
                  xHeight: 523
                };
                t["Helvetica-BoldOblique"] = {
                  ascent: 718,
                  descent: -207,
                  capHeight: 718,
                  xHeight: 532
                };
                t["Times-Roman"] = {
                  ascent: 683,
                  descent: -217,
                  capHeight: 662,
                  xHeight: 450
                };
                t["Times-Bold"] = {
                  ascent: 683,
                  descent: -217,
                  capHeight: 676,
                  xHeight: 461
                };
                t["Times-Italic"] = {
                  ascent: 683,
                  descent: -217,
                  capHeight: 653,
                  xHeight: 441
                };
                t["Times-BoldItalic"] = {
                  ascent: 683,
                  descent: -217,
                  capHeight: 669,
                  xHeight: 462
                };
                t.Symbol = {
                  ascent: Math.NaN,
                  descent: Math.NaN,
                  capHeight: Math.NaN,
                  xHeight: Math.NaN
                };
                t.ZapfDingbats = {
                  ascent: Math.NaN,
                  descent: Math.NaN,
                  capHeight: Math.NaN,
                  xHeight: Math.NaN
                };
              });
              exports2.getFontBasicMetrics = getFontBasicMetrics;
            },
            /* 171 */
            /***/
            (__unused_webpack_module, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.GlyfTable = void 0;
              const ON_CURVE_POINT = 1 << 0;
              const X_SHORT_VECTOR = 1 << 1;
              const Y_SHORT_VECTOR = 1 << 2;
              const REPEAT_FLAG = 1 << 3;
              const X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR = 1 << 4;
              const Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR = 1 << 5;
              const OVERLAP_SIMPLE = 1 << 6;
              const ARG_1_AND_2_ARE_WORDS = 1 << 0;
              const ARGS_ARE_XY_VALUES = 1 << 1;
              const WE_HAVE_A_SCALE = 1 << 3;
              const MORE_COMPONENTS = 1 << 5;
              const WE_HAVE_AN_X_AND_Y_SCALE = 1 << 6;
              const WE_HAVE_A_TWO_BY_TWO = 1 << 7;
              const WE_HAVE_INSTRUCTIONS = 1 << 8;
              const _GlyfTable = class _GlyfTable {
                constructor(_ref) {
                  let {
                    glyfTable,
                    isGlyphLocationsLong,
                    locaTable,
                    numGlyphs
                  } = _ref;
                  this.glyphs = [];
                  const loca = new DataView(locaTable.buffer, locaTable.byteOffset, locaTable.byteLength);
                  const glyf = new DataView(glyfTable.buffer, glyfTable.byteOffset, glyfTable.byteLength);
                  const offsetSize = isGlyphLocationsLong ? 4 : 2;
                  let prev = isGlyphLocationsLong ? loca.getUint32(0) : 2 * loca.getUint16(0);
                  let pos = 0;
                  for (let i = 0; i < numGlyphs; i++) {
                    pos += offsetSize;
                    const next = isGlyphLocationsLong ? loca.getUint32(pos) : 2 * loca.getUint16(pos);
                    if (next === prev) {
                      this.glyphs.push(new Glyph({}));
                      continue;
                    }
                    const glyph = Glyph.parse(prev, glyf);
                    this.glyphs.push(glyph);
                    prev = next;
                  }
                }
                getSize() {
                  return this.glyphs.reduce((a, g) => {
                    const size = g.getSize();
                    return a + (size + 3 & ~3);
                  }, 0);
                }
                write() {
                  const totalSize = this.getSize();
                  const glyfTable = new DataView(new ArrayBuffer(totalSize));
                  const isLocationLong = totalSize > 131070;
                  const offsetSize = isLocationLong ? 4 : 2;
                  const locaTable = new DataView(new ArrayBuffer((this.glyphs.length + 1) * offsetSize));
                  if (isLocationLong) {
                    locaTable.setUint32(0, 0);
                  } else {
                    locaTable.setUint16(0, 0);
                  }
                  let pos = 0;
                  let locaIndex = 0;
                  for (const glyph of this.glyphs) {
                    pos += glyph.write(pos, glyfTable);
                    pos = pos + 3 & ~3;
                    locaIndex += offsetSize;
                    if (isLocationLong) {
                      locaTable.setUint32(locaIndex, pos);
                    } else {
                      locaTable.setUint16(locaIndex, pos >> 1);
                    }
                  }
                  return {
                    isLocationLong,
                    loca: new Uint8Array(locaTable.buffer),
                    glyf: new Uint8Array(glyfTable.buffer)
                  };
                }
                scale(factors) {
                  for (let i = 0, ii = this.glyphs.length; i < ii; i++) {
                    this.glyphs[i].scale(factors[i]);
                  }
                }
              };
              __name(_GlyfTable, "GlyfTable");
              let GlyfTable = _GlyfTable;
              exports2.GlyfTable = GlyfTable;
              const _Glyph = class _Glyph {
                constructor(_ref2) {
                  let {
                    header = null,
                    simple = null,
                    composites = null
                  } = _ref2;
                  this.header = header;
                  this.simple = simple;
                  this.composites = composites;
                }
                static parse(pos, glyf) {
                  const [read, header] = GlyphHeader.parse(pos, glyf);
                  pos += read;
                  if (header.numberOfContours < 0) {
                    const composites = [];
                    while (true) {
                      const [n, composite] = CompositeGlyph.parse(pos, glyf);
                      pos += n;
                      composites.push(composite);
                      if (!(composite.flags & MORE_COMPONENTS)) {
                        break;
                      }
                    }
                    return new _Glyph({
                      header,
                      composites
                    });
                  }
                  const simple = SimpleGlyph.parse(pos, glyf, header.numberOfContours);
                  return new _Glyph({
                    header,
                    simple
                  });
                }
                getSize() {
                  if (!this.header) {
                    return 0;
                  }
                  const size = this.simple ? this.simple.getSize() : this.composites.reduce((a, c) => a + c.getSize(), 0);
                  return this.header.getSize() + size;
                }
                write(pos, buf) {
                  if (!this.header) {
                    return 0;
                  }
                  const spos = pos;
                  pos += this.header.write(pos, buf);
                  if (this.simple) {
                    pos += this.simple.write(pos, buf);
                  } else {
                    for (const composite of this.composites) {
                      pos += composite.write(pos, buf);
                    }
                  }
                  return pos - spos;
                }
                scale(factor) {
                  if (!this.header) {
                    return;
                  }
                  const xMiddle = (this.header.xMin + this.header.xMax) / 2;
                  this.header.scale(xMiddle, factor);
                  if (this.simple) {
                    this.simple.scale(xMiddle, factor);
                  } else {
                    for (const composite of this.composites) {
                      composite.scale(xMiddle, factor);
                    }
                  }
                }
              };
              __name(_Glyph, "Glyph");
              let Glyph = _Glyph;
              const _GlyphHeader = class _GlyphHeader {
                constructor(_ref3) {
                  let {
                    numberOfContours,
                    xMin,
                    yMin,
                    xMax,
                    yMax
                  } = _ref3;
                  this.numberOfContours = numberOfContours;
                  this.xMin = xMin;
                  this.yMin = yMin;
                  this.xMax = xMax;
                  this.yMax = yMax;
                }
                static parse(pos, glyf) {
                  return [10, new _GlyphHeader({
                    numberOfContours: glyf.getInt16(pos),
                    xMin: glyf.getInt16(pos + 2),
                    yMin: glyf.getInt16(pos + 4),
                    xMax: glyf.getInt16(pos + 6),
                    yMax: glyf.getInt16(pos + 8)
                  })];
                }
                getSize() {
                  return 10;
                }
                write(pos, buf) {
                  buf.setInt16(pos, this.numberOfContours);
                  buf.setInt16(pos + 2, this.xMin);
                  buf.setInt16(pos + 4, this.yMin);
                  buf.setInt16(pos + 6, this.xMax);
                  buf.setInt16(pos + 8, this.yMax);
                  return 10;
                }
                scale(x, factor) {
                  this.xMin = Math.round(x + (this.xMin - x) * factor);
                  this.xMax = Math.round(x + (this.xMax - x) * factor);
                }
              };
              __name(_GlyphHeader, "GlyphHeader");
              let GlyphHeader = _GlyphHeader;
              const _Contour = class _Contour {
                constructor(_ref4) {
                  let {
                    flags,
                    xCoordinates,
                    yCoordinates
                  } = _ref4;
                  this.xCoordinates = xCoordinates;
                  this.yCoordinates = yCoordinates;
                  this.flags = flags;
                }
              };
              __name(_Contour, "Contour");
              let Contour = _Contour;
              const _SimpleGlyph = class _SimpleGlyph {
                constructor(_ref5) {
                  let {
                    contours,
                    instructions
                  } = _ref5;
                  this.contours = contours;
                  this.instructions = instructions;
                }
                static parse(pos, glyf, numberOfContours) {
                  const endPtsOfContours = [];
                  for (let i = 0; i < numberOfContours; i++) {
                    const endPt = glyf.getUint16(pos);
                    pos += 2;
                    endPtsOfContours.push(endPt);
                  }
                  const numberOfPt = endPtsOfContours[numberOfContours - 1] + 1;
                  const instructionLength = glyf.getUint16(pos);
                  pos += 2;
                  const instructions = new Uint8Array(glyf).slice(pos, pos + instructionLength);
                  pos += instructionLength;
                  const flags = [];
                  for (let i = 0; i < numberOfPt; pos++, i++) {
                    let flag = glyf.getUint8(pos);
                    flags.push(flag);
                    if (flag & REPEAT_FLAG) {
                      const count = glyf.getUint8(++pos);
                      flag ^= REPEAT_FLAG;
                      for (let m = 0; m < count; m++) {
                        flags.push(flag);
                      }
                      i += count;
                    }
                  }
                  const allXCoordinates = [];
                  let xCoordinates = [];
                  let yCoordinates = [];
                  let pointFlags = [];
                  const contours = [];
                  let endPtsOfContoursIndex = 0;
                  let lastCoordinate = 0;
                  for (let i = 0; i < numberOfPt; i++) {
                    const flag = flags[i];
                    if (flag & X_SHORT_VECTOR) {
                      const x = glyf.getUint8(pos++);
                      lastCoordinate += flag & X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR ? x : -x;
                      xCoordinates.push(lastCoordinate);
                    } else if (flag & X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR) {
                      xCoordinates.push(lastCoordinate);
                    } else {
                      lastCoordinate += glyf.getInt16(pos);
                      pos += 2;
                      xCoordinates.push(lastCoordinate);
                    }
                    if (endPtsOfContours[endPtsOfContoursIndex] === i) {
                      endPtsOfContoursIndex++;
                      allXCoordinates.push(xCoordinates);
                      xCoordinates = [];
                    }
                  }
                  lastCoordinate = 0;
                  endPtsOfContoursIndex = 0;
                  for (let i = 0; i < numberOfPt; i++) {
                    const flag = flags[i];
                    if (flag & Y_SHORT_VECTOR) {
                      const y = glyf.getUint8(pos++);
                      lastCoordinate += flag & Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR ? y : -y;
                      yCoordinates.push(lastCoordinate);
                    } else if (flag & Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR) {
                      yCoordinates.push(lastCoordinate);
                    } else {
                      lastCoordinate += glyf.getInt16(pos);
                      pos += 2;
                      yCoordinates.push(lastCoordinate);
                    }
                    pointFlags.push(flag & ON_CURVE_POINT | flag & OVERLAP_SIMPLE);
                    if (endPtsOfContours[endPtsOfContoursIndex] === i) {
                      xCoordinates = allXCoordinates[endPtsOfContoursIndex];
                      endPtsOfContoursIndex++;
                      contours.push(new Contour({
                        flags: pointFlags,
                        xCoordinates,
                        yCoordinates
                      }));
                      yCoordinates = [];
                      pointFlags = [];
                    }
                  }
                  return new _SimpleGlyph({
                    contours,
                    instructions
                  });
                }
                getSize() {
                  let size = this.contours.length * 2 + 2 + this.instructions.length;
                  let lastX = 0;
                  let lastY = 0;
                  for (const contour of this.contours) {
                    size += contour.flags.length;
                    for (let i = 0, ii = contour.xCoordinates.length; i < ii; i++) {
                      const x = contour.xCoordinates[i];
                      const y = contour.yCoordinates[i];
                      let abs = Math.abs(x - lastX);
                      if (abs > 255) {
                        size += 2;
                      } else if (abs > 0) {
                        size += 1;
                      }
                      lastX = x;
                      abs = Math.abs(y - lastY);
                      if (abs > 255) {
                        size += 2;
                      } else if (abs > 0) {
                        size += 1;
                      }
                      lastY = y;
                    }
                  }
                  return size;
                }
                write(pos, buf) {
                  const spos = pos;
                  const xCoordinates = [];
                  const yCoordinates = [];
                  const flags = [];
                  let lastX = 0;
                  let lastY = 0;
                  for (const contour of this.contours) {
                    for (let i = 0, ii = contour.xCoordinates.length; i < ii; i++) {
                      let flag = contour.flags[i];
                      const x = contour.xCoordinates[i];
                      let delta = x - lastX;
                      if (delta === 0) {
                        flag |= X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR;
                        xCoordinates.push(0);
                      } else {
                        const abs = Math.abs(delta);
                        if (abs <= 255) {
                          flag |= delta >= 0 ? X_SHORT_VECTOR | X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR : X_SHORT_VECTOR;
                          xCoordinates.push(abs);
                        } else {
                          xCoordinates.push(delta);
                        }
                      }
                      lastX = x;
                      const y = contour.yCoordinates[i];
                      delta = y - lastY;
                      if (delta === 0) {
                        flag |= Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR;
                        yCoordinates.push(0);
                      } else {
                        const abs = Math.abs(delta);
                        if (abs <= 255) {
                          flag |= delta >= 0 ? Y_SHORT_VECTOR | Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR : Y_SHORT_VECTOR;
                          yCoordinates.push(abs);
                        } else {
                          yCoordinates.push(delta);
                        }
                      }
                      lastY = y;
                      flags.push(flag);
                    }
                    buf.setUint16(pos, xCoordinates.length - 1);
                    pos += 2;
                  }
                  buf.setUint16(pos, this.instructions.length);
                  pos += 2;
                  if (this.instructions.length) {
                    new Uint8Array(buf.buffer, 0, buf.buffer.byteLength).set(this.instructions, pos);
                    pos += this.instructions.length;
                  }
                  for (const flag of flags) {
                    buf.setUint8(pos++, flag);
                  }
                  for (let i = 0, ii = xCoordinates.length; i < ii; i++) {
                    const x = xCoordinates[i];
                    const flag = flags[i];
                    if (flag & X_SHORT_VECTOR) {
                      buf.setUint8(pos++, x);
                    } else if (!(flag & X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR)) {
                      buf.setInt16(pos, x);
                      pos += 2;
                    }
                  }
                  for (let i = 0, ii = yCoordinates.length; i < ii; i++) {
                    const y = yCoordinates[i];
                    const flag = flags[i];
                    if (flag & Y_SHORT_VECTOR) {
                      buf.setUint8(pos++, y);
                    } else if (!(flag & Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR)) {
                      buf.setInt16(pos, y);
                      pos += 2;
                    }
                  }
                  return pos - spos;
                }
                scale(x, factor) {
                  for (const contour of this.contours) {
                    if (contour.xCoordinates.length === 0) {
                      continue;
                    }
                    for (let i = 0, ii = contour.xCoordinates.length; i < ii; i++) {
                      contour.xCoordinates[i] = Math.round(x + (contour.xCoordinates[i] - x) * factor);
                    }
                  }
                }
              };
              __name(_SimpleGlyph, "SimpleGlyph");
              let SimpleGlyph = _SimpleGlyph;
              const _CompositeGlyph = class _CompositeGlyph {
                constructor(_ref6) {
                  let {
                    flags,
                    glyphIndex,
                    argument1,
                    argument2,
                    transf,
                    instructions
                  } = _ref6;
                  this.flags = flags;
                  this.glyphIndex = glyphIndex;
                  this.argument1 = argument1;
                  this.argument2 = argument2;
                  this.transf = transf;
                  this.instructions = instructions;
                }
                static parse(pos, glyf) {
                  const spos = pos;
                  const transf = [];
                  let flags = glyf.getUint16(pos);
                  const glyphIndex = glyf.getUint16(pos + 2);
                  pos += 4;
                  let argument1, argument2;
                  if (flags & ARG_1_AND_2_ARE_WORDS) {
                    if (flags & ARGS_ARE_XY_VALUES) {
                      argument1 = glyf.getInt16(pos);
                      argument2 = glyf.getInt16(pos + 2);
                    } else {
                      argument1 = glyf.getUint16(pos);
                      argument2 = glyf.getUint16(pos + 2);
                    }
                    pos += 4;
                    flags ^= ARG_1_AND_2_ARE_WORDS;
                  } else {
                    if (flags & ARGS_ARE_XY_VALUES) {
                      argument1 = glyf.getInt8(pos);
                      argument2 = glyf.getInt8(pos + 1);
                    } else {
                      argument1 = glyf.getUint8(pos);
                      argument2 = glyf.getUint8(pos + 1);
                    }
                    pos += 2;
                  }
                  if (flags & WE_HAVE_A_SCALE) {
                    transf.push(glyf.getUint16(pos));
                    pos += 2;
                  } else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) {
                    transf.push(glyf.getUint16(pos), glyf.getUint16(pos + 2));
                    pos += 4;
                  } else if (flags & WE_HAVE_A_TWO_BY_TWO) {
                    transf.push(glyf.getUint16(pos), glyf.getUint16(pos + 2), glyf.getUint16(pos + 4), glyf.getUint16(pos + 6));
                    pos += 8;
                  }
                  let instructions = null;
                  if (flags & WE_HAVE_INSTRUCTIONS) {
                    const instructionLength = glyf.getUint16(pos);
                    pos += 2;
                    instructions = new Uint8Array(glyf).slice(pos, pos + instructionLength);
                    pos += instructionLength;
                  }
                  return [pos - spos, new _CompositeGlyph({
                    flags,
                    glyphIndex,
                    argument1,
                    argument2,
                    transf,
                    instructions
                  })];
                }
                getSize() {
                  let size = 2 + 2 + this.transf.length * 2;
                  if (this.flags & WE_HAVE_INSTRUCTIONS) {
                    size += 2 + this.instructions.length;
                  }
                  size += 2;
                  if (this.flags & 2) {
                    if (!(this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127)) {
                      size += 2;
                    }
                  } else {
                    if (!(this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255)) {
                      size += 2;
                    }
                  }
                  return size;
                }
                write(pos, buf) {
                  const spos = pos;
                  if (this.flags & ARGS_ARE_XY_VALUES) {
                    if (!(this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127)) {
                      this.flags |= ARG_1_AND_2_ARE_WORDS;
                    }
                  } else {
                    if (!(this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255)) {
                      this.flags |= ARG_1_AND_2_ARE_WORDS;
                    }
                  }
                  buf.setUint16(pos, this.flags);
                  buf.setUint16(pos + 2, this.glyphIndex);
                  pos += 4;
                  if (this.flags & ARG_1_AND_2_ARE_WORDS) {
                    if (this.flags & ARGS_ARE_XY_VALUES) {
                      buf.setInt16(pos, this.argument1);
                      buf.setInt16(pos + 2, this.argument2);
                    } else {
                      buf.setUint16(pos, this.argument1);
                      buf.setUint16(pos + 2, this.argument2);
                    }
                    pos += 4;
                  } else {
                    buf.setUint8(pos, this.argument1);
                    buf.setUint8(pos + 1, this.argument2);
                    pos += 2;
                  }
                  if (this.flags & WE_HAVE_INSTRUCTIONS) {
                    buf.setUint16(pos, this.instructions.length);
                    pos += 2;
                    if (this.instructions.length) {
                      new Uint8Array(buf.buffer, 0, buf.buffer.byteLength).set(this.instructions, pos);
                      pos += this.instructions.length;
                    }
                  }
                  return pos - spos;
                }
                scale(x, factor) {
                }
              };
              __name(_CompositeGlyph, "CompositeGlyph");
              let CompositeGlyph = _CompositeGlyph;
            },
            /* 172 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.OpenTypeFileBuilder = void 0;
              var _core_utils = __w_pdfjs_require__2(131);
              var _util = __w_pdfjs_require__2(2);
              function writeInt16(dest, offset, num) {
                dest[offset] = num >> 8 & 255;
                dest[offset + 1] = num & 255;
              }
              __name(writeInt16, "writeInt16");
              function writeInt32(dest, offset, num) {
                dest[offset] = num >> 24 & 255;
                dest[offset + 1] = num >> 16 & 255;
                dest[offset + 2] = num >> 8 & 255;
                dest[offset + 3] = num & 255;
              }
              __name(writeInt32, "writeInt32");
              function writeData(dest, offset, data) {
                if (data instanceof Uint8Array) {
                  dest.set(data, offset);
                } else if (typeof data === "string") {
                  for (let i = 0, ii = data.length; i < ii; i++) {
                    dest[offset++] = data.charCodeAt(i) & 255;
                  }
                } else {
                  for (let i = 0, ii = data.length; i < ii; i++) {
                    dest[offset++] = data[i] & 255;
                  }
                }
              }
              __name(writeData, "writeData");
              const OTF_HEADER_SIZE = 12;
              const OTF_TABLE_ENTRY_SIZE = 16;
              const _OpenTypeFileBuilder = class _OpenTypeFileBuilder {
                constructor(sfnt) {
                  this.sfnt = sfnt;
                  this.tables = /* @__PURE__ */ Object.create(null);
                }
                static getSearchParams(entriesCount, entrySize) {
                  let maxPower2 = 1, log2 = 0;
                  while ((maxPower2 ^ entriesCount) > maxPower2) {
                    maxPower2 <<= 1;
                    log2++;
                  }
                  const searchRange = maxPower2 * entrySize;
                  return {
                    range: searchRange,
                    entry: log2,
                    rangeShift: entrySize * entriesCount - searchRange
                  };
                }
                toArray() {
                  let sfnt = this.sfnt;
                  const tables = this.tables;
                  const tablesNames = Object.keys(tables);
                  tablesNames.sort();
                  const numTables = tablesNames.length;
                  let i, j, jj, table, tableName;
                  let offset = OTF_HEADER_SIZE + numTables * OTF_TABLE_ENTRY_SIZE;
                  const tableOffsets = [offset];
                  for (i = 0; i < numTables; i++) {
                    table = tables[tablesNames[i]];
                    const paddedLength = (table.length + 3 & ~3) >>> 0;
                    offset += paddedLength;
                    tableOffsets.push(offset);
                  }
                  const file = new Uint8Array(offset);
                  for (i = 0; i < numTables; i++) {
                    table = tables[tablesNames[i]];
                    writeData(file, tableOffsets[i], table);
                  }
                  if (sfnt === "true") {
                    sfnt = (0, _util.string32)(65536);
                  }
                  file[0] = sfnt.charCodeAt(0) & 255;
                  file[1] = sfnt.charCodeAt(1) & 255;
                  file[2] = sfnt.charCodeAt(2) & 255;
                  file[3] = sfnt.charCodeAt(3) & 255;
                  writeInt16(file, 4, numTables);
                  const searchParams = _OpenTypeFileBuilder.getSearchParams(numTables, 16);
                  writeInt16(file, 6, searchParams.range);
                  writeInt16(file, 8, searchParams.entry);
                  writeInt16(file, 10, searchParams.rangeShift);
                  offset = OTF_HEADER_SIZE;
                  for (i = 0; i < numTables; i++) {
                    tableName = tablesNames[i];
                    file[offset] = tableName.charCodeAt(0) & 255;
                    file[offset + 1] = tableName.charCodeAt(1) & 255;
                    file[offset + 2] = tableName.charCodeAt(2) & 255;
                    file[offset + 3] = tableName.charCodeAt(3) & 255;
                    let checksum = 0;
                    for (j = tableOffsets[i], jj = tableOffsets[i + 1]; j < jj; j += 4) {
                      const quad = (0, _core_utils.readUint32)(file, j);
                      checksum = checksum + quad >>> 0;
                    }
                    writeInt32(file, offset + 4, checksum);
                    writeInt32(file, offset + 8, tableOffsets[i]);
                    writeInt32(file, offset + 12, tables[tableName].length);
                    offset += OTF_TABLE_ENTRY_SIZE;
                  }
                  return file;
                }
                addTable(tag, data) {
                  if (tag in this.tables) {
                    throw new Error("Table " + tag + " already exists");
                  }
                  this.tables[tag] = data;
                }
              };
              __name(_OpenTypeFileBuilder, "OpenTypeFileBuilder");
              let OpenTypeFileBuilder = _OpenTypeFileBuilder;
              exports2.OpenTypeFileBuilder = OpenTypeFileBuilder;
            },
            /* 173 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Type1Font = void 0;
              var _cff_parser = __w_pdfjs_require__2(160);
              var _fonts_utils = __w_pdfjs_require__2(163);
              var _core_utils = __w_pdfjs_require__2(131);
              var _stream = __w_pdfjs_require__2(135);
              var _type1_parser = __w_pdfjs_require__2(174);
              var _util = __w_pdfjs_require__2(2);
              function findBlock(streamBytes, signature, startIndex) {
                const streamBytesLength = streamBytes.length;
                const signatureLength = signature.length;
                const scanLength = streamBytesLength - signatureLength;
                let i = startIndex, found = false;
                while (i < scanLength) {
                  let j = 0;
                  while (j < signatureLength && streamBytes[i + j] === signature[j]) {
                    j++;
                  }
                  if (j >= signatureLength) {
                    i += j;
                    while (i < streamBytesLength && (0, _core_utils.isWhiteSpace)(streamBytes[i])) {
                      i++;
                    }
                    found = true;
                    break;
                  }
                  i++;
                }
                return {
                  found,
                  length: i
                };
              }
              __name(findBlock, "findBlock");
              function getHeaderBlock(stream, suggestedLength) {
                const EEXEC_SIGNATURE = [101, 101, 120, 101, 99];
                const streamStartPos = stream.pos;
                let headerBytes, headerBytesLength, block;
                try {
                  headerBytes = stream.getBytes(suggestedLength);
                  headerBytesLength = headerBytes.length;
                } catch (ex) {
                }
                if (headerBytesLength === suggestedLength) {
                  block = findBlock(headerBytes, EEXEC_SIGNATURE, suggestedLength - 2 * EEXEC_SIGNATURE.length);
                  if (block.found && block.length === suggestedLength) {
                    return {
                      stream: new _stream.Stream(headerBytes),
                      length: suggestedLength
                    };
                  }
                }
                (0, _util.warn)('Invalid "Length1" property in Type1 font -- trying to recover.');
                stream.pos = streamStartPos;
                const SCAN_BLOCK_LENGTH = 2048;
                let actualLength;
                while (true) {
                  const scanBytes = stream.peekBytes(SCAN_BLOCK_LENGTH);
                  block = findBlock(scanBytes, EEXEC_SIGNATURE, 0);
                  if (block.length === 0) {
                    break;
                  }
                  stream.pos += block.length;
                  if (block.found) {
                    actualLength = stream.pos - streamStartPos;
                    break;
                  }
                }
                stream.pos = streamStartPos;
                if (actualLength) {
                  return {
                    stream: new _stream.Stream(stream.getBytes(actualLength)),
                    length: actualLength
                  };
                }
                (0, _util.warn)('Unable to recover "Length1" property in Type1 font -- using as is.');
                return {
                  stream: new _stream.Stream(stream.getBytes(suggestedLength)),
                  length: suggestedLength
                };
              }
              __name(getHeaderBlock, "getHeaderBlock");
              function getEexecBlock(stream, suggestedLength) {
                const eexecBytes = stream.getBytes();
                return {
                  stream: new _stream.Stream(eexecBytes),
                  length: eexecBytes.length
                };
              }
              __name(getEexecBlock, "getEexecBlock");
              const _Type1Font = class _Type1Font {
                constructor(name, file, properties) {
                  const PFB_HEADER_SIZE = 6;
                  let headerBlockLength = properties.length1;
                  properties.length2;
                  let pfbHeader = file.peekBytes(PFB_HEADER_SIZE);
                  const pfbHeaderPresent = pfbHeader[0] === 128 && pfbHeader[1] === 1;
                  if (pfbHeaderPresent) {
                    file.skip(PFB_HEADER_SIZE);
                    headerBlockLength = pfbHeader[5] << 24 | pfbHeader[4] << 16 | pfbHeader[3] << 8 | pfbHeader[2];
                  }
                  const headerBlock = getHeaderBlock(file, headerBlockLength);
                  const headerBlockParser = new _type1_parser.Type1Parser(headerBlock.stream, false, _fonts_utils.SEAC_ANALYSIS_ENABLED);
                  headerBlockParser.extractFontHeader(properties);
                  if (pfbHeaderPresent) {
                    pfbHeader = file.getBytes(PFB_HEADER_SIZE);
                    pfbHeader[5] << 24 | pfbHeader[4] << 16 | pfbHeader[3] << 8 | pfbHeader[2];
                  }
                  const eexecBlock = getEexecBlock(file);
                  const eexecBlockParser = new _type1_parser.Type1Parser(eexecBlock.stream, true, _fonts_utils.SEAC_ANALYSIS_ENABLED);
                  const data = eexecBlockParser.extractFontProgram(properties);
                  for (const key in data.properties) {
                    properties[key] = data.properties[key];
                  }
                  const charstrings = data.charstrings;
                  const type2Charstrings = this.getType2Charstrings(charstrings);
                  const subrs = this.getType2Subrs(data.subrs);
                  this.charstrings = charstrings;
                  this.data = this.wrap(name, type2Charstrings, this.charstrings, subrs, properties);
                  this.seacs = this.getSeacs(data.charstrings);
                }
                get numGlyphs() {
                  return this.charstrings.length + 1;
                }
                getCharset() {
                  const charset = [".notdef"];
                  for (const {
                    glyphName
                  } of this.charstrings) {
                    charset.push(glyphName);
                  }
                  return charset;
                }
                getGlyphMapping(properties) {
                  const charstrings = this.charstrings;
                  if (properties.composite) {
                    const charCodeToGlyphId = /* @__PURE__ */ Object.create(null);
                    for (let glyphId2 = 0, charstringsLen = charstrings.length; glyphId2 < charstringsLen; glyphId2++) {
                      const charCode = properties.cMap.charCodeOf(glyphId2);
                      charCodeToGlyphId[charCode] = glyphId2 + 1;
                    }
                    return charCodeToGlyphId;
                  }
                  const glyphNames = [".notdef"];
                  let builtInEncoding, glyphId;
                  for (glyphId = 0; glyphId < charstrings.length; glyphId++) {
                    glyphNames.push(charstrings[glyphId].glyphName);
                  }
                  const encoding = properties.builtInEncoding;
                  if (encoding) {
                    builtInEncoding = /* @__PURE__ */ Object.create(null);
                    for (const charCode in encoding) {
                      glyphId = glyphNames.indexOf(encoding[charCode]);
                      if (glyphId >= 0) {
                        builtInEncoding[charCode] = glyphId;
                      }
                    }
                  }
                  return (0, _fonts_utils.type1FontGlyphMapping)(properties, builtInEncoding, glyphNames);
                }
                hasGlyphId(id) {
                  if (id < 0 || id >= this.numGlyphs) {
                    return false;
                  }
                  if (id === 0) {
                    return true;
                  }
                  const glyph = this.charstrings[id - 1];
                  return glyph.charstring.length > 0;
                }
                getSeacs(charstrings) {
                  const seacMap = [];
                  for (let i = 0, ii = charstrings.length; i < ii; i++) {
                    const charstring = charstrings[i];
                    if (charstring.seac) {
                      seacMap[i + 1] = charstring.seac;
                    }
                  }
                  return seacMap;
                }
                getType2Charstrings(type1Charstrings) {
                  const type2Charstrings = [];
                  for (let i = 0, ii = type1Charstrings.length; i < ii; i++) {
                    type2Charstrings.push(type1Charstrings[i].charstring);
                  }
                  return type2Charstrings;
                }
                getType2Subrs(type1Subrs) {
                  let bias = 0;
                  const count = type1Subrs.length;
                  if (count < 1133) {
                    bias = 107;
                  } else if (count < 33769) {
                    bias = 1131;
                  } else {
                    bias = 32768;
                  }
                  const type2Subrs = [];
                  let i;
                  for (i = 0; i < bias; i++) {
                    type2Subrs.push([11]);
                  }
                  for (i = 0; i < count; i++) {
                    type2Subrs.push(type1Subrs[i]);
                  }
                  return type2Subrs;
                }
                wrap(name, glyphs, charstrings, subrs, properties) {
                  const cff = new _cff_parser.CFF();
                  cff.header = new _cff_parser.CFFHeader(1, 0, 4, 4);
                  cff.names = [name];
                  const topDict = new _cff_parser.CFFTopDict();
                  topDict.setByName("version", 391);
                  topDict.setByName("Notice", 392);
                  topDict.setByName("FullName", 393);
                  topDict.setByName("FamilyName", 394);
                  topDict.setByName("Weight", 395);
                  topDict.setByName("Encoding", null);
                  topDict.setByName("FontMatrix", properties.fontMatrix);
                  topDict.setByName("FontBBox", properties.bbox);
                  topDict.setByName("charset", null);
                  topDict.setByName("CharStrings", null);
                  topDict.setByName("Private", null);
                  cff.topDict = topDict;
                  const strings = new _cff_parser.CFFStrings();
                  strings.add("Version 0.11");
                  strings.add("See original notice");
                  strings.add(name);
                  strings.add(name);
                  strings.add("Medium");
                  cff.strings = strings;
                  cff.globalSubrIndex = new _cff_parser.CFFIndex();
                  const count = glyphs.length;
                  const charsetArray = [".notdef"];
                  let i, ii;
                  for (i = 0; i < count; i++) {
                    const glyphName = charstrings[i].glyphName;
                    const index = _cff_parser.CFFStandardStrings.indexOf(glyphName);
                    if (index === -1) {
                      strings.add(glyphName);
                    }
                    charsetArray.push(glyphName);
                  }
                  cff.charset = new _cff_parser.CFFCharset(false, 0, charsetArray);
                  const charStringsIndex = new _cff_parser.CFFIndex();
                  charStringsIndex.add([139, 14]);
                  for (i = 0; i < count; i++) {
                    charStringsIndex.add(glyphs[i]);
                  }
                  cff.charStrings = charStringsIndex;
                  const privateDict = new _cff_parser.CFFPrivateDict();
                  privateDict.setByName("Subrs", null);
                  const fields = ["BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StemSnapH", "StemSnapV", "BlueShift", "BlueFuzz", "BlueScale", "LanguageGroup", "ExpansionFactor", "ForceBold", "StdHW", "StdVW"];
                  for (i = 0, ii = fields.length; i < ii; i++) {
                    const field = fields[i];
                    if (!(field in properties.privateData)) {
                      continue;
                    }
                    const value = properties.privateData[field];
                    if (Array.isArray(value)) {
                      for (let j = value.length - 1; j > 0; j--) {
                        value[j] -= value[j - 1];
                      }
                    }
                    privateDict.setByName(field, value);
                  }
                  cff.topDict.privateDict = privateDict;
                  const subrIndex = new _cff_parser.CFFIndex();
                  for (i = 0, ii = subrs.length; i < ii; i++) {
                    subrIndex.add(subrs[i]);
                  }
                  privateDict.subrsIndex = subrIndex;
                  const compiler = new _cff_parser.CFFCompiler(cff);
                  return compiler.compile();
                }
              };
              __name(_Type1Font, "Type1Font");
              let Type1Font = _Type1Font;
              exports2.Type1Font = Type1Font;
            },
            /* 174 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Type1Parser = void 0;
              var _encodings = __w_pdfjs_require__2(162);
              var _core_utils = __w_pdfjs_require__2(131);
              var _stream = __w_pdfjs_require__2(135);
              var _util = __w_pdfjs_require__2(2);
              const HINTING_ENABLED = false;
              const COMMAND_MAP = {
                hstem: [1],
                vstem: [3],
                vmoveto: [4],
                rlineto: [5],
                hlineto: [6],
                vlineto: [7],
                rrcurveto: [8],
                callsubr: [10],
                flex: [12, 35],
                drop: [12, 18],
                endchar: [14],
                rmoveto: [21],
                hmoveto: [22],
                vhcurveto: [30],
                hvcurveto: [31]
              };
              const _Type1CharString = class _Type1CharString {
                constructor() {
                  this.width = 0;
                  this.lsb = 0;
                  this.flexing = false;
                  this.output = [];
                  this.stack = [];
                }
                convert(encoded, subrs, seacAnalysisEnabled) {
                  const count = encoded.length;
                  let error = false;
                  let wx, sbx, subrNumber;
                  for (let i = 0; i < count; i++) {
                    let value = encoded[i];
                    if (value < 32) {
                      if (value === 12) {
                        value = (value << 8) + encoded[++i];
                      }
                      switch (value) {
                        case 1: {
                          this.stack = [];
                          break;
                        }
                        case 3: {
                          this.stack = [];
                          break;
                        }
                        case 4:
                          if (this.flexing) {
                            if (this.stack.length < 1) {
                              error = true;
                              break;
                            }
                            const dy = this.stack.pop();
                            this.stack.push(0, dy);
                            break;
                          }
                          error = this.executeCommand(1, COMMAND_MAP.vmoveto);
                          break;
                        case 5:
                          error = this.executeCommand(2, COMMAND_MAP.rlineto);
                          break;
                        case 6:
                          error = this.executeCommand(1, COMMAND_MAP.hlineto);
                          break;
                        case 7:
                          error = this.executeCommand(1, COMMAND_MAP.vlineto);
                          break;
                        case 8:
                          error = this.executeCommand(6, COMMAND_MAP.rrcurveto);
                          break;
                        case 9:
                          this.stack = [];
                          break;
                        case 10:
                          if (this.stack.length < 1) {
                            error = true;
                            break;
                          }
                          subrNumber = this.stack.pop();
                          if (!subrs[subrNumber]) {
                            error = true;
                            break;
                          }
                          error = this.convert(subrs[subrNumber], subrs, seacAnalysisEnabled);
                          break;
                        case 11:
                          return error;
                        case 13:
                          if (this.stack.length < 2) {
                            error = true;
                            break;
                          }
                          wx = this.stack.pop();
                          sbx = this.stack.pop();
                          this.lsb = sbx;
                          this.width = wx;
                          this.stack.push(wx, sbx);
                          error = this.executeCommand(2, COMMAND_MAP.hmoveto);
                          break;
                        case 14:
                          this.output.push(COMMAND_MAP.endchar[0]);
                          break;
                        case 21:
                          if (this.flexing) {
                            break;
                          }
                          error = this.executeCommand(2, COMMAND_MAP.rmoveto);
                          break;
                        case 22:
                          if (this.flexing) {
                            this.stack.push(0);
                            break;
                          }
                          error = this.executeCommand(1, COMMAND_MAP.hmoveto);
                          break;
                        case 30:
                          error = this.executeCommand(4, COMMAND_MAP.vhcurveto);
                          break;
                        case 31:
                          error = this.executeCommand(4, COMMAND_MAP.hvcurveto);
                          break;
                        case (12 << 8) + 0:
                          this.stack = [];
                          break;
                        case (12 << 8) + 1: {
                          this.stack = [];
                          break;
                        }
                        case (12 << 8) + 2: {
                          this.stack = [];
                          break;
                        }
                        case (12 << 8) + 6:
                          if (seacAnalysisEnabled) {
                            const asb = this.stack.at(-5);
                            this.seac = this.stack.splice(-4, 4);
                            this.seac[0] += this.lsb - asb;
                            error = this.executeCommand(0, COMMAND_MAP.endchar);
                          } else {
                            error = this.executeCommand(4, COMMAND_MAP.endchar);
                          }
                          break;
                        case (12 << 8) + 7:
                          if (this.stack.length < 4) {
                            error = true;
                            break;
                          }
                          this.stack.pop();
                          wx = this.stack.pop();
                          const sby = this.stack.pop();
                          sbx = this.stack.pop();
                          this.lsb = sbx;
                          this.width = wx;
                          this.stack.push(wx, sbx, sby);
                          error = this.executeCommand(3, COMMAND_MAP.rmoveto);
                          break;
                        case (12 << 8) + 12:
                          if (this.stack.length < 2) {
                            error = true;
                            break;
                          }
                          const num2 = this.stack.pop();
                          const num1 = this.stack.pop();
                          this.stack.push(num1 / num2);
                          break;
                        case (12 << 8) + 16:
                          if (this.stack.length < 2) {
                            error = true;
                            break;
                          }
                          subrNumber = this.stack.pop();
                          const numArgs = this.stack.pop();
                          if (subrNumber === 0 && numArgs === 3) {
                            const flexArgs = this.stack.splice(this.stack.length - 17, 17);
                            this.stack.push(flexArgs[2] + flexArgs[0], flexArgs[3] + flexArgs[1], flexArgs[4], flexArgs[5], flexArgs[6], flexArgs[7], flexArgs[8], flexArgs[9], flexArgs[10], flexArgs[11], flexArgs[12], flexArgs[13], flexArgs[14]);
                            error = this.executeCommand(13, COMMAND_MAP.flex, true);
                            this.flexing = false;
                            this.stack.push(flexArgs[15], flexArgs[16]);
                          } else if (subrNumber === 1 && numArgs === 0) {
                            this.flexing = true;
                          }
                          break;
                        case (12 << 8) + 17:
                          break;
                        case (12 << 8) + 33:
                          this.stack = [];
                          break;
                        default:
                          (0, _util.warn)('Unknown type 1 charstring command of "' + value + '"');
                          break;
                      }
                      if (error) {
                        break;
                      }
                      continue;
                    } else if (value <= 246) {
                      value -= 139;
                    } else if (value <= 250) {
                      value = (value - 247) * 256 + encoded[++i] + 108;
                    } else if (value <= 254) {
                      value = -((value - 251) * 256) - encoded[++i] - 108;
                    } else {
                      value = (encoded[++i] & 255) << 24 | (encoded[++i] & 255) << 16 | (encoded[++i] & 255) << 8 | (encoded[++i] & 255) << 0;
                    }
                    this.stack.push(value);
                  }
                  return error;
                }
                executeCommand(howManyArgs, command, keepStack) {
                  const stackLength = this.stack.length;
                  if (howManyArgs > stackLength) {
                    return true;
                  }
                  const start = stackLength - howManyArgs;
                  for (let i = start; i < stackLength; i++) {
                    let value = this.stack[i];
                    if (Number.isInteger(value)) {
                      this.output.push(28, value >> 8 & 255, value & 255);
                    } else {
                      value = 65536 * value | 0;
                      this.output.push(255, value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255);
                    }
                  }
                  this.output.push(...command);
                  if (keepStack) {
                    this.stack.splice(start, howManyArgs);
                  } else {
                    this.stack.length = 0;
                  }
                  return false;
                }
              };
              __name(_Type1CharString, "Type1CharString");
              let Type1CharString = _Type1CharString;
              const EEXEC_ENCRYPT_KEY = 55665;
              const CHAR_STRS_ENCRYPT_KEY = 4330;
              function isHexDigit(code) {
                return code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102;
              }
              __name(isHexDigit, "isHexDigit");
              function decrypt(data, key, discardNumber) {
                if (discardNumber >= data.length) {
                  return new Uint8Array(0);
                }
                const c1 = 52845, c2 = 22719;
                let r = key | 0, i, j;
                for (i = 0; i < discardNumber; i++) {
                  r = (data[i] + r) * c1 + c2 & (1 << 16) - 1;
                }
                const count = data.length - discardNumber;
                const decrypted = new Uint8Array(count);
                for (i = discardNumber, j = 0; j < count; i++, j++) {
                  const value = data[i];
                  decrypted[j] = value ^ r >> 8;
                  r = (value + r) * c1 + c2 & (1 << 16) - 1;
                }
                return decrypted;
              }
              __name(decrypt, "decrypt");
              function decryptAscii(data, key, discardNumber) {
                const c1 = 52845, c2 = 22719;
                let r = key | 0;
                const count = data.length, maybeLength = count >>> 1;
                const decrypted = new Uint8Array(maybeLength);
                let i, j;
                for (i = 0, j = 0; i < count; i++) {
                  const digit1 = data[i];
                  if (!isHexDigit(digit1)) {
                    continue;
                  }
                  i++;
                  let digit2;
                  while (i < count && !isHexDigit(digit2 = data[i])) {
                    i++;
                  }
                  if (i < count) {
                    const value = parseInt(String.fromCharCode(digit1, digit2), 16);
                    decrypted[j++] = value ^ r >> 8;
                    r = (value + r) * c1 + c2 & (1 << 16) - 1;
                  }
                }
                return decrypted.slice(discardNumber, j);
              }
              __name(decryptAscii, "decryptAscii");
              function isSpecial(c) {
                return c === 47 || c === 91 || c === 93 || c === 123 || c === 125 || c === 40 || c === 41;
              }
              __name(isSpecial, "isSpecial");
              const _Type1Parser = class _Type1Parser {
                constructor(stream, encrypted, seacAnalysisEnabled) {
                  if (encrypted) {
                    const data = stream.getBytes();
                    const isBinary = !((isHexDigit(data[0]) || (0, _core_utils.isWhiteSpace)(data[0])) && isHexDigit(data[1]) && isHexDigit(data[2]) && isHexDigit(data[3]) && isHexDigit(data[4]) && isHexDigit(data[5]) && isHexDigit(data[6]) && isHexDigit(data[7]));
                    stream = new _stream.Stream(isBinary ? decrypt(data, EEXEC_ENCRYPT_KEY, 4) : decryptAscii(data, EEXEC_ENCRYPT_KEY, 4));
                  }
                  this.seacAnalysisEnabled = !!seacAnalysisEnabled;
                  this.stream = stream;
                  this.nextChar();
                }
                readNumberArray() {
                  this.getToken();
                  const array = [];
                  while (true) {
                    const token = this.getToken();
                    if (token === null || token === "]" || token === "}") {
                      break;
                    }
                    array.push(parseFloat(token || 0));
                  }
                  return array;
                }
                readNumber() {
                  const token = this.getToken();
                  return parseFloat(token || 0);
                }
                readInt() {
                  const token = this.getToken();
                  return parseInt(token || 0, 10) | 0;
                }
                readBoolean() {
                  const token = this.getToken();
                  return token === "true" ? 1 : 0;
                }
                nextChar() {
                  return this.currentChar = this.stream.getByte();
                }
                prevChar() {
                  this.stream.skip(-2);
                  return this.currentChar = this.stream.getByte();
                }
                getToken() {
                  let comment = false;
                  let ch = this.currentChar;
                  while (true) {
                    if (ch === -1) {
                      return null;
                    }
                    if (comment) {
                      if (ch === 10 || ch === 13) {
                        comment = false;
                      }
                    } else if (ch === 37) {
                      comment = true;
                    } else if (!(0, _core_utils.isWhiteSpace)(ch)) {
                      break;
                    }
                    ch = this.nextChar();
                  }
                  if (isSpecial(ch)) {
                    this.nextChar();
                    return String.fromCharCode(ch);
                  }
                  let token = "";
                  do {
                    token += String.fromCharCode(ch);
                    ch = this.nextChar();
                  } while (ch >= 0 && !(0, _core_utils.isWhiteSpace)(ch) && !isSpecial(ch));
                  return token;
                }
                readCharStrings(bytes, lenIV) {
                  if (lenIV === -1) {
                    return bytes;
                  }
                  return decrypt(bytes, CHAR_STRS_ENCRYPT_KEY, lenIV);
                }
                extractFontProgram(properties) {
                  const stream = this.stream;
                  const subrs = [], charstrings = [];
                  const privateData = /* @__PURE__ */ Object.create(null);
                  privateData.lenIV = 4;
                  const program = {
                    subrs: [],
                    charstrings: [],
                    properties: {
                      privateData
                    }
                  };
                  let token, length, data, lenIV;
                  while ((token = this.getToken()) !== null) {
                    if (token !== "/") {
                      continue;
                    }
                    token = this.getToken();
                    switch (token) {
                      case "CharStrings":
                        this.getToken();
                        this.getToken();
                        this.getToken();
                        this.getToken();
                        while (true) {
                          token = this.getToken();
                          if (token === null || token === "end") {
                            break;
                          }
                          if (token !== "/") {
                            continue;
                          }
                          const glyph = this.getToken();
                          length = this.readInt();
                          this.getToken();
                          data = length > 0 ? stream.getBytes(length) : new Uint8Array(0);
                          lenIV = program.properties.privateData.lenIV;
                          const encoded = this.readCharStrings(data, lenIV);
                          this.nextChar();
                          token = this.getToken();
                          if (token === "noaccess") {
                            this.getToken();
                          } else if (token === "/") {
                            this.prevChar();
                          }
                          charstrings.push({
                            glyph,
                            encoded
                          });
                        }
                        break;
                      case "Subrs":
                        this.readInt();
                        this.getToken();
                        while (this.getToken() === "dup") {
                          const index = this.readInt();
                          length = this.readInt();
                          this.getToken();
                          data = length > 0 ? stream.getBytes(length) : new Uint8Array(0);
                          lenIV = program.properties.privateData.lenIV;
                          const encoded = this.readCharStrings(data, lenIV);
                          this.nextChar();
                          token = this.getToken();
                          if (token === "noaccess") {
                            this.getToken();
                          }
                          subrs[index] = encoded;
                        }
                        break;
                      case "BlueValues":
                      case "OtherBlues":
                      case "FamilyBlues":
                      case "FamilyOtherBlues":
                        const blueArray = this.readNumberArray();
                        if (blueArray.length > 0 && blueArray.length % 2 === 0 && HINTING_ENABLED) {
                          program.properties.privateData[token] = blueArray;
                        }
                        break;
                      case "StemSnapH":
                      case "StemSnapV":
                        program.properties.privateData[token] = this.readNumberArray();
                        break;
                      case "StdHW":
                      case "StdVW":
                        program.properties.privateData[token] = this.readNumberArray()[0];
                        break;
                      case "BlueShift":
                      case "lenIV":
                      case "BlueFuzz":
                      case "BlueScale":
                      case "LanguageGroup":
                      case "ExpansionFactor":
                        program.properties.privateData[token] = this.readNumber();
                        break;
                      case "ForceBold":
                        program.properties.privateData[token] = this.readBoolean();
                        break;
                    }
                  }
                  for (const {
                    encoded,
                    glyph
                  } of charstrings) {
                    const charString = new Type1CharString();
                    const error = charString.convert(encoded, subrs, this.seacAnalysisEnabled);
                    let output = charString.output;
                    if (error) {
                      output = [14];
                    }
                    const charStringObject = {
                      glyphName: glyph,
                      charstring: output,
                      width: charString.width,
                      lsb: charString.lsb,
                      seac: charString.seac
                    };
                    if (glyph === ".notdef") {
                      program.charstrings.unshift(charStringObject);
                    } else {
                      program.charstrings.push(charStringObject);
                    }
                    if (properties.builtInEncoding) {
                      const index = properties.builtInEncoding.indexOf(glyph);
                      if (index > -1 && properties.widths[index] === void 0 && index >= properties.firstChar && index <= properties.lastChar) {
                        properties.widths[index] = charString.width;
                      }
                    }
                  }
                  return program;
                }
                extractFontHeader(properties) {
                  let token;
                  while ((token = this.getToken()) !== null) {
                    if (token !== "/") {
                      continue;
                    }
                    token = this.getToken();
                    switch (token) {
                      case "FontMatrix":
                        const matrix = this.readNumberArray();
                        properties.fontMatrix = matrix;
                        break;
                      case "Encoding":
                        const encodingArg = this.getToken();
                        let encoding;
                        if (!/^\d+$/.test(encodingArg)) {
                          encoding = (0, _encodings.getEncoding)(encodingArg);
                        } else {
                          encoding = [];
                          const size = parseInt(encodingArg, 10) | 0;
                          this.getToken();
                          for (let j = 0; j < size; j++) {
                            token = this.getToken();
                            while (token !== "dup" && token !== "def") {
                              token = this.getToken();
                              if (token === null) {
                                return;
                              }
                            }
                            if (token === "def") {
                              break;
                            }
                            const index = this.readInt();
                            this.getToken();
                            const glyph = this.getToken();
                            encoding[index] = glyph;
                            this.getToken();
                          }
                        }
                        properties.builtInEncoding = encoding;
                        break;
                      case "FontBBox":
                        const fontBBox = this.readNumberArray();
                        properties.ascent = Math.max(fontBBox[3], fontBBox[1]);
                        properties.descent = Math.min(fontBBox[1], fontBBox[3]);
                        properties.ascentScaled = true;
                        break;
                    }
                  }
                }
              };
              __name(_Type1Parser, "Type1Parser");
              let Type1Parser = _Type1Parser;
              exports2.Type1Parser = Type1Parser;
            },
            /* 175 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Pattern = void 0;
              exports2.getTilingPatternIR = getTilingPatternIR;
              var _util = __w_pdfjs_require__2(2);
              var _base_stream = __w_pdfjs_require__2(132);
              var _colorspace = __w_pdfjs_require__2(139);
              var _core_utils = __w_pdfjs_require__2(131);
              const ShadingType = {
                FUNCTION_BASED: 1,
                AXIAL: 2,
                RADIAL: 3,
                FREE_FORM_MESH: 4,
                LATTICE_FORM_MESH: 5,
                COONS_PATCH_MESH: 6,
                TENSOR_PATCH_MESH: 7
              };
              const _Pattern = class _Pattern {
                constructor() {
                  (0, _util.unreachable)("Cannot initialize Pattern.");
                }
                static parseShading(shading, xref, res, handler, pdfFunctionFactory, localColorSpaceCache) {
                  const dict = shading instanceof _base_stream.BaseStream ? shading.dict : shading;
                  const type = dict.get("ShadingType");
                  try {
                    switch (type) {
                      case ShadingType.AXIAL:
                      case ShadingType.RADIAL:
                        return new RadialAxialShading(dict, xref, res, pdfFunctionFactory, localColorSpaceCache);
                      case ShadingType.FREE_FORM_MESH:
                      case ShadingType.LATTICE_FORM_MESH:
                      case ShadingType.COONS_PATCH_MESH:
                      case ShadingType.TENSOR_PATCH_MESH:
                        return new MeshShading(shading, xref, res, pdfFunctionFactory, localColorSpaceCache);
                      default:
                        throw new _util.FormatError("Unsupported ShadingType: " + type);
                    }
                  } catch (ex) {
                    if (ex instanceof _core_utils.MissingDataException) {
                      throw ex;
                    }
                    handler.send("UnsupportedFeature", {
                      featureId: _util.UNSUPPORTED_FEATURES.shadingPattern
                    });
                    (0, _util.warn)(ex);
                    return new DummyShading();
                  }
                }
              };
              __name(_Pattern, "Pattern");
              let Pattern = _Pattern;
              exports2.Pattern = Pattern;
              const _BaseShading = class _BaseShading {
                static get SMALL_NUMBER() {
                  return (0, _util.shadow)(this, "SMALL_NUMBER", 1e-6);
                }
                constructor() {
                  if (this.constructor === _BaseShading) {
                    (0, _util.unreachable)("Cannot initialize BaseShading.");
                  }
                }
                getIR() {
                  (0, _util.unreachable)("Abstract method `getIR` called.");
                }
              };
              __name(_BaseShading, "BaseShading");
              let BaseShading = _BaseShading;
              const _RadialAxialShading = class _RadialAxialShading extends BaseShading {
                constructor(dict, xref, resources, pdfFunctionFactory, localColorSpaceCache) {
                  super();
                  this.coordsArr = dict.getArray("Coords");
                  this.shadingType = dict.get("ShadingType");
                  const cs = _colorspace.ColorSpace.parse({
                    cs: dict.getRaw("CS") || dict.getRaw("ColorSpace"),
                    xref,
                    resources,
                    pdfFunctionFactory,
                    localColorSpaceCache
                  });
                  const bbox = dict.getArray("BBox");
                  if (Array.isArray(bbox) && bbox.length === 4) {
                    this.bbox = _util.Util.normalizeRect(bbox);
                  } else {
                    this.bbox = null;
                  }
                  let t0 = 0, t1 = 1;
                  if (dict.has("Domain")) {
                    const domainArr = dict.getArray("Domain");
                    t0 = domainArr[0];
                    t1 = domainArr[1];
                  }
                  let extendStart = false, extendEnd = false;
                  if (dict.has("Extend")) {
                    const extendArr = dict.getArray("Extend");
                    extendStart = extendArr[0];
                    extendEnd = extendArr[1];
                  }
                  if (this.shadingType === ShadingType.RADIAL && (!extendStart || !extendEnd)) {
                    const [x1, y1, r1, x2, y2, r2] = this.coordsArr;
                    const distance = Math.hypot(x1 - x2, y1 - y2);
                    if (r1 <= r2 + distance && r2 <= r1 + distance) {
                      (0, _util.warn)("Unsupported radial gradient.");
                    }
                  }
                  this.extendStart = extendStart;
                  this.extendEnd = extendEnd;
                  const fnObj = dict.getRaw("Function");
                  const fn = pdfFunctionFactory.createFromArray(fnObj);
                  const NUMBER_OF_SAMPLES = 10;
                  const step = (t1 - t0) / NUMBER_OF_SAMPLES;
                  const colorStops = this.colorStops = [];
                  if (t0 >= t1 || step <= 0) {
                    (0, _util.info)("Bad shading domain.");
                    return;
                  }
                  const color = new Float32Array(cs.numComps), ratio = new Float32Array(1);
                  let rgbColor;
                  for (let i = 0; i <= NUMBER_OF_SAMPLES; i++) {
                    ratio[0] = t0 + i * step;
                    fn(ratio, 0, color, 0);
                    rgbColor = cs.getRgb(color, 0);
                    const cssColor = _util.Util.makeHexColor(rgbColor[0], rgbColor[1], rgbColor[2]);
                    colorStops.push([i / NUMBER_OF_SAMPLES, cssColor]);
                  }
                  let background = "transparent";
                  if (dict.has("Background")) {
                    rgbColor = cs.getRgb(dict.get("Background"), 0);
                    background = _util.Util.makeHexColor(rgbColor[0], rgbColor[1], rgbColor[2]);
                  }
                  if (!extendStart) {
                    colorStops.unshift([0, background]);
                    colorStops[1][0] += BaseShading.SMALL_NUMBER;
                  }
                  if (!extendEnd) {
                    colorStops.at(-1)[0] -= BaseShading.SMALL_NUMBER;
                    colorStops.push([1, background]);
                  }
                  this.colorStops = colorStops;
                }
                getIR() {
                  const coordsArr = this.coordsArr;
                  const shadingType = this.shadingType;
                  let type, p0, p1, r0, r1;
                  if (shadingType === ShadingType.AXIAL) {
                    p0 = [coordsArr[0], coordsArr[1]];
                    p1 = [coordsArr[2], coordsArr[3]];
                    r0 = null;
                    r1 = null;
                    type = "axial";
                  } else if (shadingType === ShadingType.RADIAL) {
                    p0 = [coordsArr[0], coordsArr[1]];
                    p1 = [coordsArr[3], coordsArr[4]];
                    r0 = coordsArr[2];
                    r1 = coordsArr[5];
                    type = "radial";
                  } else {
                    (0, _util.unreachable)(`getPattern type unknown: ${shadingType}`);
                  }
                  return ["RadialAxial", type, this.bbox, this.colorStops, p0, p1, r0, r1];
                }
              };
              __name(_RadialAxialShading, "RadialAxialShading");
              let RadialAxialShading = _RadialAxialShading;
              const _MeshStreamReader = class _MeshStreamReader {
                constructor(stream, context) {
                  this.stream = stream;
                  this.context = context;
                  this.buffer = 0;
                  this.bufferLength = 0;
                  const numComps = context.numComps;
                  this.tmpCompsBuf = new Float32Array(numComps);
                  const csNumComps = context.colorSpace.numComps;
                  this.tmpCsCompsBuf = context.colorFn ? new Float32Array(csNumComps) : this.tmpCompsBuf;
                }
                get hasData() {
                  if (this.stream.end) {
                    return this.stream.pos < this.stream.end;
                  }
                  if (this.bufferLength > 0) {
                    return true;
                  }
                  const nextByte = this.stream.getByte();
                  if (nextByte < 0) {
                    return false;
                  }
                  this.buffer = nextByte;
                  this.bufferLength = 8;
                  return true;
                }
                readBits(n) {
                  let buffer = this.buffer;
                  let bufferLength = this.bufferLength;
                  if (n === 32) {
                    if (bufferLength === 0) {
                      return (this.stream.getByte() << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte()) >>> 0;
                    }
                    buffer = buffer << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte();
                    const nextByte = this.stream.getByte();
                    this.buffer = nextByte & (1 << bufferLength) - 1;
                    return (buffer << 8 - bufferLength | (nextByte & 255) >> bufferLength) >>> 0;
                  }
                  if (n === 8 && bufferLength === 0) {
                    return this.stream.getByte();
                  }
                  while (bufferLength < n) {
                    buffer = buffer << 8 | this.stream.getByte();
                    bufferLength += 8;
                  }
                  bufferLength -= n;
                  this.bufferLength = bufferLength;
                  this.buffer = buffer & (1 << bufferLength) - 1;
                  return buffer >> bufferLength;
                }
                align() {
                  this.buffer = 0;
                  this.bufferLength = 0;
                }
                readFlag() {
                  return this.readBits(this.context.bitsPerFlag);
                }
                readCoordinate() {
                  const bitsPerCoordinate = this.context.bitsPerCoordinate;
                  const xi = this.readBits(bitsPerCoordinate);
                  const yi = this.readBits(bitsPerCoordinate);
                  const decode = this.context.decode;
                  const scale = bitsPerCoordinate < 32 ? 1 / ((1 << bitsPerCoordinate) - 1) : 23283064365386963e-26;
                  return [xi * scale * (decode[1] - decode[0]) + decode[0], yi * scale * (decode[3] - decode[2]) + decode[2]];
                }
                readComponents() {
                  const numComps = this.context.numComps;
                  const bitsPerComponent = this.context.bitsPerComponent;
                  const scale = bitsPerComponent < 32 ? 1 / ((1 << bitsPerComponent) - 1) : 23283064365386963e-26;
                  const decode = this.context.decode;
                  const components = this.tmpCompsBuf;
                  for (let i = 0, j = 4; i < numComps; i++, j += 2) {
                    const ci = this.readBits(bitsPerComponent);
                    components[i] = ci * scale * (decode[j + 1] - decode[j]) + decode[j];
                  }
                  const color = this.tmpCsCompsBuf;
                  if (this.context.colorFn) {
                    this.context.colorFn(components, 0, color, 0);
                  }
                  return this.context.colorSpace.getRgb(color, 0);
                }
              };
              __name(_MeshStreamReader, "MeshStreamReader");
              let MeshStreamReader = _MeshStreamReader;
              const getB = (/* @__PURE__ */ __name(function getBClosure() {
                function buildB(count) {
                  const lut = [];
                  for (let i = 0; i <= count; i++) {
                    const t = i / count, t_ = 1 - t;
                    lut.push(new Float32Array([t_ * t_ * t_, 3 * t * t_ * t_, 3 * t * t * t_, t * t * t]));
                  }
                  return lut;
                }
                __name(buildB, "buildB");
                const cache = [];
                return function(count) {
                  if (!cache[count]) {
                    cache[count] = buildB(count);
                  }
                  return cache[count];
                };
              }, "getBClosure"))();
              const _MeshShading = class _MeshShading extends BaseShading {
                static get MIN_SPLIT_PATCH_CHUNKS_AMOUNT() {
                  return (0, _util.shadow)(this, "MIN_SPLIT_PATCH_CHUNKS_AMOUNT", 3);
                }
                static get MAX_SPLIT_PATCH_CHUNKS_AMOUNT() {
                  return (0, _util.shadow)(this, "MAX_SPLIT_PATCH_CHUNKS_AMOUNT", 20);
                }
                static get TRIANGLE_DENSITY() {
                  return (0, _util.shadow)(this, "TRIANGLE_DENSITY", 20);
                }
                constructor(stream, xref, resources, pdfFunctionFactory, localColorSpaceCache) {
                  super();
                  if (!(stream instanceof _base_stream.BaseStream)) {
                    throw new _util.FormatError("Mesh data is not a stream");
                  }
                  const dict = stream.dict;
                  this.shadingType = dict.get("ShadingType");
                  const bbox = dict.getArray("BBox");
                  if (Array.isArray(bbox) && bbox.length === 4) {
                    this.bbox = _util.Util.normalizeRect(bbox);
                  } else {
                    this.bbox = null;
                  }
                  const cs = _colorspace.ColorSpace.parse({
                    cs: dict.getRaw("CS") || dict.getRaw("ColorSpace"),
                    xref,
                    resources,
                    pdfFunctionFactory,
                    localColorSpaceCache
                  });
                  this.background = dict.has("Background") ? cs.getRgb(dict.get("Background"), 0) : null;
                  const fnObj = dict.getRaw("Function");
                  const fn = fnObj ? pdfFunctionFactory.createFromArray(fnObj) : null;
                  this.coords = [];
                  this.colors = [];
                  this.figures = [];
                  const decodeContext = {
                    bitsPerCoordinate: dict.get("BitsPerCoordinate"),
                    bitsPerComponent: dict.get("BitsPerComponent"),
                    bitsPerFlag: dict.get("BitsPerFlag"),
                    decode: dict.getArray("Decode"),
                    colorFn: fn,
                    colorSpace: cs,
                    numComps: fn ? 1 : cs.numComps
                  };
                  const reader = new MeshStreamReader(stream, decodeContext);
                  let patchMesh = false;
                  switch (this.shadingType) {
                    case ShadingType.FREE_FORM_MESH:
                      this._decodeType4Shading(reader);
                      break;
                    case ShadingType.LATTICE_FORM_MESH:
                      const verticesPerRow = dict.get("VerticesPerRow") | 0;
                      if (verticesPerRow < 2) {
                        throw new _util.FormatError("Invalid VerticesPerRow");
                      }
                      this._decodeType5Shading(reader, verticesPerRow);
                      break;
                    case ShadingType.COONS_PATCH_MESH:
                      this._decodeType6Shading(reader);
                      patchMesh = true;
                      break;
                    case ShadingType.TENSOR_PATCH_MESH:
                      this._decodeType7Shading(reader);
                      patchMesh = true;
                      break;
                    default:
                      (0, _util.unreachable)("Unsupported mesh type.");
                      break;
                  }
                  if (patchMesh) {
                    this._updateBounds();
                    for (let i = 0, ii = this.figures.length; i < ii; i++) {
                      this._buildFigureFromPatch(i);
                    }
                  }
                  this._updateBounds();
                  this._packData();
                }
                _decodeType4Shading(reader) {
                  const coords = this.coords;
                  const colors = this.colors;
                  const ps = [];
                  let verticesLeft = 0;
                  while (reader.hasData) {
                    const f = reader.readFlag();
                    const coord = reader.readCoordinate();
                    const color = reader.readComponents();
                    if (verticesLeft === 0) {
                      if (!(0 <= f && f <= 2)) {
                        throw new _util.FormatError("Unknown type4 flag");
                      }
                      switch (f) {
                        case 0:
                          verticesLeft = 3;
                          break;
                        case 1:
                          ps.push(ps.at(-2), ps.at(-1));
                          verticesLeft = 1;
                          break;
                        case 2:
                          ps.push(ps.at(-3), ps.at(-1));
                          verticesLeft = 1;
                          break;
                      }
                    }
                    ps.push(coords.length);
                    coords.push(coord);
                    colors.push(color);
                    verticesLeft--;
                    reader.align();
                  }
                  this.figures.push({
                    type: "triangles",
                    coords: new Int32Array(ps),
                    colors: new Int32Array(ps)
                  });
                }
                _decodeType5Shading(reader, verticesPerRow) {
                  const coords = this.coords;
                  const colors = this.colors;
                  const ps = [];
                  while (reader.hasData) {
                    const coord = reader.readCoordinate();
                    const color = reader.readComponents();
                    ps.push(coords.length);
                    coords.push(coord);
                    colors.push(color);
                  }
                  this.figures.push({
                    type: "lattice",
                    coords: new Int32Array(ps),
                    colors: new Int32Array(ps),
                    verticesPerRow
                  });
                }
                _decodeType6Shading(reader) {
                  const coords = this.coords;
                  const colors = this.colors;
                  const ps = new Int32Array(16);
                  const cs = new Int32Array(4);
                  while (reader.hasData) {
                    const f = reader.readFlag();
                    if (!(0 <= f && f <= 3)) {
                      throw new _util.FormatError("Unknown type6 flag");
                    }
                    const pi = coords.length;
                    for (let i = 0, ii = f !== 0 ? 8 : 12; i < ii; i++) {
                      coords.push(reader.readCoordinate());
                    }
                    const ci = colors.length;
                    for (let i = 0, ii = f !== 0 ? 2 : 4; i < ii; i++) {
                      colors.push(reader.readComponents());
                    }
                    let tmp1, tmp2, tmp3, tmp4;
                    switch (f) {
                      case 0:
                        ps[12] = pi + 3;
                        ps[13] = pi + 4;
                        ps[14] = pi + 5;
                        ps[15] = pi + 6;
                        ps[8] = pi + 2;
                        ps[11] = pi + 7;
                        ps[4] = pi + 1;
                        ps[7] = pi + 8;
                        ps[0] = pi;
                        ps[1] = pi + 11;
                        ps[2] = pi + 10;
                        ps[3] = pi + 9;
                        cs[2] = ci + 1;
                        cs[3] = ci + 2;
                        cs[0] = ci;
                        cs[1] = ci + 3;
                        break;
                      case 1:
                        tmp1 = ps[12];
                        tmp2 = ps[13];
                        tmp3 = ps[14];
                        tmp4 = ps[15];
                        ps[12] = tmp4;
                        ps[13] = pi + 0;
                        ps[14] = pi + 1;
                        ps[15] = pi + 2;
                        ps[8] = tmp3;
                        ps[11] = pi + 3;
                        ps[4] = tmp2;
                        ps[7] = pi + 4;
                        ps[0] = tmp1;
                        ps[1] = pi + 7;
                        ps[2] = pi + 6;
                        ps[3] = pi + 5;
                        tmp1 = cs[2];
                        tmp2 = cs[3];
                        cs[2] = tmp2;
                        cs[3] = ci;
                        cs[0] = tmp1;
                        cs[1] = ci + 1;
                        break;
                      case 2:
                        tmp1 = ps[15];
                        tmp2 = ps[11];
                        ps[12] = ps[3];
                        ps[13] = pi + 0;
                        ps[14] = pi + 1;
                        ps[15] = pi + 2;
                        ps[8] = ps[7];
                        ps[11] = pi + 3;
                        ps[4] = tmp2;
                        ps[7] = pi + 4;
                        ps[0] = tmp1;
                        ps[1] = pi + 7;
                        ps[2] = pi + 6;
                        ps[3] = pi + 5;
                        tmp1 = cs[3];
                        cs[2] = cs[1];
                        cs[3] = ci;
                        cs[0] = tmp1;
                        cs[1] = ci + 1;
                        break;
                      case 3:
                        ps[12] = ps[0];
                        ps[13] = pi + 0;
                        ps[14] = pi + 1;
                        ps[15] = pi + 2;
                        ps[8] = ps[1];
                        ps[11] = pi + 3;
                        ps[4] = ps[2];
                        ps[7] = pi + 4;
                        ps[0] = ps[3];
                        ps[1] = pi + 7;
                        ps[2] = pi + 6;
                        ps[3] = pi + 5;
                        cs[2] = cs[0];
                        cs[3] = ci;
                        cs[0] = cs[1];
                        cs[1] = ci + 1;
                        break;
                    }
                    ps[5] = coords.length;
                    coords.push([(-4 * coords[ps[0]][0] - coords[ps[15]][0] + 6 * (coords[ps[4]][0] + coords[ps[1]][0]) - 2 * (coords[ps[12]][0] + coords[ps[3]][0]) + 3 * (coords[ps[13]][0] + coords[ps[7]][0])) / 9, (-4 * coords[ps[0]][1] - coords[ps[15]][1] + 6 * (coords[ps[4]][1] + coords[ps[1]][1]) - 2 * (coords[ps[12]][1] + coords[ps[3]][1]) + 3 * (coords[ps[13]][1] + coords[ps[7]][1])) / 9]);
                    ps[6] = coords.length;
                    coords.push([(-4 * coords[ps[3]][0] - coords[ps[12]][0] + 6 * (coords[ps[2]][0] + coords[ps[7]][0]) - 2 * (coords[ps[0]][0] + coords[ps[15]][0]) + 3 * (coords[ps[4]][0] + coords[ps[14]][0])) / 9, (-4 * coords[ps[3]][1] - coords[ps[12]][1] + 6 * (coords[ps[2]][1] + coords[ps[7]][1]) - 2 * (coords[ps[0]][1] + coords[ps[15]][1]) + 3 * (coords[ps[4]][1] + coords[ps[14]][1])) / 9]);
                    ps[9] = coords.length;
                    coords.push([(-4 * coords[ps[12]][0] - coords[ps[3]][0] + 6 * (coords[ps[8]][0] + coords[ps[13]][0]) - 2 * (coords[ps[0]][0] + coords[ps[15]][0]) + 3 * (coords[ps[11]][0] + coords[ps[1]][0])) / 9, (-4 * coords[ps[12]][1] - coords[ps[3]][1] + 6 * (coords[ps[8]][1] + coords[ps[13]][1]) - 2 * (coords[ps[0]][1] + coords[ps[15]][1]) + 3 * (coords[ps[11]][1] + coords[ps[1]][1])) / 9]);
                    ps[10] = coords.length;
                    coords.push([(-4 * coords[ps[15]][0] - coords[ps[0]][0] + 6 * (coords[ps[11]][0] + coords[ps[14]][0]) - 2 * (coords[ps[12]][0] + coords[ps[3]][0]) + 3 * (coords[ps[2]][0] + coords[ps[8]][0])) / 9, (-4 * coords[ps[15]][1] - coords[ps[0]][1] + 6 * (coords[ps[11]][1] + coords[ps[14]][1]) - 2 * (coords[ps[12]][1] + coords[ps[3]][1]) + 3 * (coords[ps[2]][1] + coords[ps[8]][1])) / 9]);
                    this.figures.push({
                      type: "patch",
                      coords: new Int32Array(ps),
                      colors: new Int32Array(cs)
                    });
                  }
                }
                _decodeType7Shading(reader) {
                  const coords = this.coords;
                  const colors = this.colors;
                  const ps = new Int32Array(16);
                  const cs = new Int32Array(4);
                  while (reader.hasData) {
                    const f = reader.readFlag();
                    if (!(0 <= f && f <= 3)) {
                      throw new _util.FormatError("Unknown type7 flag");
                    }
                    const pi = coords.length;
                    for (let i = 0, ii = f !== 0 ? 12 : 16; i < ii; i++) {
                      coords.push(reader.readCoordinate());
                    }
                    const ci = colors.length;
                    for (let i = 0, ii = f !== 0 ? 2 : 4; i < ii; i++) {
                      colors.push(reader.readComponents());
                    }
                    let tmp1, tmp2, tmp3, tmp4;
                    switch (f) {
                      case 0:
                        ps[12] = pi + 3;
                        ps[13] = pi + 4;
                        ps[14] = pi + 5;
                        ps[15] = pi + 6;
                        ps[8] = pi + 2;
                        ps[9] = pi + 13;
                        ps[10] = pi + 14;
                        ps[11] = pi + 7;
                        ps[4] = pi + 1;
                        ps[5] = pi + 12;
                        ps[6] = pi + 15;
                        ps[7] = pi + 8;
                        ps[0] = pi;
                        ps[1] = pi + 11;
                        ps[2] = pi + 10;
                        ps[3] = pi + 9;
                        cs[2] = ci + 1;
                        cs[3] = ci + 2;
                        cs[0] = ci;
                        cs[1] = ci + 3;
                        break;
                      case 1:
                        tmp1 = ps[12];
                        tmp2 = ps[13];
                        tmp3 = ps[14];
                        tmp4 = ps[15];
                        ps[12] = tmp4;
                        ps[13] = pi + 0;
                        ps[14] = pi + 1;
                        ps[15] = pi + 2;
                        ps[8] = tmp3;
                        ps[9] = pi + 9;
                        ps[10] = pi + 10;
                        ps[11] = pi + 3;
                        ps[4] = tmp2;
                        ps[5] = pi + 8;
                        ps[6] = pi + 11;
                        ps[7] = pi + 4;
                        ps[0] = tmp1;
                        ps[1] = pi + 7;
                        ps[2] = pi + 6;
                        ps[3] = pi + 5;
                        tmp1 = cs[2];
                        tmp2 = cs[3];
                        cs[2] = tmp2;
                        cs[3] = ci;
                        cs[0] = tmp1;
                        cs[1] = ci + 1;
                        break;
                      case 2:
                        tmp1 = ps[15];
                        tmp2 = ps[11];
                        ps[12] = ps[3];
                        ps[13] = pi + 0;
                        ps[14] = pi + 1;
                        ps[15] = pi + 2;
                        ps[8] = ps[7];
                        ps[9] = pi + 9;
                        ps[10] = pi + 10;
                        ps[11] = pi + 3;
                        ps[4] = tmp2;
                        ps[5] = pi + 8;
                        ps[6] = pi + 11;
                        ps[7] = pi + 4;
                        ps[0] = tmp1;
                        ps[1] = pi + 7;
                        ps[2] = pi + 6;
                        ps[3] = pi + 5;
                        tmp1 = cs[3];
                        cs[2] = cs[1];
                        cs[3] = ci;
                        cs[0] = tmp1;
                        cs[1] = ci + 1;
                        break;
                      case 3:
                        ps[12] = ps[0];
                        ps[13] = pi + 0;
                        ps[14] = pi + 1;
                        ps[15] = pi + 2;
                        ps[8] = ps[1];
                        ps[9] = pi + 9;
                        ps[10] = pi + 10;
                        ps[11] = pi + 3;
                        ps[4] = ps[2];
                        ps[5] = pi + 8;
                        ps[6] = pi + 11;
                        ps[7] = pi + 4;
                        ps[0] = ps[3];
                        ps[1] = pi + 7;
                        ps[2] = pi + 6;
                        ps[3] = pi + 5;
                        cs[2] = cs[0];
                        cs[3] = ci;
                        cs[0] = cs[1];
                        cs[1] = ci + 1;
                        break;
                    }
                    this.figures.push({
                      type: "patch",
                      coords: new Int32Array(ps),
                      colors: new Int32Array(cs)
                    });
                  }
                }
                _buildFigureFromPatch(index) {
                  const figure = this.figures[index];
                  (0, _util.assert)(figure.type === "patch", "Unexpected patch mesh figure");
                  const coords = this.coords, colors = this.colors;
                  const pi = figure.coords;
                  const ci = figure.colors;
                  const figureMinX = Math.min(coords[pi[0]][0], coords[pi[3]][0], coords[pi[12]][0], coords[pi[15]][0]);
                  const figureMinY = Math.min(coords[pi[0]][1], coords[pi[3]][1], coords[pi[12]][1], coords[pi[15]][1]);
                  const figureMaxX = Math.max(coords[pi[0]][0], coords[pi[3]][0], coords[pi[12]][0], coords[pi[15]][0]);
                  const figureMaxY = Math.max(coords[pi[0]][1], coords[pi[3]][1], coords[pi[12]][1], coords[pi[15]][1]);
                  let splitXBy = Math.ceil((figureMaxX - figureMinX) * _MeshShading.TRIANGLE_DENSITY / (this.bounds[2] - this.bounds[0]));
                  splitXBy = Math.max(_MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(_MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, splitXBy));
                  let splitYBy = Math.ceil((figureMaxY - figureMinY) * _MeshShading.TRIANGLE_DENSITY / (this.bounds[3] - this.bounds[1]));
                  splitYBy = Math.max(_MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(_MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, splitYBy));
                  const verticesPerRow = splitXBy + 1;
                  const figureCoords = new Int32Array((splitYBy + 1) * verticesPerRow);
                  const figureColors = new Int32Array((splitYBy + 1) * verticesPerRow);
                  let k = 0;
                  const cl = new Uint8Array(3), cr = new Uint8Array(3);
                  const c0 = colors[ci[0]], c1 = colors[ci[1]], c2 = colors[ci[2]], c3 = colors[ci[3]];
                  const bRow = getB(splitYBy), bCol = getB(splitXBy);
                  for (let row = 0; row <= splitYBy; row++) {
                    cl[0] = (c0[0] * (splitYBy - row) + c2[0] * row) / splitYBy | 0;
                    cl[1] = (c0[1] * (splitYBy - row) + c2[1] * row) / splitYBy | 0;
                    cl[2] = (c0[2] * (splitYBy - row) + c2[2] * row) / splitYBy | 0;
                    cr[0] = (c1[0] * (splitYBy - row) + c3[0] * row) / splitYBy | 0;
                    cr[1] = (c1[1] * (splitYBy - row) + c3[1] * row) / splitYBy | 0;
                    cr[2] = (c1[2] * (splitYBy - row) + c3[2] * row) / splitYBy | 0;
                    for (let col = 0; col <= splitXBy; col++, k++) {
                      if ((row === 0 || row === splitYBy) && (col === 0 || col === splitXBy)) {
                        continue;
                      }
                      let x = 0, y = 0;
                      let q = 0;
                      for (let i = 0; i <= 3; i++) {
                        for (let j = 0; j <= 3; j++, q++) {
                          const m = bRow[row][i] * bCol[col][j];
                          x += coords[pi[q]][0] * m;
                          y += coords[pi[q]][1] * m;
                        }
                      }
                      figureCoords[k] = coords.length;
                      coords.push([x, y]);
                      figureColors[k] = colors.length;
                      const newColor = new Uint8Array(3);
                      newColor[0] = (cl[0] * (splitXBy - col) + cr[0] * col) / splitXBy | 0;
                      newColor[1] = (cl[1] * (splitXBy - col) + cr[1] * col) / splitXBy | 0;
                      newColor[2] = (cl[2] * (splitXBy - col) + cr[2] * col) / splitXBy | 0;
                      colors.push(newColor);
                    }
                  }
                  figureCoords[0] = pi[0];
                  figureColors[0] = ci[0];
                  figureCoords[splitXBy] = pi[3];
                  figureColors[splitXBy] = ci[1];
                  figureCoords[verticesPerRow * splitYBy] = pi[12];
                  figureColors[verticesPerRow * splitYBy] = ci[2];
                  figureCoords[verticesPerRow * splitYBy + splitXBy] = pi[15];
                  figureColors[verticesPerRow * splitYBy + splitXBy] = ci[3];
                  this.figures[index] = {
                    type: "lattice",
                    coords: figureCoords,
                    colors: figureColors,
                    verticesPerRow
                  };
                }
                _updateBounds() {
                  let minX = this.coords[0][0], minY = this.coords[0][1], maxX = minX, maxY = minY;
                  for (let i = 1, ii = this.coords.length; i < ii; i++) {
                    const x = this.coords[i][0], y = this.coords[i][1];
                    minX = minX > x ? x : minX;
                    minY = minY > y ? y : minY;
                    maxX = maxX < x ? x : maxX;
                    maxY = maxY < y ? y : maxY;
                  }
                  this.bounds = [minX, minY, maxX, maxY];
                }
                _packData() {
                  let i, ii, j, jj;
                  const coords = this.coords;
                  const coordsPacked = new Float32Array(coords.length * 2);
                  for (i = 0, j = 0, ii = coords.length; i < ii; i++) {
                    const xy = coords[i];
                    coordsPacked[j++] = xy[0];
                    coordsPacked[j++] = xy[1];
                  }
                  this.coords = coordsPacked;
                  const colors = this.colors;
                  const colorsPacked = new Uint8Array(colors.length * 3);
                  for (i = 0, j = 0, ii = colors.length; i < ii; i++) {
                    const c = colors[i];
                    colorsPacked[j++] = c[0];
                    colorsPacked[j++] = c[1];
                    colorsPacked[j++] = c[2];
                  }
                  this.colors = colorsPacked;
                  const figures = this.figures;
                  for (i = 0, ii = figures.length; i < ii; i++) {
                    const figure = figures[i], ps = figure.coords, cs = figure.colors;
                    for (j = 0, jj = ps.length; j < jj; j++) {
                      ps[j] *= 2;
                      cs[j] *= 3;
                    }
                  }
                }
                getIR() {
                  return ["Mesh", this.shadingType, this.coords, this.colors, this.figures, this.bounds, this.bbox, this.background];
                }
              };
              __name(_MeshShading, "MeshShading");
              let MeshShading = _MeshShading;
              const _DummyShading = class _DummyShading extends BaseShading {
                getIR() {
                  return ["Dummy"];
                }
              };
              __name(_DummyShading, "DummyShading");
              let DummyShading = _DummyShading;
              function getTilingPatternIR(operatorList, dict, color) {
                const matrix = dict.getArray("Matrix");
                const bbox = _util.Util.normalizeRect(dict.getArray("BBox"));
                const xstep = dict.get("XStep");
                const ystep = dict.get("YStep");
                const paintType = dict.get("PaintType");
                const tilingType = dict.get("TilingType");
                if (bbox[2] - bbox[0] === 0 || bbox[3] - bbox[1] === 0) {
                  throw new _util.FormatError(`Invalid getTilingPatternIR /BBox array: [${bbox}].`);
                }
                return ["TilingPattern", color, operatorList, matrix, bbox, xstep, ystep, paintType, tilingType];
              }
              __name(getTilingPatternIR, "getTilingPatternIR");
            },
            /* 176 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.getXfaFontDict = getXfaFontDict;
              exports2.getXfaFontName = getXfaFontName;
              var _calibri_factors = __w_pdfjs_require__2(177);
              var _primitives = __w_pdfjs_require__2(130);
              var _helvetica_factors = __w_pdfjs_require__2(178);
              var _liberationsans_widths = __w_pdfjs_require__2(179);
              var _myriadpro_factors = __w_pdfjs_require__2(180);
              var _segoeui_factors = __w_pdfjs_require__2(181);
              var _core_utils = __w_pdfjs_require__2(131);
              var _fonts_utils = __w_pdfjs_require__2(163);
              const getXFAFontMap = (0, _core_utils.getLookupTableFactory)(function(t) {
                t["MyriadPro-Regular"] = t["PdfJS-Fallback-Regular"] = {
                  name: "LiberationSans-Regular",
                  factors: _myriadpro_factors.MyriadProRegularFactors,
                  baseWidths: _liberationsans_widths.LiberationSansRegularWidths,
                  baseMapping: _liberationsans_widths.LiberationSansRegularMapping,
                  metrics: _myriadpro_factors.MyriadProRegularMetrics
                };
                t["MyriadPro-Bold"] = t["PdfJS-Fallback-Bold"] = {
                  name: "LiberationSans-Bold",
                  factors: _myriadpro_factors.MyriadProBoldFactors,
                  baseWidths: _liberationsans_widths.LiberationSansBoldWidths,
                  baseMapping: _liberationsans_widths.LiberationSansBoldMapping,
                  metrics: _myriadpro_factors.MyriadProBoldMetrics
                };
                t["MyriadPro-It"] = t["MyriadPro-Italic"] = t["PdfJS-Fallback-Italic"] = {
                  name: "LiberationSans-Italic",
                  factors: _myriadpro_factors.MyriadProItalicFactors,
                  baseWidths: _liberationsans_widths.LiberationSansItalicWidths,
                  baseMapping: _liberationsans_widths.LiberationSansItalicMapping,
                  metrics: _myriadpro_factors.MyriadProItalicMetrics
                };
                t["MyriadPro-BoldIt"] = t["MyriadPro-BoldItalic"] = t["PdfJS-Fallback-BoldItalic"] = {
                  name: "LiberationSans-BoldItalic",
                  factors: _myriadpro_factors.MyriadProBoldItalicFactors,
                  baseWidths: _liberationsans_widths.LiberationSansBoldItalicWidths,
                  baseMapping: _liberationsans_widths.LiberationSansBoldItalicMapping,
                  metrics: _myriadpro_factors.MyriadProBoldItalicMetrics
                };
                t.ArialMT = t.Arial = t["Arial-Regular"] = {
                  name: "LiberationSans-Regular",
                  baseWidths: _liberationsans_widths.LiberationSansRegularWidths,
                  baseMapping: _liberationsans_widths.LiberationSansRegularMapping
                };
                t["Arial-BoldMT"] = t["Arial-Bold"] = {
                  name: "LiberationSans-Bold",
                  baseWidths: _liberationsans_widths.LiberationSansBoldWidths,
                  baseMapping: _liberationsans_widths.LiberationSansBoldMapping
                };
                t["Arial-ItalicMT"] = t["Arial-Italic"] = {
                  name: "LiberationSans-Italic",
                  baseWidths: _liberationsans_widths.LiberationSansItalicWidths,
                  baseMapping: _liberationsans_widths.LiberationSansItalicMapping
                };
                t["Arial-BoldItalicMT"] = t["Arial-BoldItalic"] = {
                  name: "LiberationSans-BoldItalic",
                  baseWidths: _liberationsans_widths.LiberationSansBoldItalicWidths,
                  baseMapping: _liberationsans_widths.LiberationSansBoldItalicMapping
                };
                t["Calibri-Regular"] = {
                  name: "LiberationSans-Regular",
                  factors: _calibri_factors.CalibriRegularFactors,
                  baseWidths: _liberationsans_widths.LiberationSansRegularWidths,
                  baseMapping: _liberationsans_widths.LiberationSansRegularMapping,
                  metrics: _calibri_factors.CalibriRegularMetrics
                };
                t["Calibri-Bold"] = {
                  name: "LiberationSans-Bold",
                  factors: _calibri_factors.CalibriBoldFactors,
                  baseWidths: _liberationsans_widths.LiberationSansBoldWidths,
                  baseMapping: _liberationsans_widths.LiberationSansBoldMapping,
                  metrics: _calibri_factors.CalibriBoldMetrics
                };
                t["Calibri-Italic"] = {
                  name: "LiberationSans-Italic",
                  factors: _calibri_factors.CalibriItalicFactors,
                  baseWidths: _liberationsans_widths.LiberationSansItalicWidths,
                  baseMapping: _liberationsans_widths.LiberationSansItalicMapping,
                  metrics: _calibri_factors.CalibriItalicMetrics
                };
                t["Calibri-BoldItalic"] = {
                  name: "LiberationSans-BoldItalic",
                  factors: _calibri_factors.CalibriBoldItalicFactors,
                  baseWidths: _liberationsans_widths.LiberationSansBoldItalicWidths,
                  baseMapping: _liberationsans_widths.LiberationSansBoldItalicMapping,
                  metrics: _calibri_factors.CalibriBoldItalicMetrics
                };
                t["Segoeui-Regular"] = {
                  name: "LiberationSans-Regular",
                  factors: _segoeui_factors.SegoeuiRegularFactors,
                  baseWidths: _liberationsans_widths.LiberationSansRegularWidths,
                  baseMapping: _liberationsans_widths.LiberationSansRegularMapping,
                  metrics: _segoeui_factors.SegoeuiRegularMetrics
                };
                t["Segoeui-Bold"] = {
                  name: "LiberationSans-Bold",
                  factors: _segoeui_factors.SegoeuiBoldFactors,
                  baseWidths: _liberationsans_widths.LiberationSansBoldWidths,
                  baseMapping: _liberationsans_widths.LiberationSansBoldMapping,
                  metrics: _segoeui_factors.SegoeuiBoldMetrics
                };
                t["Segoeui-Italic"] = {
                  name: "LiberationSans-Italic",
                  factors: _segoeui_factors.SegoeuiItalicFactors,
                  baseWidths: _liberationsans_widths.LiberationSansItalicWidths,
                  baseMapping: _liberationsans_widths.LiberationSansItalicMapping,
                  metrics: _segoeui_factors.SegoeuiItalicMetrics
                };
                t["Segoeui-BoldItalic"] = {
                  name: "LiberationSans-BoldItalic",
                  factors: _segoeui_factors.SegoeuiBoldItalicFactors,
                  baseWidths: _liberationsans_widths.LiberationSansBoldItalicWidths,
                  baseMapping: _liberationsans_widths.LiberationSansBoldItalicMapping,
                  metrics: _segoeui_factors.SegoeuiBoldItalicMetrics
                };
                t["Helvetica-Regular"] = t.Helvetica = {
                  name: "LiberationSans-Regular",
                  factors: _helvetica_factors.HelveticaRegularFactors,
                  baseWidths: _liberationsans_widths.LiberationSansRegularWidths,
                  baseMapping: _liberationsans_widths.LiberationSansRegularMapping,
                  metrics: _helvetica_factors.HelveticaRegularMetrics
                };
                t["Helvetica-Bold"] = {
                  name: "LiberationSans-Bold",
                  factors: _helvetica_factors.HelveticaBoldFactors,
                  baseWidths: _liberationsans_widths.LiberationSansBoldWidths,
                  baseMapping: _liberationsans_widths.LiberationSansBoldMapping,
                  metrics: _helvetica_factors.HelveticaBoldMetrics
                };
                t["Helvetica-Italic"] = {
                  name: "LiberationSans-Italic",
                  factors: _helvetica_factors.HelveticaItalicFactors,
                  baseWidths: _liberationsans_widths.LiberationSansItalicWidths,
                  baseMapping: _liberationsans_widths.LiberationSansItalicMapping,
                  metrics: _helvetica_factors.HelveticaItalicMetrics
                };
                t["Helvetica-BoldItalic"] = {
                  name: "LiberationSans-BoldItalic",
                  factors: _helvetica_factors.HelveticaBoldItalicFactors,
                  baseWidths: _liberationsans_widths.LiberationSansBoldItalicWidths,
                  baseMapping: _liberationsans_widths.LiberationSansBoldItalicMapping,
                  metrics: _helvetica_factors.HelveticaBoldItalicMetrics
                };
              });
              function getXfaFontName(name) {
                const fontName = (0, _fonts_utils.normalizeFontName)(name);
                const fontMap = getXFAFontMap();
                return fontMap[fontName];
              }
              __name(getXfaFontName, "getXfaFontName");
              function getXfaFontWidths(name) {
                const info = getXfaFontName(name);
                if (!info) {
                  return null;
                }
                const {
                  baseWidths,
                  baseMapping,
                  factors
                } = info;
                let rescaledBaseWidths;
                if (!factors) {
                  rescaledBaseWidths = baseWidths;
                } else {
                  rescaledBaseWidths = baseWidths.map((w, i) => w * factors[i]);
                }
                let currentCode = -2;
                let currentArray;
                const newWidths = [];
                for (const [unicode, glyphIndex] of baseMapping.map((charUnicode, index) => [charUnicode, index]).sort((_ref, _ref2) => {
                  let [unicode1] = _ref;
                  let [unicode2] = _ref2;
                  return unicode1 - unicode2;
                })) {
                  if (unicode === -1) {
                    continue;
                  }
                  if (unicode === currentCode + 1) {
                    currentArray.push(rescaledBaseWidths[glyphIndex]);
                    currentCode += 1;
                  } else {
                    currentCode = unicode;
                    currentArray = [rescaledBaseWidths[glyphIndex]];
                    newWidths.push(unicode, currentArray);
                  }
                }
                return newWidths;
              }
              __name(getXfaFontWidths, "getXfaFontWidths");
              function getXfaFontDict(name) {
                const widths = getXfaFontWidths(name);
                const dict = new _primitives.Dict(null);
                dict.set("BaseFont", _primitives.Name.get(name));
                dict.set("Type", _primitives.Name.get("Font"));
                dict.set("Subtype", _primitives.Name.get("CIDFontType2"));
                dict.set("Encoding", _primitives.Name.get("Identity-H"));
                dict.set("CIDToGIDMap", _primitives.Name.get("Identity"));
                dict.set("W", widths);
                dict.set("FirstChar", widths[0]);
                dict.set("LastChar", widths.at(-2) + widths.at(-1).length - 1);
                const descriptor = new _primitives.Dict(null);
                dict.set("FontDescriptor", descriptor);
                const systemInfo = new _primitives.Dict(null);
                systemInfo.set("Ordering", "Identity");
                systemInfo.set("Registry", "Adobe");
                systemInfo.set("Supplement", 0);
                dict.set("CIDSystemInfo", systemInfo);
                return dict;
              }
              __name(getXfaFontDict, "getXfaFontDict");
            },
            /* 177 */
            /***/
            (__unused_webpack_module, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.CalibriRegularMetrics = exports2.CalibriRegularFactors = exports2.CalibriItalicMetrics = exports2.CalibriItalicFactors = exports2.CalibriBoldMetrics = exports2.CalibriBoldItalicMetrics = exports2.CalibriBoldItalicFactors = exports2.CalibriBoldFactors = void 0;
              const CalibriBoldFactors = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.54657, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.73293, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.9121, 0.86943, 0.79795, 0.88198, 0.77958, 0.70864, 0.81055, 0.90399, 0.88653, 0.96017, 0.82577, 0.77892, 0.78257, 0.97507, 1.54657, 0.97507, 0.85284, 0.89552, 0.90176, 0.88762, 0.8785, 0.75241, 0.8785, 0.90518, 0.95015, 0.77618, 0.8785, 0.88401, 0.91916, 0.86304, 0.88401, 0.91488, 0.8785, 0.8801, 0.8785, 0.8785, 0.91343, 0.7173, 1.04106, 0.8785, 0.85075, 0.95794, 0.82616, 0.85162, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.12401, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.73293, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.9121, 0.86943, 0.86943, 0.86943, 0.86943, 0.86943, 0.85284, 0.87508, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.8715, 0.75241, 0.90518, 0.90518, 0.90518, 0.90518, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.8785, 0.8801, 0.8801, 0.8801, 0.8801, 0.8801, 0.90747, 0.89049, 0.8785, 0.8785, 0.8785, 0.8785, 0.85162, 0.8785, 0.85162, 0.83908, 0.88762, 0.83908, 0.88762, 0.83908, 0.88762, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.87289, 0.83016, 0.88506, 0.93125, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.81921, 0.77618, 0.81921, 0.77618, 0.81921, 0.77618, 1, 1, 0.87356, 0.8785, 0.91075, 0.89608, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76229, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.79468, 0.91926, 0.88175, 0.70823, 0.94903, 0.9121, 0.8785, 1, 1, 0.9121, 0.8785, 0.87802, 0.88656, 0.8785, 0.86943, 0.8801, 0.86943, 0.8801, 0.86943, 0.8801, 0.87402, 0.89291, 0.77958, 0.91343, 1, 1, 0.77958, 0.91343, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.96017, 0.95794, 0.77892, 0.85162, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.88762, 0.77539, 0.8715, 0.87508, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70674, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.06303, 0.83908, 0.80352, 0.57184, 0.6965, 0.56289, 0.82001, 0.56029, 0.81235, 1.02988, 0.83908, 0.7762, 0.68156, 0.80367, 0.73133, 0.78257, 0.87356, 0.86943, 0.95958, 0.75727, 0.89019, 1.04924, 0.9121, 0.7648, 0.86943, 0.87356, 0.79795, 0.78275, 0.81055, 0.77892, 0.9762, 0.82577, 0.99819, 0.84896, 0.95958, 0.77892, 0.96108, 1.01407, 0.89049, 1.02988, 0.94211, 0.96108, 0.8936, 0.84021, 0.87842, 0.96399, 0.79109, 0.89049, 1.00813, 1.02988, 0.86077, 0.87445, 0.92099, 0.84723, 0.86513, 0.8801, 0.75638, 0.85714, 0.78216, 0.79586, 0.87965, 0.94211, 0.97747, 0.78287, 0.97926, 0.84971, 1.02988, 0.94211, 0.8801, 0.94211, 0.84971, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90264, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90518, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90548, 1, 1, 1, 1, 1, 1, 0.96017, 0.95794, 0.96017, 0.95794, 0.96017, 0.95794, 0.77892, 0.85162, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.92794, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71143, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.93835, 0.83406, 0.91133, 0.84107, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90527, 1.81055, 0.90527, 1.81055, 1.31006, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
              exports2.CalibriBoldFactors = CalibriBoldFactors;
              const CalibriBoldMetrics = {
                lineHeight: 1.2207,
                lineGap: 0.2207
              };
              exports2.CalibriBoldMetrics = CalibriBoldMetrics;
              const CalibriBoldItalicFactors = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.56239, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.71805, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.90872, 0.85938, 0.79795, 0.87068, 0.77958, 0.69766, 0.81055, 0.90399, 0.88653, 0.96068, 0.82577, 0.77892, 0.78257, 0.97507, 1.529, 0.97507, 0.85284, 0.89552, 0.90176, 0.94908, 0.86411, 0.74012, 0.86411, 0.88323, 0.95015, 0.86411, 0.86331, 0.88401, 0.91916, 0.86304, 0.88401, 0.9039, 0.86331, 0.86331, 0.86411, 0.86411, 0.90464, 0.70852, 1.04106, 0.86331, 0.84372, 0.95794, 0.82616, 0.84548, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.19129, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.71805, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.90872, 0.85938, 0.85938, 0.85938, 0.85938, 0.85938, 0.85284, 0.87068, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.85887, 0.74012, 0.88323, 0.88323, 0.88323, 0.88323, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.90747, 0.89049, 0.86331, 0.86331, 0.86331, 0.86331, 0.84548, 0.86411, 0.84548, 0.83908, 0.94908, 0.83908, 0.94908, 0.83908, 0.94908, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.87289, 0.79538, 0.88506, 0.92726, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.81921, 0.86411, 0.81921, 0.86411, 0.81921, 0.86411, 1, 1, 0.87356, 0.86331, 0.91075, 0.8777, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76467, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.77312, 0.91926, 0.88175, 0.70823, 0.94903, 0.90872, 0.86331, 1, 1, 0.90872, 0.86331, 0.86906, 0.88116, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.87402, 0.86549, 0.77958, 0.90464, 1, 1, 0.77958, 0.90464, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.96068, 0.95794, 0.77892, 0.84548, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.94908, 0.77539, 0.85887, 0.87068, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70088, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.48387, 0.83908, 0.80352, 0.57118, 0.6965, 0.56347, 0.79179, 0.55853, 0.80346, 1.02988, 0.83908, 0.7762, 0.67174, 0.86036, 0.73133, 0.78257, 0.87356, 0.86441, 0.95958, 0.75727, 0.89019, 1.04924, 0.90872, 0.74889, 0.85938, 0.87891, 0.79795, 0.7957, 0.81055, 0.77892, 0.97447, 0.82577, 0.97466, 0.87179, 0.95958, 0.77892, 0.94252, 0.95612, 0.8753, 1.02988, 0.92733, 0.94252, 0.87411, 0.84021, 0.8728, 0.95612, 0.74081, 0.8753, 1.02189, 1.02988, 0.84814, 0.87445, 0.91822, 0.84723, 0.85668, 0.86331, 0.81344, 0.87581, 0.76422, 0.82046, 0.96057, 0.92733, 0.99375, 0.78022, 0.95452, 0.86015, 1.02988, 0.92733, 0.86331, 0.92733, 0.86015, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90631, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88323, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85174, 1, 1, 1, 1, 1, 1, 0.96068, 0.95794, 0.96068, 0.95794, 0.96068, 0.95794, 0.77892, 0.84548, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.89807, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71094, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.92972, 0.83406, 0.91133, 0.83326, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90616, 1.81055, 0.90527, 1.81055, 1.3107, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
              exports2.CalibriBoldItalicFactors = CalibriBoldItalicFactors;
              const CalibriBoldItalicMetrics = {
                lineHeight: 1.2207,
                lineGap: 0.2207
              };
              exports2.CalibriBoldItalicMetrics = CalibriBoldItalicMetrics;
              const CalibriItalicFactors = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39543, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.72346, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89249, 0.84118, 0.77452, 0.85374, 0.75186, 0.67789, 0.79776, 0.88844, 0.85066, 0.94309, 0.77818, 0.7306, 0.76659, 1.10369, 1.38313, 1.10369, 1.06139, 0.89552, 0.8739, 0.9245, 0.9245, 0.83203, 0.9245, 0.85865, 1.09842, 0.9245, 0.9245, 1.03297, 1.07692, 0.90918, 1.03297, 0.94959, 0.9245, 0.92274, 0.9245, 0.9245, 1.02933, 0.77832, 1.20562, 0.9245, 0.8916, 0.98986, 0.86621, 0.89453, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.16359, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.72346, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89249, 0.84118, 0.84118, 0.84118, 0.84118, 0.84118, 0.85284, 0.84557, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.84843, 0.83203, 0.85865, 0.85865, 0.85865, 0.85865, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.9245, 0.92274, 0.92274, 0.92274, 0.92274, 0.92274, 0.90747, 0.86651, 0.9245, 0.9245, 0.9245, 0.9245, 0.89453, 0.9245, 0.89453, 0.8675, 0.9245, 0.8675, 0.9245, 0.8675, 0.9245, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.85193, 0.8875, 0.86477, 0.99034, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.81105, 0.9245, 0.81105, 0.9245, 0.81105, 0.9245, 1, 1, 0.86275, 0.9245, 0.90872, 0.93591, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77896, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.9375, 0.98156, 0.93407, 0.77261, 1.11429, 0.89249, 0.9245, 1, 1, 0.89249, 0.9245, 0.92534, 0.86698, 0.9245, 0.84118, 0.92274, 0.84118, 0.92274, 0.84118, 0.92274, 0.8667, 0.86291, 0.75186, 1.02933, 1, 1, 0.75186, 1.02933, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 1, 1, 0.79776, 0.97655, 0.79776, 1.23023, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.94309, 0.98986, 0.7306, 0.89453, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.9245, 0.76318, 0.84843, 0.84557, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67009, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.8675, 0.90861, 0.6192, 0.7363, 0.64824, 0.82411, 0.56321, 0.85696, 1.23516, 0.8675, 0.81552, 0.7286, 0.84134, 0.73206, 0.76659, 0.86275, 0.84369, 0.90685, 0.77892, 0.85871, 1.02638, 0.89249, 0.75828, 0.84118, 0.85984, 0.77452, 0.76466, 0.79776, 0.7306, 0.90782, 0.77818, 0.903, 0.87291, 0.90685, 0.7306, 0.99058, 1.03667, 0.94635, 1.23516, 0.9849, 0.99058, 0.92393, 0.8916, 0.942, 1.03667, 0.75026, 0.94635, 1.0297, 1.23516, 0.90918, 0.94048, 0.98217, 0.89746, 0.84153, 0.92274, 0.82507, 0.88832, 0.84438, 0.88178, 1.03525, 0.9849, 1.00225, 0.78086, 0.97248, 0.89404, 1.23516, 0.9849, 0.92274, 0.9849, 0.89404, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89693, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85865, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90933, 1, 1, 1, 1, 1, 1, 0.94309, 0.98986, 0.94309, 0.98986, 0.94309, 0.98986, 0.7306, 0.89453, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.68994, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.97858, 0.82616, 0.91133, 0.83437, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90572, 1.81055, 0.90749, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85284, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
              exports2.CalibriItalicFactors = CalibriItalicFactors;
              const CalibriItalicMetrics = {
                lineHeight: 1.2207,
                lineGap: 0.2207
              };
              exports2.CalibriItalicMetrics = CalibriItalicMetrics;
              const CalibriRegularFactors = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39016, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.73834, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89385, 0.85122, 0.77452, 0.86503, 0.75186, 0.68887, 0.79776, 0.88844, 0.85066, 0.94258, 0.77818, 0.7306, 0.76659, 1.10369, 1.39016, 1.10369, 1.06139, 0.89552, 0.8739, 0.86128, 0.94469, 0.8457, 0.94469, 0.89464, 1.09842, 0.84636, 0.94469, 1.03297, 1.07692, 0.90918, 1.03297, 0.95897, 0.94469, 0.9482, 0.94469, 0.94469, 1.04692, 0.78223, 1.20562, 0.94469, 0.90332, 0.98986, 0.86621, 0.90527, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.08707, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.73834, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89385, 0.85122, 0.85122, 0.85122, 0.85122, 0.85122, 0.85284, 0.85311, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.8693, 0.8457, 0.89464, 0.89464, 0.89464, 0.89464, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.94469, 0.9482, 0.9482, 0.9482, 0.9482, 0.9482, 0.90747, 0.86651, 0.94469, 0.94469, 0.94469, 0.94469, 0.90527, 0.94469, 0.90527, 0.8675, 0.86128, 0.8675, 0.86128, 0.8675, 0.86128, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.85193, 0.92454, 0.86477, 0.9921, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.81105, 0.84636, 0.81105, 0.84636, 0.81105, 0.84636, 1, 1, 0.86275, 0.94469, 0.90872, 0.95786, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77741, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.90452, 0.98156, 1.11842, 0.77261, 1.11429, 0.89385, 0.94469, 1, 1, 0.89385, 0.94469, 0.95877, 0.86901, 0.94469, 0.85122, 0.9482, 0.85122, 0.9482, 0.85122, 0.9482, 0.8667, 0.90016, 0.75186, 1.04692, 1, 1, 0.75186, 1.04692, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 1, 1, 0.79776, 0.92188, 0.79776, 1.23023, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.94258, 0.98986, 0.7306, 0.90527, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.86128, 0.76318, 0.8693, 0.85311, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67742, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.86686, 0.90861, 0.62267, 0.74359, 0.65649, 0.85498, 0.56963, 0.88254, 1.23516, 0.8675, 0.81552, 0.75443, 0.84503, 0.73206, 0.76659, 0.86275, 0.85122, 0.90685, 0.77892, 0.85746, 1.02638, 0.89385, 0.75657, 0.85122, 0.86275, 0.77452, 0.74171, 0.79776, 0.7306, 0.95165, 0.77818, 0.89772, 0.88831, 0.90685, 0.7306, 0.98142, 1.02191, 0.96576, 1.23516, 0.99018, 0.98142, 0.9236, 0.89258, 0.94035, 1.02191, 0.78848, 0.96576, 0.9561, 1.23516, 0.90918, 0.92578, 0.95424, 0.89746, 0.83969, 0.9482, 0.80113, 0.89442, 0.85208, 0.86155, 0.98022, 0.99018, 1.00452, 0.81209, 0.99247, 0.89181, 1.23516, 0.99018, 0.9482, 0.99018, 0.89181, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88844, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89464, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96766, 1, 1, 1, 1, 1, 1, 0.94258, 0.98986, 0.94258, 0.98986, 0.94258, 0.98986, 0.7306, 0.90527, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.69043, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.99331, 0.82616, 0.91133, 0.84286, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90527, 1.81055, 0.90527, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1.07185, 0.99413, 0.96334, 1.08065, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
              exports2.CalibriRegularFactors = CalibriRegularFactors;
              const CalibriRegularMetrics = {
                lineHeight: 1.2207,
                lineGap: 0.2207
              };
              exports2.CalibriRegularMetrics = CalibriRegularMetrics;
            },
            /* 178 */
            /***/
            (__unused_webpack_module, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.HelveticaRegularMetrics = exports2.HelveticaRegularFactors = exports2.HelveticaItalicMetrics = exports2.HelveticaItalicFactors = exports2.HelveticaBoldMetrics = exports2.HelveticaBoldItalicMetrics = exports2.HelveticaBoldItalicFactors = exports2.HelveticaBoldFactors = void 0;
              const HelveticaBoldFactors = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.03374, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.00042, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.03828, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00034, 0.99977, 1, 0.99997, 1.00026, 1.00078, 1.00036, 0.99973, 1.00013, 1.0006, 0.99977, 0.99977, 0.99988, 0.85148, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 1.00069, 1.00022, 0.99977, 1.00001, 0.99984, 1.00026, 1.00001, 1.00024, 1.00001, 0.9999, 1, 1.0006, 1.00001, 1.00041, 0.99962, 1.00026, 1.0006, 0.99995, 1.00041, 0.99942, 0.99973, 0.99927, 1.00082, 0.99902, 1.00026, 1.00087, 1.0006, 1.00069, 0.99973, 0.99867, 0.99973, 0.9993, 1.00026, 1.00049, 1.00056, 1, 0.99988, 0.99935, 0.99995, 0.99954, 1.00055, 0.99945, 1.00032, 1.0006, 0.99995, 1.00026, 0.99995, 1.00032, 1.00001, 1.00008, 0.99971, 1.00019, 0.9994, 1.00001, 1.0006, 1.00044, 0.99973, 1.00023, 1.00047, 1, 0.99942, 0.99561, 0.99989, 1.00035, 0.99977, 1.00035, 0.99977, 1.00019, 0.99944, 1.00001, 1.00021, 0.99926, 1.00035, 1.00035, 0.99942, 1.00048, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.99989, 1.00057, 1.00001, 0.99936, 1.00052, 1.00012, 0.99996, 1.00043, 1, 1.00035, 0.9994, 0.99976, 1.00035, 0.99973, 1.00052, 1.00041, 1.00119, 1.00037, 0.99973, 1.00002, 0.99986, 1.00041, 1.00041, 0.99902, 0.9996, 1.00034, 0.99999, 1.00026, 0.99999, 1.00026, 0.99973, 1.00052, 0.99973, 1, 0.99973, 1.00041, 1.00075, 0.9994, 1.0003, 0.99999, 1, 1.00041, 0.99955, 1, 0.99915, 0.99973, 0.99973, 1.00026, 1.00119, 0.99955, 0.99973, 1.0006, 0.99911, 1.0006, 1.00026, 0.99972, 1.00026, 0.99902, 1.00041, 0.99973, 0.99999, 1, 1, 1.00038, 1.0005, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 1.00047, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
              exports2.HelveticaBoldFactors = HelveticaBoldFactors;
              const HelveticaBoldMetrics = {
                lineHeight: 1.2,
                lineGap: 0.2
              };
              exports2.HelveticaBoldMetrics = HelveticaBoldMetrics;
              const HelveticaBoldItalicFactors = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.0044, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99971, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.01011, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99977, 1, 1, 1.00026, 0.99969, 0.99972, 0.99981, 0.9998, 1.0006, 0.99977, 0.99977, 1.00022, 0.91155, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 0.99966, 1.00022, 1.00032, 1.00001, 0.99944, 1.00026, 1.00001, 0.99968, 1.00001, 1.00047, 1, 1.0006, 1.00001, 0.99981, 1.00101, 1.00026, 1.0006, 0.99948, 0.99981, 1.00064, 0.99973, 0.99942, 1.00101, 1.00061, 1.00026, 1.00069, 1.0006, 1.00014, 0.99973, 1.01322, 0.99973, 1.00065, 1.00026, 1.00012, 0.99923, 1, 1.00064, 1.00076, 0.99948, 1.00055, 1.00063, 1.00007, 0.99943, 1.0006, 0.99948, 1.00026, 0.99948, 0.99943, 1.00001, 1.00001, 1.00029, 1.00038, 1.00035, 1.00001, 1.0006, 1.0006, 0.99973, 0.99978, 1.00001, 1.00057, 0.99989, 0.99967, 0.99964, 0.99967, 0.99977, 0.99999, 0.99977, 1.00038, 0.99977, 1.00001, 0.99973, 1.00066, 0.99967, 0.99967, 1.00041, 0.99998, 0.99999, 0.99977, 1.00022, 0.99967, 1.00001, 0.99977, 1.00026, 0.99964, 1.00031, 1.00001, 0.99999, 0.99999, 1, 1.00023, 1, 1, 0.99999, 1.00035, 1.00001, 0.99999, 0.99973, 0.99977, 0.99999, 1.00058, 0.99973, 0.99973, 0.99955, 0.9995, 1.00026, 1.00026, 1.00032, 0.99989, 1.00034, 0.99999, 1.00026, 1.00026, 1.00026, 0.99973, 0.45998, 0.99973, 1.00026, 0.99973, 1.00001, 0.99999, 0.99982, 0.99994, 0.99996, 1, 1.00042, 1.00044, 1.00029, 1.00023, 0.99973, 0.99973, 1.00026, 0.99949, 1.00002, 0.99973, 1.0006, 1.0006, 1.0006, 0.99975, 1.00026, 1.00026, 1.00032, 0.98685, 0.99973, 1.00026, 1, 1, 0.99966, 1.00044, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1, 0.99973, 0.99971, 0.99978, 1, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00098, 1, 1, 1, 1.00049, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
              exports2.HelveticaBoldItalicFactors = HelveticaBoldItalicFactors;
              const HelveticaBoldItalicMetrics = {
                lineHeight: 1.35,
                lineGap: 0.2
              };
              exports2.HelveticaBoldItalicMetrics = HelveticaBoldItalicMetrics;
              const HelveticaItalicFactors = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.0288, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 0.99946, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.06311, 0.99973, 1.00024, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00041, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.89547, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00001, 1, 1.00054, 0.99977, 1.00084, 1.00007, 0.99973, 1.00013, 0.99924, 1.00001, 1.00001, 0.99945, 0.91221, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00001, 0.99999, 0.99977, 0.99933, 1.00022, 1.00054, 1.00001, 1.00065, 1.00026, 1.00001, 1.0001, 1.00001, 1.00052, 1, 1.0006, 1.00001, 0.99945, 0.99897, 0.99968, 0.99924, 1.00036, 0.99945, 0.99949, 1, 1.0006, 0.99897, 0.99918, 0.99968, 0.99911, 0.99924, 1, 0.99962, 1.01487, 1, 1.0005, 0.99973, 1.00012, 1.00043, 1, 0.99995, 0.99994, 1.00036, 0.99947, 1.00019, 1.00063, 1.00025, 0.99924, 1.00036, 0.99973, 1.00036, 1.00025, 1.00001, 1.00001, 1.00027, 1.0001, 1.00068, 1.00001, 1.0006, 1.0006, 1, 1.00008, 0.99957, 0.99972, 0.9994, 0.99954, 0.99975, 1.00051, 1.00001, 1.00019, 1.00001, 1.0001, 0.99986, 1.00001, 1.00001, 1.00038, 0.99954, 0.99954, 0.9994, 1.00066, 0.99999, 0.99977, 1.00022, 1.00054, 1.00001, 0.99977, 1.00026, 0.99975, 1.0001, 1.00001, 0.99993, 0.9995, 0.99955, 1.00016, 0.99978, 0.99974, 1.00019, 1.00022, 0.99955, 1.00053, 0.99973, 1.00089, 1.00005, 0.99967, 1.00048, 0.99973, 1.00002, 1.00034, 0.99973, 0.99973, 0.99964, 1.00006, 1.00066, 0.99947, 0.99973, 0.98894, 0.99973, 1, 0.44898, 1, 0.99946, 1, 1.00039, 1.00082, 0.99991, 0.99991, 0.99985, 1.00022, 1.00023, 1.00061, 1.00006, 0.99966, 0.99973, 0.99973, 0.99973, 1.00019, 1.0008, 1, 0.99924, 0.99924, 0.99924, 0.99983, 1.00044, 0.99973, 0.99964, 0.98332, 1, 0.99973, 1, 1, 0.99962, 0.99895, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 1.00423, 0.99925, 0.99999, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00049, 1, 1.00245, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 1.00003, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
              exports2.HelveticaItalicFactors = HelveticaItalicFactors;
              const HelveticaItalicMetrics = {
                lineHeight: 1.35,
                lineGap: 0.2
              };
              exports2.HelveticaItalicMetrics = HelveticaItalicMetrics;
              const HelveticaRegularFactors = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.04596, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 1.00019, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.02572, 0.99973, 1.00005, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99999, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.84533, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99928, 1, 0.99977, 1.00013, 1.00055, 0.99947, 0.99945, 0.99941, 0.99924, 1.00001, 1.00001, 1.0004, 0.91621, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00005, 0.99999, 0.99977, 1.00015, 1.00022, 0.99977, 1.00001, 0.99973, 1.00026, 1.00001, 1.00019, 1.00001, 0.99946, 1, 1.0006, 1.00001, 0.99978, 1.00045, 0.99973, 0.99924, 1.00023, 0.99978, 0.99966, 1, 1.00065, 1.00045, 1.00019, 0.99973, 0.99973, 0.99924, 1, 1, 0.96499, 1, 1.00055, 0.99973, 1.00008, 1.00027, 1, 0.9997, 0.99995, 1.00023, 0.99933, 1.00019, 1.00015, 1.00031, 0.99924, 1.00023, 0.99973, 1.00023, 1.00031, 1.00001, 0.99928, 1.00029, 1.00092, 1.00035, 1.00001, 1.0006, 1.0006, 1, 0.99988, 0.99975, 1, 1.00082, 0.99561, 0.9996, 1.00035, 1.00001, 0.99962, 1.00001, 1.00092, 0.99964, 1.00001, 0.99963, 0.99999, 1.00035, 1.00035, 1.00082, 0.99962, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.9996, 0.99967, 1.00001, 1.00034, 1.00074, 1.00054, 1.00053, 1.00063, 0.99971, 0.99962, 1.00035, 0.99975, 0.99977, 0.99973, 1.00043, 0.99953, 1.0007, 0.99915, 0.99973, 1.00008, 0.99892, 1.00073, 1.00073, 1.00114, 0.99915, 1.00073, 0.99955, 0.99973, 1.00092, 0.99973, 1, 0.99998, 1, 1.0003, 1, 1.00043, 1.00001, 0.99969, 1.0003, 1, 1.00035, 1.00001, 0.9995, 1, 1.00092, 0.99973, 0.99973, 0.99973, 1.0007, 0.9995, 1, 0.99924, 1.0006, 0.99924, 0.99972, 1.00062, 0.99973, 1.00114, 1.00073, 1, 0.99955, 1, 1, 1.00047, 0.99968, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 0.99925, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
              exports2.HelveticaRegularFactors = HelveticaRegularFactors;
              const HelveticaRegularMetrics = {
                lineHeight: 1.2,
                lineGap: 0.2
              };
              exports2.HelveticaRegularMetrics = HelveticaRegularMetrics;
            },
            /* 179 */
            /***/
            (__unused_webpack_module, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.LiberationSansRegularWidths = exports2.LiberationSansRegularMapping = exports2.LiberationSansItalicWidths = exports2.LiberationSansItalicMapping = exports2.LiberationSansBoldWidths = exports2.LiberationSansBoldMapping = exports2.LiberationSansBoldItalicWidths = exports2.LiberationSansBoldItalicMapping = void 0;
              const LiberationSansBoldWidths = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 719, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 785, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 385, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 465, 722, 333, 853, 906, 474, 825, 927, 838, 278, 722, 722, 601, 719, 667, 611, 722, 778, 278, 722, 667, 833, 722, 644, 778, 722, 667, 600, 611, 667, 821, 667, 809, 802, 278, 667, 615, 451, 611, 278, 582, 615, 610, 556, 606, 475, 460, 611, 541, 278, 558, 556, 612, 556, 445, 611, 766, 619, 520, 684, 446, 582, 715, 576, 753, 845, 278, 582, 611, 582, 845, 667, 669, 885, 567, 711, 667, 278, 276, 556, 1094, 1062, 875, 610, 722, 622, 719, 722, 719, 722, 567, 712, 667, 904, 626, 719, 719, 610, 702, 833, 722, 778, 719, 667, 722, 611, 622, 854, 667, 730, 703, 1005, 1019, 870, 979, 719, 711, 1031, 719, 556, 618, 615, 417, 635, 556, 709, 497, 615, 615, 500, 635, 740, 604, 611, 604, 611, 556, 490, 556, 875, 556, 615, 581, 833, 844, 729, 854, 615, 552, 854, 583, 556, 556, 611, 417, 552, 556, 278, 281, 278, 969, 906, 611, 500, 615, 556, 604, 778, 611, 487, 447, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1094, 556, 885, 489, 1115, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333];
              exports2.LiberationSansBoldWidths = LiberationSansBoldWidths;
              const LiberationSansBoldMapping = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
              exports2.LiberationSansBoldMapping = LiberationSansBoldMapping;
              const LiberationSansBoldItalicWidths = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 740, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 782, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 396, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 722, 333, 854, 906, 473, 844, 930, 847, 278, 722, 722, 610, 671, 667, 611, 722, 778, 278, 722, 667, 833, 722, 657, 778, 718, 667, 590, 611, 667, 822, 667, 829, 781, 278, 667, 620, 479, 611, 278, 591, 620, 621, 556, 610, 479, 492, 611, 558, 278, 566, 556, 603, 556, 450, 611, 712, 605, 532, 664, 409, 591, 704, 578, 773, 834, 278, 591, 611, 591, 834, 667, 667, 886, 614, 719, 667, 278, 278, 556, 1094, 1042, 854, 622, 719, 677, 719, 722, 708, 722, 614, 722, 667, 927, 643, 719, 719, 615, 687, 833, 722, 778, 719, 667, 722, 611, 677, 781, 667, 729, 708, 979, 989, 854, 1e3, 708, 719, 1042, 729, 556, 619, 604, 534, 618, 556, 736, 510, 611, 611, 507, 622, 740, 604, 611, 611, 611, 556, 889, 556, 885, 556, 646, 583, 889, 935, 707, 854, 594, 552, 865, 589, 556, 556, 611, 469, 563, 556, 278, 278, 278, 969, 906, 611, 507, 619, 556, 611, 778, 611, 575, 467, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1104, 556, 885, 516, 1146, 1e3, 768, 600, 834, 834, 834, 834, 999, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333];
              exports2.LiberationSansBoldItalicWidths = LiberationSansBoldItalicWidths;
              const LiberationSansBoldItalicMapping = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
              exports2.LiberationSansBoldItalicMapping = LiberationSansBoldItalicMapping;
              const LiberationSansItalicWidths = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 625, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 733, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 281, 556, 400, 556, 222, 722, 556, 722, 556, 722, 556, 615, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 354, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 789, 846, 389, 794, 865, 775, 222, 667, 667, 570, 671, 667, 611, 722, 778, 278, 667, 667, 833, 722, 648, 778, 725, 667, 600, 611, 667, 837, 667, 831, 761, 278, 667, 570, 439, 555, 222, 550, 570, 571, 500, 556, 439, 463, 555, 542, 222, 500, 492, 548, 500, 447, 556, 670, 573, 486, 603, 374, 550, 652, 546, 728, 779, 222, 550, 556, 550, 779, 667, 667, 843, 544, 708, 667, 278, 278, 500, 1066, 982, 844, 589, 715, 639, 724, 667, 651, 667, 544, 704, 667, 917, 614, 715, 715, 589, 686, 833, 722, 778, 725, 667, 722, 611, 639, 795, 667, 727, 673, 920, 923, 805, 886, 651, 694, 1022, 682, 556, 562, 522, 493, 553, 556, 688, 465, 556, 556, 472, 564, 686, 550, 556, 556, 556, 500, 833, 500, 835, 500, 572, 518, 830, 851, 621, 736, 526, 492, 752, 534, 556, 556, 556, 378, 496, 500, 222, 222, 222, 910, 828, 556, 472, 565, 500, 556, 778, 556, 492, 339, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1083, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 998, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 584, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285];
              exports2.LiberationSansItalicWidths = LiberationSansItalicWidths;
              const LiberationSansItalicMapping = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
              exports2.LiberationSansItalicMapping = LiberationSansItalicMapping;
              const LiberationSansRegularWidths = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 615, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 735, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 292, 556, 334, 556, 222, 722, 556, 722, 556, 722, 556, 604, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 375, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 784, 838, 384, 774, 855, 752, 222, 667, 667, 551, 668, 667, 611, 722, 778, 278, 667, 668, 833, 722, 650, 778, 722, 667, 618, 611, 667, 798, 667, 835, 748, 278, 667, 578, 446, 556, 222, 547, 578, 575, 500, 557, 446, 441, 556, 556, 222, 500, 500, 576, 500, 448, 556, 690, 569, 482, 617, 395, 547, 648, 525, 713, 781, 222, 547, 556, 547, 781, 667, 667, 865, 542, 719, 667, 278, 278, 500, 1057, 1010, 854, 583, 722, 635, 719, 667, 656, 667, 542, 677, 667, 923, 604, 719, 719, 583, 656, 833, 722, 778, 719, 667, 722, 611, 635, 760, 667, 740, 667, 917, 938, 792, 885, 656, 719, 1010, 722, 556, 573, 531, 365, 583, 556, 669, 458, 559, 559, 438, 583, 688, 552, 556, 542, 556, 500, 458, 500, 823, 500, 573, 521, 802, 823, 625, 719, 521, 510, 750, 542, 556, 556, 556, 365, 510, 500, 222, 278, 222, 906, 812, 556, 438, 559, 500, 552, 778, 556, 489, 411, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1073, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285];
              exports2.LiberationSansRegularWidths = LiberationSansRegularWidths;
              const LiberationSansRegularMapping = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
              exports2.LiberationSansRegularMapping = LiberationSansRegularMapping;
            },
            /* 180 */
            /***/
            (__unused_webpack_module, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.MyriadProRegularMetrics = exports2.MyriadProRegularFactors = exports2.MyriadProItalicMetrics = exports2.MyriadProItalicFactors = exports2.MyriadProBoldMetrics = exports2.MyriadProBoldItalicMetrics = exports2.MyriadProBoldItalicFactors = exports2.MyriadProBoldFactors = void 0;
              const MyriadProBoldFactors = [1.36898, 1, 1, 0.72706, 0.80479, 0.83734, 0.98894, 0.99793, 0.9897, 0.93884, 0.86209, 0.94292, 0.94292, 1.16661, 1.02058, 0.93582, 0.96694, 0.93582, 1.19137, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.72851, 0.78966, 0.90838, 0.83637, 0.82391, 0.96376, 0.80061, 0.86275, 0.8768, 0.95407, 1.0258, 0.73901, 0.85022, 0.83655, 1.0156, 0.95546, 0.92179, 0.87107, 0.92179, 0.82114, 0.8096, 0.89713, 0.94438, 0.95353, 0.94083, 0.91905, 0.90406, 0.9446, 0.94292, 1.18777, 0.94292, 1.02058, 0.89903, 0.90088, 0.94938, 0.97898, 0.81093, 0.97571, 0.94938, 1.024, 0.9577, 0.95933, 0.98621, 1.0474, 0.97455, 0.98981, 0.9672, 0.95933, 0.9446, 0.97898, 0.97407, 0.97646, 0.78036, 1.10208, 0.95442, 0.95298, 0.97579, 0.9332, 0.94039, 0.938, 0.80687, 1.01149, 0.80687, 1.02058, 0.80479, 0.99793, 0.99793, 0.99793, 0.99793, 1.01149, 1.00872, 0.90088, 0.91882, 1.0213, 0.8361, 1.02058, 0.62295, 0.54324, 0.89022, 1.08595, 1, 1, 0.90088, 1, 0.97455, 0.93582, 0.90088, 1, 1.05686, 0.8361, 0.99642, 0.99642, 0.99642, 0.72851, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.868, 0.82391, 0.80061, 0.80061, 0.80061, 0.80061, 1.0258, 1.0258, 1.0258, 1.0258, 0.97484, 0.95546, 0.92179, 0.92179, 0.92179, 0.92179, 0.92179, 1.02058, 0.92179, 0.94438, 0.94438, 0.94438, 0.94438, 0.90406, 0.86958, 0.98225, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.9031, 0.81093, 0.94938, 0.94938, 0.94938, 0.94938, 0.98621, 0.98621, 0.98621, 0.98621, 0.93969, 0.95933, 0.9446, 0.9446, 0.9446, 0.9446, 0.9446, 1.08595, 0.9446, 0.95442, 0.95442, 0.95442, 0.95442, 0.94039, 0.97898, 0.94039, 0.90838, 0.94938, 0.90838, 0.94938, 0.90838, 0.94938, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.96376, 0.84313, 0.97484, 0.97571, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.8768, 0.9577, 0.8768, 0.9577, 0.8768, 0.9577, 1, 1, 0.95407, 0.95933, 0.97069, 0.95933, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 0.887, 1.01591, 0.73901, 1.0474, 1, 1, 0.97455, 0.83655, 0.98981, 1, 1, 0.83655, 0.73977, 0.83655, 0.73903, 0.84638, 1.033, 0.95546, 0.95933, 1, 1, 0.95546, 0.95933, 0.8271, 0.95417, 0.95933, 0.92179, 0.9446, 0.92179, 0.9446, 0.92179, 0.9446, 0.936, 0.91964, 0.82114, 0.97646, 1, 1, 0.82114, 0.97646, 0.8096, 0.78036, 0.8096, 0.78036, 1, 1, 0.8096, 0.78036, 1, 1, 0.89713, 0.77452, 0.89713, 1.10208, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94083, 0.97579, 0.90406, 0.94039, 0.90406, 0.9446, 0.938, 0.9446, 0.938, 0.9446, 0.938, 1, 0.99793, 0.90838, 0.94938, 0.868, 0.9031, 0.92179, 0.9446, 1, 1, 0.89713, 1.10208, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90989, 0.9358, 0.91945, 0.83181, 0.75261, 0.87992, 0.82976, 0.96034, 0.83689, 0.97268, 1.0078, 0.90838, 0.83637, 0.8019, 0.90157, 0.80061, 0.9446, 0.95407, 0.92436, 1.0258, 0.85022, 0.97153, 1.0156, 0.95546, 0.89192, 0.92179, 0.92361, 0.87107, 0.96318, 0.89713, 0.93704, 0.95638, 0.91905, 0.91709, 0.92796, 1.0258, 0.93704, 0.94836, 1.0373, 0.95933, 1.0078, 0.95871, 0.94836, 0.96174, 0.92601, 0.9498, 0.98607, 0.95776, 0.95933, 1.05453, 1.0078, 0.98275, 0.9314, 0.95617, 0.91701, 1.05993, 0.9446, 0.78367, 0.9553, 1, 0.86832, 1.0128, 0.95871, 0.99394, 0.87548, 0.96361, 0.86774, 1.0078, 0.95871, 0.9446, 0.95871, 0.86774, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.94083, 0.97579, 0.94083, 0.97579, 0.94083, 0.97579, 0.90406, 0.94039, 0.96694, 1, 0.89903, 1, 1, 1, 0.93582, 0.93582, 0.93582, 1, 0.908, 0.908, 0.918, 0.94219, 0.94219, 0.96544, 1, 1.285, 1, 1, 0.81079, 0.81079, 1, 1, 0.74854, 1, 1, 1, 1, 0.99793, 1, 1, 1, 0.65, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.17173, 1, 0.80535, 0.76169, 1.02058, 1.0732, 1.05486, 1, 1, 1.30692, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.16161, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
              exports2.MyriadProBoldFactors = MyriadProBoldFactors;
              const MyriadProBoldMetrics = {
                lineHeight: 1.2,
                lineGap: 0.2
              };
              exports2.MyriadProBoldMetrics = MyriadProBoldMetrics;
              const MyriadProBoldItalicFactors = [1.36898, 1, 1, 0.66227, 0.80779, 0.81625, 0.97276, 0.97276, 0.97733, 0.92222, 0.83266, 0.94292, 0.94292, 1.16148, 1.02058, 0.93582, 0.96694, 0.93582, 1.17337, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.71541, 0.76813, 0.85576, 0.80591, 0.80729, 0.94299, 0.77512, 0.83655, 0.86523, 0.92222, 0.98621, 0.71743, 0.81698, 0.79726, 0.98558, 0.92222, 0.90637, 0.83809, 0.90637, 0.80729, 0.76463, 0.86275, 0.90699, 0.91605, 0.9154, 0.85308, 0.85458, 0.90531, 0.94292, 1.21296, 0.94292, 1.02058, 0.89903, 1.18616, 0.99613, 0.91677, 0.78216, 0.91677, 0.90083, 0.98796, 0.9135, 0.92168, 0.95381, 0.98981, 0.95298, 0.95381, 0.93459, 0.92168, 0.91513, 0.92004, 0.91677, 0.95077, 0.748, 1.04502, 0.91677, 0.92061, 0.94236, 0.89544, 0.89364, 0.9, 0.80687, 0.8578, 0.80687, 1.02058, 0.80779, 0.97276, 0.97276, 0.97276, 0.97276, 0.8578, 0.99973, 1.18616, 0.91339, 1.08074, 0.82891, 1.02058, 0.55509, 0.71526, 0.89022, 1.08595, 1, 1, 1.18616, 1, 0.96736, 0.93582, 1.18616, 1, 1.04864, 0.82711, 0.99043, 0.99043, 0.99043, 0.71541, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.845, 0.80729, 0.77512, 0.77512, 0.77512, 0.77512, 0.98621, 0.98621, 0.98621, 0.98621, 0.95961, 0.92222, 0.90637, 0.90637, 0.90637, 0.90637, 0.90637, 1.02058, 0.90251, 0.90699, 0.90699, 0.90699, 0.90699, 0.85458, 0.83659, 0.94951, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.85811, 0.78216, 0.90083, 0.90083, 0.90083, 0.90083, 0.95381, 0.95381, 0.95381, 0.95381, 0.9135, 0.92168, 0.91513, 0.91513, 0.91513, 0.91513, 0.91513, 1.08595, 0.91677, 0.91677, 0.91677, 0.91677, 0.91677, 0.89364, 0.92332, 0.89364, 0.85576, 0.99613, 0.85576, 0.99613, 0.85576, 0.99613, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.94299, 0.76783, 0.95961, 0.91677, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.86523, 0.9135, 0.86523, 0.9135, 0.86523, 0.9135, 1, 1, 0.92222, 0.92168, 0.92222, 0.92168, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.86036, 0.97096, 0.71743, 0.98981, 1, 1, 0.95298, 0.79726, 0.95381, 1, 1, 0.79726, 0.6894, 0.79726, 0.74321, 0.81691, 1.0006, 0.92222, 0.92168, 1, 1, 0.92222, 0.92168, 0.79464, 0.92098, 0.92168, 0.90637, 0.91513, 0.90637, 0.91513, 0.90637, 0.91513, 0.909, 0.87514, 0.80729, 0.95077, 1, 1, 0.80729, 0.95077, 0.76463, 0.748, 0.76463, 0.748, 1, 1, 0.76463, 0.748, 1, 1, 0.86275, 0.72651, 0.86275, 1.04502, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.9154, 0.94236, 0.85458, 0.89364, 0.85458, 0.90531, 0.9, 0.90531, 0.9, 0.90531, 0.9, 1, 0.97276, 0.85576, 0.99613, 0.845, 0.85811, 0.90251, 0.91677, 1, 1, 0.86275, 1.04502, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.00899, 1.30628, 0.85576, 0.80178, 0.66862, 0.7927, 0.69323, 0.88127, 0.72459, 0.89711, 0.95381, 0.85576, 0.80591, 0.7805, 0.94729, 0.77512, 0.90531, 0.92222, 0.90637, 0.98621, 0.81698, 0.92655, 0.98558, 0.92222, 0.85359, 0.90637, 0.90976, 0.83809, 0.94523, 0.86275, 0.83509, 0.93157, 0.85308, 0.83392, 0.92346, 0.98621, 0.83509, 0.92886, 0.91324, 0.92168, 0.95381, 0.90646, 0.92886, 0.90557, 0.86847, 0.90276, 0.91324, 0.86842, 0.92168, 0.99531, 0.95381, 0.9224, 0.85408, 0.92699, 0.86847, 1.0051, 0.91513, 0.80487, 0.93481, 1, 0.88159, 1.05214, 0.90646, 0.97355, 0.81539, 0.89398, 0.85923, 0.95381, 0.90646, 0.91513, 0.90646, 0.85923, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9154, 0.94236, 0.9154, 0.94236, 0.9154, 0.94236, 0.85458, 0.89364, 0.96694, 1, 0.89903, 1, 1, 1, 0.91782, 0.91782, 0.91782, 1, 0.896, 0.896, 0.896, 0.9332, 0.9332, 0.95973, 1, 1.26, 1, 1, 0.80479, 0.80178, 1, 1, 0.85633, 1, 1, 1, 1, 0.97276, 1, 1, 1, 0.698, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.14542, 1, 0.79199, 0.78694, 1.02058, 1.03493, 1.05486, 1, 1, 1.23026, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.20006, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
              exports2.MyriadProBoldItalicFactors = MyriadProBoldItalicFactors;
              const MyriadProBoldItalicMetrics = {
                lineHeight: 1.2,
                lineGap: 0.2
              };
              exports2.MyriadProBoldItalicMetrics = MyriadProBoldItalicMetrics;
              const MyriadProItalicFactors = [1.36898, 1, 1, 0.65507, 0.84943, 0.85639, 0.88465, 0.88465, 0.86936, 0.88307, 0.86948, 0.85283, 0.85283, 1.06383, 1.02058, 0.75945, 0.9219, 0.75945, 1.17337, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.75945, 0.75945, 1.02058, 1.02058, 1.02058, 0.69046, 0.70926, 0.85158, 0.77812, 0.76852, 0.89591, 0.70466, 0.76125, 0.80094, 0.86822, 0.83864, 0.728, 0.77212, 0.79475, 0.93637, 0.87514, 0.8588, 0.76013, 0.8588, 0.72421, 0.69866, 0.77598, 0.85991, 0.80811, 0.87832, 0.78112, 0.77512, 0.8562, 1.0222, 1.18417, 1.0222, 1.27014, 0.89903, 1.15012, 0.93859, 0.94399, 0.846, 0.94399, 0.81453, 1.0186, 0.94219, 0.96017, 1.03075, 1.02175, 0.912, 1.03075, 0.96998, 0.96017, 0.93859, 0.94399, 0.94399, 0.95493, 0.746, 1.12658, 0.94578, 0.91, 0.979, 0.882, 0.882, 0.83, 0.85034, 0.83537, 0.85034, 1.02058, 0.70869, 0.88465, 0.88465, 0.88465, 0.88465, 0.83537, 0.90083, 1.15012, 0.9161, 0.94565, 0.73541, 1.02058, 0.53609, 0.69353, 0.79519, 1.08595, 1, 1, 1.15012, 1, 0.91974, 0.75945, 1.15012, 1, 0.9446, 0.73361, 0.9005, 0.9005, 0.9005, 0.62864, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.773, 0.76852, 0.70466, 0.70466, 0.70466, 0.70466, 0.83864, 0.83864, 0.83864, 0.83864, 0.90561, 0.87514, 0.8588, 0.8588, 0.8588, 0.8588, 0.8588, 1.02058, 0.85751, 0.85991, 0.85991, 0.85991, 0.85991, 0.77512, 0.76013, 0.88075, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.8075, 0.846, 0.81453, 0.81453, 0.81453, 0.81453, 0.82424, 0.82424, 0.82424, 0.82424, 0.9278, 0.96017, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 1.08595, 0.8562, 0.94578, 0.94578, 0.94578, 0.94578, 0.882, 0.94578, 0.882, 0.85158, 0.93859, 0.85158, 0.93859, 0.85158, 0.93859, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.89591, 0.8544, 0.90561, 0.94399, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.80094, 0.94219, 0.80094, 0.94219, 0.80094, 0.94219, 1, 1, 0.86822, 0.96017, 0.86822, 0.96017, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 1.03075, 0.83864, 0.82424, 0.81402, 1.02738, 0.728, 1.02175, 1, 1, 0.912, 0.79475, 1.03075, 1, 1, 0.79475, 0.83911, 0.79475, 0.66266, 0.80553, 1.06676, 0.87514, 0.96017, 1, 1, 0.87514, 0.96017, 0.86865, 0.87396, 0.96017, 0.8588, 0.93859, 0.8588, 0.93859, 0.8588, 0.93859, 0.867, 0.84759, 0.72421, 0.95493, 1, 1, 0.72421, 0.95493, 0.69866, 0.746, 0.69866, 0.746, 1, 1, 0.69866, 0.746, 1, 1, 0.77598, 0.88417, 0.77598, 1.12658, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.87832, 0.979, 0.77512, 0.882, 0.77512, 0.8562, 0.83, 0.8562, 0.83, 0.8562, 0.83, 1, 0.88465, 0.85158, 0.93859, 0.773, 0.8075, 0.85751, 0.8562, 1, 1, 0.77598, 1.12658, 1.15012, 1.15012, 1.15012, 1.15012, 1.15012, 1.15313, 1.15012, 1.15012, 1.15012, 1.08106, 1.03901, 0.85158, 0.77025, 0.62264, 0.7646, 0.65351, 0.86026, 0.69461, 0.89947, 1.03075, 0.85158, 0.77812, 0.76449, 0.88836, 0.70466, 0.8562, 0.86822, 0.8588, 0.83864, 0.77212, 0.85308, 0.93637, 0.87514, 0.82352, 0.8588, 0.85701, 0.76013, 0.89058, 0.77598, 0.8156, 0.82565, 0.78112, 0.77899, 0.89386, 0.83864, 0.8156, 0.9486, 0.92388, 0.96186, 1.03075, 0.91123, 0.9486, 0.93298, 0.878, 0.93942, 0.92388, 0.84596, 0.96186, 0.95119, 1.03075, 0.922, 0.88787, 0.95829, 0.88, 0.93559, 0.93859, 0.78815, 0.93758, 1, 0.89217, 1.03737, 0.91123, 0.93969, 0.77487, 0.85769, 0.86799, 1.03075, 0.91123, 0.93859, 0.91123, 0.86799, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87832, 0.979, 0.87832, 0.979, 0.87832, 0.979, 0.77512, 0.882, 0.9219, 1, 0.89903, 1, 1, 1, 0.87321, 0.87321, 0.87321, 1, 1.027, 1.027, 1.027, 0.86847, 0.86847, 0.79121, 1, 1.124, 1, 1, 0.73572, 0.73572, 1, 1, 0.85034, 1, 1, 1, 1, 0.88465, 1, 1, 1, 0.669, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04828, 1, 0.74948, 0.75187, 1.02058, 0.98391, 1.02119, 1, 1, 1.06233, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05233, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
              exports2.MyriadProItalicFactors = MyriadProItalicFactors;
              const MyriadProItalicMetrics = {
                lineHeight: 1.2,
                lineGap: 0.2
              };
              exports2.MyriadProItalicMetrics = MyriadProItalicMetrics;
              const MyriadProRegularFactors = [1.36898, 1, 1, 0.76305, 0.82784, 0.94935, 0.89364, 0.92241, 0.89073, 0.90706, 0.98472, 0.85283, 0.85283, 1.0664, 1.02058, 0.74505, 0.9219, 0.74505, 1.23456, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.74505, 0.74505, 1.02058, 1.02058, 1.02058, 0.73002, 0.72601, 0.91755, 0.8126, 0.80314, 0.92222, 0.73764, 0.79726, 0.83051, 0.90284, 0.86023, 0.74, 0.8126, 0.84869, 0.96518, 0.91115, 0.8858, 0.79761, 0.8858, 0.74498, 0.73914, 0.81363, 0.89591, 0.83659, 0.89633, 0.85608, 0.8111, 0.90531, 1.0222, 1.22736, 1.0222, 1.27014, 0.89903, 0.90088, 0.86667, 1.0231, 0.896, 1.01411, 0.90083, 1.05099, 1.00512, 0.99793, 1.05326, 1.09377, 0.938, 1.06226, 1.00119, 0.99793, 0.98714, 1.0231, 1.01231, 0.98196, 0.792, 1.19137, 0.99074, 0.962, 1.01915, 0.926, 0.942, 0.856, 0.85034, 0.92006, 0.85034, 1.02058, 0.69067, 0.92241, 0.92241, 0.92241, 0.92241, 0.92006, 0.9332, 0.90088, 0.91882, 0.93484, 0.75339, 1.02058, 0.56866, 0.54324, 0.79519, 1.08595, 1, 1, 0.90088, 1, 0.95325, 0.74505, 0.90088, 1, 0.97198, 0.75339, 0.91009, 0.91009, 0.91009, 0.66466, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.788, 0.80314, 0.73764, 0.73764, 0.73764, 0.73764, 0.86023, 0.86023, 0.86023, 0.86023, 0.92915, 0.91115, 0.8858, 0.8858, 0.8858, 0.8858, 0.8858, 1.02058, 0.8858, 0.89591, 0.89591, 0.89591, 0.89591, 0.8111, 0.79611, 0.89713, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86936, 0.896, 0.90083, 0.90083, 0.90083, 0.90083, 0.84224, 0.84224, 0.84224, 0.84224, 0.97276, 0.99793, 0.98714, 0.98714, 0.98714, 0.98714, 0.98714, 1.08595, 0.89876, 0.99074, 0.99074, 0.99074, 0.99074, 0.942, 1.0231, 0.942, 0.91755, 0.86667, 0.91755, 0.86667, 0.91755, 0.86667, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.92222, 0.93372, 0.92915, 1.01411, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.83051, 1.00512, 0.83051, 1.00512, 0.83051, 1.00512, 1, 1, 0.90284, 0.99793, 0.90976, 0.99793, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 1.05326, 0.86023, 0.84224, 0.82873, 1.07469, 0.74, 1.09377, 1, 1, 0.938, 0.84869, 1.06226, 1, 1, 0.84869, 0.83704, 0.84869, 0.81441, 0.85588, 1.08927, 0.91115, 0.99793, 1, 1, 0.91115, 0.99793, 0.91887, 0.90991, 0.99793, 0.8858, 0.98714, 0.8858, 0.98714, 0.8858, 0.98714, 0.894, 0.91434, 0.74498, 0.98196, 1, 1, 0.74498, 0.98196, 0.73914, 0.792, 0.73914, 0.792, 1, 1, 0.73914, 0.792, 1, 1, 0.81363, 0.904, 0.81363, 1.19137, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89633, 1.01915, 0.8111, 0.942, 0.8111, 0.90531, 0.856, 0.90531, 0.856, 0.90531, 0.856, 1, 0.92241, 0.91755, 0.86667, 0.788, 0.86936, 0.8858, 0.89876, 1, 1, 0.81363, 1.19137, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90388, 1.03901, 0.92138, 0.78105, 0.7154, 0.86169, 0.80513, 0.94007, 0.82528, 0.98612, 1.06226, 0.91755, 0.8126, 0.81884, 0.92819, 0.73764, 0.90531, 0.90284, 0.8858, 0.86023, 0.8126, 0.91172, 0.96518, 0.91115, 0.83089, 0.8858, 0.87791, 0.79761, 0.89297, 0.81363, 0.88157, 0.89992, 0.85608, 0.81992, 0.94307, 0.86023, 0.88157, 0.95308, 0.98699, 0.99793, 1.06226, 0.95817, 0.95308, 0.97358, 0.928, 0.98088, 0.98699, 0.92761, 0.99793, 0.96017, 1.06226, 0.986, 0.944, 0.95978, 0.938, 0.96705, 0.98714, 0.80442, 0.98972, 1, 0.89762, 1.04552, 0.95817, 0.99007, 0.87064, 0.91879, 0.88888, 1.06226, 0.95817, 0.98714, 0.95817, 0.88888, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89633, 1.01915, 0.89633, 1.01915, 0.89633, 1.01915, 0.8111, 0.942, 0.9219, 1, 0.89903, 1, 1, 1, 0.93173, 0.93173, 0.93173, 1, 1.06304, 1.06304, 1.06904, 0.89903, 0.89903, 0.80549, 1, 1.156, 1, 1, 0.76575, 0.76575, 1, 1, 0.72458, 1, 1, 1, 1, 0.92241, 1, 1, 1, 0.619, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.07257, 1, 0.74705, 0.71119, 1.02058, 1.024, 1.02119, 1, 1, 1.1536, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05638, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
              exports2.MyriadProRegularFactors = MyriadProRegularFactors;
              const MyriadProRegularMetrics = {
                lineHeight: 1.2,
                lineGap: 0.2
              };
              exports2.MyriadProRegularMetrics = MyriadProRegularMetrics;
            },
            /* 181 */
            /***/
            (__unused_webpack_module, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.SegoeuiRegularMetrics = exports2.SegoeuiRegularFactors = exports2.SegoeuiItalicMetrics = exports2.SegoeuiItalicFactors = exports2.SegoeuiBoldMetrics = exports2.SegoeuiBoldItalicMetrics = exports2.SegoeuiBoldItalicFactors = exports2.SegoeuiBoldFactors = void 0;
              const SegoeuiBoldFactors = [1.76738, 1, 1, 0.99297, 0.9824, 1.04016, 1.06497, 1.03424, 0.97529, 1.17647, 1.23203, 1.1085, 1.1085, 1.16939, 1.2107, 0.9754, 1.21408, 0.9754, 1.59578, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 0.81378, 0.81378, 1.2107, 1.2107, 1.2107, 0.71703, 0.97847, 0.97363, 0.88776, 0.8641, 1.02096, 0.79795, 0.85132, 0.914, 1.06085, 1.1406, 0.8007, 0.89858, 0.83693, 1.14889, 1.09398, 0.97489, 0.92094, 0.97489, 0.90399, 0.84041, 0.95923, 1.00135, 1, 1.06467, 0.98243, 0.90996, 0.99361, 1.1085, 1.56942, 1.1085, 1.2107, 0.74627, 0.94282, 0.96752, 1.01519, 0.86304, 1.01359, 0.97278, 1.15103, 1.01359, 0.98561, 1.02285, 1.02285, 1.00527, 1.02285, 1.0302, 0.99041, 1.0008, 1.01519, 1.01359, 1.02258, 0.79104, 1.16862, 0.99041, 0.97454, 1.02511, 0.99298, 0.96752, 0.95801, 0.94856, 1.16579, 0.94856, 1.2107, 0.9824, 1.03424, 1.03424, 1, 1.03424, 1.16579, 0.8727, 1.3871, 1.18622, 1.10818, 1.04478, 1.2107, 1.18622, 0.75155, 0.94994, 1.28826, 1.21408, 1.21408, 0.91056, 1, 0.91572, 0.9754, 0.64663, 1.18328, 1.24866, 1.04478, 1.14169, 1.15749, 1.17389, 0.71703, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.93506, 0.8641, 0.79795, 0.79795, 0.79795, 0.79795, 1.1406, 1.1406, 1.1406, 1.1406, 1.02096, 1.09398, 0.97426, 0.97426, 0.97426, 0.97426, 0.97426, 1.2107, 0.97489, 1.00135, 1.00135, 1.00135, 1.00135, 0.90996, 0.92094, 1.02798, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.93136, 0.86304, 0.97278, 0.97278, 0.97278, 0.97278, 1.02285, 1.02285, 1.02285, 1.02285, 0.97122, 0.99041, 1, 1, 1, 1, 1, 1.28826, 1.0008, 0.99041, 0.99041, 0.99041, 0.99041, 0.96752, 1.01519, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 1.02096, 1.03057, 1.02096, 1.03517, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.914, 1.01359, 0.914, 1.01359, 0.914, 1.01359, 1, 1, 1.06085, 0.98561, 1.06085, 1.00879, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 0.97138, 1.08692, 0.8007, 1.02285, 1, 1, 1.00527, 0.83693, 1.02285, 1, 1, 0.83693, 0.9455, 0.83693, 0.90418, 0.83693, 1.13005, 1.09398, 0.99041, 1, 1, 1.09398, 0.99041, 0.96692, 1.09251, 0.99041, 0.97489, 1.0008, 0.97489, 1.0008, 0.97489, 1.0008, 0.93994, 0.97931, 0.90399, 1.02258, 1, 1, 0.90399, 1.02258, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 1, 1, 0.95923, 1.07034, 0.95923, 1.16862, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.06467, 1.02511, 0.90996, 0.96752, 0.90996, 0.99361, 0.95801, 0.99361, 0.95801, 0.99361, 0.95801, 1.07733, 1.03424, 0.97363, 0.96752, 0.93506, 0.93136, 0.97489, 1.0008, 1, 1, 0.95923, 1.16862, 1.15103, 1.15103, 1.01173, 1.03959, 0.75953, 0.81378, 0.79912, 1.15103, 1.21994, 0.95161, 0.87815, 1.01149, 0.81525, 0.7676, 0.98167, 1.01134, 1.02546, 0.84097, 1.03089, 1.18102, 0.97363, 0.88776, 0.85134, 0.97826, 0.79795, 0.99361, 1.06085, 0.97489, 1.1406, 0.89858, 1.0388, 1.14889, 1.09398, 0.86039, 0.97489, 1.0595, 0.92094, 0.94793, 0.95923, 0.90996, 0.99346, 0.98243, 1.02112, 0.95493, 1.1406, 0.90996, 1.03574, 1.02597, 1.0008, 1.18102, 1.06628, 1.03574, 1.0192, 1.01932, 1.00886, 0.97531, 1.0106, 1.0008, 1.13189, 1.18102, 1.02277, 0.98683, 1.0016, 0.99561, 1.07237, 1.0008, 0.90434, 0.99921, 0.93803, 0.8965, 1.23085, 1.06628, 1.04983, 0.96268, 1.0499, 0.98439, 1.18102, 1.06628, 1.0008, 1.06628, 0.98439, 0.79795, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09466, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.97278, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.02065, 1, 1, 1, 1, 1, 1, 1.06467, 1.02511, 1.06467, 1.02511, 1.06467, 1.02511, 0.90996, 0.96752, 1, 1.21408, 0.89903, 1, 1, 0.75155, 1.04394, 1.04394, 1.04394, 1.04394, 0.98633, 0.98633, 0.98633, 0.73047, 0.73047, 1.20642, 0.91211, 1.25635, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.12454, 0.93503, 1.03424, 1.19687, 1.03424, 1, 1, 1, 0.771, 1, 1, 1.15749, 1.15749, 1.15749, 1.10948, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.16897, 1, 0.96085, 0.90137, 1.2107, 1.18416, 1.13973, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21172, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18874, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.09193, 1.09193, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
              exports2.SegoeuiBoldFactors = SegoeuiBoldFactors;
              const SegoeuiBoldMetrics = {
                lineHeight: 1.33008,
                lineGap: 0
              };
              exports2.SegoeuiBoldMetrics = SegoeuiBoldMetrics;
              const SegoeuiBoldItalicFactors = [1.76738, 1, 1, 0.98946, 1.03959, 1.04016, 1.02809, 1.036, 0.97639, 1.10953, 1.23203, 1.11144, 1.11144, 1.16939, 1.21237, 0.9754, 1.21261, 0.9754, 1.59754, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 0.81378, 0.81378, 1.21237, 1.21237, 1.21237, 0.73541, 0.97847, 0.97363, 0.89723, 0.87897, 1.0426, 0.79429, 0.85292, 0.91149, 1.05815, 1.1406, 0.79631, 0.90128, 0.83853, 1.04396, 1.10615, 0.97552, 0.94436, 0.97552, 0.88641, 0.80527, 0.96083, 1.00135, 1, 1.06777, 0.9817, 0.91142, 0.99361, 1.11144, 1.57293, 1.11144, 1.21237, 0.74627, 1.31818, 1.06585, 0.97042, 0.83055, 0.97042, 0.93503, 1.1261, 0.97042, 0.97922, 1.14236, 0.94552, 1.01054, 1.14236, 1.02471, 0.97922, 0.94165, 0.97042, 0.97042, 1.0276, 0.78929, 1.1261, 0.97922, 0.95874, 1.02197, 0.98507, 0.96752, 0.97168, 0.95107, 1.16579, 0.95107, 1.21237, 1.03959, 1.036, 1.036, 1, 1.036, 1.16579, 0.87357, 1.31818, 1.18754, 1.26781, 1.05356, 1.21237, 1.18622, 0.79487, 0.94994, 1.29004, 1.24047, 1.24047, 1.31818, 1, 0.91484, 0.9754, 1.31818, 1.1349, 1.24866, 1.05356, 1.13934, 1.15574, 1.17389, 0.73541, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.94385, 0.87897, 0.79429, 0.79429, 0.79429, 0.79429, 1.1406, 1.1406, 1.1406, 1.1406, 1.0426, 1.10615, 0.97552, 0.97552, 0.97552, 0.97552, 0.97552, 1.21237, 0.97552, 1.00135, 1.00135, 1.00135, 1.00135, 0.91142, 0.94436, 0.98721, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 0.96705, 0.83055, 0.93503, 0.93503, 0.93503, 0.93503, 1.14236, 1.14236, 1.14236, 1.14236, 0.93125, 0.97922, 0.94165, 0.94165, 0.94165, 0.94165, 0.94165, 1.29004, 0.94165, 0.97922, 0.97922, 0.97922, 0.97922, 0.96752, 0.97042, 0.96752, 0.97363, 1.06585, 0.97363, 1.06585, 0.97363, 1.06585, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 1.0426, 1.0033, 1.0426, 0.97042, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.91149, 0.97042, 0.91149, 0.97042, 0.91149, 0.97042, 1, 1, 1.05815, 0.97922, 1.05815, 0.97922, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 0.97441, 1.04302, 0.79631, 1.01582, 1, 1, 1.01054, 0.83853, 1.14236, 1, 1, 0.83853, 1.09125, 0.83853, 0.90418, 0.83853, 1.19508, 1.10615, 0.97922, 1, 1, 1.10615, 0.97922, 1.01034, 1.10466, 0.97922, 0.97552, 0.94165, 0.97552, 0.94165, 0.97552, 0.94165, 0.91602, 0.91981, 0.88641, 1.0276, 1, 1, 0.88641, 1.0276, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 1, 1, 0.96083, 1.05403, 0.95923, 1.16862, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.06777, 1.02197, 0.91142, 0.96752, 0.91142, 0.99361, 0.97168, 0.99361, 0.97168, 0.99361, 0.97168, 1.23199, 1.036, 0.97363, 1.06585, 0.94385, 0.96705, 0.97552, 0.94165, 1, 1, 0.96083, 1.1261, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 0.95161, 1.27126, 1.00811, 0.83284, 0.77702, 0.99137, 0.95253, 1.0347, 0.86142, 1.07205, 1.14236, 0.97363, 0.89723, 0.86869, 1.09818, 0.79429, 0.99361, 1.05815, 0.97552, 1.1406, 0.90128, 1.06662, 1.04396, 1.10615, 0.84918, 0.97552, 1.04694, 0.94436, 0.98015, 0.96083, 0.91142, 1.00356, 0.9817, 1.01945, 0.98999, 1.1406, 0.91142, 1.04961, 0.9898, 1.00639, 1.14236, 1.07514, 1.04961, 0.99607, 1.02897, 1.008, 0.9898, 0.95134, 1.00639, 1.11121, 1.14236, 1.00518, 0.97981, 1.02186, 1, 1.08578, 0.94165, 0.99314, 0.98387, 0.93028, 0.93377, 1.35125, 1.07514, 1.10687, 0.93491, 1.04232, 1.00351, 1.14236, 1.07514, 0.94165, 1.07514, 1.00351, 0.79429, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09097, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.93503, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96609, 1, 1, 1, 1, 1, 1, 1.06777, 1.02197, 1.06777, 1.02197, 1.06777, 1.02197, 0.91142, 0.96752, 1, 1.21261, 0.89903, 1, 1, 0.75155, 1.04745, 1.04745, 1.04745, 1.04394, 0.98633, 0.98633, 0.98633, 0.72959, 0.72959, 1.20502, 0.91406, 1.26514, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.09125, 0.93327, 1.03336, 1.16541, 1.036, 1, 1, 1, 0.771, 1, 1, 1.15574, 1.15574, 1.15574, 1.15574, 0.86364, 0.94434, 0.86279, 0.94434, 0.86224, 1, 1, 1.16798, 1, 0.96085, 0.90068, 1.21237, 1.18416, 1.13904, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21339, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18775, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.13269, 1.13269, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
              exports2.SegoeuiBoldItalicFactors = SegoeuiBoldItalicFactors;
              const SegoeuiBoldItalicMetrics = {
                lineHeight: 1.33008,
                lineGap: 0
              };
              exports2.SegoeuiBoldItalicMetrics = SegoeuiBoldItalicMetrics;
              const SegoeuiItalicFactors = [1.76738, 1, 1, 0.98946, 1.14763, 1.05365, 1.06234, 0.96927, 0.92586, 1.15373, 1.18414, 0.91349, 0.91349, 1.07403, 1.17308, 0.78383, 1.20088, 0.78383, 1.42531, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78383, 0.78383, 1.17308, 1.17308, 1.17308, 0.77349, 0.94565, 0.94729, 0.85944, 0.88506, 0.9858, 0.74817, 0.80016, 0.88449, 0.98039, 0.95782, 0.69238, 0.89898, 0.83231, 0.98183, 1.03989, 0.96924, 0.86237, 0.96924, 0.80595, 0.74524, 0.86091, 0.95402, 0.94143, 0.98448, 0.8858, 0.83089, 0.93285, 1.0949, 1.39016, 1.0949, 1.45994, 0.74627, 1.04839, 0.97454, 0.97454, 0.87207, 0.97454, 0.87533, 1.06151, 0.97454, 1.00176, 1.16484, 1.08132, 0.98047, 1.16484, 1.02989, 1.01054, 0.96225, 0.97454, 0.97454, 1.06598, 0.79004, 1.16344, 1.00351, 0.94629, 0.9973, 0.91016, 0.96777, 0.9043, 0.91082, 0.92481, 0.91082, 1.17308, 0.95748, 0.96927, 0.96927, 1, 0.96927, 0.92481, 0.80597, 1.04839, 1.23393, 1.1781, 0.9245, 1.17308, 1.20808, 0.63218, 0.94261, 1.24822, 1.09971, 1.09971, 1.04839, 1, 0.85273, 0.78032, 1.04839, 1.09971, 1.22326, 0.9245, 1.09836, 1.13525, 1.15222, 0.70424, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.85498, 0.88506, 0.74817, 0.74817, 0.74817, 0.74817, 0.95782, 0.95782, 0.95782, 0.95782, 0.9858, 1.03989, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.17308, 0.96924, 0.95402, 0.95402, 0.95402, 0.95402, 0.83089, 0.86237, 0.88409, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.92916, 0.87207, 0.87533, 0.87533, 0.87533, 0.87533, 0.93146, 0.93146, 0.93146, 0.93146, 0.93854, 1.01054, 0.96225, 0.96225, 0.96225, 0.96225, 0.96225, 1.24822, 0.8761, 1.00351, 1.00351, 1.00351, 1.00351, 0.96777, 0.97454, 0.96777, 0.94729, 0.97454, 0.94729, 0.97454, 0.94729, 0.97454, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.9858, 0.95391, 0.9858, 0.97454, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.88449, 0.97454, 0.88449, 0.97454, 0.88449, 0.97454, 1, 1, 0.98039, 1.00176, 0.98039, 1.00176, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 1.16484, 0.95782, 0.93146, 0.84421, 1.12761, 0.69238, 1.08132, 1, 1, 0.98047, 0.83231, 1.16484, 1, 1, 0.84723, 1.04861, 0.84723, 0.78755, 0.83231, 1.23736, 1.03989, 1.01054, 1, 1, 1.03989, 1.01054, 0.9857, 1.03849, 1.01054, 0.96924, 0.96225, 0.96924, 0.96225, 0.96924, 0.96225, 0.92383, 0.90171, 0.80595, 1.06598, 1, 1, 0.80595, 1.06598, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 1, 1, 0.86091, 1.02759, 0.85771, 1.16344, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.98448, 0.9973, 0.83089, 0.96777, 0.83089, 0.93285, 0.9043, 0.93285, 0.9043, 0.93285, 0.9043, 1.31868, 0.96927, 0.94729, 0.97454, 0.85498, 0.92916, 0.96924, 0.8761, 1, 1, 0.86091, 1.16344, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 0.81965, 0.81965, 0.94729, 0.78032, 0.71022, 0.90883, 0.84171, 0.99877, 0.77596, 1.05734, 1.2, 0.94729, 0.85944, 0.82791, 0.9607, 0.74817, 0.93285, 0.98039, 0.96924, 0.95782, 0.89898, 0.98316, 0.98183, 1.03989, 0.78614, 0.96924, 0.97642, 0.86237, 0.86075, 0.86091, 0.83089, 0.90082, 0.8858, 0.97296, 1.01284, 0.95782, 0.83089, 1.0976, 1.04, 1.03342, 1.2, 1.0675, 1.0976, 0.98205, 1.03809, 1.05097, 1.04, 0.95364, 1.03342, 1.05401, 1.2, 1.02148, 1.0119, 1.04724, 1.0127, 1.02732, 0.96225, 0.8965, 0.97783, 0.93574, 0.94818, 1.30679, 1.0675, 1.11826, 0.99821, 1.0557, 1.0326, 1.2, 1.0675, 0.96225, 1.0675, 1.0326, 0.74817, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03754, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87533, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.98705, 1, 1, 1, 1, 1, 1, 0.98448, 0.9973, 0.98448, 0.9973, 0.98448, 0.9973, 0.83089, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 0.94945, 0.94945, 0.94945, 0.94945, 1.12317, 1.12317, 1.12317, 0.67603, 0.67603, 1.15621, 0.73584, 1.21191, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87709, 0.96927, 1.01473, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.09836, 1.09836, 1.09836, 1.01522, 0.86321, 0.94434, 0.8649, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86438, 1.17308, 1.18416, 1.14589, 0.69825, 0.97622, 1.96791, 1.24822, 1.24822, 1.17308, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.17984, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10742, 1.10742, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
              exports2.SegoeuiItalicFactors = SegoeuiItalicFactors;
              const SegoeuiItalicMetrics = {
                lineHeight: 1.33008,
                lineGap: 0
              };
              exports2.SegoeuiItalicMetrics = SegoeuiItalicMetrics;
              const SegoeuiRegularFactors = [1.76738, 1, 1, 0.98594, 1.02285, 1.10454, 1.06234, 0.96927, 0.92037, 1.19985, 1.2046, 0.90616, 0.90616, 1.07152, 1.1714, 0.78032, 1.20088, 0.78032, 1.40246, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78032, 0.78032, 1.1714, 1.1714, 1.1714, 0.80597, 0.94084, 0.96706, 0.85944, 0.85734, 0.97093, 0.75842, 0.79936, 0.88198, 0.9831, 0.95782, 0.71387, 0.86969, 0.84636, 1.07796, 1.03584, 0.96924, 0.83968, 0.96924, 0.82826, 0.79649, 0.85771, 0.95132, 0.93119, 0.98965, 0.88433, 0.8287, 0.93365, 1.08612, 1.3638, 1.08612, 1.45786, 0.74627, 0.80499, 0.91484, 1.05707, 0.92383, 1.05882, 0.9403, 1.12654, 1.05882, 1.01756, 1.09011, 1.09011, 0.99414, 1.09011, 1.034, 1.01756, 1.05356, 1.05707, 1.05882, 1.04399, 0.84863, 1.21968, 1.01756, 0.95801, 1.00068, 0.91797, 0.96777, 0.9043, 0.90351, 0.92105, 0.90351, 1.1714, 0.85337, 0.96927, 0.96927, 0.99912, 0.96927, 0.92105, 0.80597, 1.2434, 1.20808, 1.05937, 0.90957, 1.1714, 1.20808, 0.75155, 0.94261, 1.24644, 1.09971, 1.09971, 0.84751, 1, 0.85273, 0.78032, 0.61584, 1.05425, 1.17914, 0.90957, 1.08665, 1.11593, 1.14169, 0.73381, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.86035, 0.85734, 0.75842, 0.75842, 0.75842, 0.75842, 0.95782, 0.95782, 0.95782, 0.95782, 0.97093, 1.03584, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.1714, 0.96924, 0.95132, 0.95132, 0.95132, 0.95132, 0.8287, 0.83968, 0.89049, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.93575, 0.92383, 0.9403, 0.9403, 0.9403, 0.9403, 0.8717, 0.8717, 0.8717, 0.8717, 1.00527, 1.01756, 1.05356, 1.05356, 1.05356, 1.05356, 1.05356, 1.24644, 0.95923, 1.01756, 1.01756, 1.01756, 1.01756, 0.96777, 1.05707, 0.96777, 0.96706, 0.91484, 0.96706, 0.91484, 0.96706, 0.91484, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.97093, 1.0969, 0.97093, 1.05882, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.88198, 1.05882, 0.88198, 1.05882, 0.88198, 1.05882, 1, 1, 0.9831, 1.01756, 0.9831, 1.01756, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 1.09011, 0.95782, 0.8717, 0.84784, 1.11551, 0.71387, 1.09011, 1, 1, 0.99414, 0.84636, 1.09011, 1, 1, 0.84636, 1.0536, 0.84636, 0.94298, 0.84636, 1.23297, 1.03584, 1.01756, 1, 1, 1.03584, 1.01756, 1.00323, 1.03444, 1.01756, 0.96924, 1.05356, 0.96924, 1.05356, 0.96924, 1.05356, 0.93066, 0.98293, 0.82826, 1.04399, 1, 1, 0.82826, 1.04399, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 1, 1, 0.85771, 1.17318, 0.85771, 1.21968, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.98965, 1.00068, 0.8287, 0.96777, 0.8287, 0.93365, 0.9043, 0.93365, 0.9043, 0.93365, 0.9043, 1.08571, 0.96927, 0.96706, 0.91484, 0.86035, 0.93575, 0.96924, 0.95923, 1, 1, 0.85771, 1.21968, 1.11437, 1.11437, 0.93109, 0.91202, 0.60411, 0.84164, 0.55572, 1.01173, 0.97361, 0.81818, 0.81818, 0.96635, 0.78032, 0.72727, 0.92366, 0.98601, 1.03405, 0.77968, 1.09799, 1.2, 0.96706, 0.85944, 0.85638, 0.96491, 0.75842, 0.93365, 0.9831, 0.96924, 0.95782, 0.86969, 0.94152, 1.07796, 1.03584, 0.78437, 0.96924, 0.98715, 0.83968, 0.83491, 0.85771, 0.8287, 0.94492, 0.88433, 0.9287, 1.0098, 0.95782, 0.8287, 1.0625, 0.98248, 1.03424, 1.2, 1.01071, 1.0625, 0.95246, 1.03809, 1.04912, 0.98248, 1.00221, 1.03424, 1.05443, 1.2, 1.04785, 0.99609, 1.00169, 1.05176, 0.99346, 1.05356, 0.9087, 1.03004, 0.95542, 0.93117, 1.23362, 1.01071, 1.07831, 1.02512, 1.05205, 1.03502, 1.2, 1.01071, 1.05356, 1.01071, 1.03502, 0.75842, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03719, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9403, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04021, 1, 1, 1, 1, 1, 1, 0.98965, 1.00068, 0.98965, 1.00068, 0.98965, 1.00068, 0.8287, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 1.03077, 1.03077, 1.03077, 1.03077, 1.13196, 1.13196, 1.13196, 0.67428, 0.67428, 1.16039, 0.73291, 1.20996, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87796, 0.96927, 1.01518, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.10539, 1.10539, 1.11358, 1.06967, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86507, 1.1714, 1.18416, 1.14589, 0.69825, 0.97622, 1.9697, 1.24822, 1.24822, 1.17238, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18083, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10938, 1.10938, 1, 1, 1, 1.05425, 1.09971, 1.09971, 1.09971, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
              exports2.SegoeuiRegularFactors = SegoeuiRegularFactors;
              const SegoeuiRegularMetrics = {
                lineHeight: 1.33008,
                lineGap: 0
              };
              exports2.SegoeuiRegularMetrics = SegoeuiRegularMetrics;
            },
            /* 182 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PostScriptEvaluator = exports2.PostScriptCompiler = exports2.PDFFunctionFactory = void 0;
              exports2.isPDFFunction = isPDFFunction;
              var _primitives = __w_pdfjs_require__2(130);
              var _util = __w_pdfjs_require__2(2);
              var _ps_parser = __w_pdfjs_require__2(183);
              var _base_stream = __w_pdfjs_require__2(132);
              var _image_utils = __w_pdfjs_require__2(184);
              const _PDFFunctionFactory = class _PDFFunctionFactory {
                constructor(_ref) {
                  let {
                    xref,
                    isEvalSupported = true
                  } = _ref;
                  this.xref = xref;
                  this.isEvalSupported = isEvalSupported !== false;
                }
                create(fn) {
                  const cachedFunction = this.getCached(fn);
                  if (cachedFunction) {
                    return cachedFunction;
                  }
                  const parsedFunction = PDFFunction.parse({
                    xref: this.xref,
                    isEvalSupported: this.isEvalSupported,
                    fn: fn instanceof _primitives.Ref ? this.xref.fetch(fn) : fn
                  });
                  this._cache(fn, parsedFunction);
                  return parsedFunction;
                }
                createFromArray(fnObj) {
                  const cachedFunction = this.getCached(fnObj);
                  if (cachedFunction) {
                    return cachedFunction;
                  }
                  const parsedFunction = PDFFunction.parseArray({
                    xref: this.xref,
                    isEvalSupported: this.isEvalSupported,
                    fnObj: fnObj instanceof _primitives.Ref ? this.xref.fetch(fnObj) : fnObj
                  });
                  this._cache(fnObj, parsedFunction);
                  return parsedFunction;
                }
                getCached(cacheKey) {
                  let fnRef;
                  if (cacheKey instanceof _primitives.Ref) {
                    fnRef = cacheKey;
                  } else if (cacheKey instanceof _primitives.Dict) {
                    fnRef = cacheKey.objId;
                  } else if (cacheKey instanceof _base_stream.BaseStream) {
                    fnRef = cacheKey.dict && cacheKey.dict.objId;
                  }
                  if (fnRef) {
                    const localFunction = this._localFunctionCache.getByRef(fnRef);
                    if (localFunction) {
                      return localFunction;
                    }
                  }
                  return null;
                }
                _cache(cacheKey, parsedFunction) {
                  if (!parsedFunction) {
                    throw new Error('PDFFunctionFactory._cache - expected "parsedFunction" argument.');
                  }
                  let fnRef;
                  if (cacheKey instanceof _primitives.Ref) {
                    fnRef = cacheKey;
                  } else if (cacheKey instanceof _primitives.Dict) {
                    fnRef = cacheKey.objId;
                  } else if (cacheKey instanceof _base_stream.BaseStream) {
                    fnRef = cacheKey.dict && cacheKey.dict.objId;
                  }
                  if (fnRef) {
                    this._localFunctionCache.set(null, fnRef, parsedFunction);
                  }
                }
                get _localFunctionCache() {
                  return (0, _util.shadow)(this, "_localFunctionCache", new _image_utils.LocalFunctionCache());
                }
              };
              __name(_PDFFunctionFactory, "PDFFunctionFactory");
              let PDFFunctionFactory = _PDFFunctionFactory;
              exports2.PDFFunctionFactory = PDFFunctionFactory;
              function toNumberArray(arr) {
                if (!Array.isArray(arr)) {
                  return null;
                }
                const length = arr.length;
                for (let i = 0; i < length; i++) {
                  if (typeof arr[i] !== "number") {
                    const result = new Array(length);
                    for (let j = 0; j < length; j++) {
                      result[j] = +arr[j];
                    }
                    return result;
                  }
                }
                return arr;
              }
              __name(toNumberArray, "toNumberArray");
              const _PDFFunction = class _PDFFunction {
                static getSampleArray(size, outputSize, bps, stream) {
                  let i, ii;
                  let length = 1;
                  for (i = 0, ii = size.length; i < ii; i++) {
                    length *= size[i];
                  }
                  length *= outputSize;
                  const array = new Array(length);
                  let codeSize = 0;
                  let codeBuf = 0;
                  const sampleMul = 1 / (2 ** bps - 1);
                  const strBytes = stream.getBytes((length * bps + 7) / 8);
                  let strIdx = 0;
                  for (i = 0; i < length; i++) {
                    while (codeSize < bps) {
                      codeBuf <<= 8;
                      codeBuf |= strBytes[strIdx++];
                      codeSize += 8;
                    }
                    codeSize -= bps;
                    array[i] = (codeBuf >> codeSize) * sampleMul;
                    codeBuf &= (1 << codeSize) - 1;
                  }
                  return array;
                }
                static parse(_ref2) {
                  let {
                    xref,
                    isEvalSupported,
                    fn
                  } = _ref2;
                  const dict = fn.dict || fn;
                  const typeNum = dict.get("FunctionType");
                  switch (typeNum) {
                    case 0:
                      return this.constructSampled({
                        xref,
                        isEvalSupported,
                        fn,
                        dict
                      });
                    case 1:
                      break;
                    case 2:
                      return this.constructInterpolated({
                        xref,
                        isEvalSupported,
                        dict
                      });
                    case 3:
                      return this.constructStiched({
                        xref,
                        isEvalSupported,
                        dict
                      });
                    case 4:
                      return this.constructPostScript({
                        xref,
                        isEvalSupported,
                        fn,
                        dict
                      });
                  }
                  throw new _util.FormatError("Unknown type of function");
                }
                static parseArray(_ref3) {
                  let {
                    xref,
                    isEvalSupported,
                    fnObj
                  } = _ref3;
                  if (!Array.isArray(fnObj)) {
                    return this.parse({
                      xref,
                      isEvalSupported,
                      fn: fnObj
                    });
                  }
                  const fnArray = [];
                  for (let j = 0, jj = fnObj.length; j < jj; j++) {
                    fnArray.push(this.parse({
                      xref,
                      isEvalSupported,
                      fn: xref.fetchIfRef(fnObj[j])
                    }));
                  }
                  return function(src, srcOffset, dest, destOffset) {
                    for (let i = 0, ii = fnArray.length; i < ii; i++) {
                      fnArray[i](src, srcOffset, dest, destOffset + i);
                    }
                  };
                }
                static constructSampled(_ref4) {
                  let {
                    xref,
                    isEvalSupported,
                    fn,
                    dict
                  } = _ref4;
                  function toMultiArray(arr) {
                    const inputLength = arr.length;
                    const out = [];
                    let index = 0;
                    for (let i = 0; i < inputLength; i += 2) {
                      out[index++] = [arr[i], arr[i + 1]];
                    }
                    return out;
                  }
                  __name(toMultiArray, "toMultiArray");
                  function interpolate(x, xmin, xmax, ymin, ymax) {
                    return ymin + (x - xmin) * ((ymax - ymin) / (xmax - xmin));
                  }
                  __name(interpolate, "interpolate");
                  let domain = toNumberArray(dict.getArray("Domain"));
                  let range = toNumberArray(dict.getArray("Range"));
                  if (!domain || !range) {
                    throw new _util.FormatError("No domain or range");
                  }
                  const inputSize = domain.length / 2;
                  const outputSize = range.length / 2;
                  domain = toMultiArray(domain);
                  range = toMultiArray(range);
                  const size = toNumberArray(dict.getArray("Size"));
                  const bps = dict.get("BitsPerSample");
                  const order = dict.get("Order") || 1;
                  if (order !== 1) {
                    (0, _util.info)("No support for cubic spline interpolation: " + order);
                  }
                  let encode = toNumberArray(dict.getArray("Encode"));
                  if (!encode) {
                    encode = [];
                    for (let i = 0; i < inputSize; ++i) {
                      encode.push([0, size[i] - 1]);
                    }
                  } else {
                    encode = toMultiArray(encode);
                  }
                  let decode = toNumberArray(dict.getArray("Decode"));
                  if (!decode) {
                    decode = range;
                  } else {
                    decode = toMultiArray(decode);
                  }
                  const samples = this.getSampleArray(size, outputSize, bps, fn);
                  return /* @__PURE__ */ __name(function constructSampledFn(src, srcOffset, dest, destOffset) {
                    const cubeVertices = 1 << inputSize;
                    const cubeN = new Float64Array(cubeVertices);
                    const cubeVertex = new Uint32Array(cubeVertices);
                    let i, j;
                    for (j = 0; j < cubeVertices; j++) {
                      cubeN[j] = 1;
                    }
                    let k = outputSize, pos = 1;
                    for (i = 0; i < inputSize; ++i) {
                      const domain_2i = domain[i][0];
                      const domain_2i_1 = domain[i][1];
                      const xi = Math.min(Math.max(src[srcOffset + i], domain_2i), domain_2i_1);
                      let e = interpolate(xi, domain_2i, domain_2i_1, encode[i][0], encode[i][1]);
                      const size_i = size[i];
                      e = Math.min(Math.max(e, 0), size_i - 1);
                      const e0 = e < size_i - 1 ? Math.floor(e) : e - 1;
                      const n0 = e0 + 1 - e;
                      const n1 = e - e0;
                      const offset0 = e0 * k;
                      const offset1 = offset0 + k;
                      for (j = 0; j < cubeVertices; j++) {
                        if (j & pos) {
                          cubeN[j] *= n1;
                          cubeVertex[j] += offset1;
                        } else {
                          cubeN[j] *= n0;
                          cubeVertex[j] += offset0;
                        }
                      }
                      k *= size_i;
                      pos <<= 1;
                    }
                    for (j = 0; j < outputSize; ++j) {
                      let rj = 0;
                      for (i = 0; i < cubeVertices; i++) {
                        rj += samples[cubeVertex[i] + j] * cubeN[i];
                      }
                      rj = interpolate(rj, 0, 1, decode[j][0], decode[j][1]);
                      dest[destOffset + j] = Math.min(Math.max(rj, range[j][0]), range[j][1]);
                    }
                  }, "constructSampledFn");
                }
                static constructInterpolated(_ref5) {
                  let {
                    xref,
                    isEvalSupported,
                    dict
                  } = _ref5;
                  const c0 = toNumberArray(dict.getArray("C0")) || [0];
                  const c1 = toNumberArray(dict.getArray("C1")) || [1];
                  const n = dict.get("N");
                  const diff = [];
                  for (let i = 0, ii = c0.length; i < ii; ++i) {
                    diff.push(c1[i] - c0[i]);
                  }
                  const length = diff.length;
                  return /* @__PURE__ */ __name(function constructInterpolatedFn(src, srcOffset, dest, destOffset) {
                    const x = n === 1 ? src[srcOffset] : src[srcOffset] ** n;
                    for (let j = 0; j < length; ++j) {
                      dest[destOffset + j] = c0[j] + x * diff[j];
                    }
                  }, "constructInterpolatedFn");
                }
                static constructStiched(_ref6) {
                  let {
                    xref,
                    isEvalSupported,
                    dict
                  } = _ref6;
                  const domain = toNumberArray(dict.getArray("Domain"));
                  if (!domain) {
                    throw new _util.FormatError("No domain");
                  }
                  const inputSize = domain.length / 2;
                  if (inputSize !== 1) {
                    throw new _util.FormatError("Bad domain for stiched function");
                  }
                  const fnRefs = dict.get("Functions");
                  const fns = [];
                  for (let i = 0, ii = fnRefs.length; i < ii; ++i) {
                    fns.push(this.parse({
                      xref,
                      isEvalSupported,
                      fn: xref.fetchIfRef(fnRefs[i])
                    }));
                  }
                  const bounds = toNumberArray(dict.getArray("Bounds"));
                  const encode = toNumberArray(dict.getArray("Encode"));
                  const tmpBuf = new Float32Array(1);
                  return /* @__PURE__ */ __name(function constructStichedFn(src, srcOffset, dest, destOffset) {
                    const clip = /* @__PURE__ */ __name(function constructStichedFromIRClip(v2, min, max) {
                      if (v2 > max) {
                        v2 = max;
                      } else if (v2 < min) {
                        v2 = min;
                      }
                      return v2;
                    }, "constructStichedFromIRClip");
                    const v = clip(src[srcOffset], domain[0], domain[1]);
                    const length = bounds.length;
                    let i;
                    for (i = 0; i < length; ++i) {
                      if (v < bounds[i]) {
                        break;
                      }
                    }
                    let dmin = domain[0];
                    if (i > 0) {
                      dmin = bounds[i - 1];
                    }
                    let dmax = domain[1];
                    if (i < bounds.length) {
                      dmax = bounds[i];
                    }
                    const rmin = encode[2 * i];
                    const rmax = encode[2 * i + 1];
                    tmpBuf[0] = dmin === dmax ? rmin : rmin + (v - dmin) * (rmax - rmin) / (dmax - dmin);
                    fns[i](tmpBuf, 0, dest, destOffset);
                  }, "constructStichedFn");
                }
                static constructPostScript(_ref7) {
                  let {
                    xref,
                    isEvalSupported,
                    fn,
                    dict
                  } = _ref7;
                  const domain = toNumberArray(dict.getArray("Domain"));
                  const range = toNumberArray(dict.getArray("Range"));
                  if (!domain) {
                    throw new _util.FormatError("No domain.");
                  }
                  if (!range) {
                    throw new _util.FormatError("No range.");
                  }
                  const lexer = new _ps_parser.PostScriptLexer(fn);
                  const parser = new _ps_parser.PostScriptParser(lexer);
                  const code = parser.parse();
                  if (isEvalSupported && _util.FeatureTest.isEvalSupported) {
                    const compiled = new PostScriptCompiler().compile(code, domain, range);
                    if (compiled) {
                      return new Function("src", "srcOffset", "dest", "destOffset", compiled);
                    }
                  }
                  (0, _util.info)("Unable to compile PS function");
                  const numOutputs = range.length >> 1;
                  const numInputs = domain.length >> 1;
                  const evaluator = new PostScriptEvaluator(code);
                  const cache = /* @__PURE__ */ Object.create(null);
                  const MAX_CACHE_SIZE = 2048 * 4;
                  let cache_available = MAX_CACHE_SIZE;
                  const tmpBuf = new Float32Array(numInputs);
                  return /* @__PURE__ */ __name(function constructPostScriptFn(src, srcOffset, dest, destOffset) {
                    let i, value;
                    let key = "";
                    const input = tmpBuf;
                    for (i = 0; i < numInputs; i++) {
                      value = src[srcOffset + i];
                      input[i] = value;
                      key += value + "_";
                    }
                    const cachedValue = cache[key];
                    if (cachedValue !== void 0) {
                      dest.set(cachedValue, destOffset);
                      return;
                    }
                    const output = new Float32Array(numOutputs);
                    const stack = evaluator.execute(input);
                    const stackIndex = stack.length - numOutputs;
                    for (i = 0; i < numOutputs; i++) {
                      value = stack[stackIndex + i];
                      let bound = range[i * 2];
                      if (value < bound) {
                        value = bound;
                      } else {
                        bound = range[i * 2 + 1];
                        if (value > bound) {
                          value = bound;
                        }
                      }
                      output[i] = value;
                    }
                    if (cache_available > 0) {
                      cache_available--;
                      cache[key] = output;
                    }
                    dest.set(output, destOffset);
                  }, "constructPostScriptFn");
                }
              };
              __name(_PDFFunction, "PDFFunction");
              let PDFFunction = _PDFFunction;
              function isPDFFunction(v) {
                let fnDict;
                if (typeof v !== "object") {
                  return false;
                } else if (v instanceof _primitives.Dict) {
                  fnDict = v;
                } else if (v instanceof _base_stream.BaseStream) {
                  fnDict = v.dict;
                } else {
                  return false;
                }
                return fnDict.has("FunctionType");
              }
              __name(isPDFFunction, "isPDFFunction");
              const _PostScriptStack = class _PostScriptStack {
                static get MAX_STACK_SIZE() {
                  return (0, _util.shadow)(this, "MAX_STACK_SIZE", 100);
                }
                constructor(initialStack) {
                  this.stack = !initialStack ? [] : Array.prototype.slice.call(initialStack, 0);
                }
                push(value) {
                  if (this.stack.length >= _PostScriptStack.MAX_STACK_SIZE) {
                    throw new Error("PostScript function stack overflow.");
                  }
                  this.stack.push(value);
                }
                pop() {
                  if (this.stack.length <= 0) {
                    throw new Error("PostScript function stack underflow.");
                  }
                  return this.stack.pop();
                }
                copy(n) {
                  if (this.stack.length + n >= _PostScriptStack.MAX_STACK_SIZE) {
                    throw new Error("PostScript function stack overflow.");
                  }
                  const stack = this.stack;
                  for (let i = stack.length - n, j = n - 1; j >= 0; j--, i++) {
                    stack.push(stack[i]);
                  }
                }
                index(n) {
                  this.push(this.stack[this.stack.length - n - 1]);
                }
                roll(n, p) {
                  const stack = this.stack;
                  const l = stack.length - n;
                  const r = stack.length - 1;
                  const c = l + (p - Math.floor(p / n) * n);
                  for (let i = l, j = r; i < j; i++, j--) {
                    const t = stack[i];
                    stack[i] = stack[j];
                    stack[j] = t;
                  }
                  for (let i = l, j = c - 1; i < j; i++, j--) {
                    const t = stack[i];
                    stack[i] = stack[j];
                    stack[j] = t;
                  }
                  for (let i = c, j = r; i < j; i++, j--) {
                    const t = stack[i];
                    stack[i] = stack[j];
                    stack[j] = t;
                  }
                }
              };
              __name(_PostScriptStack, "PostScriptStack");
              let PostScriptStack = _PostScriptStack;
              const _PostScriptEvaluator = class _PostScriptEvaluator {
                constructor(operators) {
                  this.operators = operators;
                }
                execute(initialStack) {
                  const stack = new PostScriptStack(initialStack);
                  let counter = 0;
                  const operators = this.operators;
                  const length = operators.length;
                  let operator, a, b;
                  while (counter < length) {
                    operator = operators[counter++];
                    if (typeof operator === "number") {
                      stack.push(operator);
                      continue;
                    }
                    switch (operator) {
                      case "jz":
                        b = stack.pop();
                        a = stack.pop();
                        if (!a) {
                          counter = b;
                        }
                        break;
                      case "j":
                        a = stack.pop();
                        counter = a;
                        break;
                      case "abs":
                        a = stack.pop();
                        stack.push(Math.abs(a));
                        break;
                      case "add":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a + b);
                        break;
                      case "and":
                        b = stack.pop();
                        a = stack.pop();
                        if (typeof a === "boolean" && typeof b === "boolean") {
                          stack.push(a && b);
                        } else {
                          stack.push(a & b);
                        }
                        break;
                      case "atan":
                        a = stack.pop();
                        stack.push(Math.atan(a));
                        break;
                      case "bitshift":
                        b = stack.pop();
                        a = stack.pop();
                        if (a > 0) {
                          stack.push(a << b);
                        } else {
                          stack.push(a >> b);
                        }
                        break;
                      case "ceiling":
                        a = stack.pop();
                        stack.push(Math.ceil(a));
                        break;
                      case "copy":
                        a = stack.pop();
                        stack.copy(a);
                        break;
                      case "cos":
                        a = stack.pop();
                        stack.push(Math.cos(a));
                        break;
                      case "cvi":
                        a = stack.pop() | 0;
                        stack.push(a);
                        break;
                      case "cvr":
                        break;
                      case "div":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a / b);
                        break;
                      case "dup":
                        stack.copy(1);
                        break;
                      case "eq":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a === b);
                        break;
                      case "exch":
                        stack.roll(2, 1);
                        break;
                      case "exp":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a ** b);
                        break;
                      case "false":
                        stack.push(false);
                        break;
                      case "floor":
                        a = stack.pop();
                        stack.push(Math.floor(a));
                        break;
                      case "ge":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a >= b);
                        break;
                      case "gt":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a > b);
                        break;
                      case "idiv":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a / b | 0);
                        break;
                      case "index":
                        a = stack.pop();
                        stack.index(a);
                        break;
                      case "le":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a <= b);
                        break;
                      case "ln":
                        a = stack.pop();
                        stack.push(Math.log(a));
                        break;
                      case "log":
                        a = stack.pop();
                        stack.push(Math.log(a) / Math.LN10);
                        break;
                      case "lt":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a < b);
                        break;
                      case "mod":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a % b);
                        break;
                      case "mul":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a * b);
                        break;
                      case "ne":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a !== b);
                        break;
                      case "neg":
                        a = stack.pop();
                        stack.push(-a);
                        break;
                      case "not":
                        a = stack.pop();
                        if (typeof a === "boolean") {
                          stack.push(!a);
                        } else {
                          stack.push(~a);
                        }
                        break;
                      case "or":
                        b = stack.pop();
                        a = stack.pop();
                        if (typeof a === "boolean" && typeof b === "boolean") {
                          stack.push(a || b);
                        } else {
                          stack.push(a | b);
                        }
                        break;
                      case "pop":
                        stack.pop();
                        break;
                      case "roll":
                        b = stack.pop();
                        a = stack.pop();
                        stack.roll(a, b);
                        break;
                      case "round":
                        a = stack.pop();
                        stack.push(Math.round(a));
                        break;
                      case "sin":
                        a = stack.pop();
                        stack.push(Math.sin(a));
                        break;
                      case "sqrt":
                        a = stack.pop();
                        stack.push(Math.sqrt(a));
                        break;
                      case "sub":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a - b);
                        break;
                      case "true":
                        stack.push(true);
                        break;
                      case "truncate":
                        a = stack.pop();
                        a = a < 0 ? Math.ceil(a) : Math.floor(a);
                        stack.push(a);
                        break;
                      case "xor":
                        b = stack.pop();
                        a = stack.pop();
                        if (typeof a === "boolean" && typeof b === "boolean") {
                          stack.push(a !== b);
                        } else {
                          stack.push(a ^ b);
                        }
                        break;
                      default:
                        throw new _util.FormatError(`Unknown operator ${operator}`);
                    }
                  }
                  return stack.stack;
                }
              };
              __name(_PostScriptEvaluator, "PostScriptEvaluator");
              let PostScriptEvaluator = _PostScriptEvaluator;
              exports2.PostScriptEvaluator = PostScriptEvaluator;
              const _AstNode = class _AstNode {
                constructor(type) {
                  this.type = type;
                }
                visit(visitor) {
                  (0, _util.unreachable)("abstract method");
                }
              };
              __name(_AstNode, "AstNode");
              let AstNode = _AstNode;
              const _AstArgument = class _AstArgument extends AstNode {
                constructor(index, min, max) {
                  super("args");
                  this.index = index;
                  this.min = min;
                  this.max = max;
                }
                visit(visitor) {
                  visitor.visitArgument(this);
                }
              };
              __name(_AstArgument, "AstArgument");
              let AstArgument = _AstArgument;
              const _AstLiteral = class _AstLiteral extends AstNode {
                constructor(number) {
                  super("literal");
                  this.number = number;
                  this.min = number;
                  this.max = number;
                }
                visit(visitor) {
                  visitor.visitLiteral(this);
                }
              };
              __name(_AstLiteral, "AstLiteral");
              let AstLiteral = _AstLiteral;
              const _AstBinaryOperation = class _AstBinaryOperation extends AstNode {
                constructor(op, arg1, arg2, min, max) {
                  super("binary");
                  this.op = op;
                  this.arg1 = arg1;
                  this.arg2 = arg2;
                  this.min = min;
                  this.max = max;
                }
                visit(visitor) {
                  visitor.visitBinaryOperation(this);
                }
              };
              __name(_AstBinaryOperation, "AstBinaryOperation");
              let AstBinaryOperation = _AstBinaryOperation;
              const _AstMin = class _AstMin extends AstNode {
                constructor(arg, max) {
                  super("max");
                  this.arg = arg;
                  this.min = arg.min;
                  this.max = max;
                }
                visit(visitor) {
                  visitor.visitMin(this);
                }
              };
              __name(_AstMin, "AstMin");
              let AstMin = _AstMin;
              const _AstVariable = class _AstVariable extends AstNode {
                constructor(index, min, max) {
                  super("var");
                  this.index = index;
                  this.min = min;
                  this.max = max;
                }
                visit(visitor) {
                  visitor.visitVariable(this);
                }
              };
              __name(_AstVariable, "AstVariable");
              let AstVariable = _AstVariable;
              const _AstVariableDefinition = class _AstVariableDefinition extends AstNode {
                constructor(variable, arg) {
                  super("definition");
                  this.variable = variable;
                  this.arg = arg;
                }
                visit(visitor) {
                  visitor.visitVariableDefinition(this);
                }
              };
              __name(_AstVariableDefinition, "AstVariableDefinition");
              let AstVariableDefinition = _AstVariableDefinition;
              const _ExpressionBuilderVisitor = class _ExpressionBuilderVisitor {
                constructor() {
                  this.parts = [];
                }
                visitArgument(arg) {
                  this.parts.push("Math.max(", arg.min, ", Math.min(", arg.max, ", src[srcOffset + ", arg.index, "]))");
                }
                visitVariable(variable) {
                  this.parts.push("v", variable.index);
                }
                visitLiteral(literal) {
                  this.parts.push(literal.number);
                }
                visitBinaryOperation(operation) {
                  this.parts.push("(");
                  operation.arg1.visit(this);
                  this.parts.push(" ", operation.op, " ");
                  operation.arg2.visit(this);
                  this.parts.push(")");
                }
                visitVariableDefinition(definition) {
                  this.parts.push("var ");
                  definition.variable.visit(this);
                  this.parts.push(" = ");
                  definition.arg.visit(this);
                  this.parts.push(";");
                }
                visitMin(max) {
                  this.parts.push("Math.min(");
                  max.arg.visit(this);
                  this.parts.push(", ", max.max, ")");
                }
                toString() {
                  return this.parts.join("");
                }
              };
              __name(_ExpressionBuilderVisitor, "ExpressionBuilderVisitor");
              let ExpressionBuilderVisitor = _ExpressionBuilderVisitor;
              function buildAddOperation(num1, num2) {
                if (num2.type === "literal" && num2.number === 0) {
                  return num1;
                }
                if (num1.type === "literal" && num1.number === 0) {
                  return num2;
                }
                if (num2.type === "literal" && num1.type === "literal") {
                  return new AstLiteral(num1.number + num2.number);
                }
                return new AstBinaryOperation("+", num1, num2, num1.min + num2.min, num1.max + num2.max);
              }
              __name(buildAddOperation, "buildAddOperation");
              function buildMulOperation(num1, num2) {
                if (num2.type === "literal") {
                  if (num2.number === 0) {
                    return new AstLiteral(0);
                  } else if (num2.number === 1) {
                    return num1;
                  } else if (num1.type === "literal") {
                    return new AstLiteral(num1.number * num2.number);
                  }
                }
                if (num1.type === "literal") {
                  if (num1.number === 0) {
                    return new AstLiteral(0);
                  } else if (num1.number === 1) {
                    return num2;
                  }
                }
                const min = Math.min(num1.min * num2.min, num1.min * num2.max, num1.max * num2.min, num1.max * num2.max);
                const max = Math.max(num1.min * num2.min, num1.min * num2.max, num1.max * num2.min, num1.max * num2.max);
                return new AstBinaryOperation("*", num1, num2, min, max);
              }
              __name(buildMulOperation, "buildMulOperation");
              function buildSubOperation(num1, num2) {
                if (num2.type === "literal") {
                  if (num2.number === 0) {
                    return num1;
                  } else if (num1.type === "literal") {
                    return new AstLiteral(num1.number - num2.number);
                  }
                }
                if (num2.type === "binary" && num2.op === "-" && num1.type === "literal" && num1.number === 1 && num2.arg1.type === "literal" && num2.arg1.number === 1) {
                  return num2.arg2;
                }
                return new AstBinaryOperation("-", num1, num2, num1.min - num2.max, num1.max - num2.min);
              }
              __name(buildSubOperation, "buildSubOperation");
              function buildMinOperation(num1, max) {
                if (num1.min >= max) {
                  return new AstLiteral(max);
                } else if (num1.max <= max) {
                  return num1;
                }
                return new AstMin(num1, max);
              }
              __name(buildMinOperation, "buildMinOperation");
              const _PostScriptCompiler = class _PostScriptCompiler {
                compile(code, domain, range) {
                  const stack = [];
                  const instructions = [];
                  const inputSize = domain.length >> 1, outputSize = range.length >> 1;
                  let lastRegister = 0;
                  let n, j;
                  let num1, num2, ast1, ast2, tmpVar, item;
                  for (let i = 0; i < inputSize; i++) {
                    stack.push(new AstArgument(i, domain[i * 2], domain[i * 2 + 1]));
                  }
                  for (let i = 0, ii = code.length; i < ii; i++) {
                    item = code[i];
                    if (typeof item === "number") {
                      stack.push(new AstLiteral(item));
                      continue;
                    }
                    switch (item) {
                      case "add":
                        if (stack.length < 2) {
                          return null;
                        }
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(buildAddOperation(num1, num2));
                        break;
                      case "cvr":
                        if (stack.length < 1) {
                          return null;
                        }
                        break;
                      case "mul":
                        if (stack.length < 2) {
                          return null;
                        }
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(buildMulOperation(num1, num2));
                        break;
                      case "sub":
                        if (stack.length < 2) {
                          return null;
                        }
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(buildSubOperation(num1, num2));
                        break;
                      case "exch":
                        if (stack.length < 2) {
                          return null;
                        }
                        ast1 = stack.pop();
                        ast2 = stack.pop();
                        stack.push(ast1, ast2);
                        break;
                      case "pop":
                        if (stack.length < 1) {
                          return null;
                        }
                        stack.pop();
                        break;
                      case "index":
                        if (stack.length < 1) {
                          return null;
                        }
                        num1 = stack.pop();
                        if (num1.type !== "literal") {
                          return null;
                        }
                        n = num1.number;
                        if (n < 0 || !Number.isInteger(n) || stack.length < n) {
                          return null;
                        }
                        ast1 = stack[stack.length - n - 1];
                        if (ast1.type === "literal" || ast1.type === "var") {
                          stack.push(ast1);
                          break;
                        }
                        tmpVar = new AstVariable(lastRegister++, ast1.min, ast1.max);
                        stack[stack.length - n - 1] = tmpVar;
                        stack.push(tmpVar);
                        instructions.push(new AstVariableDefinition(tmpVar, ast1));
                        break;
                      case "dup":
                        if (stack.length < 1) {
                          return null;
                        }
                        if (typeof code[i + 1] === "number" && code[i + 2] === "gt" && code[i + 3] === i + 7 && code[i + 4] === "jz" && code[i + 5] === "pop" && code[i + 6] === code[i + 1]) {
                          num1 = stack.pop();
                          stack.push(buildMinOperation(num1, code[i + 1]));
                          i += 6;
                          break;
                        }
                        ast1 = stack.at(-1);
                        if (ast1.type === "literal" || ast1.type === "var") {
                          stack.push(ast1);
                          break;
                        }
                        tmpVar = new AstVariable(lastRegister++, ast1.min, ast1.max);
                        stack[stack.length - 1] = tmpVar;
                        stack.push(tmpVar);
                        instructions.push(new AstVariableDefinition(tmpVar, ast1));
                        break;
                      case "roll":
                        if (stack.length < 2) {
                          return null;
                        }
                        num2 = stack.pop();
                        num1 = stack.pop();
                        if (num2.type !== "literal" || num1.type !== "literal") {
                          return null;
                        }
                        j = num2.number;
                        n = num1.number;
                        if (n <= 0 || !Number.isInteger(n) || !Number.isInteger(j) || stack.length < n) {
                          return null;
                        }
                        j = (j % n + n) % n;
                        if (j === 0) {
                          break;
                        }
                        Array.prototype.push.apply(stack, stack.splice(stack.length - n, n - j));
                        break;
                      default:
                        return null;
                    }
                  }
                  if (stack.length !== outputSize) {
                    return null;
                  }
                  const result = [];
                  for (const instruction of instructions) {
                    const statementBuilder = new ExpressionBuilderVisitor();
                    instruction.visit(statementBuilder);
                    result.push(statementBuilder.toString());
                  }
                  for (let i = 0, ii = stack.length; i < ii; i++) {
                    const expr = stack[i], statementBuilder = new ExpressionBuilderVisitor();
                    expr.visit(statementBuilder);
                    const min = range[i * 2], max = range[i * 2 + 1];
                    const out = [statementBuilder.toString()];
                    if (min > expr.min) {
                      out.unshift("Math.max(", min, ", ");
                      out.push(")");
                    }
                    if (max < expr.max) {
                      out.unshift("Math.min(", max, ", ");
                      out.push(")");
                    }
                    out.unshift("dest[destOffset + ", i, "] = ");
                    out.push(";");
                    result.push(out.join(""));
                  }
                  return result.join("\n");
                }
              };
              __name(_PostScriptCompiler, "PostScriptCompiler");
              let PostScriptCompiler = _PostScriptCompiler;
              exports2.PostScriptCompiler = PostScriptCompiler;
            },
            /* 183 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PostScriptParser = exports2.PostScriptLexer = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _primitives = __w_pdfjs_require__2(130);
              var _core_utils = __w_pdfjs_require__2(131);
              const _PostScriptParser = class _PostScriptParser {
                constructor(lexer) {
                  this.lexer = lexer;
                  this.operators = [];
                  this.token = null;
                  this.prev = null;
                }
                nextToken() {
                  this.prev = this.token;
                  this.token = this.lexer.getToken();
                }
                accept(type) {
                  if (this.token.type === type) {
                    this.nextToken();
                    return true;
                  }
                  return false;
                }
                expect(type) {
                  if (this.accept(type)) {
                    return true;
                  }
                  throw new _util.FormatError(`Unexpected symbol: found ${this.token.type} expected ${type}.`);
                }
                parse() {
                  this.nextToken();
                  this.expect(PostScriptTokenTypes.LBRACE);
                  this.parseBlock();
                  this.expect(PostScriptTokenTypes.RBRACE);
                  return this.operators;
                }
                parseBlock() {
                  while (true) {
                    if (this.accept(PostScriptTokenTypes.NUMBER)) {
                      this.operators.push(this.prev.value);
                    } else if (this.accept(PostScriptTokenTypes.OPERATOR)) {
                      this.operators.push(this.prev.value);
                    } else if (this.accept(PostScriptTokenTypes.LBRACE)) {
                      this.parseCondition();
                    } else {
                      return;
                    }
                  }
                }
                parseCondition() {
                  const conditionLocation = this.operators.length;
                  this.operators.push(null, null);
                  this.parseBlock();
                  this.expect(PostScriptTokenTypes.RBRACE);
                  if (this.accept(PostScriptTokenTypes.IF)) {
                    this.operators[conditionLocation] = this.operators.length;
                    this.operators[conditionLocation + 1] = "jz";
                  } else if (this.accept(PostScriptTokenTypes.LBRACE)) {
                    const jumpLocation = this.operators.length;
                    this.operators.push(null, null);
                    const endOfTrue = this.operators.length;
                    this.parseBlock();
                    this.expect(PostScriptTokenTypes.RBRACE);
                    this.expect(PostScriptTokenTypes.IFELSE);
                    this.operators[jumpLocation] = this.operators.length;
                    this.operators[jumpLocation + 1] = "j";
                    this.operators[conditionLocation] = endOfTrue;
                    this.operators[conditionLocation + 1] = "jz";
                  } else {
                    throw new _util.FormatError("PS Function: error parsing conditional.");
                  }
                }
              };
              __name(_PostScriptParser, "PostScriptParser");
              let PostScriptParser = _PostScriptParser;
              exports2.PostScriptParser = PostScriptParser;
              const PostScriptTokenTypes = {
                LBRACE: 0,
                RBRACE: 1,
                NUMBER: 2,
                OPERATOR: 3,
                IF: 4,
                IFELSE: 5
              };
              const _PostScriptToken = class _PostScriptToken {
                static get opCache() {
                  return (0, _util.shadow)(this, "opCache", /* @__PURE__ */ Object.create(null));
                }
                constructor(type, value) {
                  this.type = type;
                  this.value = value;
                }
                static getOperator(op) {
                  const opValue = _PostScriptToken.opCache[op];
                  if (opValue) {
                    return opValue;
                  }
                  return _PostScriptToken.opCache[op] = new _PostScriptToken(PostScriptTokenTypes.OPERATOR, op);
                }
                static get LBRACE() {
                  return (0, _util.shadow)(this, "LBRACE", new _PostScriptToken(PostScriptTokenTypes.LBRACE, "{"));
                }
                static get RBRACE() {
                  return (0, _util.shadow)(this, "RBRACE", new _PostScriptToken(PostScriptTokenTypes.RBRACE, "}"));
                }
                static get IF() {
                  return (0, _util.shadow)(this, "IF", new _PostScriptToken(PostScriptTokenTypes.IF, "IF"));
                }
                static get IFELSE() {
                  return (0, _util.shadow)(this, "IFELSE", new _PostScriptToken(PostScriptTokenTypes.IFELSE, "IFELSE"));
                }
              };
              __name(_PostScriptToken, "PostScriptToken");
              let PostScriptToken = _PostScriptToken;
              const _PostScriptLexer = class _PostScriptLexer {
                constructor(stream) {
                  this.stream = stream;
                  this.nextChar();
                  this.strBuf = [];
                }
                nextChar() {
                  return this.currentChar = this.stream.getByte();
                }
                getToken() {
                  let comment = false;
                  let ch = this.currentChar;
                  while (true) {
                    if (ch < 0) {
                      return _primitives.EOF;
                    }
                    if (comment) {
                      if (ch === 10 || ch === 13) {
                        comment = false;
                      }
                    } else if (ch === 37) {
                      comment = true;
                    } else if (!(0, _core_utils.isWhiteSpace)(ch)) {
                      break;
                    }
                    ch = this.nextChar();
                  }
                  switch (ch | 0) {
                    case 48:
                    case 49:
                    case 50:
                    case 51:
                    case 52:
                    case 53:
                    case 54:
                    case 55:
                    case 56:
                    case 57:
                    case 43:
                    case 45:
                    case 46:
                      return new PostScriptToken(PostScriptTokenTypes.NUMBER, this.getNumber());
                    case 123:
                      this.nextChar();
                      return PostScriptToken.LBRACE;
                    case 125:
                      this.nextChar();
                      return PostScriptToken.RBRACE;
                  }
                  const strBuf = this.strBuf;
                  strBuf.length = 0;
                  strBuf[0] = String.fromCharCode(ch);
                  while ((ch = this.nextChar()) >= 0 && (ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122)) {
                    strBuf.push(String.fromCharCode(ch));
                  }
                  const str = strBuf.join("");
                  switch (str.toLowerCase()) {
                    case "if":
                      return PostScriptToken.IF;
                    case "ifelse":
                      return PostScriptToken.IFELSE;
                    default:
                      return PostScriptToken.getOperator(str);
                  }
                }
                getNumber() {
                  let ch = this.currentChar;
                  const strBuf = this.strBuf;
                  strBuf.length = 0;
                  strBuf[0] = String.fromCharCode(ch);
                  while ((ch = this.nextChar()) >= 0) {
                    if (ch >= 48 && ch <= 57 || ch === 45 || ch === 46) {
                      strBuf.push(String.fromCharCode(ch));
                    } else {
                      break;
                    }
                  }
                  const value = parseFloat(strBuf.join(""));
                  if (isNaN(value)) {
                    throw new _util.FormatError(`Invalid floating point number: ${value}`);
                  }
                  return value;
                }
              };
              __name(_PostScriptLexer, "PostScriptLexer");
              let PostScriptLexer = _PostScriptLexer;
              exports2.PostScriptLexer = PostScriptLexer;
            },
            /* 184 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.LocalTilingPatternCache = exports2.LocalImageCache = exports2.LocalGStateCache = exports2.LocalFunctionCache = exports2.LocalColorSpaceCache = exports2.GlobalImageCache = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _primitives = __w_pdfjs_require__2(130);
              const _BaseLocalCache = class _BaseLocalCache {
                constructor(options) {
                  if (this.constructor === _BaseLocalCache) {
                    (0, _util.unreachable)("Cannot initialize BaseLocalCache.");
                  }
                  this._onlyRefs = (options && options.onlyRefs) === true;
                  if (!this._onlyRefs) {
                    this._nameRefMap = /* @__PURE__ */ new Map();
                    this._imageMap = /* @__PURE__ */ new Map();
                  }
                  this._imageCache = new _primitives.RefSetCache();
                }
                getByName(name) {
                  if (this._onlyRefs) {
                    (0, _util.unreachable)("Should not call `getByName` method.");
                  }
                  const ref = this._nameRefMap.get(name);
                  if (ref) {
                    return this.getByRef(ref);
                  }
                  return this._imageMap.get(name) || null;
                }
                getByRef(ref) {
                  return this._imageCache.get(ref) || null;
                }
                set(name, ref, data) {
                  (0, _util.unreachable)("Abstract method `set` called.");
                }
              };
              __name(_BaseLocalCache, "BaseLocalCache");
              let BaseLocalCache = _BaseLocalCache;
              const _LocalImageCache = class _LocalImageCache extends BaseLocalCache {
                set(name) {
                  let ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                  let data = arguments.length > 2 ? arguments[2] : void 0;
                  if (typeof name !== "string") {
                    throw new Error('LocalImageCache.set - expected "name" argument.');
                  }
                  if (ref) {
                    if (this._imageCache.has(ref)) {
                      return;
                    }
                    this._nameRefMap.set(name, ref);
                    this._imageCache.put(ref, data);
                    return;
                  }
                  if (this._imageMap.has(name)) {
                    return;
                  }
                  this._imageMap.set(name, data);
                }
              };
              __name(_LocalImageCache, "LocalImageCache");
              let LocalImageCache = _LocalImageCache;
              exports2.LocalImageCache = LocalImageCache;
              const _LocalColorSpaceCache = class _LocalColorSpaceCache extends BaseLocalCache {
                set() {
                  let name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                  let ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                  let data = arguments.length > 2 ? arguments[2] : void 0;
                  if (typeof name !== "string" && !ref) {
                    throw new Error('LocalColorSpaceCache.set - expected "name" and/or "ref" argument.');
                  }
                  if (ref) {
                    if (this._imageCache.has(ref)) {
                      return;
                    }
                    if (name !== null) {
                      this._nameRefMap.set(name, ref);
                    }
                    this._imageCache.put(ref, data);
                    return;
                  }
                  if (this._imageMap.has(name)) {
                    return;
                  }
                  this._imageMap.set(name, data);
                }
              };
              __name(_LocalColorSpaceCache, "LocalColorSpaceCache");
              let LocalColorSpaceCache = _LocalColorSpaceCache;
              exports2.LocalColorSpaceCache = LocalColorSpaceCache;
              const _LocalFunctionCache = class _LocalFunctionCache extends BaseLocalCache {
                constructor(options) {
                  super({
                    onlyRefs: true
                  });
                }
                set() {
                  let ref = arguments.length > 1 ? arguments[1] : void 0;
                  let data = arguments.length > 2 ? arguments[2] : void 0;
                  if (!ref) {
                    throw new Error('LocalFunctionCache.set - expected "ref" argument.');
                  }
                  if (this._imageCache.has(ref)) {
                    return;
                  }
                  this._imageCache.put(ref, data);
                }
              };
              __name(_LocalFunctionCache, "LocalFunctionCache");
              let LocalFunctionCache = _LocalFunctionCache;
              exports2.LocalFunctionCache = LocalFunctionCache;
              const _LocalGStateCache = class _LocalGStateCache extends BaseLocalCache {
                set(name) {
                  let ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                  let data = arguments.length > 2 ? arguments[2] : void 0;
                  if (typeof name !== "string") {
                    throw new Error('LocalGStateCache.set - expected "name" argument.');
                  }
                  if (ref) {
                    if (this._imageCache.has(ref)) {
                      return;
                    }
                    this._nameRefMap.set(name, ref);
                    this._imageCache.put(ref, data);
                    return;
                  }
                  if (this._imageMap.has(name)) {
                    return;
                  }
                  this._imageMap.set(name, data);
                }
              };
              __name(_LocalGStateCache, "LocalGStateCache");
              let LocalGStateCache = _LocalGStateCache;
              exports2.LocalGStateCache = LocalGStateCache;
              const _LocalTilingPatternCache = class _LocalTilingPatternCache extends BaseLocalCache {
                constructor(options) {
                  super({
                    onlyRefs: true
                  });
                }
                set() {
                  let ref = arguments.length > 1 ? arguments[1] : void 0;
                  let data = arguments.length > 2 ? arguments[2] : void 0;
                  if (!ref) {
                    throw new Error('LocalTilingPatternCache.set - expected "ref" argument.');
                  }
                  if (this._imageCache.has(ref)) {
                    return;
                  }
                  this._imageCache.put(ref, data);
                }
              };
              __name(_LocalTilingPatternCache, "LocalTilingPatternCache");
              let LocalTilingPatternCache = _LocalTilingPatternCache;
              exports2.LocalTilingPatternCache = LocalTilingPatternCache;
              const _GlobalImageCache = class _GlobalImageCache {
                static get NUM_PAGES_THRESHOLD() {
                  return (0, _util.shadow)(this, "NUM_PAGES_THRESHOLD", 2);
                }
                static get MIN_IMAGES_TO_CACHE() {
                  return (0, _util.shadow)(this, "MIN_IMAGES_TO_CACHE", 10);
                }
                static get MAX_BYTE_SIZE() {
                  return (0, _util.shadow)(this, "MAX_BYTE_SIZE", 4e7);
                }
                constructor() {
                  this._refCache = new _primitives.RefSetCache();
                  this._imageCache = new _primitives.RefSetCache();
                }
                get _byteSize() {
                  let byteSize = 0;
                  for (const imageData of this._imageCache) {
                    byteSize += imageData.byteSize;
                  }
                  return byteSize;
                }
                get _cacheLimitReached() {
                  if (this._imageCache.size < _GlobalImageCache.MIN_IMAGES_TO_CACHE) {
                    return false;
                  }
                  if (this._byteSize < _GlobalImageCache.MAX_BYTE_SIZE) {
                    return false;
                  }
                  return true;
                }
                shouldCache(ref, pageIndex) {
                  const pageIndexSet = this._refCache.get(ref);
                  const numPages = pageIndexSet ? pageIndexSet.size + (pageIndexSet.has(pageIndex) ? 0 : 1) : 1;
                  if (numPages < _GlobalImageCache.NUM_PAGES_THRESHOLD) {
                    return false;
                  }
                  if (!this._imageCache.has(ref) && this._cacheLimitReached) {
                    return false;
                  }
                  return true;
                }
                addPageIndex(ref, pageIndex) {
                  let pageIndexSet = this._refCache.get(ref);
                  if (!pageIndexSet) {
                    pageIndexSet = /* @__PURE__ */ new Set();
                    this._refCache.put(ref, pageIndexSet);
                  }
                  pageIndexSet.add(pageIndex);
                }
                addByteSize(ref, byteSize) {
                  const imageData = this._imageCache.get(ref);
                  if (!imageData) {
                    return;
                  }
                  if (imageData.byteSize) {
                    return;
                  }
                  imageData.byteSize = byteSize;
                }
                getData(ref, pageIndex) {
                  const pageIndexSet = this._refCache.get(ref);
                  if (!pageIndexSet) {
                    return null;
                  }
                  if (pageIndexSet.size < _GlobalImageCache.NUM_PAGES_THRESHOLD) {
                    return null;
                  }
                  const imageData = this._imageCache.get(ref);
                  if (!imageData) {
                    return null;
                  }
                  pageIndexSet.add(pageIndex);
                  return imageData;
                }
                setData(ref, data) {
                  if (!this._refCache.has(ref)) {
                    throw new Error('GlobalImageCache.setData - expected "addPageIndex" to have been called.');
                  }
                  if (this._imageCache.has(ref)) {
                    return;
                  }
                  if (this._cacheLimitReached) {
                    (0, _util.warn)("GlobalImageCache.setData - cache limit reached.");
                    return;
                  }
                  this._imageCache.put(ref, data);
                }
                clear() {
                  let onlyData = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  if (!onlyData) {
                    this._refCache.clear();
                  }
                  this._imageCache.clear();
                }
              };
              __name(_GlobalImageCache, "GlobalImageCache");
              let GlobalImageCache = _GlobalImageCache;
              exports2.GlobalImageCache = GlobalImageCache;
            },
            /* 185 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.bidi = bidi;
              var _util = __w_pdfjs_require__2(2);
              const baseTypes = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "ON", "ON", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "ON", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "ON", "ET", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "L", "ON", "ON", "BN", "ON", "ON", "ET", "ET", "EN", "EN", "ON", "L", "ON", "ON", "ON", "EN", "L", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L"];
              const arabicTypes = ["AN", "AN", "AN", "AN", "AN", "AN", "ON", "ON", "AL", "ET", "ET", "AL", "CS", "AL", "ON", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "ON", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL"];
              function isOdd(i) {
                return (i & 1) !== 0;
              }
              __name(isOdd, "isOdd");
              function isEven(i) {
                return (i & 1) === 0;
              }
              __name(isEven, "isEven");
              function findUnequal(arr, start, value) {
                let j, jj;
                for (j = start, jj = arr.length; j < jj; ++j) {
                  if (arr[j] !== value) {
                    return j;
                  }
                }
                return j;
              }
              __name(findUnequal, "findUnequal");
              function setValues(arr, start, end, value) {
                for (let j = start; j < end; ++j) {
                  arr[j] = value;
                }
              }
              __name(setValues, "setValues");
              function reverseValues(arr, start, end) {
                for (let i = start, j = end - 1; i < j; ++i, --j) {
                  const temp = arr[i];
                  arr[i] = arr[j];
                  arr[j] = temp;
                }
              }
              __name(reverseValues, "reverseValues");
              function createBidiText(str, isLTR) {
                let vertical = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                let dir = "ltr";
                if (vertical) {
                  dir = "ttb";
                } else if (!isLTR) {
                  dir = "rtl";
                }
                return {
                  str,
                  dir
                };
              }
              __name(createBidiText, "createBidiText");
              const chars = [];
              const types = [];
              function bidi(str) {
                let startLevel = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
                let vertical = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                let isLTR = true;
                const strLength = str.length;
                if (strLength === 0 || vertical) {
                  return createBidiText(str, isLTR, vertical);
                }
                chars.length = strLength;
                types.length = strLength;
                let numBidi = 0;
                let i, ii;
                for (i = 0; i < strLength; ++i) {
                  chars[i] = str.charAt(i);
                  const charCode = str.charCodeAt(i);
                  let charType = "L";
                  if (charCode <= 255) {
                    charType = baseTypes[charCode];
                  } else if (1424 <= charCode && charCode <= 1524) {
                    charType = "R";
                  } else if (1536 <= charCode && charCode <= 1791) {
                    charType = arabicTypes[charCode & 255];
                    if (!charType) {
                      (0, _util.warn)("Bidi: invalid Unicode character " + charCode.toString(16));
                    }
                  } else if (1792 <= charCode && charCode <= 2220) {
                    charType = "AL";
                  }
                  if (charType === "R" || charType === "AL" || charType === "AN") {
                    numBidi++;
                  }
                  types[i] = charType;
                }
                if (numBidi === 0) {
                  isLTR = true;
                  return createBidiText(str, isLTR);
                }
                if (startLevel === -1) {
                  if (numBidi / strLength < 0.3 && strLength > 4) {
                    isLTR = true;
                    startLevel = 0;
                  } else {
                    isLTR = false;
                    startLevel = 1;
                  }
                }
                const levels = [];
                for (i = 0; i < strLength; ++i) {
                  levels[i] = startLevel;
                }
                const e = isOdd(startLevel) ? "R" : "L";
                const sor = e;
                const eor = sor;
                let lastType = sor;
                for (i = 0; i < strLength; ++i) {
                  if (types[i] === "NSM") {
                    types[i] = lastType;
                  } else {
                    lastType = types[i];
                  }
                }
                lastType = sor;
                let t;
                for (i = 0; i < strLength; ++i) {
                  t = types[i];
                  if (t === "EN") {
                    types[i] = lastType === "AL" ? "AN" : "EN";
                  } else if (t === "R" || t === "L" || t === "AL") {
                    lastType = t;
                  }
                }
                for (i = 0; i < strLength; ++i) {
                  t = types[i];
                  if (t === "AL") {
                    types[i] = "R";
                  }
                }
                for (i = 1; i < strLength - 1; ++i) {
                  if (types[i] === "ES" && types[i - 1] === "EN" && types[i + 1] === "EN") {
                    types[i] = "EN";
                  }
                  if (types[i] === "CS" && (types[i - 1] === "EN" || types[i - 1] === "AN") && types[i + 1] === types[i - 1]) {
                    types[i] = types[i - 1];
                  }
                }
                for (i = 0; i < strLength; ++i) {
                  if (types[i] === "EN") {
                    for (let j = i - 1; j >= 0; --j) {
                      if (types[j] !== "ET") {
                        break;
                      }
                      types[j] = "EN";
                    }
                    for (let j = i + 1; j < strLength; ++j) {
                      if (types[j] !== "ET") {
                        break;
                      }
                      types[j] = "EN";
                    }
                  }
                }
                for (i = 0; i < strLength; ++i) {
                  t = types[i];
                  if (t === "WS" || t === "ES" || t === "ET" || t === "CS") {
                    types[i] = "ON";
                  }
                }
                lastType = sor;
                for (i = 0; i < strLength; ++i) {
                  t = types[i];
                  if (t === "EN") {
                    types[i] = lastType === "L" ? "L" : "EN";
                  } else if (t === "R" || t === "L") {
                    lastType = t;
                  }
                }
                for (i = 0; i < strLength; ++i) {
                  if (types[i] === "ON") {
                    const end = findUnequal(types, i + 1, "ON");
                    let before = sor;
                    if (i > 0) {
                      before = types[i - 1];
                    }
                    let after = eor;
                    if (end + 1 < strLength) {
                      after = types[end + 1];
                    }
                    if (before !== "L") {
                      before = "R";
                    }
                    if (after !== "L") {
                      after = "R";
                    }
                    if (before === after) {
                      setValues(types, i, end, before);
                    }
                    i = end - 1;
                  }
                }
                for (i = 0; i < strLength; ++i) {
                  if (types[i] === "ON") {
                    types[i] = e;
                  }
                }
                for (i = 0; i < strLength; ++i) {
                  t = types[i];
                  if (isEven(levels[i])) {
                    if (t === "R") {
                      levels[i] += 1;
                    } else if (t === "AN" || t === "EN") {
                      levels[i] += 2;
                    }
                  } else {
                    if (t === "L" || t === "AN" || t === "EN") {
                      levels[i] += 1;
                    }
                  }
                }
                let highestLevel = -1;
                let lowestOddLevel = 99;
                let level;
                for (i = 0, ii = levels.length; i < ii; ++i) {
                  level = levels[i];
                  if (highestLevel < level) {
                    highestLevel = level;
                  }
                  if (lowestOddLevel > level && isOdd(level)) {
                    lowestOddLevel = level;
                  }
                }
                for (level = highestLevel; level >= lowestOddLevel; --level) {
                  let start = -1;
                  for (i = 0, ii = levels.length; i < ii; ++i) {
                    if (levels[i] < level) {
                      if (start >= 0) {
                        reverseValues(chars, start, i);
                        start = -1;
                      }
                    } else if (start < 0) {
                      start = i;
                    }
                  }
                  if (start >= 0) {
                    reverseValues(chars, start, levels.length);
                  }
                }
                for (i = 0, ii = chars.length; i < ii; ++i) {
                  const ch = chars[i];
                  if (ch === "<" || ch === ">") {
                    chars[i] = "";
                  }
                }
                return createBidiText(chars.join(""), isLTR);
              }
              __name(bidi, "bidi");
            },
            /* 186 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.MurmurHash3_64 = void 0;
              var _util = __w_pdfjs_require__2(2);
              const SEED = 3285377520;
              const MASK_HIGH = 4294901760;
              const MASK_LOW = 65535;
              const _MurmurHash3_64 = class _MurmurHash3_64 {
                constructor(seed) {
                  this.h1 = seed ? seed & 4294967295 : SEED;
                  this.h2 = seed ? seed & 4294967295 : SEED;
                }
                update(input) {
                  let data, length;
                  if (typeof input === "string") {
                    data = new Uint8Array(input.length * 2);
                    length = 0;
                    for (let i = 0, ii = input.length; i < ii; i++) {
                      const code = input.charCodeAt(i);
                      if (code <= 255) {
                        data[length++] = code;
                      } else {
                        data[length++] = code >>> 8;
                        data[length++] = code & 255;
                      }
                    }
                  } else if ((0, _util.isArrayBuffer)(input)) {
                    data = input.slice();
                    length = data.byteLength;
                  } else {
                    throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");
                  }
                  const blockCounts = length >> 2;
                  const tailLength = length - blockCounts * 4;
                  const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);
                  let k1 = 0, k2 = 0;
                  let h1 = this.h1, h2 = this.h2;
                  const C1 = 3432918353, C2 = 461845907;
                  const C1_LOW = C1 & MASK_LOW, C2_LOW = C2 & MASK_LOW;
                  for (let i = 0; i < blockCounts; i++) {
                    if (i & 1) {
                      k1 = dataUint32[i];
                      k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
                      k1 = k1 << 15 | k1 >>> 17;
                      k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
                      h1 ^= k1;
                      h1 = h1 << 13 | h1 >>> 19;
                      h1 = h1 * 5 + 3864292196;
                    } else {
                      k2 = dataUint32[i];
                      k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;
                      k2 = k2 << 15 | k2 >>> 17;
                      k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;
                      h2 ^= k2;
                      h2 = h2 << 13 | h2 >>> 19;
                      h2 = h2 * 5 + 3864292196;
                    }
                  }
                  k1 = 0;
                  switch (tailLength) {
                    case 3:
                      k1 ^= data[blockCounts * 4 + 2] << 16;
                    case 2:
                      k1 ^= data[blockCounts * 4 + 1] << 8;
                    case 1:
                      k1 ^= data[blockCounts * 4];
                      k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
                      k1 = k1 << 15 | k1 >>> 17;
                      k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
                      if (blockCounts & 1) {
                        h1 ^= k1;
                      } else {
                        h2 ^= k1;
                      }
                  }
                  this.h1 = h1;
                  this.h2 = h2;
                }
                hexdigest() {
                  let h1 = this.h1, h2 = this.h2;
                  h1 ^= h2 >>> 1;
                  h1 = h1 * 3981806797 & MASK_HIGH | h1 * 36045 & MASK_LOW;
                  h2 = h2 * 4283543511 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 2950163797 & MASK_HIGH) >>> 16;
                  h1 ^= h2 >>> 1;
                  h1 = h1 * 444984403 & MASK_HIGH | h1 * 60499 & MASK_LOW;
                  h2 = h2 * 3301882366 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 3120437893 & MASK_HIGH) >>> 16;
                  h1 ^= h2 >>> 1;
                  const hex1 = (h1 >>> 0).toString(16), hex2 = (h2 >>> 0).toString(16);
                  return hex1.padStart(8, "0") + hex2.padStart(8, "0");
                }
              };
              __name(_MurmurHash3_64, "MurmurHash3_64");
              let MurmurHash3_64 = _MurmurHash3_64;
              exports2.MurmurHash3_64 = MurmurHash3_64;
            },
            /* 187 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.OperatorList = void 0;
              var _util = __w_pdfjs_require__2(2);
              function addState(parentState, pattern, checkFn, iterateFn, processFn) {
                let state = parentState;
                for (let i = 0, ii = pattern.length - 1; i < ii; i++) {
                  const item = pattern[i];
                  state = state[item] || (state[item] = []);
                }
                state[pattern.at(-1)] = {
                  checkFn,
                  iterateFn,
                  processFn
                };
              }
              __name(addState, "addState");
              const InitialState = [];
              addState(InitialState, [_util.OPS.save, _util.OPS.transform, _util.OPS.paintInlineImageXObject, _util.OPS.restore], null, /* @__PURE__ */ __name(function iterateInlineImageGroup(context, i) {
                const fnArray = context.fnArray;
                const iFirstSave = context.iCurr - 3;
                const pos = (i - iFirstSave) % 4;
                switch (pos) {
                  case 0:
                    return fnArray[i] === _util.OPS.save;
                  case 1:
                    return fnArray[i] === _util.OPS.transform;
                  case 2:
                    return fnArray[i] === _util.OPS.paintInlineImageXObject;
                  case 3:
                    return fnArray[i] === _util.OPS.restore;
                }
                throw new Error(`iterateInlineImageGroup - invalid pos: ${pos}`);
              }, "iterateInlineImageGroup"), /* @__PURE__ */ __name(function foundInlineImageGroup(context, i) {
                const MIN_IMAGES_IN_INLINE_IMAGES_BLOCK = 10;
                const MAX_IMAGES_IN_INLINE_IMAGES_BLOCK = 200;
                const MAX_WIDTH = 1e3;
                const IMAGE_PADDING = 1;
                const fnArray = context.fnArray, argsArray = context.argsArray;
                const curr = context.iCurr;
                const iFirstSave = curr - 3;
                const iFirstTransform = curr - 2;
                const iFirstPIIXO = curr - 1;
                const count = Math.min(Math.floor((i - iFirstSave) / 4), MAX_IMAGES_IN_INLINE_IMAGES_BLOCK);
                if (count < MIN_IMAGES_IN_INLINE_IMAGES_BLOCK) {
                  return i - (i - iFirstSave) % 4;
                }
                let maxX = 0;
                const map = [];
                let maxLineHeight = 0;
                let currentX = IMAGE_PADDING, currentY = IMAGE_PADDING;
                for (let q = 0; q < count; q++) {
                  const transform = argsArray[iFirstTransform + (q << 2)];
                  const img = argsArray[iFirstPIIXO + (q << 2)][0];
                  if (currentX + img.width > MAX_WIDTH) {
                    maxX = Math.max(maxX, currentX);
                    currentY += maxLineHeight + 2 * IMAGE_PADDING;
                    currentX = 0;
                    maxLineHeight = 0;
                  }
                  map.push({
                    transform,
                    x: currentX,
                    y: currentY,
                    w: img.width,
                    h: img.height
                  });
                  currentX += img.width + 2 * IMAGE_PADDING;
                  maxLineHeight = Math.max(maxLineHeight, img.height);
                }
                const imgWidth = Math.max(maxX, currentX) + IMAGE_PADDING;
                const imgHeight = currentY + maxLineHeight + IMAGE_PADDING;
                const imgData = new Uint8Array(imgWidth * imgHeight * 4);
                const imgRowSize = imgWidth << 2;
                for (let q = 0; q < count; q++) {
                  const data = argsArray[iFirstPIIXO + (q << 2)][0].data;
                  const rowSize = map[q].w << 2;
                  let dataOffset = 0;
                  let offset = map[q].x + map[q].y * imgWidth << 2;
                  imgData.set(data.subarray(0, rowSize), offset - imgRowSize);
                  for (let k = 0, kk = map[q].h; k < kk; k++) {
                    imgData.set(data.subarray(dataOffset, dataOffset + rowSize), offset);
                    dataOffset += rowSize;
                    offset += imgRowSize;
                  }
                  imgData.set(data.subarray(dataOffset - rowSize, dataOffset), offset);
                  while (offset >= 0) {
                    data[offset - 4] = data[offset];
                    data[offset - 3] = data[offset + 1];
                    data[offset - 2] = data[offset + 2];
                    data[offset - 1] = data[offset + 3];
                    data[offset + rowSize] = data[offset + rowSize - 4];
                    data[offset + rowSize + 1] = data[offset + rowSize - 3];
                    data[offset + rowSize + 2] = data[offset + rowSize - 2];
                    data[offset + rowSize + 3] = data[offset + rowSize - 1];
                    offset -= imgRowSize;
                  }
                }
                fnArray.splice(iFirstSave, count * 4, _util.OPS.paintInlineImageXObjectGroup);
                argsArray.splice(iFirstSave, count * 4, [{
                  width: imgWidth,
                  height: imgHeight,
                  kind: _util.ImageKind.RGBA_32BPP,
                  data: imgData
                }, map]);
                return iFirstSave + 1;
              }, "foundInlineImageGroup"));
              addState(InitialState, [_util.OPS.save, _util.OPS.transform, _util.OPS.paintImageMaskXObject, _util.OPS.restore], null, /* @__PURE__ */ __name(function iterateImageMaskGroup(context, i) {
                const fnArray = context.fnArray;
                const iFirstSave = context.iCurr - 3;
                const pos = (i - iFirstSave) % 4;
                switch (pos) {
                  case 0:
                    return fnArray[i] === _util.OPS.save;
                  case 1:
                    return fnArray[i] === _util.OPS.transform;
                  case 2:
                    return fnArray[i] === _util.OPS.paintImageMaskXObject;
                  case 3:
                    return fnArray[i] === _util.OPS.restore;
                }
                throw new Error(`iterateImageMaskGroup - invalid pos: ${pos}`);
              }, "iterateImageMaskGroup"), /* @__PURE__ */ __name(function foundImageMaskGroup(context, i) {
                const MIN_IMAGES_IN_MASKS_BLOCK = 10;
                const MAX_IMAGES_IN_MASKS_BLOCK = 100;
                const MAX_SAME_IMAGES_IN_MASKS_BLOCK = 1e3;
                const fnArray = context.fnArray, argsArray = context.argsArray;
                const curr = context.iCurr;
                const iFirstSave = curr - 3;
                const iFirstTransform = curr - 2;
                const iFirstPIMXO = curr - 1;
                let count = Math.floor((i - iFirstSave) / 4);
                if (count < MIN_IMAGES_IN_MASKS_BLOCK) {
                  return i - (i - iFirstSave) % 4;
                }
                let isSameImage = false;
                let iTransform, transformArgs;
                const firstPIMXOArg0 = argsArray[iFirstPIMXO][0];
                const firstTransformArg0 = argsArray[iFirstTransform][0], firstTransformArg1 = argsArray[iFirstTransform][1], firstTransformArg2 = argsArray[iFirstTransform][2], firstTransformArg3 = argsArray[iFirstTransform][3];
                if (firstTransformArg1 === firstTransformArg2) {
                  isSameImage = true;
                  iTransform = iFirstTransform + 4;
                  let iPIMXO = iFirstPIMXO + 4;
                  for (let q = 1; q < count; q++, iTransform += 4, iPIMXO += 4) {
                    transformArgs = argsArray[iTransform];
                    if (argsArray[iPIMXO][0] !== firstPIMXOArg0 || transformArgs[0] !== firstTransformArg0 || transformArgs[1] !== firstTransformArg1 || transformArgs[2] !== firstTransformArg2 || transformArgs[3] !== firstTransformArg3) {
                      if (q < MIN_IMAGES_IN_MASKS_BLOCK) {
                        isSameImage = false;
                      } else {
                        count = q;
                      }
                      break;
                    }
                  }
                }
                if (isSameImage) {
                  count = Math.min(count, MAX_SAME_IMAGES_IN_MASKS_BLOCK);
                  const positions = new Float32Array(count * 2);
                  iTransform = iFirstTransform;
                  for (let q = 0; q < count; q++, iTransform += 4) {
                    transformArgs = argsArray[iTransform];
                    positions[q << 1] = transformArgs[4];
                    positions[(q << 1) + 1] = transformArgs[5];
                  }
                  fnArray.splice(iFirstSave, count * 4, _util.OPS.paintImageMaskXObjectRepeat);
                  argsArray.splice(iFirstSave, count * 4, [firstPIMXOArg0, firstTransformArg0, firstTransformArg1, firstTransformArg2, firstTransformArg3, positions]);
                } else {
                  count = Math.min(count, MAX_IMAGES_IN_MASKS_BLOCK);
                  const images = [];
                  for (let q = 0; q < count; q++) {
                    transformArgs = argsArray[iFirstTransform + (q << 2)];
                    const maskParams = argsArray[iFirstPIMXO + (q << 2)][0];
                    images.push({
                      data: maskParams.data,
                      width: maskParams.width,
                      height: maskParams.height,
                      interpolate: maskParams.interpolate,
                      count: maskParams.count,
                      transform: transformArgs
                    });
                  }
                  fnArray.splice(iFirstSave, count * 4, _util.OPS.paintImageMaskXObjectGroup);
                  argsArray.splice(iFirstSave, count * 4, [images]);
                }
                return iFirstSave + 1;
              }, "foundImageMaskGroup"));
              addState(InitialState, [_util.OPS.save, _util.OPS.transform, _util.OPS.paintImageXObject, _util.OPS.restore], function(context) {
                const argsArray = context.argsArray;
                const iFirstTransform = context.iCurr - 2;
                return argsArray[iFirstTransform][1] === 0 && argsArray[iFirstTransform][2] === 0;
              }, /* @__PURE__ */ __name(function iterateImageGroup(context, i) {
                const fnArray = context.fnArray, argsArray = context.argsArray;
                const iFirstSave = context.iCurr - 3;
                const pos = (i - iFirstSave) % 4;
                switch (pos) {
                  case 0:
                    return fnArray[i] === _util.OPS.save;
                  case 1:
                    if (fnArray[i] !== _util.OPS.transform) {
                      return false;
                    }
                    const iFirstTransform = context.iCurr - 2;
                    const firstTransformArg0 = argsArray[iFirstTransform][0];
                    const firstTransformArg3 = argsArray[iFirstTransform][3];
                    if (argsArray[i][0] !== firstTransformArg0 || argsArray[i][1] !== 0 || argsArray[i][2] !== 0 || argsArray[i][3] !== firstTransformArg3) {
                      return false;
                    }
                    return true;
                  case 2:
                    if (fnArray[i] !== _util.OPS.paintImageXObject) {
                      return false;
                    }
                    const iFirstPIXO = context.iCurr - 1;
                    const firstPIXOArg0 = argsArray[iFirstPIXO][0];
                    if (argsArray[i][0] !== firstPIXOArg0) {
                      return false;
                    }
                    return true;
                  case 3:
                    return fnArray[i] === _util.OPS.restore;
                }
                throw new Error(`iterateImageGroup - invalid pos: ${pos}`);
              }, "iterateImageGroup"), function(context, i) {
                const MIN_IMAGES_IN_BLOCK = 3;
                const MAX_IMAGES_IN_BLOCK = 1e3;
                const fnArray = context.fnArray, argsArray = context.argsArray;
                const curr = context.iCurr;
                const iFirstSave = curr - 3;
                const iFirstTransform = curr - 2;
                const iFirstPIXO = curr - 1;
                const firstPIXOArg0 = argsArray[iFirstPIXO][0];
                const firstTransformArg0 = argsArray[iFirstTransform][0];
                const firstTransformArg3 = argsArray[iFirstTransform][3];
                const count = Math.min(Math.floor((i - iFirstSave) / 4), MAX_IMAGES_IN_BLOCK);
                if (count < MIN_IMAGES_IN_BLOCK) {
                  return i - (i - iFirstSave) % 4;
                }
                const positions = new Float32Array(count * 2);
                let iTransform = iFirstTransform;
                for (let q = 0; q < count; q++, iTransform += 4) {
                  const transformArgs = argsArray[iTransform];
                  positions[q << 1] = transformArgs[4];
                  positions[(q << 1) + 1] = transformArgs[5];
                }
                const args = [firstPIXOArg0, firstTransformArg0, firstTransformArg3, positions];
                fnArray.splice(iFirstSave, count * 4, _util.OPS.paintImageXObjectRepeat);
                argsArray.splice(iFirstSave, count * 4, args);
                return iFirstSave + 1;
              });
              addState(InitialState, [_util.OPS.beginText, _util.OPS.setFont, _util.OPS.setTextMatrix, _util.OPS.showText, _util.OPS.endText], null, /* @__PURE__ */ __name(function iterateShowTextGroup(context, i) {
                const fnArray = context.fnArray, argsArray = context.argsArray;
                const iFirstSave = context.iCurr - 4;
                const pos = (i - iFirstSave) % 5;
                switch (pos) {
                  case 0:
                    return fnArray[i] === _util.OPS.beginText;
                  case 1:
                    return fnArray[i] === _util.OPS.setFont;
                  case 2:
                    return fnArray[i] === _util.OPS.setTextMatrix;
                  case 3:
                    if (fnArray[i] !== _util.OPS.showText) {
                      return false;
                    }
                    const iFirstSetFont = context.iCurr - 3;
                    const firstSetFontArg0 = argsArray[iFirstSetFont][0];
                    const firstSetFontArg1 = argsArray[iFirstSetFont][1];
                    if (argsArray[i][0] !== firstSetFontArg0 || argsArray[i][1] !== firstSetFontArg1) {
                      return false;
                    }
                    return true;
                  case 4:
                    return fnArray[i] === _util.OPS.endText;
                }
                throw new Error(`iterateShowTextGroup - invalid pos: ${pos}`);
              }, "iterateShowTextGroup"), function(context, i) {
                const MIN_CHARS_IN_BLOCK = 3;
                const MAX_CHARS_IN_BLOCK = 1e3;
                const fnArray = context.fnArray, argsArray = context.argsArray;
                const curr = context.iCurr;
                const iFirstBeginText = curr - 4;
                const iFirstSetFont = curr - 3;
                const iFirstSetTextMatrix = curr - 2;
                const iFirstShowText = curr - 1;
                const iFirstEndText = curr;
                const firstSetFontArg0 = argsArray[iFirstSetFont][0];
                const firstSetFontArg1 = argsArray[iFirstSetFont][1];
                let count = Math.min(Math.floor((i - iFirstBeginText) / 5), MAX_CHARS_IN_BLOCK);
                if (count < MIN_CHARS_IN_BLOCK) {
                  return i - (i - iFirstBeginText) % 5;
                }
                let iFirst = iFirstBeginText;
                if (iFirstBeginText >= 4 && fnArray[iFirstBeginText - 4] === fnArray[iFirstSetFont] && fnArray[iFirstBeginText - 3] === fnArray[iFirstSetTextMatrix] && fnArray[iFirstBeginText - 2] === fnArray[iFirstShowText] && fnArray[iFirstBeginText - 1] === fnArray[iFirstEndText] && argsArray[iFirstBeginText - 4][0] === firstSetFontArg0 && argsArray[iFirstBeginText - 4][1] === firstSetFontArg1) {
                  count++;
                  iFirst -= 5;
                }
                let iEndText = iFirst + 4;
                for (let q = 1; q < count; q++) {
                  fnArray.splice(iEndText, 3);
                  argsArray.splice(iEndText, 3);
                  iEndText += 2;
                }
                return iEndText + 1;
              });
              const _NullOptimizer = class _NullOptimizer {
                constructor(queue) {
                  this.queue = queue;
                }
                _optimize() {
                }
                push(fn, args) {
                  this.queue.fnArray.push(fn);
                  this.queue.argsArray.push(args);
                  this._optimize();
                }
                flush() {
                }
                reset() {
                }
              };
              __name(_NullOptimizer, "NullOptimizer");
              let NullOptimizer = _NullOptimizer;
              const _QueueOptimizer = class _QueueOptimizer extends NullOptimizer {
                constructor(queue) {
                  super(queue);
                  this.state = null;
                  this.context = {
                    iCurr: 0,
                    fnArray: queue.fnArray,
                    argsArray: queue.argsArray
                  };
                  this.match = null;
                  this.lastProcessed = 0;
                }
                _optimize() {
                  const fnArray = this.queue.fnArray;
                  let i = this.lastProcessed, ii = fnArray.length;
                  let state = this.state;
                  let match = this.match;
                  if (!state && !match && i + 1 === ii && !InitialState[fnArray[i]]) {
                    this.lastProcessed = ii;
                    return;
                  }
                  const context = this.context;
                  while (i < ii) {
                    if (match) {
                      const iterate = (0, match.iterateFn)(context, i);
                      if (iterate) {
                        i++;
                        continue;
                      }
                      i = (0, match.processFn)(context, i + 1);
                      ii = fnArray.length;
                      match = null;
                      state = null;
                      if (i >= ii) {
                        break;
                      }
                    }
                    state = (state || InitialState)[fnArray[i]];
                    if (!state || Array.isArray(state)) {
                      i++;
                      continue;
                    }
                    context.iCurr = i;
                    i++;
                    if (state.checkFn && !(0, state.checkFn)(context)) {
                      state = null;
                      continue;
                    }
                    match = state;
                    state = null;
                  }
                  this.state = state;
                  this.match = match;
                  this.lastProcessed = i;
                }
                flush() {
                  while (this.match) {
                    const length = this.queue.fnArray.length;
                    this.lastProcessed = (0, this.match.processFn)(this.context, length);
                    this.match = null;
                    this.state = null;
                    this._optimize();
                  }
                }
                reset() {
                  this.state = null;
                  this.match = null;
                  this.lastProcessed = 0;
                }
              };
              __name(_QueueOptimizer, "QueueOptimizer");
              let QueueOptimizer = _QueueOptimizer;
              const _OperatorList = class _OperatorList {
                static get CHUNK_SIZE() {
                  return (0, _util.shadow)(this, "CHUNK_SIZE", 1e3);
                }
                static get CHUNK_SIZE_ABOUT() {
                  return (0, _util.shadow)(this, "CHUNK_SIZE_ABOUT", this.CHUNK_SIZE - 5);
                }
                constructor() {
                  let intent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                  let streamSink = arguments.length > 1 ? arguments[1] : void 0;
                  this._streamSink = streamSink;
                  this.fnArray = [];
                  this.argsArray = [];
                  if (streamSink && !(intent & _util.RenderingIntentFlag.OPLIST)) {
                    this.optimizer = new QueueOptimizer(this);
                  } else {
                    this.optimizer = new NullOptimizer(this);
                  }
                  this.dependencies = /* @__PURE__ */ new Set();
                  this._totalLength = 0;
                  this.weight = 0;
                  this._resolved = streamSink ? null : Promise.resolve();
                }
                get length() {
                  return this.argsArray.length;
                }
                get ready() {
                  return this._resolved || this._streamSink.ready;
                }
                get totalLength() {
                  return this._totalLength + this.length;
                }
                addOp(fn, args) {
                  this.optimizer.push(fn, args);
                  this.weight++;
                  if (this._streamSink) {
                    if (this.weight >= _OperatorList.CHUNK_SIZE) {
                      this.flush();
                    } else if (this.weight >= _OperatorList.CHUNK_SIZE_ABOUT && (fn === _util.OPS.restore || fn === _util.OPS.endText)) {
                      this.flush();
                    }
                  }
                }
                addImageOps(fn, args, optionalContent) {
                  if (optionalContent !== void 0) {
                    this.addOp(_util.OPS.beginMarkedContentProps, ["OC", optionalContent]);
                  }
                  this.addOp(fn, args);
                  if (optionalContent !== void 0) {
                    this.addOp(_util.OPS.endMarkedContent, []);
                  }
                }
                addDependency(dependency) {
                  if (this.dependencies.has(dependency)) {
                    return;
                  }
                  this.dependencies.add(dependency);
                  this.addOp(_util.OPS.dependency, [dependency]);
                }
                addDependencies(dependencies) {
                  for (const dependency of dependencies) {
                    this.addDependency(dependency);
                  }
                }
                addOpList(opList) {
                  if (!(opList instanceof _OperatorList)) {
                    (0, _util.warn)('addOpList - ignoring invalid "opList" parameter.');
                    return;
                  }
                  for (const dependency of opList.dependencies) {
                    this.dependencies.add(dependency);
                  }
                  for (let i = 0, ii = opList.length; i < ii; i++) {
                    this.addOp(opList.fnArray[i], opList.argsArray[i]);
                  }
                }
                getIR() {
                  return {
                    fnArray: this.fnArray,
                    argsArray: this.argsArray,
                    length: this.length
                  };
                }
                get _transfers() {
                  const transfers = [];
                  const {
                    fnArray,
                    argsArray,
                    length
                  } = this;
                  for (let i = 0; i < length; i++) {
                    switch (fnArray[i]) {
                      case _util.OPS.paintInlineImageXObject:
                      case _util.OPS.paintInlineImageXObjectGroup:
                      case _util.OPS.paintImageMaskXObject:
                        const arg = argsArray[i][0];
                        if (!arg.cached && arg.data && arg.data.buffer instanceof ArrayBuffer) {
                          transfers.push(arg.data.buffer);
                        }
                        break;
                    }
                  }
                  return transfers;
                }
                flush() {
                  let lastChunk = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  let separateAnnots = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                  this.optimizer.flush();
                  const length = this.length;
                  this._totalLength += length;
                  this._streamSink.enqueue({
                    fnArray: this.fnArray,
                    argsArray: this.argsArray,
                    lastChunk,
                    separateAnnots,
                    length
                  }, 1, this._transfers);
                  this.dependencies.clear();
                  this.fnArray.length = 0;
                  this.argsArray.length = 0;
                  this.weight = 0;
                  this.optimizer.reset();
                }
              };
              __name(_OperatorList, "OperatorList");
              let OperatorList = _OperatorList;
              exports2.OperatorList = OperatorList;
            },
            /* 188 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFImage = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _image_utils = __w_pdfjs_require__2(189);
              var _base_stream = __w_pdfjs_require__2(132);
              var _colorspace = __w_pdfjs_require__2(139);
              var _decode_stream = __w_pdfjs_require__2(144);
              var _jpeg_stream = __w_pdfjs_require__2(152);
              var _jpx = __w_pdfjs_require__2(155);
              var _primitives = __w_pdfjs_require__2(130);
              function decodeAndClamp(value, addend, coefficient, max) {
                value = addend + value * coefficient;
                if (value < 0) {
                  value = 0;
                } else if (value > max) {
                  value = max;
                }
                return value;
              }
              __name(decodeAndClamp, "decodeAndClamp");
              function resizeImageMask(src, bpc, w1, h1, w2, h2) {
                const length = w2 * h2;
                let dest;
                if (bpc <= 8) {
                  dest = new Uint8Array(length);
                } else if (bpc <= 16) {
                  dest = new Uint16Array(length);
                } else {
                  dest = new Uint32Array(length);
                }
                const xRatio = w1 / w2;
                const yRatio = h1 / h2;
                let i, j, py, newIndex = 0, oldIndex;
                const xScaled = new Uint16Array(w2);
                const w1Scanline = w1;
                for (i = 0; i < w2; i++) {
                  xScaled[i] = Math.floor(i * xRatio);
                }
                for (i = 0; i < h2; i++) {
                  py = Math.floor(i * yRatio) * w1Scanline;
                  for (j = 0; j < w2; j++) {
                    oldIndex = py + xScaled[j];
                    dest[newIndex++] = src[oldIndex];
                  }
                }
                return dest;
              }
              __name(resizeImageMask, "resizeImageMask");
              const _PDFImage = class _PDFImage {
                constructor(_ref) {
                  let {
                    xref,
                    res,
                    image,
                    isInline = false,
                    smask = null,
                    mask = null,
                    isMask = false,
                    pdfFunctionFactory,
                    localColorSpaceCache
                  } = _ref;
                  this.image = image;
                  const dict = image.dict;
                  const filter = dict.get("F", "Filter");
                  let filterName;
                  if (filter instanceof _primitives.Name) {
                    filterName = filter.name;
                  } else if (Array.isArray(filter)) {
                    const filterZero = xref.fetchIfRef(filter[0]);
                    if (filterZero instanceof _primitives.Name) {
                      filterName = filterZero.name;
                    }
                  }
                  switch (filterName) {
                    case "JPXDecode":
                      const jpxImage = new _jpx.JpxImage();
                      jpxImage.parseImageProperties(image.stream);
                      image.stream.reset();
                      image.width = jpxImage.width;
                      image.height = jpxImage.height;
                      image.bitsPerComponent = jpxImage.bitsPerComponent;
                      image.numComps = jpxImage.componentsCount;
                      break;
                    case "JBIG2Decode":
                      image.bitsPerComponent = 1;
                      image.numComps = 1;
                      break;
                  }
                  let width = dict.get("W", "Width");
                  let height = dict.get("H", "Height");
                  if (Number.isInteger(image.width) && image.width > 0 && Number.isInteger(image.height) && image.height > 0 && (image.width !== width || image.height !== height)) {
                    (0, _util.warn)("PDFImage - using the Width/Height of the image data, rather than the image dictionary.");
                    width = image.width;
                    height = image.height;
                  }
                  if (width < 1 || height < 1) {
                    throw new _util.FormatError(`Invalid image width: ${width} or height: ${height}`);
                  }
                  this.width = width;
                  this.height = height;
                  this.interpolate = dict.get("I", "Interpolate");
                  this.imageMask = dict.get("IM", "ImageMask") || false;
                  this.matte = dict.get("Matte") || false;
                  let bitsPerComponent = image.bitsPerComponent;
                  if (!bitsPerComponent) {
                    bitsPerComponent = dict.get("BPC", "BitsPerComponent");
                    if (!bitsPerComponent) {
                      if (this.imageMask) {
                        bitsPerComponent = 1;
                      } else {
                        throw new _util.FormatError(`Bits per component missing in image: ${this.imageMask}`);
                      }
                    }
                  }
                  this.bpc = bitsPerComponent;
                  if (!this.imageMask) {
                    let colorSpace = dict.getRaw("CS") || dict.getRaw("ColorSpace");
                    if (!colorSpace) {
                      (0, _util.info)("JPX images (which do not require color spaces)");
                      switch (image.numComps) {
                        case 1:
                          colorSpace = _primitives.Name.get("DeviceGray");
                          break;
                        case 3:
                          colorSpace = _primitives.Name.get("DeviceRGB");
                          break;
                        case 4:
                          colorSpace = _primitives.Name.get("DeviceCMYK");
                          break;
                        default:
                          throw new Error(`JPX images with ${image.numComps} color components not supported.`);
                      }
                    }
                    this.colorSpace = _colorspace.ColorSpace.parse({
                      cs: colorSpace,
                      xref,
                      resources: isInline ? res : null,
                      pdfFunctionFactory,
                      localColorSpaceCache
                    });
                    this.numComps = this.colorSpace.numComps;
                  }
                  this.decode = dict.getArray("D", "Decode");
                  this.needsDecode = false;
                  if (this.decode && (this.colorSpace && !this.colorSpace.isDefaultDecode(this.decode, bitsPerComponent) || isMask && !_colorspace.ColorSpace.isDefaultDecode(this.decode, 1))) {
                    this.needsDecode = true;
                    const max = (1 << bitsPerComponent) - 1;
                    this.decodeCoefficients = [];
                    this.decodeAddends = [];
                    const isIndexed = this.colorSpace && this.colorSpace.name === "Indexed";
                    for (let i = 0, j = 0; i < this.decode.length; i += 2, ++j) {
                      const dmin = this.decode[i];
                      const dmax = this.decode[i + 1];
                      this.decodeCoefficients[j] = isIndexed ? (dmax - dmin) / max : dmax - dmin;
                      this.decodeAddends[j] = isIndexed ? dmin : max * dmin;
                    }
                  }
                  if (smask) {
                    this.smask = new _PDFImage({
                      xref,
                      res,
                      image: smask,
                      isInline,
                      pdfFunctionFactory,
                      localColorSpaceCache
                    });
                  } else if (mask) {
                    if (mask instanceof _base_stream.BaseStream) {
                      const maskDict = mask.dict, imageMask = maskDict.get("IM", "ImageMask");
                      if (!imageMask) {
                        (0, _util.warn)("Ignoring /Mask in image without /ImageMask.");
                      } else {
                        this.mask = new _PDFImage({
                          xref,
                          res,
                          image: mask,
                          isInline,
                          isMask: true,
                          pdfFunctionFactory,
                          localColorSpaceCache
                        });
                      }
                    } else {
                      this.mask = mask;
                    }
                  }
                }
                static async buildImage(_ref2) {
                  let {
                    xref,
                    res,
                    image,
                    isInline = false,
                    pdfFunctionFactory,
                    localColorSpaceCache
                  } = _ref2;
                  const imageData = image;
                  let smaskData = null;
                  let maskData = null;
                  const smask = image.dict.get("SMask");
                  const mask = image.dict.get("Mask");
                  if (smask) {
                    if (smask instanceof _base_stream.BaseStream) {
                      smaskData = smask;
                    } else {
                      (0, _util.warn)("Unsupported /SMask format.");
                    }
                  } else if (mask) {
                    if (mask instanceof _base_stream.BaseStream || Array.isArray(mask)) {
                      maskData = mask;
                    } else {
                      (0, _util.warn)("Unsupported /Mask format.");
                    }
                  }
                  return new _PDFImage({
                    xref,
                    res,
                    image: imageData,
                    isInline,
                    smask: smaskData,
                    mask: maskData,
                    pdfFunctionFactory,
                    localColorSpaceCache
                  });
                }
                static createRawMask(_ref3) {
                  let {
                    imgArray,
                    width,
                    height,
                    imageIsFromDecodeStream,
                    inverseDecode,
                    interpolate
                  } = _ref3;
                  const computedLength = (width + 7 >> 3) * height;
                  const actualLength = imgArray.byteLength;
                  const haveFullData = computedLength === actualLength;
                  let data, i;
                  if (imageIsFromDecodeStream && (!inverseDecode || haveFullData)) {
                    data = imgArray;
                  } else if (!inverseDecode) {
                    data = new Uint8Array(imgArray);
                  } else {
                    data = new Uint8Array(computedLength);
                    data.set(imgArray);
                    data.fill(255, actualLength);
                  }
                  if (inverseDecode) {
                    for (i = 0; i < actualLength; i++) {
                      data[i] ^= 255;
                    }
                  }
                  return {
                    data,
                    width,
                    height,
                    interpolate
                  };
                }
                static createMask(_ref4) {
                  let {
                    imgArray,
                    width,
                    height,
                    imageIsFromDecodeStream,
                    inverseDecode,
                    interpolate
                  } = _ref4;
                  const isSingleOpaquePixel = width === 1 && height === 1 && inverseDecode === (imgArray.length === 0 || !!(imgArray[0] & 128));
                  if (isSingleOpaquePixel) {
                    return {
                      isSingleOpaquePixel
                    };
                  }
                  if (_util.FeatureTest.isOffscreenCanvasSupported) {
                    const canvas = new OffscreenCanvas(width, height);
                    const ctx = canvas.getContext("2d");
                    const imgData = ctx.createImageData(width, height);
                    (0, _image_utils.applyMaskImageData)({
                      src: imgArray,
                      dest: imgData.data,
                      width,
                      height,
                      inverseDecode
                    });
                    ctx.putImageData(imgData, 0, 0);
                    const bitmap = canvas.transferToImageBitmap();
                    return {
                      data: null,
                      width,
                      height,
                      interpolate,
                      bitmap
                    };
                  }
                  return this.createRawMask({
                    imgArray,
                    width,
                    height,
                    inverseDecode,
                    imageIsFromDecodeStream,
                    interpolate
                  });
                }
                get drawWidth() {
                  return Math.max(this.width, this.smask && this.smask.width || 0, this.mask && this.mask.width || 0);
                }
                get drawHeight() {
                  return Math.max(this.height, this.smask && this.smask.height || 0, this.mask && this.mask.height || 0);
                }
                decodeBuffer(buffer) {
                  const bpc = this.bpc;
                  const numComps = this.numComps;
                  const decodeAddends = this.decodeAddends;
                  const decodeCoefficients = this.decodeCoefficients;
                  const max = (1 << bpc) - 1;
                  let i, ii;
                  if (bpc === 1) {
                    for (i = 0, ii = buffer.length; i < ii; i++) {
                      buffer[i] = +!buffer[i];
                    }
                    return;
                  }
                  let index = 0;
                  for (i = 0, ii = this.width * this.height; i < ii; i++) {
                    for (let j = 0; j < numComps; j++) {
                      buffer[index] = decodeAndClamp(buffer[index], decodeAddends[j], decodeCoefficients[j], max);
                      index++;
                    }
                  }
                }
                getComponents(buffer) {
                  const bpc = this.bpc;
                  if (bpc === 8) {
                    return buffer;
                  }
                  const width = this.width;
                  const height = this.height;
                  const numComps = this.numComps;
                  const length = width * height * numComps;
                  let bufferPos = 0;
                  let output;
                  if (bpc <= 8) {
                    output = new Uint8Array(length);
                  } else if (bpc <= 16) {
                    output = new Uint16Array(length);
                  } else {
                    output = new Uint32Array(length);
                  }
                  const rowComps = width * numComps;
                  const max = (1 << bpc) - 1;
                  let i = 0, ii, buf;
                  if (bpc === 1) {
                    let mask, loop1End, loop2End;
                    for (let j = 0; j < height; j++) {
                      loop1End = i + (rowComps & ~7);
                      loop2End = i + rowComps;
                      while (i < loop1End) {
                        buf = buffer[bufferPos++];
                        output[i] = buf >> 7 & 1;
                        output[i + 1] = buf >> 6 & 1;
                        output[i + 2] = buf >> 5 & 1;
                        output[i + 3] = buf >> 4 & 1;
                        output[i + 4] = buf >> 3 & 1;
                        output[i + 5] = buf >> 2 & 1;
                        output[i + 6] = buf >> 1 & 1;
                        output[i + 7] = buf & 1;
                        i += 8;
                      }
                      if (i < loop2End) {
                        buf = buffer[bufferPos++];
                        mask = 128;
                        while (i < loop2End) {
                          output[i++] = +!!(buf & mask);
                          mask >>= 1;
                        }
                      }
                    }
                  } else {
                    let bits = 0;
                    buf = 0;
                    for (i = 0, ii = length; i < ii; ++i) {
                      if (i % rowComps === 0) {
                        buf = 0;
                        bits = 0;
                      }
                      while (bits < bpc) {
                        buf = buf << 8 | buffer[bufferPos++];
                        bits += 8;
                      }
                      const remainingBits = bits - bpc;
                      let value = buf >> remainingBits;
                      if (value < 0) {
                        value = 0;
                      } else if (value > max) {
                        value = max;
                      }
                      output[i] = value;
                      buf &= (1 << remainingBits) - 1;
                      bits = remainingBits;
                    }
                  }
                  return output;
                }
                fillOpacity(rgbaBuf, width, height, actualHeight, image) {
                  const smask = this.smask;
                  const mask = this.mask;
                  let alphaBuf, sw, sh, i, ii, j;
                  if (smask) {
                    sw = smask.width;
                    sh = smask.height;
                    alphaBuf = new Uint8ClampedArray(sw * sh);
                    smask.fillGrayBuffer(alphaBuf);
                    if (sw !== width || sh !== height) {
                      alphaBuf = resizeImageMask(alphaBuf, smask.bpc, sw, sh, width, height);
                    }
                  } else if (mask) {
                    if (mask instanceof _PDFImage) {
                      sw = mask.width;
                      sh = mask.height;
                      alphaBuf = new Uint8ClampedArray(sw * sh);
                      mask.numComps = 1;
                      mask.fillGrayBuffer(alphaBuf);
                      for (i = 0, ii = sw * sh; i < ii; ++i) {
                        alphaBuf[i] = 255 - alphaBuf[i];
                      }
                      if (sw !== width || sh !== height) {
                        alphaBuf = resizeImageMask(alphaBuf, mask.bpc, sw, sh, width, height);
                      }
                    } else if (Array.isArray(mask)) {
                      alphaBuf = new Uint8ClampedArray(width * height);
                      const numComps = this.numComps;
                      for (i = 0, ii = width * height; i < ii; ++i) {
                        let opacity = 0;
                        const imageOffset = i * numComps;
                        for (j = 0; j < numComps; ++j) {
                          const color = image[imageOffset + j];
                          const maskOffset = j * 2;
                          if (color < mask[maskOffset] || color > mask[maskOffset + 1]) {
                            opacity = 255;
                            break;
                          }
                        }
                        alphaBuf[i] = opacity;
                      }
                    } else {
                      throw new _util.FormatError("Unknown mask format.");
                    }
                  }
                  if (alphaBuf) {
                    for (i = 0, j = 3, ii = width * actualHeight; i < ii; ++i, j += 4) {
                      rgbaBuf[j] = alphaBuf[i];
                    }
                  } else {
                    for (i = 0, j = 3, ii = width * actualHeight; i < ii; ++i, j += 4) {
                      rgbaBuf[j] = 255;
                    }
                  }
                }
                undoPreblend(buffer, width, height) {
                  const matte = this.smask && this.smask.matte;
                  if (!matte) {
                    return;
                  }
                  const matteRgb = this.colorSpace.getRgb(matte, 0);
                  const matteR = matteRgb[0];
                  const matteG = matteRgb[1];
                  const matteB = matteRgb[2];
                  const length = width * height * 4;
                  for (let i = 0; i < length; i += 4) {
                    const alpha = buffer[i + 3];
                    if (alpha === 0) {
                      buffer[i] = 255;
                      buffer[i + 1] = 255;
                      buffer[i + 2] = 255;
                      continue;
                    }
                    const k = 255 / alpha;
                    buffer[i] = (buffer[i] - matteR) * k + matteR;
                    buffer[i + 1] = (buffer[i + 1] - matteG) * k + matteG;
                    buffer[i + 2] = (buffer[i + 2] - matteB) * k + matteB;
                  }
                }
                createImageData() {
                  let forceRGBA = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  const drawWidth = this.drawWidth;
                  const drawHeight = this.drawHeight;
                  const imgData = {
                    width: drawWidth,
                    height: drawHeight,
                    interpolate: this.interpolate,
                    kind: 0,
                    data: null
                  };
                  const numComps = this.numComps;
                  const originalWidth = this.width;
                  const originalHeight = this.height;
                  const bpc = this.bpc;
                  const rowBytes = originalWidth * numComps * bpc + 7 >> 3;
                  if (!forceRGBA) {
                    let kind;
                    if (this.colorSpace.name === "DeviceGray" && bpc === 1) {
                      kind = _util.ImageKind.GRAYSCALE_1BPP;
                    } else if (this.colorSpace.name === "DeviceRGB" && bpc === 8 && !this.needsDecode) {
                      kind = _util.ImageKind.RGB_24BPP;
                    }
                    if (kind && !this.smask && !this.mask && drawWidth === originalWidth && drawHeight === originalHeight) {
                      imgData.kind = kind;
                      imgData.data = this.getImageBytes(originalHeight * rowBytes, {});
                      if (this.needsDecode) {
                        (0, _util.assert)(kind === _util.ImageKind.GRAYSCALE_1BPP, "PDFImage.createImageData: The image must be grayscale.");
                        const buffer = imgData.data;
                        for (let i = 0, ii = buffer.length; i < ii; i++) {
                          buffer[i] ^= 255;
                        }
                      }
                      return imgData;
                    }
                    if (this.image instanceof _jpeg_stream.JpegStream && !this.smask && !this.mask) {
                      let imageLength = originalHeight * rowBytes;
                      switch (this.colorSpace.name) {
                        case "DeviceGray":
                          imageLength *= 3;
                        case "DeviceRGB":
                        case "DeviceCMYK":
                          imgData.kind = _util.ImageKind.RGB_24BPP;
                          imgData.data = this.getImageBytes(imageLength, {
                            drawWidth,
                            drawHeight,
                            forceRGB: true
                          });
                          return imgData;
                      }
                    }
                  }
                  const imgArray = this.getImageBytes(originalHeight * rowBytes, {
                    internal: true
                  });
                  const actualHeight = 0 | imgArray.length / rowBytes * drawHeight / originalHeight;
                  const comps = this.getComponents(imgArray);
                  let alpha01, maybeUndoPreblend;
                  if (!forceRGBA && !this.smask && !this.mask) {
                    imgData.kind = _util.ImageKind.RGB_24BPP;
                    imgData.data = new Uint8ClampedArray(drawWidth * drawHeight * 3);
                    alpha01 = 0;
                    maybeUndoPreblend = false;
                  } else {
                    imgData.kind = _util.ImageKind.RGBA_32BPP;
                    imgData.data = new Uint8ClampedArray(drawWidth * drawHeight * 4);
                    alpha01 = 1;
                    maybeUndoPreblend = true;
                    this.fillOpacity(imgData.data, drawWidth, drawHeight, actualHeight, comps);
                  }
                  if (this.needsDecode) {
                    this.decodeBuffer(comps);
                  }
                  this.colorSpace.fillRgb(imgData.data, originalWidth, originalHeight, drawWidth, drawHeight, actualHeight, bpc, comps, alpha01);
                  if (maybeUndoPreblend) {
                    this.undoPreblend(imgData.data, drawWidth, actualHeight);
                  }
                  return imgData;
                }
                fillGrayBuffer(buffer) {
                  const numComps = this.numComps;
                  if (numComps !== 1) {
                    throw new _util.FormatError(`Reading gray scale from a color image: ${numComps}`);
                  }
                  const width = this.width;
                  const height = this.height;
                  const bpc = this.bpc;
                  const rowBytes = width * numComps * bpc + 7 >> 3;
                  const imgArray = this.getImageBytes(height * rowBytes, {
                    internal: true
                  });
                  const comps = this.getComponents(imgArray);
                  let i, length;
                  if (bpc === 1) {
                    length = width * height;
                    if (this.needsDecode) {
                      for (i = 0; i < length; ++i) {
                        buffer[i] = comps[i] - 1 & 255;
                      }
                    } else {
                      for (i = 0; i < length; ++i) {
                        buffer[i] = -comps[i] & 255;
                      }
                    }
                    return;
                  }
                  if (this.needsDecode) {
                    this.decodeBuffer(comps);
                  }
                  length = width * height;
                  const scale = 255 / ((1 << bpc) - 1);
                  for (i = 0; i < length; ++i) {
                    buffer[i] = scale * comps[i];
                  }
                }
                getImageBytes(length, _ref5) {
                  let {
                    drawWidth,
                    drawHeight,
                    forceRGB = false,
                    internal = false
                  } = _ref5;
                  this.image.reset();
                  this.image.drawWidth = drawWidth || this.width;
                  this.image.drawHeight = drawHeight || this.height;
                  this.image.forceRGB = !!forceRGB;
                  const imageBytes = this.image.getBytes(length);
                  if (internal || this.image instanceof _decode_stream.DecodeStream) {
                    return imageBytes;
                  }
                  (0, _util.assert)(imageBytes instanceof Uint8Array, 'PDFImage.getImageBytes: Unsupported "imageBytes" type.');
                  return new Uint8Array(imageBytes);
                }
              };
              __name(_PDFImage, "PDFImage");
              let PDFImage = _PDFImage;
              exports2.PDFImage = PDFImage;
            },
            /* 189 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.applyMaskImageData = applyMaskImageData;
              var _util = __w_pdfjs_require__2(2);
              function applyMaskImageData(_ref) {
                let {
                  src,
                  srcPos = 0,
                  dest,
                  destPos = 0,
                  width,
                  height,
                  inverseDecode = false
                } = _ref;
                const opaque = _util.FeatureTest.isLittleEndian ? 4278190080 : 255;
                const [zeroMapping, oneMapping] = !inverseDecode ? [opaque, 0] : [0, opaque];
                const widthInSource = width >> 3;
                const widthRemainder = width & 7;
                const srcLength = src.length;
                dest = new Uint32Array(dest.buffer);
                for (let i = 0; i < height; i++) {
                  for (const max = srcPos + widthInSource; srcPos < max; srcPos++) {
                    const elem2 = srcPos < srcLength ? src[srcPos] : 255;
                    dest[destPos++] = elem2 & 128 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 64 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 32 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 16 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 8 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 4 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 2 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 1 ? oneMapping : zeroMapping;
                  }
                  if (widthRemainder === 0) {
                    continue;
                  }
                  const elem = srcPos < srcLength ? src[srcPos++] : 255;
                  for (let j = 0; j < widthRemainder; j++) {
                    dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;
                  }
                }
                return {
                  srcPos,
                  destPos
                };
              }
              __name(applyMaskImageData, "applyMaskImageData");
            },
            /* 190 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.incrementalUpdate = incrementalUpdate;
              exports2.writeDict = writeDict;
              exports2.writeObject = writeObject;
              var _util = __w_pdfjs_require__2(2);
              var _primitives = __w_pdfjs_require__2(130);
              var _core_utils = __w_pdfjs_require__2(131);
              var _xml_parser = __w_pdfjs_require__2(191);
              var _base_stream = __w_pdfjs_require__2(132);
              var _crypto = __w_pdfjs_require__2(192);
              function writeObject(ref, obj, buffer, transform) {
                buffer.push(`${ref.num} ${ref.gen} obj
`);
                if (obj instanceof _primitives.Dict) {
                  writeDict(obj, buffer, transform);
                } else if (obj instanceof _base_stream.BaseStream) {
                  writeStream(obj, buffer, transform);
                }
                buffer.push("\nendobj\n");
              }
              __name(writeObject, "writeObject");
              function writeDict(dict, buffer, transform) {
                buffer.push("<<");
                for (const key of dict.getKeys()) {
                  buffer.push(` /${(0, _core_utils.escapePDFName)(key)} `);
                  writeValue(dict.getRaw(key), buffer, transform);
                }
                buffer.push(">>");
              }
              __name(writeDict, "writeDict");
              function writeStream(stream, buffer, transform) {
                writeDict(stream.dict, buffer, transform);
                buffer.push(" stream\n");
                let string = stream.getString();
                if (transform !== null) {
                  string = transform.encryptString(string);
                }
                buffer.push(string, "\nendstream\n");
              }
              __name(writeStream, "writeStream");
              function writeArray(array, buffer, transform) {
                buffer.push("[");
                let first = true;
                for (const val of array) {
                  if (!first) {
                    buffer.push(" ");
                  } else {
                    first = false;
                  }
                  writeValue(val, buffer, transform);
                }
                buffer.push("]");
              }
              __name(writeArray, "writeArray");
              function writeValue(value, buffer, transform) {
                if (value instanceof _primitives.Name) {
                  buffer.push(`/${(0, _core_utils.escapePDFName)(value.name)}`);
                } else if (value instanceof _primitives.Ref) {
                  buffer.push(`${value.num} ${value.gen} R`);
                } else if (Array.isArray(value)) {
                  writeArray(value, buffer, transform);
                } else if (typeof value === "string") {
                  if (transform !== null) {
                    value = transform.encryptString(value);
                  }
                  buffer.push(`(${(0, _util.escapeString)(value)})`);
                } else if (typeof value === "number") {
                  buffer.push((0, _core_utils.numberToString)(value));
                } else if (typeof value === "boolean") {
                  buffer.push(value.toString());
                } else if (value instanceof _primitives.Dict) {
                  writeDict(value, buffer, transform);
                } else if (value instanceof _base_stream.BaseStream) {
                  writeStream(value, buffer, transform);
                } else if (value === null) {
                  buffer.push("null");
                } else {
                  (0, _util.warn)(`Unhandled value in writer: ${typeof value}, please file a bug.`);
                }
              }
              __name(writeValue, "writeValue");
              function writeInt(number, size, offset, buffer) {
                for (let i = size + offset - 1; i > offset - 1; i--) {
                  buffer[i] = number & 255;
                  number >>= 8;
                }
                return offset + size;
              }
              __name(writeInt, "writeInt");
              function writeString(string, offset, buffer) {
                for (let i = 0, len = string.length; i < len; i++) {
                  buffer[offset + i] = string.charCodeAt(i) & 255;
                }
              }
              __name(writeString, "writeString");
              function computeMD5(filesize, xrefInfo) {
                const time = Math.floor(Date.now() / 1e3);
                const filename = xrefInfo.filename || "";
                const md5Buffer = [time.toString(), filename, filesize.toString()];
                let md5BufferLen = md5Buffer.reduce((a, str) => a + str.length, 0);
                for (const value of Object.values(xrefInfo.info)) {
                  md5Buffer.push(value);
                  md5BufferLen += value.length;
                }
                const array = new Uint8Array(md5BufferLen);
                let offset = 0;
                for (const str of md5Buffer) {
                  writeString(str, offset, array);
                  offset += str.length;
                }
                return (0, _util.bytesToString)((0, _crypto.calculateMD5)(array));
              }
              __name(computeMD5, "computeMD5");
              function writeXFADataForAcroform(str, newRefs) {
                const xml = new _xml_parser.SimpleXMLParser({
                  hasAttributes: true
                }).parseFromString(str);
                for (const {
                  xfa
                } of newRefs) {
                  if (!xfa) {
                    continue;
                  }
                  const {
                    path,
                    value
                  } = xfa;
                  if (!path) {
                    continue;
                  }
                  const node = xml.documentElement.searchNode((0, _core_utils.parseXFAPath)(path), 0);
                  if (node) {
                    if (Array.isArray(value)) {
                      node.childNodes = value.map((val) => new _xml_parser.SimpleDOMNode("value", val));
                    } else {
                      node.childNodes = [new _xml_parser.SimpleDOMNode("#text", value)];
                    }
                  } else {
                    (0, _util.warn)(`Node not found for path: ${path}`);
                  }
                }
                const buffer = [];
                xml.documentElement.dump(buffer);
                return buffer.join("");
              }
              __name(writeXFADataForAcroform, "writeXFADataForAcroform");
              function updateXFA(_ref) {
                let {
                  xfaData,
                  xfaDatasetsRef,
                  hasXfaDatasetsEntry,
                  acroFormRef,
                  acroForm,
                  newRefs,
                  xref,
                  xrefInfo
                } = _ref;
                if (xref === null) {
                  return;
                }
                if (!hasXfaDatasetsEntry) {
                  if (!acroFormRef) {
                    (0, _util.warn)("XFA - Cannot save it");
                    return;
                  }
                  const oldXfa = acroForm.get("XFA");
                  const newXfa = oldXfa.slice();
                  newXfa.splice(2, 0, "datasets");
                  newXfa.splice(3, 0, xfaDatasetsRef);
                  acroForm.set("XFA", newXfa);
                  const encrypt2 = xref.encrypt;
                  let transform = null;
                  if (encrypt2) {
                    transform = encrypt2.createCipherTransform(acroFormRef.num, acroFormRef.gen);
                  }
                  const buffer = [`${acroFormRef.num} ${acroFormRef.gen} obj
`];
                  writeDict(acroForm, buffer, transform);
                  buffer.push("\n");
                  acroForm.set("XFA", oldXfa);
                  newRefs.push({
                    ref: acroFormRef,
                    data: buffer.join("")
                  });
                }
                if (xfaData === null) {
                  const datasets = xref.fetchIfRef(xfaDatasetsRef);
                  xfaData = writeXFADataForAcroform(datasets.getString(), newRefs);
                }
                const encrypt = xref.encrypt;
                if (encrypt) {
                  const transform = encrypt.createCipherTransform(xfaDatasetsRef.num, xfaDatasetsRef.gen);
                  xfaData = transform.encryptString(xfaData);
                }
                const data = `${xfaDatasetsRef.num} ${xfaDatasetsRef.gen} obj
<< /Type /EmbeddedFile /Length ${xfaData.length}>>
stream
` + xfaData + "\nendstream\nendobj\n";
                newRefs.push({
                  ref: xfaDatasetsRef,
                  data
                });
              }
              __name(updateXFA, "updateXFA");
              function incrementalUpdate(_ref2) {
                let {
                  originalData,
                  xrefInfo,
                  newRefs,
                  xref = null,
                  hasXfa = false,
                  xfaDatasetsRef = null,
                  hasXfaDatasetsEntry = false,
                  acroFormRef = null,
                  acroForm = null,
                  xfaData = null
                } = _ref2;
                if (hasXfa) {
                  updateXFA({
                    xfaData,
                    xfaDatasetsRef,
                    hasXfaDatasetsEntry,
                    acroFormRef,
                    acroForm,
                    newRefs,
                    xref,
                    xrefInfo
                  });
                }
                const newXref = new _primitives.Dict(null);
                const refForXrefTable = xrefInfo.newRef;
                let buffer, baseOffset;
                const lastByte = originalData.at(-1);
                if (lastByte === 10 || lastByte === 13) {
                  buffer = [];
                  baseOffset = originalData.length;
                } else {
                  buffer = ["\n"];
                  baseOffset = originalData.length + 1;
                }
                newXref.set("Size", refForXrefTable.num + 1);
                newXref.set("Prev", xrefInfo.startXRef);
                newXref.set("Type", _primitives.Name.get("XRef"));
                if (xrefInfo.rootRef !== null) {
                  newXref.set("Root", xrefInfo.rootRef);
                }
                if (xrefInfo.infoRef !== null) {
                  newXref.set("Info", xrefInfo.infoRef);
                }
                if (xrefInfo.encryptRef !== null) {
                  newXref.set("Encrypt", xrefInfo.encryptRef);
                }
                newRefs.push({
                  ref: refForXrefTable,
                  data: ""
                });
                newRefs = newRefs.sort((a, b) => {
                  return a.ref.num - b.ref.num;
                });
                const xrefTableData = [[0, 1, 65535]];
                const indexes = [0, 1];
                let maxOffset = 0;
                for (const {
                  ref,
                  data
                } of newRefs) {
                  maxOffset = Math.max(maxOffset, baseOffset);
                  xrefTableData.push([1, baseOffset, Math.min(ref.gen, 65535)]);
                  baseOffset += data.length;
                  indexes.push(ref.num, 1);
                  buffer.push(data);
                }
                newXref.set("Index", indexes);
                if (Array.isArray(xrefInfo.fileIds) && xrefInfo.fileIds.length > 0) {
                  const md5 = computeMD5(baseOffset, xrefInfo);
                  newXref.set("ID", [xrefInfo.fileIds[0], md5]);
                }
                const offsetSize = Math.ceil(Math.log2(maxOffset) / 8);
                const sizes = [1, offsetSize, 2];
                const structSize = sizes[0] + sizes[1] + sizes[2];
                const tableLength = structSize * xrefTableData.length;
                newXref.set("W", sizes);
                newXref.set("Length", tableLength);
                buffer.push(`${refForXrefTable.num} ${refForXrefTable.gen} obj
`);
                writeDict(newXref, buffer, null);
                buffer.push(" stream\n");
                const bufferLen = buffer.reduce((a, str) => a + str.length, 0);
                const footer = `
endstream
endobj
startxref
${baseOffset}
%%EOF
`;
                const array = new Uint8Array(originalData.length + bufferLen + tableLength + footer.length);
                array.set(originalData);
                let offset = originalData.length;
                for (const str of buffer) {
                  writeString(str, offset, array);
                  offset += str.length;
                }
                for (const [type, objOffset, gen] of xrefTableData) {
                  offset = writeInt(type, sizes[0], offset, array);
                  offset = writeInt(objOffset, sizes[1], offset, array);
                  offset = writeInt(gen, sizes[2], offset, array);
                }
                writeString(footer, offset, array);
                return array;
              }
              __name(incrementalUpdate, "incrementalUpdate");
            },
            /* 191 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.XMLParserErrorCode = exports2.XMLParserBase = exports2.SimpleXMLParser = exports2.SimpleDOMNode = void 0;
              var _core_utils = __w_pdfjs_require__2(131);
              const XMLParserErrorCode = {
                NoError: 0,
                EndOfDocument: -1,
                UnterminatedCdat: -2,
                UnterminatedXmlDeclaration: -3,
                UnterminatedDoctypeDeclaration: -4,
                UnterminatedComment: -5,
                MalformedElement: -6,
                OutOfMemory: -7,
                UnterminatedAttributeValue: -8,
                UnterminatedElement: -9,
                ElementNeverBegun: -10
              };
              exports2.XMLParserErrorCode = XMLParserErrorCode;
              function isWhitespace(s, index) {
                const ch = s[index];
                return ch === " " || ch === "\n" || ch === "\r" || ch === "	";
              }
              __name(isWhitespace, "isWhitespace");
              function isWhitespaceString(s) {
                for (let i = 0, ii = s.length; i < ii; i++) {
                  if (!isWhitespace(s, i)) {
                    return false;
                  }
                }
                return true;
              }
              __name(isWhitespaceString, "isWhitespaceString");
              const _XMLParserBase = class _XMLParserBase {
                _resolveEntities(s) {
                  return s.replace(/&([^;]+);/g, (all, entity) => {
                    if (entity.substring(0, 2) === "#x") {
                      return String.fromCodePoint(parseInt(entity.substring(2), 16));
                    } else if (entity.substring(0, 1) === "#") {
                      return String.fromCodePoint(parseInt(entity.substring(1), 10));
                    }
                    switch (entity) {
                      case "lt":
                        return "<";
                      case "gt":
                        return ">";
                      case "amp":
                        return "&";
                      case "quot":
                        return '"';
                      case "apos":
                        return "'";
                    }
                    return this.onResolveEntity(entity);
                  });
                }
                _parseContent(s, start) {
                  const attributes = [];
                  let pos = start;
                  function skipWs() {
                    while (pos < s.length && isWhitespace(s, pos)) {
                      ++pos;
                    }
                  }
                  __name(skipWs, "skipWs");
                  while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== ">" && s[pos] !== "/") {
                    ++pos;
                  }
                  const name = s.substring(start, pos);
                  skipWs();
                  while (pos < s.length && s[pos] !== ">" && s[pos] !== "/" && s[pos] !== "?") {
                    skipWs();
                    let attrName = "", attrValue = "";
                    while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== "=") {
                      attrName += s[pos];
                      ++pos;
                    }
                    skipWs();
                    if (s[pos] !== "=") {
                      return null;
                    }
                    ++pos;
                    skipWs();
                    const attrEndChar = s[pos];
                    if (attrEndChar !== '"' && attrEndChar !== "'") {
                      return null;
                    }
                    const attrEndIndex = s.indexOf(attrEndChar, ++pos);
                    if (attrEndIndex < 0) {
                      return null;
                    }
                    attrValue = s.substring(pos, attrEndIndex);
                    attributes.push({
                      name: attrName,
                      value: this._resolveEntities(attrValue)
                    });
                    pos = attrEndIndex + 1;
                    skipWs();
                  }
                  return {
                    name,
                    attributes,
                    parsed: pos - start
                  };
                }
                _parseProcessingInstruction(s, start) {
                  let pos = start;
                  function skipWs() {
                    while (pos < s.length && isWhitespace(s, pos)) {
                      ++pos;
                    }
                  }
                  __name(skipWs, "skipWs");
                  while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== ">" && s[pos] !== "?" && s[pos] !== "/") {
                    ++pos;
                  }
                  const name = s.substring(start, pos);
                  skipWs();
                  const attrStart = pos;
                  while (pos < s.length && (s[pos] !== "?" || s[pos + 1] !== ">")) {
                    ++pos;
                  }
                  const value = s.substring(attrStart, pos);
                  return {
                    name,
                    value,
                    parsed: pos - start
                  };
                }
                parseXml(s) {
                  let i = 0;
                  while (i < s.length) {
                    const ch = s[i];
                    let j = i;
                    if (ch === "<") {
                      ++j;
                      const ch2 = s[j];
                      let q;
                      switch (ch2) {
                        case "/":
                          ++j;
                          q = s.indexOf(">", j);
                          if (q < 0) {
                            this.onError(XMLParserErrorCode.UnterminatedElement);
                            return;
                          }
                          this.onEndElement(s.substring(j, q));
                          j = q + 1;
                          break;
                        case "?":
                          ++j;
                          const pi = this._parseProcessingInstruction(s, j);
                          if (s.substring(j + pi.parsed, j + pi.parsed + 2) !== "?>") {
                            this.onError(XMLParserErrorCode.UnterminatedXmlDeclaration);
                            return;
                          }
                          this.onPi(pi.name, pi.value);
                          j += pi.parsed + 2;
                          break;
                        case "!":
                          if (s.substring(j + 1, j + 3) === "--") {
                            q = s.indexOf("-->", j + 3);
                            if (q < 0) {
                              this.onError(XMLParserErrorCode.UnterminatedComment);
                              return;
                            }
                            this.onComment(s.substring(j + 3, q));
                            j = q + 3;
                          } else if (s.substring(j + 1, j + 8) === "[CDATA[") {
                            q = s.indexOf("]]>", j + 8);
                            if (q < 0) {
                              this.onError(XMLParserErrorCode.UnterminatedCdat);
                              return;
                            }
                            this.onCdata(s.substring(j + 8, q));
                            j = q + 3;
                          } else if (s.substring(j + 1, j + 8) === "DOCTYPE") {
                            const q2 = s.indexOf("[", j + 8);
                            let complexDoctype = false;
                            q = s.indexOf(">", j + 8);
                            if (q < 0) {
                              this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);
                              return;
                            }
                            if (q2 > 0 && q > q2) {
                              q = s.indexOf("]>", j + 8);
                              if (q < 0) {
                                this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);
                                return;
                              }
                              complexDoctype = true;
                            }
                            const doctypeContent = s.substring(j + 8, q + (complexDoctype ? 1 : 0));
                            this.onDoctype(doctypeContent);
                            j = q + (complexDoctype ? 2 : 1);
                          } else {
                            this.onError(XMLParserErrorCode.MalformedElement);
                            return;
                          }
                          break;
                        default:
                          const content = this._parseContent(s, j);
                          if (content === null) {
                            this.onError(XMLParserErrorCode.MalformedElement);
                            return;
                          }
                          let isClosed = false;
                          if (s.substring(j + content.parsed, j + content.parsed + 2) === "/>") {
                            isClosed = true;
                          } else if (s.substring(j + content.parsed, j + content.parsed + 1) !== ">") {
                            this.onError(XMLParserErrorCode.UnterminatedElement);
                            return;
                          }
                          this.onBeginElement(content.name, content.attributes, isClosed);
                          j += content.parsed + (isClosed ? 2 : 1);
                          break;
                      }
                    } else {
                      while (j < s.length && s[j] !== "<") {
                        j++;
                      }
                      const text = s.substring(i, j);
                      this.onText(this._resolveEntities(text));
                    }
                    i = j;
                  }
                }
                onResolveEntity(name) {
                  return `&${name};`;
                }
                onPi(name, value) {
                }
                onComment(text) {
                }
                onCdata(text) {
                }
                onDoctype(doctypeContent) {
                }
                onText(text) {
                }
                onBeginElement(name, attributes, isEmpty) {
                }
                onEndElement(name) {
                }
                onError(code) {
                }
              };
              __name(_XMLParserBase, "XMLParserBase");
              let XMLParserBase = _XMLParserBase;
              exports2.XMLParserBase = XMLParserBase;
              const _SimpleDOMNode = class _SimpleDOMNode {
                constructor(nodeName, nodeValue) {
                  this.nodeName = nodeName;
                  this.nodeValue = nodeValue;
                  Object.defineProperty(this, "parentNode", {
                    value: null,
                    writable: true
                  });
                }
                get firstChild() {
                  return this.childNodes && this.childNodes[0];
                }
                get nextSibling() {
                  const childNodes = this.parentNode.childNodes;
                  if (!childNodes) {
                    return void 0;
                  }
                  const index = childNodes.indexOf(this);
                  if (index === -1) {
                    return void 0;
                  }
                  return childNodes[index + 1];
                }
                get textContent() {
                  if (!this.childNodes) {
                    return this.nodeValue || "";
                  }
                  return this.childNodes.map(function(child) {
                    return child.textContent;
                  }).join("");
                }
                get children() {
                  return this.childNodes || [];
                }
                hasChildNodes() {
                  return this.childNodes && this.childNodes.length > 0;
                }
                searchNode(paths, pos) {
                  if (pos >= paths.length) {
                    return this;
                  }
                  const component = paths[pos];
                  const stack = [];
                  let node = this;
                  while (true) {
                    if (component.name === node.nodeName) {
                      if (component.pos === 0) {
                        const res = node.searchNode(paths, pos + 1);
                        if (res !== null) {
                          return res;
                        }
                      } else if (stack.length === 0) {
                        return null;
                      } else {
                        const [parent] = stack.pop();
                        let siblingPos = 0;
                        for (const child of parent.childNodes) {
                          if (component.name === child.nodeName) {
                            if (siblingPos === component.pos) {
                              return child.searchNode(paths, pos + 1);
                            }
                            siblingPos++;
                          }
                        }
                        return node.searchNode(paths, pos + 1);
                      }
                    }
                    if (node.childNodes && node.childNodes.length !== 0) {
                      stack.push([node, 0]);
                      node = node.childNodes[0];
                    } else if (stack.length === 0) {
                      return null;
                    } else {
                      while (stack.length !== 0) {
                        const [parent, currentPos] = stack.pop();
                        const newPos = currentPos + 1;
                        if (newPos < parent.childNodes.length) {
                          stack.push([parent, newPos]);
                          node = parent.childNodes[newPos];
                          break;
                        }
                      }
                      if (stack.length === 0) {
                        return null;
                      }
                    }
                  }
                }
                dump(buffer) {
                  if (this.nodeName === "#text") {
                    buffer.push((0, _core_utils.encodeToXmlString)(this.nodeValue));
                    return;
                  }
                  buffer.push(`<${this.nodeName}`);
                  if (this.attributes) {
                    for (const attribute of this.attributes) {
                      buffer.push(` ${attribute.name}="${(0, _core_utils.encodeToXmlString)(attribute.value)}"`);
                    }
                  }
                  if (this.hasChildNodes()) {
                    buffer.push(">");
                    for (const child of this.childNodes) {
                      child.dump(buffer);
                    }
                    buffer.push(`</${this.nodeName}>`);
                  } else if (this.nodeValue) {
                    buffer.push(`>${(0, _core_utils.encodeToXmlString)(this.nodeValue)}</${this.nodeName}>`);
                  } else {
                    buffer.push("/>");
                  }
                }
              };
              __name(_SimpleDOMNode, "SimpleDOMNode");
              let SimpleDOMNode = _SimpleDOMNode;
              exports2.SimpleDOMNode = SimpleDOMNode;
              const _SimpleXMLParser = class _SimpleXMLParser extends XMLParserBase {
                constructor(_ref) {
                  let {
                    hasAttributes = false,
                    lowerCaseName = false
                  } = _ref;
                  super();
                  this._currentFragment = null;
                  this._stack = null;
                  this._errorCode = XMLParserErrorCode.NoError;
                  this._hasAttributes = hasAttributes;
                  this._lowerCaseName = lowerCaseName;
                }
                parseFromString(data) {
                  this._currentFragment = [];
                  this._stack = [];
                  this._errorCode = XMLParserErrorCode.NoError;
                  this.parseXml(data);
                  if (this._errorCode !== XMLParserErrorCode.NoError) {
                    return void 0;
                  }
                  const [documentElement] = this._currentFragment;
                  if (!documentElement) {
                    return void 0;
                  }
                  return {
                    documentElement
                  };
                }
                onText(text) {
                  if (isWhitespaceString(text)) {
                    return;
                  }
                  const node = new SimpleDOMNode("#text", text);
                  this._currentFragment.push(node);
                }
                onCdata(text) {
                  const node = new SimpleDOMNode("#text", text);
                  this._currentFragment.push(node);
                }
                onBeginElement(name, attributes, isEmpty) {
                  if (this._lowerCaseName) {
                    name = name.toLowerCase();
                  }
                  const node = new SimpleDOMNode(name);
                  node.childNodes = [];
                  if (this._hasAttributes) {
                    node.attributes = attributes;
                  }
                  this._currentFragment.push(node);
                  if (isEmpty) {
                    return;
                  }
                  this._stack.push(this._currentFragment);
                  this._currentFragment = node.childNodes;
                }
                onEndElement(name) {
                  this._currentFragment = this._stack.pop() || [];
                  const lastElement = this._currentFragment.at(-1);
                  if (!lastElement) {
                    return null;
                  }
                  for (let i = 0, ii = lastElement.childNodes.length; i < ii; i++) {
                    lastElement.childNodes[i].parentNode = lastElement;
                  }
                  return lastElement;
                }
                onError(code) {
                  this._errorCode = code;
                }
              };
              __name(_SimpleXMLParser, "SimpleXMLParser");
              let SimpleXMLParser = _SimpleXMLParser;
              exports2.SimpleXMLParser = SimpleXMLParser;
            },
            /* 192 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.calculateSHA256 = exports2.calculateMD5 = exports2.PDF20 = exports2.PDF17 = exports2.CipherTransformFactory = exports2.ARCFourCipher = exports2.AES256Cipher = exports2.AES128Cipher = void 0;
              exports2.calculateSHA384 = calculateSHA384;
              exports2.calculateSHA512 = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _primitives = __w_pdfjs_require__2(130);
              var _decrypt_stream = __w_pdfjs_require__2(193);
              const _ARCFourCipher = class _ARCFourCipher {
                constructor(key) {
                  this.a = 0;
                  this.b = 0;
                  const s = new Uint8Array(256);
                  const keyLength = key.length;
                  for (let i = 0; i < 256; ++i) {
                    s[i] = i;
                  }
                  for (let i = 0, j = 0; i < 256; ++i) {
                    const tmp = s[i];
                    j = j + tmp + key[i % keyLength] & 255;
                    s[i] = s[j];
                    s[j] = tmp;
                  }
                  this.s = s;
                }
                encryptBlock(data) {
                  let a = this.a, b = this.b;
                  const s = this.s;
                  const n = data.length;
                  const output = new Uint8Array(n);
                  for (let i = 0; i < n; ++i) {
                    a = a + 1 & 255;
                    const tmp = s[a];
                    b = b + tmp & 255;
                    const tmp2 = s[b];
                    s[a] = tmp2;
                    s[b] = tmp;
                    output[i] = data[i] ^ s[tmp + tmp2 & 255];
                  }
                  this.a = a;
                  this.b = b;
                  return output;
                }
                decryptBlock(data) {
                  return this.encryptBlock(data);
                }
                encrypt(data) {
                  return this.encryptBlock(data);
                }
              };
              __name(_ARCFourCipher, "ARCFourCipher");
              let ARCFourCipher = _ARCFourCipher;
              exports2.ARCFourCipher = ARCFourCipher;
              const calculateMD5 = (/* @__PURE__ */ __name(function calculateMD5Closure() {
                const r = new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]);
                const k = new Int32Array([-680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341, -45705983, 1770035416, -1958414417, -42063, -1990404162, 1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632, 643717713, -373897302, -701558691, 38016083, -660478335, -405537848, 568446438, -1019803690, -187363961, 1163531501, -1444681467, -51403784, 1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556, -1530992060, 1272893353, -155497632, -1094730640, 681279174, -358537222, -722521979, 76029189, -640364487, -421815835, 530742520, -995338651, -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606, -1051523, -2054922799, 1873313359, -30611744, -1560198380, 1309151649, -145523070, -1120210379, 718787259, -343485551]);
                function hash(data, offset, length) {
                  let h0 = 1732584193, h1 = -271733879, h2 = -1732584194, h3 = 271733878;
                  const paddedLength = length + 72 & ~63;
                  const padded = new Uint8Array(paddedLength);
                  let i, j;
                  for (i = 0; i < length; ++i) {
                    padded[i] = data[offset++];
                  }
                  padded[i++] = 128;
                  const n = paddedLength - 8;
                  while (i < n) {
                    padded[i++] = 0;
                  }
                  padded[i++] = length << 3 & 255;
                  padded[i++] = length >> 5 & 255;
                  padded[i++] = length >> 13 & 255;
                  padded[i++] = length >> 21 & 255;
                  padded[i++] = length >>> 29 & 255;
                  padded[i++] = 0;
                  padded[i++] = 0;
                  padded[i++] = 0;
                  const w = new Int32Array(16);
                  for (i = 0; i < paddedLength; ) {
                    for (j = 0; j < 16; ++j, i += 4) {
                      w[j] = padded[i] | padded[i + 1] << 8 | padded[i + 2] << 16 | padded[i + 3] << 24;
                    }
                    let a = h0, b = h1, c = h2, d = h3, f, g;
                    for (j = 0; j < 64; ++j) {
                      if (j < 16) {
                        f = b & c | ~b & d;
                        g = j;
                      } else if (j < 32) {
                        f = d & b | ~d & c;
                        g = 5 * j + 1 & 15;
                      } else if (j < 48) {
                        f = b ^ c ^ d;
                        g = 3 * j + 5 & 15;
                      } else {
                        f = c ^ (b | ~d);
                        g = 7 * j & 15;
                      }
                      const tmp = d, rotateArg = a + f + k[j] + w[g] | 0, rotate = r[j];
                      d = c;
                      c = b;
                      b = b + (rotateArg << rotate | rotateArg >>> 32 - rotate) | 0;
                      a = tmp;
                    }
                    h0 = h0 + a | 0;
                    h1 = h1 + b | 0;
                    h2 = h2 + c | 0;
                    h3 = h3 + d | 0;
                  }
                  return new Uint8Array([h0 & 255, h0 >> 8 & 255, h0 >> 16 & 255, h0 >>> 24 & 255, h1 & 255, h1 >> 8 & 255, h1 >> 16 & 255, h1 >>> 24 & 255, h2 & 255, h2 >> 8 & 255, h2 >> 16 & 255, h2 >>> 24 & 255, h3 & 255, h3 >> 8 & 255, h3 >> 16 & 255, h3 >>> 24 & 255]);
                }
                __name(hash, "hash");
                return hash;
              }, "calculateMD5Closure"))();
              exports2.calculateMD5 = calculateMD5;
              const _Word64 = class _Word64 {
                constructor(highInteger, lowInteger) {
                  this.high = highInteger | 0;
                  this.low = lowInteger | 0;
                }
                and(word) {
                  this.high &= word.high;
                  this.low &= word.low;
                }
                xor(word) {
                  this.high ^= word.high;
                  this.low ^= word.low;
                }
                or(word) {
                  this.high |= word.high;
                  this.low |= word.low;
                }
                shiftRight(places) {
                  if (places >= 32) {
                    this.low = this.high >>> places - 32 | 0;
                    this.high = 0;
                  } else {
                    this.low = this.low >>> places | this.high << 32 - places;
                    this.high = this.high >>> places | 0;
                  }
                }
                shiftLeft(places) {
                  if (places >= 32) {
                    this.high = this.low << places - 32;
                    this.low = 0;
                  } else {
                    this.high = this.high << places | this.low >>> 32 - places;
                    this.low <<= places;
                  }
                }
                rotateRight(places) {
                  let low, high;
                  if (places & 32) {
                    high = this.low;
                    low = this.high;
                  } else {
                    low = this.low;
                    high = this.high;
                  }
                  places &= 31;
                  this.low = low >>> places | high << 32 - places;
                  this.high = high >>> places | low << 32 - places;
                }
                not() {
                  this.high = ~this.high;
                  this.low = ~this.low;
                }
                add(word) {
                  const lowAdd = (this.low >>> 0) + (word.low >>> 0);
                  let highAdd = (this.high >>> 0) + (word.high >>> 0);
                  if (lowAdd > 4294967295) {
                    highAdd += 1;
                  }
                  this.low = lowAdd | 0;
                  this.high = highAdd | 0;
                }
                copyTo(bytes, offset) {
                  bytes[offset] = this.high >>> 24 & 255;
                  bytes[offset + 1] = this.high >> 16 & 255;
                  bytes[offset + 2] = this.high >> 8 & 255;
                  bytes[offset + 3] = this.high & 255;
                  bytes[offset + 4] = this.low >>> 24 & 255;
                  bytes[offset + 5] = this.low >> 16 & 255;
                  bytes[offset + 6] = this.low >> 8 & 255;
                  bytes[offset + 7] = this.low & 255;
                }
                assign(word) {
                  this.high = word.high;
                  this.low = word.low;
                }
              };
              __name(_Word64, "Word64");
              let Word64 = _Word64;
              const calculateSHA256 = (/* @__PURE__ */ __name(function calculateSHA256Closure() {
                function rotr(x, n) {
                  return x >>> n | x << 32 - n;
                }
                __name(rotr, "rotr");
                function ch(x, y, z) {
                  return x & y ^ ~x & z;
                }
                __name(ch, "ch");
                function maj(x, y, z) {
                  return x & y ^ x & z ^ y & z;
                }
                __name(maj, "maj");
                function sigma(x) {
                  return rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22);
                }
                __name(sigma, "sigma");
                function sigmaPrime(x) {
                  return rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25);
                }
                __name(sigmaPrime, "sigmaPrime");
                function littleSigma(x) {
                  return rotr(x, 7) ^ rotr(x, 18) ^ x >>> 3;
                }
                __name(littleSigma, "littleSigma");
                function littleSigmaPrime(x) {
                  return rotr(x, 17) ^ rotr(x, 19) ^ x >>> 10;
                }
                __name(littleSigmaPrime, "littleSigmaPrime");
                const k = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
                function hash(data, offset, length) {
                  let h0 = 1779033703, h1 = 3144134277, h2 = 1013904242, h3 = 2773480762, h4 = 1359893119, h5 = 2600822924, h6 = 528734635, h7 = 1541459225;
                  const paddedLength = Math.ceil((length + 9) / 64) * 64;
                  const padded = new Uint8Array(paddedLength);
                  let i, j;
                  for (i = 0; i < length; ++i) {
                    padded[i] = data[offset++];
                  }
                  padded[i++] = 128;
                  const n = paddedLength - 8;
                  while (i < n) {
                    padded[i++] = 0;
                  }
                  padded[i++] = 0;
                  padded[i++] = 0;
                  padded[i++] = 0;
                  padded[i++] = length >>> 29 & 255;
                  padded[i++] = length >> 21 & 255;
                  padded[i++] = length >> 13 & 255;
                  padded[i++] = length >> 5 & 255;
                  padded[i++] = length << 3 & 255;
                  const w = new Uint32Array(64);
                  for (i = 0; i < paddedLength; ) {
                    for (j = 0; j < 16; ++j) {
                      w[j] = padded[i] << 24 | padded[i + 1] << 16 | padded[i + 2] << 8 | padded[i + 3];
                      i += 4;
                    }
                    for (j = 16; j < 64; ++j) {
                      w[j] = littleSigmaPrime(w[j - 2]) + w[j - 7] + littleSigma(w[j - 15]) + w[j - 16] | 0;
                    }
                    let a = h0, b = h1, c = h2, d = h3, e = h4, f = h5, g = h6, h = h7, t1, t2;
                    for (j = 0; j < 64; ++j) {
                      t1 = h + sigmaPrime(e) + ch(e, f, g) + k[j] + w[j];
                      t2 = sigma(a) + maj(a, b, c);
                      h = g;
                      g = f;
                      f = e;
                      e = d + t1 | 0;
                      d = c;
                      c = b;
                      b = a;
                      a = t1 + t2 | 0;
                    }
                    h0 = h0 + a | 0;
                    h1 = h1 + b | 0;
                    h2 = h2 + c | 0;
                    h3 = h3 + d | 0;
                    h4 = h4 + e | 0;
                    h5 = h5 + f | 0;
                    h6 = h6 + g | 0;
                    h7 = h7 + h | 0;
                  }
                  return new Uint8Array([h0 >> 24 & 255, h0 >> 16 & 255, h0 >> 8 & 255, h0 & 255, h1 >> 24 & 255, h1 >> 16 & 255, h1 >> 8 & 255, h1 & 255, h2 >> 24 & 255, h2 >> 16 & 255, h2 >> 8 & 255, h2 & 255, h3 >> 24 & 255, h3 >> 16 & 255, h3 >> 8 & 255, h3 & 255, h4 >> 24 & 255, h4 >> 16 & 255, h4 >> 8 & 255, h4 & 255, h5 >> 24 & 255, h5 >> 16 & 255, h5 >> 8 & 255, h5 & 255, h6 >> 24 & 255, h6 >> 16 & 255, h6 >> 8 & 255, h6 & 255, h7 >> 24 & 255, h7 >> 16 & 255, h7 >> 8 & 255, h7 & 255]);
                }
                __name(hash, "hash");
                return hash;
              }, "calculateSHA256Closure"))();
              exports2.calculateSHA256 = calculateSHA256;
              const calculateSHA512 = (/* @__PURE__ */ __name(function calculateSHA512Closure() {
                function ch(result, x, y, z, tmp) {
                  result.assign(x);
                  result.and(y);
                  tmp.assign(x);
                  tmp.not();
                  tmp.and(z);
                  result.xor(tmp);
                }
                __name(ch, "ch");
                function maj(result, x, y, z, tmp) {
                  result.assign(x);
                  result.and(y);
                  tmp.assign(x);
                  tmp.and(z);
                  result.xor(tmp);
                  tmp.assign(y);
                  tmp.and(z);
                  result.xor(tmp);
                }
                __name(maj, "maj");
                function sigma(result, x, tmp) {
                  result.assign(x);
                  result.rotateRight(28);
                  tmp.assign(x);
                  tmp.rotateRight(34);
                  result.xor(tmp);
                  tmp.assign(x);
                  tmp.rotateRight(39);
                  result.xor(tmp);
                }
                __name(sigma, "sigma");
                function sigmaPrime(result, x, tmp) {
                  result.assign(x);
                  result.rotateRight(14);
                  tmp.assign(x);
                  tmp.rotateRight(18);
                  result.xor(tmp);
                  tmp.assign(x);
                  tmp.rotateRight(41);
                  result.xor(tmp);
                }
                __name(sigmaPrime, "sigmaPrime");
                function littleSigma(result, x, tmp) {
                  result.assign(x);
                  result.rotateRight(1);
                  tmp.assign(x);
                  tmp.rotateRight(8);
                  result.xor(tmp);
                  tmp.assign(x);
                  tmp.shiftRight(7);
                  result.xor(tmp);
                }
                __name(littleSigma, "littleSigma");
                function littleSigmaPrime(result, x, tmp) {
                  result.assign(x);
                  result.rotateRight(19);
                  tmp.assign(x);
                  tmp.rotateRight(61);
                  result.xor(tmp);
                  tmp.assign(x);
                  tmp.shiftRight(6);
                  result.xor(tmp);
                }
                __name(littleSigmaPrime, "littleSigmaPrime");
                const k = [new Word64(1116352408, 3609767458), new Word64(1899447441, 602891725), new Word64(3049323471, 3964484399), new Word64(3921009573, 2173295548), new Word64(961987163, 4081628472), new Word64(1508970993, 3053834265), new Word64(2453635748, 2937671579), new Word64(2870763221, 3664609560), new Word64(3624381080, 2734883394), new Word64(310598401, 1164996542), new Word64(607225278, 1323610764), new Word64(1426881987, 3590304994), new Word64(1925078388, 4068182383), new Word64(2162078206, 991336113), new Word64(2614888103, 633803317), new Word64(3248222580, 3479774868), new Word64(3835390401, 2666613458), new Word64(4022224774, 944711139), new Word64(264347078, 2341262773), new Word64(604807628, 2007800933), new Word64(770255983, 1495990901), new Word64(1249150122, 1856431235), new Word64(1555081692, 3175218132), new Word64(1996064986, 2198950837), new Word64(2554220882, 3999719339), new Word64(2821834349, 766784016), new Word64(2952996808, 2566594879), new Word64(3210313671, 3203337956), new Word64(3336571891, 1034457026), new Word64(3584528711, 2466948901), new Word64(113926993, 3758326383), new Word64(338241895, 168717936), new Word64(666307205, 1188179964), new Word64(773529912, 1546045734), new Word64(1294757372, 1522805485), new Word64(1396182291, 2643833823), new Word64(1695183700, 2343527390), new Word64(1986661051, 1014477480), new Word64(2177026350, 1206759142), new Word64(2456956037, 344077627), new Word64(2730485921, 1290863460), new Word64(2820302411, 3158454273), new Word64(3259730800, 3505952657), new Word64(3345764771, 106217008), new Word64(3516065817, 3606008344), new Word64(3600352804, 1432725776), new Word64(4094571909, 1467031594), new Word64(275423344, 851169720), new Word64(430227734, 3100823752), new Word64(506948616, 1363258195), new Word64(659060556, 3750685593), new Word64(883997877, 3785050280), new Word64(958139571, 3318307427), new Word64(1322822218, 3812723403), new Word64(1537002063, 2003034995), new Word64(1747873779, 3602036899), new Word64(1955562222, 1575990012), new Word64(2024104815, 1125592928), new Word64(2227730452, 2716904306), new Word64(2361852424, 442776044), new Word64(2428436474, 593698344), new Word64(2756734187, 3733110249), new Word64(3204031479, 2999351573), new Word64(3329325298, 3815920427), new Word64(3391569614, 3928383900), new Word64(3515267271, 566280711), new Word64(3940187606, 3454069534), new Word64(4118630271, 4000239992), new Word64(116418474, 1914138554), new Word64(174292421, 2731055270), new Word64(289380356, 3203993006), new Word64(460393269, 320620315), new Word64(685471733, 587496836), new Word64(852142971, 1086792851), new Word64(1017036298, 365543100), new Word64(1126000580, 2618297676), new Word64(1288033470, 3409855158), new Word64(1501505948, 4234509866), new Word64(1607167915, 987167468), new Word64(1816402316, 1246189591)];
                function hash(data, offset, length) {
                  let mode384 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
                  let h0, h1, h2, h3, h4, h5, h6, h7;
                  if (!mode384) {
                    h0 = new Word64(1779033703, 4089235720);
                    h1 = new Word64(3144134277, 2227873595);
                    h2 = new Word64(1013904242, 4271175723);
                    h3 = new Word64(2773480762, 1595750129);
                    h4 = new Word64(1359893119, 2917565137);
                    h5 = new Word64(2600822924, 725511199);
                    h6 = new Word64(528734635, 4215389547);
                    h7 = new Word64(1541459225, 327033209);
                  } else {
                    h0 = new Word64(3418070365, 3238371032);
                    h1 = new Word64(1654270250, 914150663);
                    h2 = new Word64(2438529370, 812702999);
                    h3 = new Word64(355462360, 4144912697);
                    h4 = new Word64(1731405415, 4290775857);
                    h5 = new Word64(2394180231, 1750603025);
                    h6 = new Word64(3675008525, 1694076839);
                    h7 = new Word64(1203062813, 3204075428);
                  }
                  const paddedLength = Math.ceil((length + 17) / 128) * 128;
                  const padded = new Uint8Array(paddedLength);
                  let i, j;
                  for (i = 0; i < length; ++i) {
                    padded[i] = data[offset++];
                  }
                  padded[i++] = 128;
                  const n = paddedLength - 16;
                  while (i < n) {
                    padded[i++] = 0;
                  }
                  padded[i++] = 0;
                  padded[i++] = 0;
                  padded[i++] = 0;
                  padded[i++] = 0;
                  padded[i++] = 0;
                  padded[i++] = 0;
                  padded[i++] = 0;
                  padded[i++] = 0;
                  padded[i++] = 0;
                  padded[i++] = 0;
                  padded[i++] = 0;
                  padded[i++] = length >>> 29 & 255;
                  padded[i++] = length >> 21 & 255;
                  padded[i++] = length >> 13 & 255;
                  padded[i++] = length >> 5 & 255;
                  padded[i++] = length << 3 & 255;
                  const w = new Array(80);
                  for (i = 0; i < 80; i++) {
                    w[i] = new Word64(0, 0);
                  }
                  let a = new Word64(0, 0), b = new Word64(0, 0), c = new Word64(0, 0);
                  let d = new Word64(0, 0), e = new Word64(0, 0), f = new Word64(0, 0);
                  let g = new Word64(0, 0), h = new Word64(0, 0);
                  const t1 = new Word64(0, 0), t2 = new Word64(0, 0);
                  const tmp1 = new Word64(0, 0), tmp2 = new Word64(0, 0);
                  let tmp3;
                  for (i = 0; i < paddedLength; ) {
                    for (j = 0; j < 16; ++j) {
                      w[j].high = padded[i] << 24 | padded[i + 1] << 16 | padded[i + 2] << 8 | padded[i + 3];
                      w[j].low = padded[i + 4] << 24 | padded[i + 5] << 16 | padded[i + 6] << 8 | padded[i + 7];
                      i += 8;
                    }
                    for (j = 16; j < 80; ++j) {
                      tmp3 = w[j];
                      littleSigmaPrime(tmp3, w[j - 2], tmp2);
                      tmp3.add(w[j - 7]);
                      littleSigma(tmp1, w[j - 15], tmp2);
                      tmp3.add(tmp1);
                      tmp3.add(w[j - 16]);
                    }
                    a.assign(h0);
                    b.assign(h1);
                    c.assign(h2);
                    d.assign(h3);
                    e.assign(h4);
                    f.assign(h5);
                    g.assign(h6);
                    h.assign(h7);
                    for (j = 0; j < 80; ++j) {
                      t1.assign(h);
                      sigmaPrime(tmp1, e, tmp2);
                      t1.add(tmp1);
                      ch(tmp1, e, f, g, tmp2);
                      t1.add(tmp1);
                      t1.add(k[j]);
                      t1.add(w[j]);
                      sigma(t2, a, tmp2);
                      maj(tmp1, a, b, c, tmp2);
                      t2.add(tmp1);
                      tmp3 = h;
                      h = g;
                      g = f;
                      f = e;
                      d.add(t1);
                      e = d;
                      d = c;
                      c = b;
                      b = a;
                      tmp3.assign(t1);
                      tmp3.add(t2);
                      a = tmp3;
                    }
                    h0.add(a);
                    h1.add(b);
                    h2.add(c);
                    h3.add(d);
                    h4.add(e);
                    h5.add(f);
                    h6.add(g);
                    h7.add(h);
                  }
                  let result;
                  if (!mode384) {
                    result = new Uint8Array(64);
                    h0.copyTo(result, 0);
                    h1.copyTo(result, 8);
                    h2.copyTo(result, 16);
                    h3.copyTo(result, 24);
                    h4.copyTo(result, 32);
                    h5.copyTo(result, 40);
                    h6.copyTo(result, 48);
                    h7.copyTo(result, 56);
                  } else {
                    result = new Uint8Array(48);
                    h0.copyTo(result, 0);
                    h1.copyTo(result, 8);
                    h2.copyTo(result, 16);
                    h3.copyTo(result, 24);
                    h4.copyTo(result, 32);
                    h5.copyTo(result, 40);
                  }
                  return result;
                }
                __name(hash, "hash");
                return hash;
              }, "calculateSHA512Closure"))();
              exports2.calculateSHA512 = calculateSHA512;
              function calculateSHA384(data, offset, length) {
                return calculateSHA512(data, offset, length, true);
              }
              __name(calculateSHA384, "calculateSHA384");
              const _NullCipher = class _NullCipher {
                decryptBlock(data) {
                  return data;
                }
                encrypt(data) {
                  return data;
                }
              };
              __name(_NullCipher, "NullCipher");
              let NullCipher = _NullCipher;
              const _AESBaseCipher = class _AESBaseCipher {
                constructor() {
                  if (this.constructor === _AESBaseCipher) {
                    (0, _util.unreachable)("Cannot initialize AESBaseCipher.");
                  }
                  this._s = new Uint8Array([99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22]);
                  this._inv_s = new Uint8Array([82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125]);
                  this._mix = new Uint32Array([0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795]);
                  this._mixCol = new Uint8Array(256);
                  for (let i = 0; i < 256; i++) {
                    if (i < 128) {
                      this._mixCol[i] = i << 1;
                    } else {
                      this._mixCol[i] = i << 1 ^ 27;
                    }
                  }
                  this.buffer = new Uint8Array(16);
                  this.bufferPosition = 0;
                }
                _expandKey(cipherKey) {
                  (0, _util.unreachable)("Cannot call `_expandKey` on the base class");
                }
                _decrypt(input, key) {
                  let t, u, v;
                  const state = new Uint8Array(16);
                  state.set(input);
                  for (let j = 0, k = this._keySize; j < 16; ++j, ++k) {
                    state[j] ^= key[k];
                  }
                  for (let i = this._cyclesOfRepetition - 1; i >= 1; --i) {
                    t = state[13];
                    state[13] = state[9];
                    state[9] = state[5];
                    state[5] = state[1];
                    state[1] = t;
                    t = state[14];
                    u = state[10];
                    state[14] = state[6];
                    state[10] = state[2];
                    state[6] = t;
                    state[2] = u;
                    t = state[15];
                    u = state[11];
                    v = state[7];
                    state[15] = state[3];
                    state[11] = t;
                    state[7] = u;
                    state[3] = v;
                    for (let j = 0; j < 16; ++j) {
                      state[j] = this._inv_s[state[j]];
                    }
                    for (let j = 0, k = i * 16; j < 16; ++j, ++k) {
                      state[j] ^= key[k];
                    }
                    for (let j = 0; j < 16; j += 4) {
                      const s0 = this._mix[state[j]];
                      const s1 = this._mix[state[j + 1]];
                      const s2 = this._mix[state[j + 2]];
                      const s3 = this._mix[state[j + 3]];
                      t = s0 ^ s1 >>> 8 ^ s1 << 24 ^ s2 >>> 16 ^ s2 << 16 ^ s3 >>> 24 ^ s3 << 8;
                      state[j] = t >>> 24 & 255;
                      state[j + 1] = t >> 16 & 255;
                      state[j + 2] = t >> 8 & 255;
                      state[j + 3] = t & 255;
                    }
                  }
                  t = state[13];
                  state[13] = state[9];
                  state[9] = state[5];
                  state[5] = state[1];
                  state[1] = t;
                  t = state[14];
                  u = state[10];
                  state[14] = state[6];
                  state[10] = state[2];
                  state[6] = t;
                  state[2] = u;
                  t = state[15];
                  u = state[11];
                  v = state[7];
                  state[15] = state[3];
                  state[11] = t;
                  state[7] = u;
                  state[3] = v;
                  for (let j = 0; j < 16; ++j) {
                    state[j] = this._inv_s[state[j]];
                    state[j] ^= key[j];
                  }
                  return state;
                }
                _encrypt(input, key) {
                  const s = this._s;
                  let t, u, v;
                  const state = new Uint8Array(16);
                  state.set(input);
                  for (let j = 0; j < 16; ++j) {
                    state[j] ^= key[j];
                  }
                  for (let i = 1; i < this._cyclesOfRepetition; i++) {
                    for (let j = 0; j < 16; ++j) {
                      state[j] = s[state[j]];
                    }
                    v = state[1];
                    state[1] = state[5];
                    state[5] = state[9];
                    state[9] = state[13];
                    state[13] = v;
                    v = state[2];
                    u = state[6];
                    state[2] = state[10];
                    state[6] = state[14];
                    state[10] = v;
                    state[14] = u;
                    v = state[3];
                    u = state[7];
                    t = state[11];
                    state[3] = state[15];
                    state[7] = v;
                    state[11] = u;
                    state[15] = t;
                    for (let j = 0; j < 16; j += 4) {
                      const s0 = state[j + 0];
                      const s1 = state[j + 1];
                      const s2 = state[j + 2];
                      const s3 = state[j + 3];
                      t = s0 ^ s1 ^ s2 ^ s3;
                      state[j + 0] ^= t ^ this._mixCol[s0 ^ s1];
                      state[j + 1] ^= t ^ this._mixCol[s1 ^ s2];
                      state[j + 2] ^= t ^ this._mixCol[s2 ^ s3];
                      state[j + 3] ^= t ^ this._mixCol[s3 ^ s0];
                    }
                    for (let j = 0, k = i * 16; j < 16; ++j, ++k) {
                      state[j] ^= key[k];
                    }
                  }
                  for (let j = 0; j < 16; ++j) {
                    state[j] = s[state[j]];
                  }
                  v = state[1];
                  state[1] = state[5];
                  state[5] = state[9];
                  state[9] = state[13];
                  state[13] = v;
                  v = state[2];
                  u = state[6];
                  state[2] = state[10];
                  state[6] = state[14];
                  state[10] = v;
                  state[14] = u;
                  v = state[3];
                  u = state[7];
                  t = state[11];
                  state[3] = state[15];
                  state[7] = v;
                  state[11] = u;
                  state[15] = t;
                  for (let j = 0, k = this._keySize; j < 16; ++j, ++k) {
                    state[j] ^= key[k];
                  }
                  return state;
                }
                _decryptBlock2(data, finalize) {
                  const sourceLength = data.length;
                  let buffer = this.buffer, bufferLength = this.bufferPosition;
                  const result = [];
                  let iv = this.iv;
                  for (let i = 0; i < sourceLength; ++i) {
                    buffer[bufferLength] = data[i];
                    ++bufferLength;
                    if (bufferLength < 16) {
                      continue;
                    }
                    const plain = this._decrypt(buffer, this._key);
                    for (let j = 0; j < 16; ++j) {
                      plain[j] ^= iv[j];
                    }
                    iv = buffer;
                    result.push(plain);
                    buffer = new Uint8Array(16);
                    bufferLength = 0;
                  }
                  this.buffer = buffer;
                  this.bufferLength = bufferLength;
                  this.iv = iv;
                  if (result.length === 0) {
                    return new Uint8Array(0);
                  }
                  let outputLength = 16 * result.length;
                  if (finalize) {
                    const lastBlock = result.at(-1);
                    let psLen = lastBlock[15];
                    if (psLen <= 16) {
                      for (let i = 15, ii = 16 - psLen; i >= ii; --i) {
                        if (lastBlock[i] !== psLen) {
                          psLen = 0;
                          break;
                        }
                      }
                      outputLength -= psLen;
                      result[result.length - 1] = lastBlock.subarray(0, 16 - psLen);
                    }
                  }
                  const output = new Uint8Array(outputLength);
                  for (let i = 0, j = 0, ii = result.length; i < ii; ++i, j += 16) {
                    output.set(result[i], j);
                  }
                  return output;
                }
                decryptBlock(data, finalize) {
                  let iv = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                  const sourceLength = data.length;
                  const buffer = this.buffer;
                  let bufferLength = this.bufferPosition;
                  if (iv) {
                    this.iv = iv;
                  } else {
                    for (let i = 0; bufferLength < 16 && i < sourceLength; ++i, ++bufferLength) {
                      buffer[bufferLength] = data[i];
                    }
                    if (bufferLength < 16) {
                      this.bufferLength = bufferLength;
                      return new Uint8Array(0);
                    }
                    this.iv = buffer;
                    data = data.subarray(16);
                  }
                  this.buffer = new Uint8Array(16);
                  this.bufferLength = 0;
                  this.decryptBlock = this._decryptBlock2;
                  return this.decryptBlock(data, finalize);
                }
                encrypt(data, iv) {
                  const sourceLength = data.length;
                  let buffer = this.buffer, bufferLength = this.bufferPosition;
                  const result = [];
                  if (!iv) {
                    iv = new Uint8Array(16);
                  }
                  for (let i = 0; i < sourceLength; ++i) {
                    buffer[bufferLength] = data[i];
                    ++bufferLength;
                    if (bufferLength < 16) {
                      continue;
                    }
                    for (let j = 0; j < 16; ++j) {
                      buffer[j] ^= iv[j];
                    }
                    const cipher = this._encrypt(buffer, this._key);
                    iv = cipher;
                    result.push(cipher);
                    buffer = new Uint8Array(16);
                    bufferLength = 0;
                  }
                  this.buffer = buffer;
                  this.bufferLength = bufferLength;
                  this.iv = iv;
                  if (result.length === 0) {
                    return new Uint8Array(0);
                  }
                  const outputLength = 16 * result.length;
                  const output = new Uint8Array(outputLength);
                  for (let i = 0, j = 0, ii = result.length; i < ii; ++i, j += 16) {
                    output.set(result[i], j);
                  }
                  return output;
                }
              };
              __name(_AESBaseCipher, "AESBaseCipher");
              let AESBaseCipher = _AESBaseCipher;
              const _AES128Cipher = class _AES128Cipher extends AESBaseCipher {
                constructor(key) {
                  super();
                  this._cyclesOfRepetition = 10;
                  this._keySize = 160;
                  this._rcon = new Uint8Array([141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141]);
                  this._key = this._expandKey(key);
                }
                _expandKey(cipherKey) {
                  const b = 176;
                  const s = this._s;
                  const rcon = this._rcon;
                  const result = new Uint8Array(b);
                  result.set(cipherKey);
                  for (let j = 16, i = 1; j < b; ++i) {
                    let t1 = result[j - 3];
                    let t2 = result[j - 2];
                    let t3 = result[j - 1];
                    let t4 = result[j - 4];
                    t1 = s[t1];
                    t2 = s[t2];
                    t3 = s[t3];
                    t4 = s[t4];
                    t1 ^= rcon[i];
                    for (let n = 0; n < 4; ++n) {
                      result[j] = t1 ^= result[j - 16];
                      j++;
                      result[j] = t2 ^= result[j - 16];
                      j++;
                      result[j] = t3 ^= result[j - 16];
                      j++;
                      result[j] = t4 ^= result[j - 16];
                      j++;
                    }
                  }
                  return result;
                }
              };
              __name(_AES128Cipher, "AES128Cipher");
              let AES128Cipher = _AES128Cipher;
              exports2.AES128Cipher = AES128Cipher;
              const _AES256Cipher = class _AES256Cipher extends AESBaseCipher {
                constructor(key) {
                  super();
                  this._cyclesOfRepetition = 14;
                  this._keySize = 224;
                  this._key = this._expandKey(key);
                }
                _expandKey(cipherKey) {
                  const b = 240;
                  const s = this._s;
                  const result = new Uint8Array(b);
                  result.set(cipherKey);
                  let r = 1;
                  let t1, t2, t3, t4;
                  for (let j = 32, i = 1; j < b; ++i) {
                    if (j % 32 === 16) {
                      t1 = s[t1];
                      t2 = s[t2];
                      t3 = s[t3];
                      t4 = s[t4];
                    } else if (j % 32 === 0) {
                      t1 = result[j - 3];
                      t2 = result[j - 2];
                      t3 = result[j - 1];
                      t4 = result[j - 4];
                      t1 = s[t1];
                      t2 = s[t2];
                      t3 = s[t3];
                      t4 = s[t4];
                      t1 ^= r;
                      if ((r <<= 1) >= 256) {
                        r = (r ^ 27) & 255;
                      }
                    }
                    for (let n = 0; n < 4; ++n) {
                      result[j] = t1 ^= result[j - 32];
                      j++;
                      result[j] = t2 ^= result[j - 32];
                      j++;
                      result[j] = t3 ^= result[j - 32];
                      j++;
                      result[j] = t4 ^= result[j - 32];
                      j++;
                    }
                  }
                  return result;
                }
              };
              __name(_AES256Cipher, "AES256Cipher");
              let AES256Cipher = _AES256Cipher;
              exports2.AES256Cipher = AES256Cipher;
              const _PDF17 = class _PDF17 {
                checkOwnerPassword(password, ownerValidationSalt, userBytes, ownerPassword) {
                  const hashData = new Uint8Array(password.length + 56);
                  hashData.set(password, 0);
                  hashData.set(ownerValidationSalt, password.length);
                  hashData.set(userBytes, password.length + ownerValidationSalt.length);
                  const result = calculateSHA256(hashData, 0, hashData.length);
                  return (0, _util.isArrayEqual)(result, ownerPassword);
                }
                checkUserPassword(password, userValidationSalt, userPassword) {
                  const hashData = new Uint8Array(password.length + 8);
                  hashData.set(password, 0);
                  hashData.set(userValidationSalt, password.length);
                  const result = calculateSHA256(hashData, 0, hashData.length);
                  return (0, _util.isArrayEqual)(result, userPassword);
                }
                getOwnerKey(password, ownerKeySalt, userBytes, ownerEncryption) {
                  const hashData = new Uint8Array(password.length + 56);
                  hashData.set(password, 0);
                  hashData.set(ownerKeySalt, password.length);
                  hashData.set(userBytes, password.length + ownerKeySalt.length);
                  const key = calculateSHA256(hashData, 0, hashData.length);
                  const cipher = new AES256Cipher(key);
                  return cipher.decryptBlock(ownerEncryption, false, new Uint8Array(16));
                }
                getUserKey(password, userKeySalt, userEncryption) {
                  const hashData = new Uint8Array(password.length + 8);
                  hashData.set(password, 0);
                  hashData.set(userKeySalt, password.length);
                  const key = calculateSHA256(hashData, 0, hashData.length);
                  const cipher = new AES256Cipher(key);
                  return cipher.decryptBlock(userEncryption, false, new Uint8Array(16));
                }
              };
              __name(_PDF17, "PDF17");
              let PDF17 = _PDF17;
              exports2.PDF17 = PDF17;
              const PDF20 = (/* @__PURE__ */ __name(function PDF20Closure() {
                function calculatePDF20Hash(password, input, userBytes) {
                  let k = calculateSHA256(input, 0, input.length).subarray(0, 32);
                  let e = [0];
                  let i = 0;
                  while (i < 64 || e.at(-1) > i - 32) {
                    const combinedLength = password.length + k.length + userBytes.length, combinedArray = new Uint8Array(combinedLength);
                    let writeOffset = 0;
                    combinedArray.set(password, writeOffset);
                    writeOffset += password.length;
                    combinedArray.set(k, writeOffset);
                    writeOffset += k.length;
                    combinedArray.set(userBytes, writeOffset);
                    const k1 = new Uint8Array(combinedLength * 64);
                    for (let j = 0, pos = 0; j < 64; j++, pos += combinedLength) {
                      k1.set(combinedArray, pos);
                    }
                    const cipher = new AES128Cipher(k.subarray(0, 16));
                    e = cipher.encrypt(k1, k.subarray(16, 32));
                    let remainder = 0;
                    for (let z = 0; z < 16; z++) {
                      remainder *= 256 % 3;
                      remainder %= 3;
                      remainder += (e[z] >>> 0) % 3;
                      remainder %= 3;
                    }
                    if (remainder === 0) {
                      k = calculateSHA256(e, 0, e.length);
                    } else if (remainder === 1) {
                      k = calculateSHA384(e, 0, e.length);
                    } else if (remainder === 2) {
                      k = calculateSHA512(e, 0, e.length);
                    }
                    i++;
                  }
                  return k.subarray(0, 32);
                }
                __name(calculatePDF20Hash, "calculatePDF20Hash");
                const _PDF20 = class _PDF20 {
                  hash(password, concatBytes, userBytes) {
                    return calculatePDF20Hash(password, concatBytes, userBytes);
                  }
                  checkOwnerPassword(password, ownerValidationSalt, userBytes, ownerPassword) {
                    const hashData = new Uint8Array(password.length + 56);
                    hashData.set(password, 0);
                    hashData.set(ownerValidationSalt, password.length);
                    hashData.set(userBytes, password.length + ownerValidationSalt.length);
                    const result = calculatePDF20Hash(password, hashData, userBytes);
                    return (0, _util.isArrayEqual)(result, ownerPassword);
                  }
                  checkUserPassword(password, userValidationSalt, userPassword) {
                    const hashData = new Uint8Array(password.length + 8);
                    hashData.set(password, 0);
                    hashData.set(userValidationSalt, password.length);
                    const result = calculatePDF20Hash(password, hashData, []);
                    return (0, _util.isArrayEqual)(result, userPassword);
                  }
                  getOwnerKey(password, ownerKeySalt, userBytes, ownerEncryption) {
                    const hashData = new Uint8Array(password.length + 56);
                    hashData.set(password, 0);
                    hashData.set(ownerKeySalt, password.length);
                    hashData.set(userBytes, password.length + ownerKeySalt.length);
                    const key = calculatePDF20Hash(password, hashData, userBytes);
                    const cipher = new AES256Cipher(key);
                    return cipher.decryptBlock(ownerEncryption, false, new Uint8Array(16));
                  }
                  getUserKey(password, userKeySalt, userEncryption) {
                    const hashData = new Uint8Array(password.length + 8);
                    hashData.set(password, 0);
                    hashData.set(userKeySalt, password.length);
                    const key = calculatePDF20Hash(password, hashData, []);
                    const cipher = new AES256Cipher(key);
                    return cipher.decryptBlock(userEncryption, false, new Uint8Array(16));
                  }
                };
                __name(_PDF20, "PDF20");
                let PDF202 = _PDF20;
                return PDF202;
              }, "PDF20Closure"))();
              exports2.PDF20 = PDF20;
              const _CipherTransform = class _CipherTransform {
                constructor(stringCipherConstructor, streamCipherConstructor) {
                  this.StringCipherConstructor = stringCipherConstructor;
                  this.StreamCipherConstructor = streamCipherConstructor;
                }
                createStream(stream, length) {
                  const cipher = new this.StreamCipherConstructor();
                  return new _decrypt_stream.DecryptStream(stream, length, /* @__PURE__ */ __name(function cipherTransformDecryptStream(data, finalize) {
                    return cipher.decryptBlock(data, finalize);
                  }, "cipherTransformDecryptStream"));
                }
                decryptString(s) {
                  const cipher = new this.StringCipherConstructor();
                  let data = (0, _util.stringToBytes)(s);
                  data = cipher.decryptBlock(data, true);
                  return (0, _util.bytesToString)(data);
                }
                encryptString(s) {
                  const cipher = new this.StringCipherConstructor();
                  if (cipher instanceof AESBaseCipher) {
                    const strLen = s.length;
                    const pad = 16 - strLen % 16;
                    s += String.fromCharCode(pad).repeat(pad);
                    const iv = new Uint8Array(16);
                    if (typeof crypto !== "undefined") {
                      crypto.getRandomValues(iv);
                    } else {
                      for (let i = 0; i < 16; i++) {
                        iv[i] = Math.floor(256 * Math.random());
                      }
                    }
                    let data2 = (0, _util.stringToBytes)(s);
                    data2 = cipher.encrypt(data2, iv);
                    const buf = new Uint8Array(16 + data2.length);
                    buf.set(iv);
                    buf.set(data2, 16);
                    return (0, _util.bytesToString)(buf);
                  }
                  let data = (0, _util.stringToBytes)(s);
                  data = cipher.encrypt(data);
                  return (0, _util.bytesToString)(data);
                }
              };
              __name(_CipherTransform, "CipherTransform");
              let CipherTransform = _CipherTransform;
              const CipherTransformFactory = (/* @__PURE__ */ __name(function CipherTransformFactoryClosure() {
                const defaultPasswordBytes = new Uint8Array([40, 191, 78, 94, 78, 117, 138, 65, 100, 0, 78, 86, 255, 250, 1, 8, 46, 46, 0, 182, 208, 104, 62, 128, 47, 12, 169, 254, 100, 83, 105, 122]);
                function createEncryptionKey20(revision, password, ownerPassword, ownerValidationSalt, ownerKeySalt, uBytes, userPassword, userValidationSalt, userKeySalt, ownerEncryption, userEncryption, perms) {
                  if (password) {
                    const passwordLength = Math.min(127, password.length);
                    password = password.subarray(0, passwordLength);
                  } else {
                    password = [];
                  }
                  let pdfAlgorithm;
                  if (revision === 6) {
                    pdfAlgorithm = new PDF20();
                  } else {
                    pdfAlgorithm = new PDF17();
                  }
                  if (pdfAlgorithm.checkUserPassword(password, userValidationSalt, userPassword)) {
                    return pdfAlgorithm.getUserKey(password, userKeySalt, userEncryption);
                  } else if (password.length && pdfAlgorithm.checkOwnerPassword(password, ownerValidationSalt, uBytes, ownerPassword)) {
                    return pdfAlgorithm.getOwnerKey(password, ownerKeySalt, uBytes, ownerEncryption);
                  }
                  return null;
                }
                __name(createEncryptionKey20, "createEncryptionKey20");
                function prepareKeyData(fileId, password, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata) {
                  const hashDataSize = 40 + ownerPassword.length + fileId.length;
                  const hashData = new Uint8Array(hashDataSize);
                  let i = 0, j, n;
                  if (password) {
                    n = Math.min(32, password.length);
                    for (; i < n; ++i) {
                      hashData[i] = password[i];
                    }
                  }
                  j = 0;
                  while (i < 32) {
                    hashData[i++] = defaultPasswordBytes[j++];
                  }
                  for (j = 0, n = ownerPassword.length; j < n; ++j) {
                    hashData[i++] = ownerPassword[j];
                  }
                  hashData[i++] = flags & 255;
                  hashData[i++] = flags >> 8 & 255;
                  hashData[i++] = flags >> 16 & 255;
                  hashData[i++] = flags >>> 24 & 255;
                  for (j = 0, n = fileId.length; j < n; ++j) {
                    hashData[i++] = fileId[j];
                  }
                  if (revision >= 4 && !encryptMetadata) {
                    hashData[i++] = 255;
                    hashData[i++] = 255;
                    hashData[i++] = 255;
                    hashData[i++] = 255;
                  }
                  let hash = calculateMD5(hashData, 0, i);
                  const keyLengthInBytes = keyLength >> 3;
                  if (revision >= 3) {
                    for (j = 0; j < 50; ++j) {
                      hash = calculateMD5(hash, 0, keyLengthInBytes);
                    }
                  }
                  const encryptionKey = hash.subarray(0, keyLengthInBytes);
                  let cipher, checkData;
                  if (revision >= 3) {
                    for (i = 0; i < 32; ++i) {
                      hashData[i] = defaultPasswordBytes[i];
                    }
                    for (j = 0, n = fileId.length; j < n; ++j) {
                      hashData[i++] = fileId[j];
                    }
                    cipher = new ARCFourCipher(encryptionKey);
                    checkData = cipher.encryptBlock(calculateMD5(hashData, 0, i));
                    n = encryptionKey.length;
                    const derivedKey = new Uint8Array(n);
                    for (j = 1; j <= 19; ++j) {
                      for (let k = 0; k < n; ++k) {
                        derivedKey[k] = encryptionKey[k] ^ j;
                      }
                      cipher = new ARCFourCipher(derivedKey);
                      checkData = cipher.encryptBlock(checkData);
                    }
                    for (j = 0, n = checkData.length; j < n; ++j) {
                      if (userPassword[j] !== checkData[j]) {
                        return null;
                      }
                    }
                  } else {
                    cipher = new ARCFourCipher(encryptionKey);
                    checkData = cipher.encryptBlock(defaultPasswordBytes);
                    for (j = 0, n = checkData.length; j < n; ++j) {
                      if (userPassword[j] !== checkData[j]) {
                        return null;
                      }
                    }
                  }
                  return encryptionKey;
                }
                __name(prepareKeyData, "prepareKeyData");
                function decodeUserPassword(password, ownerPassword, revision, keyLength) {
                  const hashData = new Uint8Array(32);
                  let i = 0;
                  const n = Math.min(32, password.length);
                  for (; i < n; ++i) {
                    hashData[i] = password[i];
                  }
                  let j = 0;
                  while (i < 32) {
                    hashData[i++] = defaultPasswordBytes[j++];
                  }
                  let hash = calculateMD5(hashData, 0, i);
                  const keyLengthInBytes = keyLength >> 3;
                  if (revision >= 3) {
                    for (j = 0; j < 50; ++j) {
                      hash = calculateMD5(hash, 0, hash.length);
                    }
                  }
                  let cipher, userPassword;
                  if (revision >= 3) {
                    userPassword = ownerPassword;
                    const derivedKey = new Uint8Array(keyLengthInBytes);
                    for (j = 19; j >= 0; j--) {
                      for (let k = 0; k < keyLengthInBytes; ++k) {
                        derivedKey[k] = hash[k] ^ j;
                      }
                      cipher = new ARCFourCipher(derivedKey);
                      userPassword = cipher.encryptBlock(userPassword);
                    }
                  } else {
                    cipher = new ARCFourCipher(hash.subarray(0, keyLengthInBytes));
                    userPassword = cipher.encryptBlock(ownerPassword);
                  }
                  return userPassword;
                }
                __name(decodeUserPassword, "decodeUserPassword");
                const identityName = _primitives.Name.get("Identity");
                function buildObjectKey(num, gen, encryptionKey) {
                  let isAes = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
                  const key = new Uint8Array(encryptionKey.length + 9);
                  const n = encryptionKey.length;
                  let i;
                  for (i = 0; i < n; ++i) {
                    key[i] = encryptionKey[i];
                  }
                  key[i++] = num & 255;
                  key[i++] = num >> 8 & 255;
                  key[i++] = num >> 16 & 255;
                  key[i++] = gen & 255;
                  key[i++] = gen >> 8 & 255;
                  if (isAes) {
                    key[i++] = 115;
                    key[i++] = 65;
                    key[i++] = 108;
                    key[i++] = 84;
                  }
                  const hash = calculateMD5(key, 0, i);
                  return hash.subarray(0, Math.min(encryptionKey.length + 5, 16));
                }
                __name(buildObjectKey, "buildObjectKey");
                function buildCipherConstructor(cf, name, num, gen, key) {
                  if (!(name instanceof _primitives.Name)) {
                    throw new _util.FormatError("Invalid crypt filter name.");
                  }
                  const cryptFilter = cf.get(name.name);
                  let cfm;
                  if (cryptFilter !== null && cryptFilter !== void 0) {
                    cfm = cryptFilter.get("CFM");
                  }
                  if (!cfm || cfm.name === "None") {
                    return /* @__PURE__ */ __name(function cipherTransformFactoryBuildCipherConstructorNone() {
                      return new NullCipher();
                    }, "cipherTransformFactoryBuildCipherConstructorNone");
                  }
                  if (cfm.name === "V2") {
                    return /* @__PURE__ */ __name(function cipherTransformFactoryBuildCipherConstructorV2() {
                      return new ARCFourCipher(buildObjectKey(num, gen, key, false));
                    }, "cipherTransformFactoryBuildCipherConstructorV2");
                  }
                  if (cfm.name === "AESV2") {
                    return /* @__PURE__ */ __name(function cipherTransformFactoryBuildCipherConstructorAESV2() {
                      return new AES128Cipher(buildObjectKey(num, gen, key, true));
                    }, "cipherTransformFactoryBuildCipherConstructorAESV2");
                  }
                  if (cfm.name === "AESV3") {
                    return /* @__PURE__ */ __name(function cipherTransformFactoryBuildCipherConstructorAESV3() {
                      return new AES256Cipher(key);
                    }, "cipherTransformFactoryBuildCipherConstructorAESV3");
                  }
                  throw new _util.FormatError("Unknown crypto method");
                }
                __name(buildCipherConstructor, "buildCipherConstructor");
                const _CipherTransformFactory = class _CipherTransformFactory {
                  constructor(dict, fileId, password) {
                    const filter = dict.get("Filter");
                    if (!(0, _primitives.isName)(filter, "Standard")) {
                      throw new _util.FormatError("unknown encryption method");
                    }
                    this.filterName = filter.name;
                    this.dict = dict;
                    const algorithm = dict.get("V");
                    if (!Number.isInteger(algorithm) || algorithm !== 1 && algorithm !== 2 && algorithm !== 4 && algorithm !== 5) {
                      throw new _util.FormatError("unsupported encryption algorithm");
                    }
                    this.algorithm = algorithm;
                    let keyLength = dict.get("Length");
                    if (!keyLength) {
                      if (algorithm <= 3) {
                        keyLength = 40;
                      } else {
                        const cfDict = dict.get("CF");
                        const streamCryptoName = dict.get("StmF");
                        if (cfDict instanceof _primitives.Dict && streamCryptoName instanceof _primitives.Name) {
                          cfDict.suppressEncryption = true;
                          const handlerDict = cfDict.get(streamCryptoName.name);
                          keyLength = handlerDict && handlerDict.get("Length") || 128;
                          if (keyLength < 40) {
                            keyLength <<= 3;
                          }
                        }
                      }
                    }
                    if (!Number.isInteger(keyLength) || keyLength < 40 || keyLength % 8 !== 0) {
                      throw new _util.FormatError("invalid key length");
                    }
                    const ownerPassword = (0, _util.stringToBytes)(dict.get("O")).subarray(0, 32);
                    const userPassword = (0, _util.stringToBytes)(dict.get("U")).subarray(0, 32);
                    const flags = dict.get("P");
                    const revision = dict.get("R");
                    const encryptMetadata = (algorithm === 4 || algorithm === 5) && dict.get("EncryptMetadata") !== false;
                    this.encryptMetadata = encryptMetadata;
                    const fileIdBytes = (0, _util.stringToBytes)(fileId);
                    let passwordBytes;
                    if (password) {
                      if (revision === 6) {
                        try {
                          password = (0, _util.utf8StringToString)(password);
                        } catch (ex) {
                          (0, _util.warn)("CipherTransformFactory: Unable to convert UTF8 encoded password.");
                        }
                      }
                      passwordBytes = (0, _util.stringToBytes)(password);
                    }
                    let encryptionKey;
                    if (algorithm !== 5) {
                      encryptionKey = prepareKeyData(fileIdBytes, passwordBytes, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata);
                    } else {
                      const ownerValidationSalt = (0, _util.stringToBytes)(dict.get("O")).subarray(32, 40);
                      const ownerKeySalt = (0, _util.stringToBytes)(dict.get("O")).subarray(40, 48);
                      const uBytes = (0, _util.stringToBytes)(dict.get("U")).subarray(0, 48);
                      const userValidationSalt = (0, _util.stringToBytes)(dict.get("U")).subarray(32, 40);
                      const userKeySalt = (0, _util.stringToBytes)(dict.get("U")).subarray(40, 48);
                      const ownerEncryption = (0, _util.stringToBytes)(dict.get("OE"));
                      const userEncryption = (0, _util.stringToBytes)(dict.get("UE"));
                      (0, _util.stringToBytes)(dict.get("Perms"));
                      encryptionKey = createEncryptionKey20(revision, passwordBytes, ownerPassword, ownerValidationSalt, ownerKeySalt, uBytes, userPassword, userValidationSalt, userKeySalt, ownerEncryption, userEncryption);
                    }
                    if (!encryptionKey && !password) {
                      throw new _util.PasswordException("No password given", _util.PasswordResponses.NEED_PASSWORD);
                    } else if (!encryptionKey && password) {
                      const decodedPassword = decodeUserPassword(passwordBytes, ownerPassword, revision, keyLength);
                      encryptionKey = prepareKeyData(fileIdBytes, decodedPassword, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata);
                    }
                    if (!encryptionKey) {
                      throw new _util.PasswordException("Incorrect Password", _util.PasswordResponses.INCORRECT_PASSWORD);
                    }
                    this.encryptionKey = encryptionKey;
                    if (algorithm >= 4) {
                      const cf = dict.get("CF");
                      if (cf instanceof _primitives.Dict) {
                        cf.suppressEncryption = true;
                      }
                      this.cf = cf;
                      this.stmf = dict.get("StmF") || identityName;
                      this.strf = dict.get("StrF") || identityName;
                      this.eff = dict.get("EFF") || this.stmf;
                    }
                  }
                  createCipherTransform(num, gen) {
                    if (this.algorithm === 4 || this.algorithm === 5) {
                      return new CipherTransform(buildCipherConstructor(this.cf, this.strf, num, gen, this.encryptionKey), buildCipherConstructor(this.cf, this.stmf, num, gen, this.encryptionKey));
                    }
                    const key = buildObjectKey(num, gen, this.encryptionKey, false);
                    const cipherConstructor = /* @__PURE__ */ __name(function buildCipherCipherConstructor() {
                      return new ARCFourCipher(key);
                    }, "buildCipherCipherConstructor");
                    return new CipherTransform(cipherConstructor, cipherConstructor);
                  }
                };
                __name(_CipherTransformFactory, "CipherTransformFactory");
                let CipherTransformFactory2 = _CipherTransformFactory;
                return CipherTransformFactory2;
              }, "CipherTransformFactoryClosure"))();
              exports2.CipherTransformFactory = CipherTransformFactory;
            },
            /* 193 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.DecryptStream = void 0;
              var _decode_stream = __w_pdfjs_require__2(144);
              const chunkSize = 512;
              const _DecryptStream = class _DecryptStream extends _decode_stream.DecodeStream {
                constructor(str, maybeLength, decrypt) {
                  super(maybeLength);
                  this.str = str;
                  this.dict = str.dict;
                  this.decrypt = decrypt;
                  this.nextChunk = null;
                  this.initialized = false;
                }
                readBlock() {
                  let chunk;
                  if (this.initialized) {
                    chunk = this.nextChunk;
                  } else {
                    chunk = this.str.getBytes(chunkSize);
                    this.initialized = true;
                  }
                  if (!chunk || chunk.length === 0) {
                    this.eof = true;
                    return;
                  }
                  this.nextChunk = this.str.getBytes(chunkSize);
                  const hasMoreData = this.nextChunk && this.nextChunk.length > 0;
                  const decrypt = this.decrypt;
                  chunk = decrypt(chunk, !hasMoreData);
                  let bufferLength = this.bufferLength;
                  const n = chunk.length, buffer = this.ensureBuffer(bufferLength + n);
                  for (let i = 0; i < n; i++) {
                    buffer[bufferLength++] = chunk[i];
                  }
                  this.bufferLength = bufferLength;
                }
              };
              __name(_DecryptStream, "DecryptStream");
              let DecryptStream = _DecryptStream;
              exports2.DecryptStream = DecryptStream;
            },
            /* 194 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Catalog = void 0;
              var _core_utils = __w_pdfjs_require__2(131);
              var _util = __w_pdfjs_require__2(2);
              var _primitives = __w_pdfjs_require__2(130);
              var _name_number_tree = __w_pdfjs_require__2(195);
              var _base_stream = __w_pdfjs_require__2(132);
              var _cleanup_helper = __w_pdfjs_require__2(196);
              var _colorspace = __w_pdfjs_require__2(139);
              var _file_spec = __w_pdfjs_require__2(197);
              var _image_utils = __w_pdfjs_require__2(184);
              var _metadata_parser = __w_pdfjs_require__2(198);
              var _struct_tree = __w_pdfjs_require__2(199);
              function fetchDestination(dest) {
                if (dest instanceof _primitives.Dict) {
                  dest = dest.get("D");
                }
                return Array.isArray(dest) ? dest : null;
              }
              __name(fetchDestination, "fetchDestination");
              const _Catalog = class _Catalog {
                constructor(pdfManager, xref) {
                  this.pdfManager = pdfManager;
                  this.xref = xref;
                  this._catDict = xref.getCatalogObj();
                  if (!(this._catDict instanceof _primitives.Dict)) {
                    throw new _util.FormatError("Catalog object is not a dictionary.");
                  }
                  this.toplevelPagesDict;
                  this._actualNumPages = null;
                  this.fontCache = new _primitives.RefSetCache();
                  this.builtInCMapCache = /* @__PURE__ */ new Map();
                  this.standardFontDataCache = /* @__PURE__ */ new Map();
                  this.globalImageCache = new _image_utils.GlobalImageCache();
                  this.pageKidsCountCache = new _primitives.RefSetCache();
                  this.pageIndexCache = new _primitives.RefSetCache();
                  this.nonBlendModesSet = new _primitives.RefSet();
                }
                get version() {
                  const version = this._catDict.get("Version");
                  return (0, _util.shadow)(this, "version", version instanceof _primitives.Name ? version.name : null);
                }
                get lang() {
                  const lang = this._catDict.get("Lang");
                  return (0, _util.shadow)(this, "lang", typeof lang === "string" ? (0, _util.stringToPDFString)(lang) : null);
                }
                get needsRendering() {
                  const needsRendering = this._catDict.get("NeedsRendering");
                  return (0, _util.shadow)(this, "needsRendering", typeof needsRendering === "boolean" ? needsRendering : false);
                }
                get collection() {
                  let collection = null;
                  try {
                    const obj = this._catDict.get("Collection");
                    if (obj instanceof _primitives.Dict && obj.size > 0) {
                      collection = obj;
                    }
                  } catch (ex) {
                    if (ex instanceof _core_utils.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.info)("Cannot fetch Collection entry; assuming no collection is present.");
                  }
                  return (0, _util.shadow)(this, "collection", collection);
                }
                get acroForm() {
                  let acroForm = null;
                  try {
                    const obj = this._catDict.get("AcroForm");
                    if (obj instanceof _primitives.Dict && obj.size > 0) {
                      acroForm = obj;
                    }
                  } catch (ex) {
                    if (ex instanceof _core_utils.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.info)("Cannot fetch AcroForm entry; assuming no forms are present.");
                  }
                  return (0, _util.shadow)(this, "acroForm", acroForm);
                }
                get acroFormRef() {
                  const value = this._catDict.getRaw("AcroForm");
                  return (0, _util.shadow)(this, "acroFormRef", value instanceof _primitives.Ref ? value : null);
                }
                get metadata() {
                  const streamRef = this._catDict.getRaw("Metadata");
                  if (!(streamRef instanceof _primitives.Ref)) {
                    return (0, _util.shadow)(this, "metadata", null);
                  }
                  let metadata = null;
                  try {
                    const suppressEncryption = !(this.xref.encrypt && this.xref.encrypt.encryptMetadata);
                    const stream = this.xref.fetch(streamRef, suppressEncryption);
                    if (stream instanceof _base_stream.BaseStream && stream.dict instanceof _primitives.Dict) {
                      const type = stream.dict.get("Type");
                      const subtype = stream.dict.get("Subtype");
                      if ((0, _primitives.isName)(type, "Metadata") && (0, _primitives.isName)(subtype, "XML")) {
                        const data = (0, _util.stringToUTF8String)(stream.getString());
                        if (data) {
                          metadata = new _metadata_parser.MetadataParser(data).serializable;
                        }
                      }
                    }
                  } catch (ex) {
                    if (ex instanceof _core_utils.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.info)(`Skipping invalid Metadata: "${ex}".`);
                  }
                  return (0, _util.shadow)(this, "metadata", metadata);
                }
                get markInfo() {
                  let markInfo = null;
                  try {
                    markInfo = this._readMarkInfo();
                  } catch (ex) {
                    if (ex instanceof _core_utils.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.warn)("Unable to read mark info.");
                  }
                  return (0, _util.shadow)(this, "markInfo", markInfo);
                }
                _readMarkInfo() {
                  const obj = this._catDict.get("MarkInfo");
                  if (!(obj instanceof _primitives.Dict)) {
                    return null;
                  }
                  const markInfo = {
                    Marked: false,
                    UserProperties: false,
                    Suspects: false
                  };
                  for (const key in markInfo) {
                    const value = obj.get(key);
                    if (typeof value === "boolean") {
                      markInfo[key] = value;
                    }
                  }
                  return markInfo;
                }
                get structTreeRoot() {
                  let structTree = null;
                  try {
                    structTree = this._readStructTreeRoot();
                  } catch (ex) {
                    if (ex instanceof _core_utils.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.warn)("Unable read to structTreeRoot info.");
                  }
                  return (0, _util.shadow)(this, "structTreeRoot", structTree);
                }
                _readStructTreeRoot() {
                  const obj = this._catDict.get("StructTreeRoot");
                  if (!(obj instanceof _primitives.Dict)) {
                    return null;
                  }
                  const root = new _struct_tree.StructTreeRoot(obj);
                  root.init();
                  return root;
                }
                get toplevelPagesDict() {
                  const pagesObj = this._catDict.get("Pages");
                  if (!(pagesObj instanceof _primitives.Dict)) {
                    throw new _util.FormatError("Invalid top-level pages dictionary.");
                  }
                  return (0, _util.shadow)(this, "toplevelPagesDict", pagesObj);
                }
                get documentOutline() {
                  let obj = null;
                  try {
                    obj = this._readDocumentOutline();
                  } catch (ex) {
                    if (ex instanceof _core_utils.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.warn)("Unable to read document outline.");
                  }
                  return (0, _util.shadow)(this, "documentOutline", obj);
                }
                _readDocumentOutline() {
                  let obj = this._catDict.get("Outlines");
                  if (!(obj instanceof _primitives.Dict)) {
                    return null;
                  }
                  obj = obj.getRaw("First");
                  if (!(obj instanceof _primitives.Ref)) {
                    return null;
                  }
                  const root = {
                    items: []
                  };
                  const queue = [{
                    obj,
                    parent: root
                  }];
                  const processed = new _primitives.RefSet();
                  processed.put(obj);
                  const xref = this.xref, blackColor = new Uint8ClampedArray(3);
                  while (queue.length > 0) {
                    const i = queue.shift();
                    const outlineDict = xref.fetchIfRef(i.obj);
                    if (outlineDict === null) {
                      continue;
                    }
                    if (!outlineDict.has("Title")) {
                      throw new _util.FormatError("Invalid outline item encountered.");
                    }
                    const data = {
                      url: null,
                      dest: null
                    };
                    _Catalog.parseDestDictionary({
                      destDict: outlineDict,
                      resultObj: data,
                      docBaseUrl: this.pdfManager.docBaseUrl
                    });
                    const title = outlineDict.get("Title");
                    const flags = outlineDict.get("F") || 0;
                    const color = outlineDict.getArray("C");
                    const count = outlineDict.get("Count");
                    let rgbColor = blackColor;
                    if (Array.isArray(color) && color.length === 3 && (color[0] !== 0 || color[1] !== 0 || color[2] !== 0)) {
                      rgbColor = _colorspace.ColorSpace.singletons.rgb.getRgb(color, 0);
                    }
                    const outlineItem = {
                      dest: data.dest,
                      url: data.url,
                      unsafeUrl: data.unsafeUrl,
                      newWindow: data.newWindow,
                      title: (0, _util.stringToPDFString)(title),
                      color: rgbColor,
                      count: Number.isInteger(count) ? count : void 0,
                      bold: !!(flags & 2),
                      italic: !!(flags & 1),
                      items: []
                    };
                    i.parent.items.push(outlineItem);
                    obj = outlineDict.getRaw("First");
                    if (obj instanceof _primitives.Ref && !processed.has(obj)) {
                      queue.push({
                        obj,
                        parent: outlineItem
                      });
                      processed.put(obj);
                    }
                    obj = outlineDict.getRaw("Next");
                    if (obj instanceof _primitives.Ref && !processed.has(obj)) {
                      queue.push({
                        obj,
                        parent: i.parent
                      });
                      processed.put(obj);
                    }
                  }
                  return root.items.length > 0 ? root.items : null;
                }
                get permissions() {
                  let permissions = null;
                  try {
                    permissions = this._readPermissions();
                  } catch (ex) {
                    if (ex instanceof _core_utils.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.warn)("Unable to read permissions.");
                  }
                  return (0, _util.shadow)(this, "permissions", permissions);
                }
                _readPermissions() {
                  const encrypt = this.xref.trailer.get("Encrypt");
                  if (!(encrypt instanceof _primitives.Dict)) {
                    return null;
                  }
                  let flags = encrypt.get("P");
                  if (typeof flags !== "number") {
                    return null;
                  }
                  flags += 2 ** 32;
                  const permissions = [];
                  for (const key in _util.PermissionFlag) {
                    const value = _util.PermissionFlag[key];
                    if (flags & value) {
                      permissions.push(value);
                    }
                  }
                  return permissions;
                }
                get optionalContentConfig() {
                  let config = null;
                  try {
                    const properties = this._catDict.get("OCProperties");
                    if (!properties) {
                      return (0, _util.shadow)(this, "optionalContentConfig", null);
                    }
                    const defaultConfig = properties.get("D");
                    if (!defaultConfig) {
                      return (0, _util.shadow)(this, "optionalContentConfig", null);
                    }
                    const groupsData = properties.get("OCGs");
                    if (!Array.isArray(groupsData)) {
                      return (0, _util.shadow)(this, "optionalContentConfig", null);
                    }
                    const groups = [];
                    const groupRefs = [];
                    for (const groupRef of groupsData) {
                      if (!(groupRef instanceof _primitives.Ref)) {
                        continue;
                      }
                      groupRefs.push(groupRef);
                      const group = this.xref.fetchIfRef(groupRef);
                      groups.push({
                        id: groupRef.toString(),
                        name: typeof group.get("Name") === "string" ? (0, _util.stringToPDFString)(group.get("Name")) : null,
                        intent: typeof group.get("Intent") === "string" ? (0, _util.stringToPDFString)(group.get("Intent")) : null
                      });
                    }
                    config = this._readOptionalContentConfig(defaultConfig, groupRefs);
                    config.groups = groups;
                  } catch (ex) {
                    if (ex instanceof _core_utils.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.warn)(`Unable to read optional content config: ${ex}`);
                  }
                  return (0, _util.shadow)(this, "optionalContentConfig", config);
                }
                _readOptionalContentConfig(config, contentGroupRefs) {
                  function parseOnOff(refs) {
                    const onParsed = [];
                    if (Array.isArray(refs)) {
                      for (const value of refs) {
                        if (!(value instanceof _primitives.Ref)) {
                          continue;
                        }
                        if (contentGroupRefs.includes(value)) {
                          onParsed.push(value.toString());
                        }
                      }
                    }
                    return onParsed;
                  }
                  __name(parseOnOff, "parseOnOff");
                  function parseOrder(refs) {
                    let nestedLevels = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
                    if (!Array.isArray(refs)) {
                      return null;
                    }
                    const order = [];
                    for (const value of refs) {
                      if (value instanceof _primitives.Ref && contentGroupRefs.includes(value)) {
                        parsedOrderRefs.put(value);
                        order.push(value.toString());
                        continue;
                      }
                      const nestedOrder = parseNestedOrder(value, nestedLevels);
                      if (nestedOrder) {
                        order.push(nestedOrder);
                      }
                    }
                    if (nestedLevels > 0) {
                      return order;
                    }
                    const hiddenGroups = [];
                    for (const groupRef of contentGroupRefs) {
                      if (parsedOrderRefs.has(groupRef)) {
                        continue;
                      }
                      hiddenGroups.push(groupRef.toString());
                    }
                    if (hiddenGroups.length) {
                      order.push({
                        name: null,
                        order: hiddenGroups
                      });
                    }
                    return order;
                  }
                  __name(parseOrder, "parseOrder");
                  function parseNestedOrder(ref, nestedLevels) {
                    if (++nestedLevels > MAX_NESTED_LEVELS) {
                      (0, _util.warn)("parseNestedOrder - reached MAX_NESTED_LEVELS.");
                      return null;
                    }
                    const value = xref.fetchIfRef(ref);
                    if (!Array.isArray(value)) {
                      return null;
                    }
                    const nestedName = xref.fetchIfRef(value[0]);
                    if (typeof nestedName !== "string") {
                      return null;
                    }
                    const nestedOrder = parseOrder(value.slice(1), nestedLevels);
                    if (!nestedOrder || !nestedOrder.length) {
                      return null;
                    }
                    return {
                      name: (0, _util.stringToPDFString)(nestedName),
                      order: nestedOrder
                    };
                  }
                  __name(parseNestedOrder, "parseNestedOrder");
                  const xref = this.xref, parsedOrderRefs = new _primitives.RefSet(), MAX_NESTED_LEVELS = 10;
                  return {
                    name: typeof config.get("Name") === "string" ? (0, _util.stringToPDFString)(config.get("Name")) : null,
                    creator: typeof config.get("Creator") === "string" ? (0, _util.stringToPDFString)(config.get("Creator")) : null,
                    baseState: config.get("BaseState") instanceof _primitives.Name ? config.get("BaseState").name : null,
                    on: parseOnOff(config.get("ON")),
                    off: parseOnOff(config.get("OFF")),
                    order: parseOrder(config.get("Order")),
                    groups: null
                  };
                }
                setActualNumPages() {
                  let num = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                  this._actualNumPages = num;
                }
                get hasActualNumPages() {
                  return this._actualNumPages !== null;
                }
                get _pagesCount() {
                  const obj = this.toplevelPagesDict.get("Count");
                  if (!Number.isInteger(obj)) {
                    throw new _util.FormatError("Page count in top-level pages dictionary is not an integer.");
                  }
                  return (0, _util.shadow)(this, "_pagesCount", obj);
                }
                get numPages() {
                  return this.hasActualNumPages ? this._actualNumPages : this._pagesCount;
                }
                get destinations() {
                  const obj = this._readDests(), dests = /* @__PURE__ */ Object.create(null);
                  if (obj instanceof _name_number_tree.NameTree) {
                    for (const [key, value] of obj.getAll()) {
                      const dest = fetchDestination(value);
                      if (dest) {
                        dests[(0, _util.stringToPDFString)(key)] = dest;
                      }
                    }
                  } else if (obj instanceof _primitives.Dict) {
                    obj.forEach(function(key, value) {
                      const dest = fetchDestination(value);
                      if (dest) {
                        dests[key] = dest;
                      }
                    });
                  }
                  return (0, _util.shadow)(this, "destinations", dests);
                }
                getDestination(id) {
                  const obj = this._readDests();
                  if (obj instanceof _name_number_tree.NameTree) {
                    const dest = fetchDestination(obj.get(id));
                    if (dest) {
                      return dest;
                    }
                    const allDest = this.destinations[id];
                    if (allDest) {
                      (0, _util.warn)(`Found "${id}" at an incorrect position in the NameTree.`);
                      return allDest;
                    }
                  } else if (obj instanceof _primitives.Dict) {
                    const dest = fetchDestination(obj.get(id));
                    if (dest) {
                      return dest;
                    }
                  }
                  return null;
                }
                _readDests() {
                  const obj = this._catDict.get("Names");
                  if (obj && obj.has("Dests")) {
                    return new _name_number_tree.NameTree(obj.getRaw("Dests"), this.xref);
                  } else if (this._catDict.has("Dests")) {
                    return this._catDict.get("Dests");
                  }
                  return void 0;
                }
                get pageLabels() {
                  let obj = null;
                  try {
                    obj = this._readPageLabels();
                  } catch (ex) {
                    if (ex instanceof _core_utils.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.warn)("Unable to read page labels.");
                  }
                  return (0, _util.shadow)(this, "pageLabels", obj);
                }
                _readPageLabels() {
                  const obj = this._catDict.getRaw("PageLabels");
                  if (!obj) {
                    return null;
                  }
                  const pageLabels = new Array(this.numPages);
                  let style = null, prefix = "";
                  const numberTree = new _name_number_tree.NumberTree(obj, this.xref);
                  const nums = numberTree.getAll();
                  let currentLabel = "", currentIndex = 1;
                  for (let i = 0, ii = this.numPages; i < ii; i++) {
                    const labelDict = nums.get(i);
                    if (labelDict !== void 0) {
                      if (!(labelDict instanceof _primitives.Dict)) {
                        throw new _util.FormatError("PageLabel is not a dictionary.");
                      }
                      if (labelDict.has("Type") && !(0, _primitives.isName)(labelDict.get("Type"), "PageLabel")) {
                        throw new _util.FormatError("Invalid type in PageLabel dictionary.");
                      }
                      if (labelDict.has("S")) {
                        const s = labelDict.get("S");
                        if (!(s instanceof _primitives.Name)) {
                          throw new _util.FormatError("Invalid style in PageLabel dictionary.");
                        }
                        style = s.name;
                      } else {
                        style = null;
                      }
                      if (labelDict.has("P")) {
                        const p = labelDict.get("P");
                        if (typeof p !== "string") {
                          throw new _util.FormatError("Invalid prefix in PageLabel dictionary.");
                        }
                        prefix = (0, _util.stringToPDFString)(p);
                      } else {
                        prefix = "";
                      }
                      if (labelDict.has("St")) {
                        const st = labelDict.get("St");
                        if (!(Number.isInteger(st) && st >= 1)) {
                          throw new _util.FormatError("Invalid start in PageLabel dictionary.");
                        }
                        currentIndex = st;
                      } else {
                        currentIndex = 1;
                      }
                    }
                    switch (style) {
                      case "D":
                        currentLabel = currentIndex;
                        break;
                      case "R":
                      case "r":
                        currentLabel = (0, _core_utils.toRomanNumerals)(currentIndex, style === "r");
                        break;
                      case "A":
                      case "a":
                        const LIMIT = 26;
                        const A_UPPER_CASE = 65, A_LOWER_CASE = 97;
                        const baseCharCode = style === "a" ? A_LOWER_CASE : A_UPPER_CASE;
                        const letterIndex = currentIndex - 1;
                        const character = String.fromCharCode(baseCharCode + letterIndex % LIMIT);
                        currentLabel = character.repeat(Math.floor(letterIndex / LIMIT) + 1);
                        break;
                      default:
                        if (style) {
                          throw new _util.FormatError(`Invalid style "${style}" in PageLabel dictionary.`);
                        }
                        currentLabel = "";
                    }
                    pageLabels[i] = prefix + currentLabel;
                    currentIndex++;
                  }
                  return pageLabels;
                }
                get pageLayout() {
                  const obj = this._catDict.get("PageLayout");
                  let pageLayout = "";
                  if (obj instanceof _primitives.Name) {
                    switch (obj.name) {
                      case "SinglePage":
                      case "OneColumn":
                      case "TwoColumnLeft":
                      case "TwoColumnRight":
                      case "TwoPageLeft":
                      case "TwoPageRight":
                        pageLayout = obj.name;
                    }
                  }
                  return (0, _util.shadow)(this, "pageLayout", pageLayout);
                }
                get pageMode() {
                  const obj = this._catDict.get("PageMode");
                  let pageMode = "UseNone";
                  if (obj instanceof _primitives.Name) {
                    switch (obj.name) {
                      case "UseNone":
                      case "UseOutlines":
                      case "UseThumbs":
                      case "FullScreen":
                      case "UseOC":
                      case "UseAttachments":
                        pageMode = obj.name;
                    }
                  }
                  return (0, _util.shadow)(this, "pageMode", pageMode);
                }
                get viewerPreferences() {
                  const obj = this._catDict.get("ViewerPreferences");
                  if (!(obj instanceof _primitives.Dict)) {
                    return (0, _util.shadow)(this, "viewerPreferences", null);
                  }
                  let prefs = null;
                  for (const key of obj.getKeys()) {
                    const value = obj.get(key);
                    let prefValue;
                    switch (key) {
                      case "HideToolbar":
                      case "HideMenubar":
                      case "HideWindowUI":
                      case "FitWindow":
                      case "CenterWindow":
                      case "DisplayDocTitle":
                      case "PickTrayByPDFSize":
                        if (typeof value === "boolean") {
                          prefValue = value;
                        }
                        break;
                      case "NonFullScreenPageMode":
                        if (value instanceof _primitives.Name) {
                          switch (value.name) {
                            case "UseNone":
                            case "UseOutlines":
                            case "UseThumbs":
                            case "UseOC":
                              prefValue = value.name;
                              break;
                            default:
                              prefValue = "UseNone";
                          }
                        }
                        break;
                      case "Direction":
                        if (value instanceof _primitives.Name) {
                          switch (value.name) {
                            case "L2R":
                            case "R2L":
                              prefValue = value.name;
                              break;
                            default:
                              prefValue = "L2R";
                          }
                        }
                        break;
                      case "ViewArea":
                      case "ViewClip":
                      case "PrintArea":
                      case "PrintClip":
                        if (value instanceof _primitives.Name) {
                          switch (value.name) {
                            case "MediaBox":
                            case "CropBox":
                            case "BleedBox":
                            case "TrimBox":
                            case "ArtBox":
                              prefValue = value.name;
                              break;
                            default:
                              prefValue = "CropBox";
                          }
                        }
                        break;
                      case "PrintScaling":
                        if (value instanceof _primitives.Name) {
                          switch (value.name) {
                            case "None":
                            case "AppDefault":
                              prefValue = value.name;
                              break;
                            default:
                              prefValue = "AppDefault";
                          }
                        }
                        break;
                      case "Duplex":
                        if (value instanceof _primitives.Name) {
                          switch (value.name) {
                            case "Simplex":
                            case "DuplexFlipShortEdge":
                            case "DuplexFlipLongEdge":
                              prefValue = value.name;
                              break;
                            default:
                              prefValue = "None";
                          }
                        }
                        break;
                      case "PrintPageRange":
                        if (Array.isArray(value) && value.length % 2 === 0) {
                          const isValid = value.every((page, i, arr) => {
                            return Number.isInteger(page) && page > 0 && (i === 0 || page >= arr[i - 1]) && page <= this.numPages;
                          });
                          if (isValid) {
                            prefValue = value;
                          }
                        }
                        break;
                      case "NumCopies":
                        if (Number.isInteger(value) && value > 0) {
                          prefValue = value;
                        }
                        break;
                      default:
                        (0, _util.warn)(`Ignoring non-standard key in ViewerPreferences: ${key}.`);
                        continue;
                    }
                    if (prefValue === void 0) {
                      (0, _util.warn)(`Bad value, for key "${key}", in ViewerPreferences: ${value}.`);
                      continue;
                    }
                    if (!prefs) {
                      prefs = /* @__PURE__ */ Object.create(null);
                    }
                    prefs[key] = prefValue;
                  }
                  return (0, _util.shadow)(this, "viewerPreferences", prefs);
                }
                get openAction() {
                  const obj = this._catDict.get("OpenAction");
                  const openAction = /* @__PURE__ */ Object.create(null);
                  if (obj instanceof _primitives.Dict) {
                    const destDict = new _primitives.Dict(this.xref);
                    destDict.set("A", obj);
                    const resultObj = {
                      url: null,
                      dest: null,
                      action: null
                    };
                    _Catalog.parseDestDictionary({
                      destDict,
                      resultObj
                    });
                    if (Array.isArray(resultObj.dest)) {
                      openAction.dest = resultObj.dest;
                    } else if (resultObj.action) {
                      openAction.action = resultObj.action;
                    }
                  } else if (Array.isArray(obj)) {
                    openAction.dest = obj;
                  }
                  return (0, _util.shadow)(this, "openAction", (0, _util.objectSize)(openAction) > 0 ? openAction : null);
                }
                get attachments() {
                  const obj = this._catDict.get("Names");
                  let attachments = null;
                  if (obj instanceof _primitives.Dict && obj.has("EmbeddedFiles")) {
                    const nameTree = new _name_number_tree.NameTree(obj.getRaw("EmbeddedFiles"), this.xref);
                    for (const [key, value] of nameTree.getAll()) {
                      const fs = new _file_spec.FileSpec(value, this.xref);
                      if (!attachments) {
                        attachments = /* @__PURE__ */ Object.create(null);
                      }
                      attachments[(0, _util.stringToPDFString)(key)] = fs.serializable;
                    }
                  }
                  return (0, _util.shadow)(this, "attachments", attachments);
                }
                get xfaImages() {
                  const obj = this._catDict.get("Names");
                  let xfaImages = null;
                  if (obj instanceof _primitives.Dict && obj.has("XFAImages")) {
                    const nameTree = new _name_number_tree.NameTree(obj.getRaw("XFAImages"), this.xref);
                    for (const [key, value] of nameTree.getAll()) {
                      if (!xfaImages) {
                        xfaImages = new _primitives.Dict(this.xref);
                      }
                      xfaImages.set((0, _util.stringToPDFString)(key), value);
                    }
                  }
                  return (0, _util.shadow)(this, "xfaImages", xfaImages);
                }
                _collectJavaScript() {
                  const obj = this._catDict.get("Names");
                  let javaScript = null;
                  function appendIfJavaScriptDict(name, jsDict) {
                    if (!(jsDict instanceof _primitives.Dict)) {
                      return;
                    }
                    if (!(0, _primitives.isName)(jsDict.get("S"), "JavaScript")) {
                      return;
                    }
                    let js = jsDict.get("JS");
                    if (js instanceof _base_stream.BaseStream) {
                      js = js.getString();
                    } else if (typeof js !== "string") {
                      return;
                    }
                    if (javaScript === null) {
                      javaScript = /* @__PURE__ */ new Map();
                    }
                    js = (0, _util.stringToPDFString)(js).replace(/\u0000/g, "");
                    javaScript.set(name, js);
                  }
                  __name(appendIfJavaScriptDict, "appendIfJavaScriptDict");
                  if (obj instanceof _primitives.Dict && obj.has("JavaScript")) {
                    const nameTree = new _name_number_tree.NameTree(obj.getRaw("JavaScript"), this.xref);
                    for (const [key, value] of nameTree.getAll()) {
                      appendIfJavaScriptDict((0, _util.stringToPDFString)(key), value);
                    }
                  }
                  const openAction = this._catDict.get("OpenAction");
                  if (openAction) {
                    appendIfJavaScriptDict("OpenAction", openAction);
                  }
                  return javaScript;
                }
                get javaScript() {
                  const javaScript = this._collectJavaScript();
                  return (0, _util.shadow)(this, "javaScript", javaScript ? [...javaScript.values()] : null);
                }
                get jsActions() {
                  const javaScript = this._collectJavaScript();
                  let actions = (0, _core_utils.collectActions)(this.xref, this._catDict, _util.DocumentActionEventType);
                  if (javaScript) {
                    if (!actions) {
                      actions = /* @__PURE__ */ Object.create(null);
                    }
                    for (const [key, val] of javaScript) {
                      if (key in actions) {
                        actions[key].push(val);
                      } else {
                        actions[key] = [val];
                      }
                    }
                  }
                  return (0, _util.shadow)(this, "jsActions", actions);
                }
                async fontFallback(id, handler) {
                  const translatedFonts = await Promise.all(this.fontCache);
                  for (const translatedFont of translatedFonts) {
                    if (translatedFont.loadedName === id) {
                      translatedFont.fallback(handler);
                      return;
                    }
                  }
                }
                async cleanup() {
                  let manuallyTriggered = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  (0, _cleanup_helper.clearGlobalCaches)();
                  this.globalImageCache.clear(manuallyTriggered);
                  this.pageKidsCountCache.clear();
                  this.pageIndexCache.clear();
                  this.nonBlendModesSet.clear();
                  const translatedFonts = await Promise.all(this.fontCache);
                  for (const {
                    dict
                  } of translatedFonts) {
                    delete dict.cacheKey;
                  }
                  this.fontCache.clear();
                  this.builtInCMapCache.clear();
                  this.standardFontDataCache.clear();
                }
                async getPageDict(pageIndex) {
                  const nodesToVisit = [this.toplevelPagesDict];
                  const visitedNodes = new _primitives.RefSet();
                  const pagesRef = this._catDict.getRaw("Pages");
                  if (pagesRef instanceof _primitives.Ref) {
                    visitedNodes.put(pagesRef);
                  }
                  const xref = this.xref, pageKidsCountCache = this.pageKidsCountCache, pageIndexCache = this.pageIndexCache;
                  let currentPageIndex = 0;
                  while (nodesToVisit.length) {
                    const currentNode = nodesToVisit.pop();
                    if (currentNode instanceof _primitives.Ref) {
                      const count2 = pageKidsCountCache.get(currentNode);
                      if (count2 >= 0 && currentPageIndex + count2 <= pageIndex) {
                        currentPageIndex += count2;
                        continue;
                      }
                      if (visitedNodes.has(currentNode)) {
                        throw new _util.FormatError("Pages tree contains circular reference.");
                      }
                      visitedNodes.put(currentNode);
                      const obj = await xref.fetchAsync(currentNode);
                      if (obj instanceof _primitives.Dict) {
                        let type = obj.getRaw("Type");
                        if (type instanceof _primitives.Ref) {
                          type = await xref.fetchAsync(type);
                        }
                        if ((0, _primitives.isName)(type, "Page") || !obj.has("Kids")) {
                          if (!pageKidsCountCache.has(currentNode)) {
                            pageKidsCountCache.put(currentNode, 1);
                          }
                          if (!pageIndexCache.has(currentNode)) {
                            pageIndexCache.put(currentNode, currentPageIndex);
                          }
                          if (currentPageIndex === pageIndex) {
                            return [obj, currentNode];
                          }
                          currentPageIndex++;
                          continue;
                        }
                      }
                      nodesToVisit.push(obj);
                      continue;
                    }
                    if (!(currentNode instanceof _primitives.Dict)) {
                      throw new _util.FormatError("Page dictionary kid reference points to wrong type of object.");
                    }
                    const {
                      objId
                    } = currentNode;
                    let count = currentNode.getRaw("Count");
                    if (count instanceof _primitives.Ref) {
                      count = await xref.fetchAsync(count);
                    }
                    if (Number.isInteger(count) && count >= 0) {
                      if (objId && !pageKidsCountCache.has(objId)) {
                        pageKidsCountCache.put(objId, count);
                      }
                      if (currentPageIndex + count <= pageIndex) {
                        currentPageIndex += count;
                        continue;
                      }
                    }
                    let kids = currentNode.getRaw("Kids");
                    if (kids instanceof _primitives.Ref) {
                      kids = await xref.fetchAsync(kids);
                    }
                    if (!Array.isArray(kids)) {
                      let type = currentNode.getRaw("Type");
                      if (type instanceof _primitives.Ref) {
                        type = await xref.fetchAsync(type);
                      }
                      if ((0, _primitives.isName)(type, "Page") || !currentNode.has("Kids")) {
                        if (currentPageIndex === pageIndex) {
                          return [currentNode, null];
                        }
                        currentPageIndex++;
                        continue;
                      }
                      throw new _util.FormatError("Page dictionary kids object is not an array.");
                    }
                    for (let last = kids.length - 1; last >= 0; last--) {
                      nodesToVisit.push(kids[last]);
                    }
                  }
                  throw new Error(`Page index ${pageIndex} not found.`);
                }
                async getAllPageDicts() {
                  let recoveryMode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  const queue = [{
                    currentNode: this.toplevelPagesDict,
                    posInKids: 0
                  }];
                  const visitedNodes = new _primitives.RefSet();
                  const pagesRef = this._catDict.getRaw("Pages");
                  if (pagesRef instanceof _primitives.Ref) {
                    visitedNodes.put(pagesRef);
                  }
                  const map = /* @__PURE__ */ new Map(), xref = this.xref, pageIndexCache = this.pageIndexCache;
                  let pageIndex = 0;
                  function addPageDict(pageDict, pageRef) {
                    if (pageRef && !pageIndexCache.has(pageRef)) {
                      pageIndexCache.put(pageRef, pageIndex);
                    }
                    map.set(pageIndex++, [pageDict, pageRef]);
                  }
                  __name(addPageDict, "addPageDict");
                  function addPageError(error) {
                    if (error instanceof _core_utils.XRefEntryException && !recoveryMode) {
                      throw error;
                    }
                    map.set(pageIndex++, [error, null]);
                  }
                  __name(addPageError, "addPageError");
                  while (queue.length > 0) {
                    const queueItem = queue.at(-1);
                    const {
                      currentNode,
                      posInKids
                    } = queueItem;
                    let kids = currentNode.getRaw("Kids");
                    if (kids instanceof _primitives.Ref) {
                      try {
                        kids = await xref.fetchAsync(kids);
                      } catch (ex) {
                        addPageError(ex);
                        break;
                      }
                    }
                    if (!Array.isArray(kids)) {
                      addPageError(new _util.FormatError("Page dictionary kids object is not an array."));
                      break;
                    }
                    if (posInKids >= kids.length) {
                      queue.pop();
                      continue;
                    }
                    const kidObj = kids[posInKids];
                    let obj;
                    if (kidObj instanceof _primitives.Ref) {
                      if (visitedNodes.has(kidObj)) {
                        addPageError(new _util.FormatError("Pages tree contains circular reference."));
                        break;
                      }
                      visitedNodes.put(kidObj);
                      try {
                        obj = await xref.fetchAsync(kidObj);
                      } catch (ex) {
                        addPageError(ex);
                        break;
                      }
                    } else {
                      obj = kidObj;
                    }
                    if (!(obj instanceof _primitives.Dict)) {
                      addPageError(new _util.FormatError("Page dictionary kid reference points to wrong type of object."));
                      break;
                    }
                    let type = obj.getRaw("Type");
                    if (type instanceof _primitives.Ref) {
                      try {
                        type = await xref.fetchAsync(type);
                      } catch (ex) {
                        addPageError(ex);
                        break;
                      }
                    }
                    if ((0, _primitives.isName)(type, "Page") || !obj.has("Kids")) {
                      addPageDict(obj, kidObj instanceof _primitives.Ref ? kidObj : null);
                    } else {
                      queue.push({
                        currentNode: obj,
                        posInKids: 0
                      });
                    }
                    queueItem.posInKids++;
                  }
                  return map;
                }
                getPageIndex(pageRef) {
                  const cachedPageIndex = this.pageIndexCache.get(pageRef);
                  if (cachedPageIndex !== void 0) {
                    return Promise.resolve(cachedPageIndex);
                  }
                  const xref = this.xref;
                  function pagesBeforeRef(kidRef) {
                    let total2 = 0, parentRef;
                    return xref.fetchAsync(kidRef).then(function(node) {
                      if ((0, _primitives.isRefsEqual)(kidRef, pageRef) && !(0, _primitives.isDict)(node, "Page") && !(node instanceof _primitives.Dict && !node.has("Type") && node.has("Contents"))) {
                        throw new _util.FormatError("The reference does not point to a /Page dictionary.");
                      }
                      if (!node) {
                        return null;
                      }
                      if (!(node instanceof _primitives.Dict)) {
                        throw new _util.FormatError("Node must be a dictionary.");
                      }
                      parentRef = node.getRaw("Parent");
                      return node.getAsync("Parent");
                    }).then(function(parent) {
                      if (!parent) {
                        return null;
                      }
                      if (!(parent instanceof _primitives.Dict)) {
                        throw new _util.FormatError("Parent must be a dictionary.");
                      }
                      return parent.getAsync("Kids");
                    }).then(function(kids) {
                      if (!kids) {
                        return null;
                      }
                      const kidPromises = [];
                      let found = false;
                      for (let i = 0, ii = kids.length; i < ii; i++) {
                        const kid = kids[i];
                        if (!(kid instanceof _primitives.Ref)) {
                          throw new _util.FormatError("Kid must be a reference.");
                        }
                        if ((0, _primitives.isRefsEqual)(kid, kidRef)) {
                          found = true;
                          break;
                        }
                        kidPromises.push(xref.fetchAsync(kid).then(function(obj) {
                          if (!(obj instanceof _primitives.Dict)) {
                            throw new _util.FormatError("Kid node must be a dictionary.");
                          }
                          if (obj.has("Count")) {
                            total2 += obj.get("Count");
                          } else {
                            total2++;
                          }
                        }));
                      }
                      if (!found) {
                        throw new _util.FormatError("Kid reference not found in parent's kids.");
                      }
                      return Promise.all(kidPromises).then(function() {
                        return [total2, parentRef];
                      });
                    });
                  }
                  __name(pagesBeforeRef, "pagesBeforeRef");
                  let total = 0;
                  const next = /* @__PURE__ */ __name((ref) => pagesBeforeRef(ref).then((args) => {
                    if (!args) {
                      this.pageIndexCache.put(pageRef, total);
                      return total;
                    }
                    const [count, parentRef] = args;
                    total += count;
                    return next(parentRef);
                  }), "next");
                  return next(pageRef);
                }
                get baseUrl() {
                  const uri = this._catDict.get("URI");
                  if (uri instanceof _primitives.Dict) {
                    const base = uri.get("Base");
                    if (typeof base === "string") {
                      const absoluteUrl = (0, _util.createValidAbsoluteUrl)(base, null, {
                        tryConvertEncoding: true
                      });
                      if (absoluteUrl) {
                        return (0, _util.shadow)(this, "baseUrl", absoluteUrl.href);
                      }
                    }
                  }
                  return (0, _util.shadow)(this, "baseUrl", null);
                }
                static parseDestDictionary(params) {
                  const destDict = params.destDict;
                  if (!(destDict instanceof _primitives.Dict)) {
                    (0, _util.warn)("parseDestDictionary: `destDict` must be a dictionary.");
                    return;
                  }
                  const resultObj = params.resultObj;
                  if (typeof resultObj !== "object") {
                    (0, _util.warn)("parseDestDictionary: `resultObj` must be an object.");
                    return;
                  }
                  const docBaseUrl = params.docBaseUrl || null;
                  let action = destDict.get("A"), url, dest;
                  if (!(action instanceof _primitives.Dict)) {
                    if (destDict.has("Dest")) {
                      action = destDict.get("Dest");
                    } else {
                      action = destDict.get("AA");
                      if (action instanceof _primitives.Dict) {
                        if (action.has("D")) {
                          action = action.get("D");
                        } else if (action.has("U")) {
                          action = action.get("U");
                        }
                      }
                    }
                  }
                  if (action instanceof _primitives.Dict) {
                    const actionType = action.get("S");
                    if (!(actionType instanceof _primitives.Name)) {
                      (0, _util.warn)("parseDestDictionary: Invalid type in Action dictionary.");
                      return;
                    }
                    const actionName = actionType.name;
                    switch (actionName) {
                      case "ResetForm":
                        const flags = action.get("Flags");
                        const include = ((typeof flags === "number" ? flags : 0) & 1) === 0;
                        const fields = [];
                        const refs = [];
                        for (const obj of action.get("Fields") || []) {
                          if (obj instanceof _primitives.Ref) {
                            refs.push(obj.toString());
                          } else if (typeof obj === "string") {
                            fields.push((0, _util.stringToPDFString)(obj));
                          }
                        }
                        resultObj.resetForm = {
                          fields,
                          refs,
                          include
                        };
                        break;
                      case "URI":
                        url = action.get("URI");
                        if (url instanceof _primitives.Name) {
                          url = "/" + url.name;
                        }
                        break;
                      case "GoTo":
                        dest = action.get("D");
                        break;
                      case "Launch":
                      case "GoToR":
                        const urlDict = action.get("F");
                        if (urlDict instanceof _primitives.Dict) {
                          url = urlDict.get("F") || null;
                        } else if (typeof urlDict === "string") {
                          url = urlDict;
                        }
                        let remoteDest = action.get("D");
                        if (remoteDest) {
                          if (remoteDest instanceof _primitives.Name) {
                            remoteDest = remoteDest.name;
                          }
                          if (typeof url === "string") {
                            const baseUrl = url.split("#")[0];
                            if (typeof remoteDest === "string") {
                              url = baseUrl + "#" + remoteDest;
                            } else if (Array.isArray(remoteDest)) {
                              url = baseUrl + "#" + JSON.stringify(remoteDest);
                            }
                          }
                        }
                        const newWindow = action.get("NewWindow");
                        if (typeof newWindow === "boolean") {
                          resultObj.newWindow = newWindow;
                        }
                        break;
                      case "Named":
                        const namedAction = action.get("N");
                        if (namedAction instanceof _primitives.Name) {
                          resultObj.action = namedAction.name;
                        }
                        break;
                      case "JavaScript":
                        const jsAction = action.get("JS");
                        let js;
                        if (jsAction instanceof _base_stream.BaseStream) {
                          js = jsAction.getString();
                        } else if (typeof jsAction === "string") {
                          js = jsAction;
                        }
                        const jsURL = js && (0, _core_utils.recoverJsURL)((0, _util.stringToPDFString)(js));
                        if (jsURL) {
                          url = jsURL.url;
                          resultObj.newWindow = jsURL.newWindow;
                          break;
                        }
                      default:
                        if (actionName === "JavaScript" || actionName === "SubmitForm") {
                          break;
                        }
                        (0, _util.warn)(`parseDestDictionary - unsupported action: "${actionName}".`);
                        break;
                    }
                  } else if (destDict.has("Dest")) {
                    dest = destDict.get("Dest");
                  }
                  if (typeof url === "string") {
                    const absoluteUrl = (0, _util.createValidAbsoluteUrl)(url, docBaseUrl, {
                      addDefaultProtocol: true,
                      tryConvertEncoding: true
                    });
                    if (absoluteUrl) {
                      resultObj.url = absoluteUrl.href;
                    }
                    resultObj.unsafeUrl = url;
                  }
                  if (dest) {
                    if (dest instanceof _primitives.Name) {
                      dest = dest.name;
                    }
                    if (typeof dest === "string") {
                      resultObj.dest = (0, _util.stringToPDFString)(dest);
                    } else if (Array.isArray(dest)) {
                      resultObj.dest = dest;
                    }
                  }
                }
              };
              __name(_Catalog, "Catalog");
              let Catalog = _Catalog;
              exports2.Catalog = Catalog;
            },
            /* 195 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.NumberTree = exports2.NameTree = void 0;
              var _primitives = __w_pdfjs_require__2(130);
              var _util = __w_pdfjs_require__2(2);
              const _NameOrNumberTree = class _NameOrNumberTree {
                constructor(root, xref, type) {
                  if (this.constructor === _NameOrNumberTree) {
                    (0, _util.unreachable)("Cannot initialize NameOrNumberTree.");
                  }
                  this.root = root;
                  this.xref = xref;
                  this._type = type;
                }
                getAll() {
                  const map = /* @__PURE__ */ new Map();
                  if (!this.root) {
                    return map;
                  }
                  const xref = this.xref;
                  const processed = new _primitives.RefSet();
                  processed.put(this.root);
                  const queue = [this.root];
                  while (queue.length > 0) {
                    const obj = xref.fetchIfRef(queue.shift());
                    if (!(obj instanceof _primitives.Dict)) {
                      continue;
                    }
                    if (obj.has("Kids")) {
                      const kids = obj.get("Kids");
                      if (!Array.isArray(kids)) {
                        continue;
                      }
                      for (const kid of kids) {
                        if (processed.has(kid)) {
                          throw new _util.FormatError(`Duplicate entry in "${this._type}" tree.`);
                        }
                        queue.push(kid);
                        processed.put(kid);
                      }
                      continue;
                    }
                    const entries = obj.get(this._type);
                    if (!Array.isArray(entries)) {
                      continue;
                    }
                    for (let i = 0, ii = entries.length; i < ii; i += 2) {
                      map.set(xref.fetchIfRef(entries[i]), xref.fetchIfRef(entries[i + 1]));
                    }
                  }
                  return map;
                }
                get(key) {
                  if (!this.root) {
                    return null;
                  }
                  const xref = this.xref;
                  let kidsOrEntries = xref.fetchIfRef(this.root);
                  let loopCount = 0;
                  const MAX_LEVELS = 10;
                  while (kidsOrEntries.has("Kids")) {
                    if (++loopCount > MAX_LEVELS) {
                      (0, _util.warn)(`Search depth limit reached for "${this._type}" tree.`);
                      return null;
                    }
                    const kids = kidsOrEntries.get("Kids");
                    if (!Array.isArray(kids)) {
                      return null;
                    }
                    let l = 0, r = kids.length - 1;
                    while (l <= r) {
                      const m = l + r >> 1;
                      const kid = xref.fetchIfRef(kids[m]);
                      const limits = kid.get("Limits");
                      if (key < xref.fetchIfRef(limits[0])) {
                        r = m - 1;
                      } else if (key > xref.fetchIfRef(limits[1])) {
                        l = m + 1;
                      } else {
                        kidsOrEntries = kid;
                        break;
                      }
                    }
                    if (l > r) {
                      return null;
                    }
                  }
                  const entries = kidsOrEntries.get(this._type);
                  if (Array.isArray(entries)) {
                    let l = 0, r = entries.length - 2;
                    while (l <= r) {
                      const tmp = l + r >> 1, m = tmp + (tmp & 1);
                      const currentKey = xref.fetchIfRef(entries[m]);
                      if (key < currentKey) {
                        r = m - 2;
                      } else if (key > currentKey) {
                        l = m + 2;
                      } else {
                        return xref.fetchIfRef(entries[m + 1]);
                      }
                    }
                  }
                  return null;
                }
              };
              __name(_NameOrNumberTree, "NameOrNumberTree");
              let NameOrNumberTree = _NameOrNumberTree;
              const _NameTree = class _NameTree extends NameOrNumberTree {
                constructor(root, xref) {
                  super(root, xref, "Names");
                }
              };
              __name(_NameTree, "NameTree");
              let NameTree = _NameTree;
              exports2.NameTree = NameTree;
              const _NumberTree = class _NumberTree extends NameOrNumberTree {
                constructor(root, xref) {
                  super(root, xref, "Nums");
                }
              };
              __name(_NumberTree, "NumberTree");
              let NumberTree = _NumberTree;
              exports2.NumberTree = NumberTree;
            },
            /* 196 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.clearGlobalCaches = clearGlobalCaches;
              var _primitives = __w_pdfjs_require__2(130);
              var _unicode = __w_pdfjs_require__2(165);
              function clearGlobalCaches() {
                (0, _primitives.clearPrimitiveCaches)();
                (0, _unicode.clearUnicodeCaches)();
              }
              __name(clearGlobalCaches, "clearGlobalCaches");
            },
            /* 197 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.FileSpec = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _base_stream = __w_pdfjs_require__2(132);
              var _primitives = __w_pdfjs_require__2(130);
              function pickPlatformItem(dict) {
                if (dict.has("UF")) {
                  return dict.get("UF");
                } else if (dict.has("F")) {
                  return dict.get("F");
                } else if (dict.has("Unix")) {
                  return dict.get("Unix");
                } else if (dict.has("Mac")) {
                  return dict.get("Mac");
                } else if (dict.has("DOS")) {
                  return dict.get("DOS");
                }
                return null;
              }
              __name(pickPlatformItem, "pickPlatformItem");
              const _FileSpec = class _FileSpec {
                constructor(root, xref) {
                  if (!(root instanceof _primitives.Dict)) {
                    return;
                  }
                  this.xref = xref;
                  this.root = root;
                  if (root.has("FS")) {
                    this.fs = root.get("FS");
                  }
                  this.description = root.has("Desc") ? (0, _util.stringToPDFString)(root.get("Desc")) : "";
                  if (root.has("RF")) {
                    (0, _util.warn)("Related file specifications are not supported");
                  }
                  this.contentAvailable = true;
                  if (!root.has("EF")) {
                    this.contentAvailable = false;
                    (0, _util.warn)("Non-embedded file specifications are not supported");
                  }
                }
                get filename() {
                  if (!this._filename && this.root) {
                    const filename = pickPlatformItem(this.root) || "unnamed";
                    this._filename = (0, _util.stringToPDFString)(filename).replace(/\\\\/g, "\\").replace(/\\\//g, "/").replace(/\\/g, "/");
                  }
                  return this._filename;
                }
                get content() {
                  if (!this.contentAvailable) {
                    return null;
                  }
                  if (!this.contentRef && this.root) {
                    this.contentRef = pickPlatformItem(this.root.get("EF"));
                  }
                  let content = null;
                  if (this.contentRef) {
                    const fileObj = this.xref.fetchIfRef(this.contentRef);
                    if (fileObj instanceof _base_stream.BaseStream) {
                      content = fileObj.getBytes();
                    } else {
                      (0, _util.warn)("Embedded file specification points to non-existing/invalid content");
                    }
                  } else {
                    (0, _util.warn)("Embedded file specification does not have a content");
                  }
                  return content;
                }
                get serializable() {
                  return {
                    filename: this.filename,
                    content: this.content
                  };
                }
              };
              __name(_FileSpec, "FileSpec");
              let FileSpec = _FileSpec;
              exports2.FileSpec = FileSpec;
            },
            /* 198 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.MetadataParser = void 0;
              var _xml_parser = __w_pdfjs_require__2(191);
              const _MetadataParser = class _MetadataParser {
                constructor(data) {
                  data = this._repair(data);
                  const parser = new _xml_parser.SimpleXMLParser({
                    lowerCaseName: true
                  });
                  const xmlDocument = parser.parseFromString(data);
                  this._metadataMap = /* @__PURE__ */ new Map();
                  this._data = data;
                  if (xmlDocument) {
                    this._parse(xmlDocument);
                  }
                }
                _repair(data) {
                  return data.replace(/^[^<]+/, "").replace(/>\\376\\377([^<]+)/g, function(all, codes) {
                    const bytes = codes.replace(/\\([0-3])([0-7])([0-7])/g, function(code, d1, d2, d3) {
                      return String.fromCharCode(d1 * 64 + d2 * 8 + d3 * 1);
                    }).replace(/&(amp|apos|gt|lt|quot);/g, function(str, name) {
                      switch (name) {
                        case "amp":
                          return "&";
                        case "apos":
                          return "'";
                        case "gt":
                          return ">";
                        case "lt":
                          return "<";
                        case "quot":
                          return '"';
                      }
                      throw new Error(`_repair: ${name} isn't defined.`);
                    });
                    const charBuf = [];
                    for (let i = 0, ii = bytes.length; i < ii; i += 2) {
                      const code = bytes.charCodeAt(i) * 256 + bytes.charCodeAt(i + 1);
                      if (code >= 32 && code < 127 && code !== 60 && code !== 62 && code !== 38) {
                        charBuf.push(String.fromCharCode(code));
                      } else {
                        charBuf.push("&#x" + (65536 + code).toString(16).substring(1) + ";");
                      }
                    }
                    return ">" + charBuf.join("");
                  });
                }
                _getSequence(entry) {
                  const name = entry.nodeName;
                  if (name !== "rdf:bag" && name !== "rdf:seq" && name !== "rdf:alt") {
                    return null;
                  }
                  return entry.childNodes.filter((node) => node.nodeName === "rdf:li");
                }
                _parseArray(entry) {
                  if (!entry.hasChildNodes()) {
                    return;
                  }
                  const [seqNode] = entry.childNodes;
                  const sequence = this._getSequence(seqNode) || [];
                  this._metadataMap.set(entry.nodeName, sequence.map((node) => node.textContent.trim()));
                }
                _parse(xmlDocument) {
                  let rdf = xmlDocument.documentElement;
                  if (rdf.nodeName !== "rdf:rdf") {
                    rdf = rdf.firstChild;
                    while (rdf && rdf.nodeName !== "rdf:rdf") {
                      rdf = rdf.nextSibling;
                    }
                  }
                  if (!rdf || rdf.nodeName !== "rdf:rdf" || !rdf.hasChildNodes()) {
                    return;
                  }
                  for (const desc of rdf.childNodes) {
                    if (desc.nodeName !== "rdf:description") {
                      continue;
                    }
                    for (const entry of desc.childNodes) {
                      const name = entry.nodeName;
                      switch (name) {
                        case "#text":
                          continue;
                        case "dc:creator":
                        case "dc:subject":
                          this._parseArray(entry);
                          continue;
                      }
                      this._metadataMap.set(name, entry.textContent.trim());
                    }
                  }
                }
                get serializable() {
                  return {
                    parsedData: this._metadataMap,
                    rawData: this._data
                  };
                }
              };
              __name(_MetadataParser, "MetadataParser");
              let MetadataParser = _MetadataParser;
              exports2.MetadataParser = MetadataParser;
            },
            /* 199 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.StructTreeRoot = exports2.StructTreePage = void 0;
              var _primitives = __w_pdfjs_require__2(130);
              var _util = __w_pdfjs_require__2(2);
              var _name_number_tree = __w_pdfjs_require__2(195);
              const MAX_DEPTH = 40;
              const StructElementType = {
                PAGE_CONTENT: "PAGE_CONTENT",
                STREAM_CONTENT: "STREAM_CONTENT",
                OBJECT: "OBJECT",
                ELEMENT: "ELEMENT"
              };
              const _StructTreeRoot = class _StructTreeRoot {
                constructor(rootDict) {
                  this.dict = rootDict;
                  this.roleMap = /* @__PURE__ */ new Map();
                }
                init() {
                  this.readRoleMap();
                }
                readRoleMap() {
                  const roleMapDict = this.dict.get("RoleMap");
                  if (!(roleMapDict instanceof _primitives.Dict)) {
                    return;
                  }
                  roleMapDict.forEach((key, value) => {
                    if (!(value instanceof _primitives.Name)) {
                      return;
                    }
                    this.roleMap.set(key, value.name);
                  });
                }
              };
              __name(_StructTreeRoot, "StructTreeRoot");
              let StructTreeRoot = _StructTreeRoot;
              exports2.StructTreeRoot = StructTreeRoot;
              const _StructElementNode = class _StructElementNode {
                constructor(tree, dict) {
                  this.tree = tree;
                  this.dict = dict;
                  this.kids = [];
                  this.parseKids();
                }
                get role() {
                  const nameObj = this.dict.get("S");
                  const name = nameObj instanceof _primitives.Name ? nameObj.name : "";
                  const {
                    root
                  } = this.tree;
                  if (root.roleMap.has(name)) {
                    return root.roleMap.get(name);
                  }
                  return name;
                }
                parseKids() {
                  let pageObjId = null;
                  const objRef = this.dict.getRaw("Pg");
                  if (objRef instanceof _primitives.Ref) {
                    pageObjId = objRef.toString();
                  }
                  const kids = this.dict.get("K");
                  if (Array.isArray(kids)) {
                    for (const kid of kids) {
                      const element = this.parseKid(pageObjId, kid);
                      if (element) {
                        this.kids.push(element);
                      }
                    }
                  } else {
                    const element = this.parseKid(pageObjId, kids);
                    if (element) {
                      this.kids.push(element);
                    }
                  }
                }
                parseKid(pageObjId, kid) {
                  if (Number.isInteger(kid)) {
                    if (this.tree.pageDict.objId !== pageObjId) {
                      return null;
                    }
                    return new StructElement({
                      type: StructElementType.PAGE_CONTENT,
                      mcid: kid,
                      pageObjId
                    });
                  }
                  let kidDict = null;
                  if (kid instanceof _primitives.Ref) {
                    kidDict = this.dict.xref.fetch(kid);
                  } else if (kid instanceof _primitives.Dict) {
                    kidDict = kid;
                  }
                  if (!kidDict) {
                    return null;
                  }
                  const pageRef = kidDict.getRaw("Pg");
                  if (pageRef instanceof _primitives.Ref) {
                    pageObjId = pageRef.toString();
                  }
                  const type = kidDict.get("Type") instanceof _primitives.Name ? kidDict.get("Type").name : null;
                  if (type === "MCR") {
                    if (this.tree.pageDict.objId !== pageObjId) {
                      return null;
                    }
                    return new StructElement({
                      type: StructElementType.STREAM_CONTENT,
                      refObjId: kidDict.getRaw("Stm") instanceof _primitives.Ref ? kidDict.getRaw("Stm").toString() : null,
                      pageObjId,
                      mcid: kidDict.get("MCID")
                    });
                  }
                  if (type === "OBJR") {
                    if (this.tree.pageDict.objId !== pageObjId) {
                      return null;
                    }
                    return new StructElement({
                      type: StructElementType.OBJECT,
                      refObjId: kidDict.getRaw("Obj") instanceof _primitives.Ref ? kidDict.getRaw("Obj").toString() : null,
                      pageObjId
                    });
                  }
                  return new StructElement({
                    type: StructElementType.ELEMENT,
                    dict: kidDict
                  });
                }
              };
              __name(_StructElementNode, "StructElementNode");
              let StructElementNode = _StructElementNode;
              const _StructElement = class _StructElement {
                constructor(_ref) {
                  let {
                    type,
                    dict = null,
                    mcid = null,
                    pageObjId = null,
                    refObjId = null
                  } = _ref;
                  this.type = type;
                  this.dict = dict;
                  this.mcid = mcid;
                  this.pageObjId = pageObjId;
                  this.refObjId = refObjId;
                  this.parentNode = null;
                }
              };
              __name(_StructElement, "StructElement");
              let StructElement = _StructElement;
              const _StructTreePage = class _StructTreePage {
                constructor(structTreeRoot, pageDict) {
                  this.root = structTreeRoot;
                  this.rootDict = structTreeRoot ? structTreeRoot.dict : null;
                  this.pageDict = pageDict;
                  this.nodes = [];
                }
                parse() {
                  if (!this.root || !this.rootDict) {
                    return;
                  }
                  const parentTree = this.rootDict.get("ParentTree");
                  if (!parentTree) {
                    return;
                  }
                  const id = this.pageDict.get("StructParents");
                  if (!Number.isInteger(id)) {
                    return;
                  }
                  const numberTree = new _name_number_tree.NumberTree(parentTree, this.rootDict.xref);
                  const parentArray = numberTree.get(id);
                  if (!Array.isArray(parentArray)) {
                    return;
                  }
                  const map = /* @__PURE__ */ new Map();
                  for (const ref of parentArray) {
                    if (ref instanceof _primitives.Ref) {
                      this.addNode(this.rootDict.xref.fetch(ref), map);
                    }
                  }
                }
                addNode(dict, map) {
                  let level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
                  if (level > MAX_DEPTH) {
                    (0, _util.warn)("StructTree MAX_DEPTH reached.");
                    return null;
                  }
                  if (map.has(dict)) {
                    return map.get(dict);
                  }
                  const element = new StructElementNode(this, dict);
                  map.set(dict, element);
                  const parent = dict.get("P");
                  if (!parent || (0, _primitives.isName)(parent.get("Type"), "StructTreeRoot")) {
                    if (!this.addTopLevelNode(dict, element)) {
                      map.delete(dict);
                    }
                    return element;
                  }
                  const parentNode = this.addNode(parent, map, level + 1);
                  if (!parentNode) {
                    return element;
                  }
                  let save = false;
                  for (const kid of parentNode.kids) {
                    if (kid.type === StructElementType.ELEMENT && kid.dict === dict) {
                      kid.parentNode = element;
                      save = true;
                    }
                  }
                  if (!save) {
                    map.delete(dict);
                  }
                  return element;
                }
                addTopLevelNode(dict, element) {
                  const obj = this.rootDict.get("K");
                  if (!obj) {
                    return false;
                  }
                  if (obj instanceof _primitives.Dict) {
                    if (obj.objId !== dict.objId) {
                      return false;
                    }
                    this.nodes[0] = element;
                    return true;
                  }
                  if (!Array.isArray(obj)) {
                    return true;
                  }
                  let save = false;
                  for (let i = 0; i < obj.length; i++) {
                    const kidRef = obj[i];
                    if (kidRef && kidRef.toString() === dict.objId) {
                      this.nodes[i] = element;
                      save = true;
                    }
                  }
                  return save;
                }
                get serializable() {
                  function nodeToSerializable(node, parent) {
                    let level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
                    if (level > MAX_DEPTH) {
                      (0, _util.warn)("StructTree too deep to be fully serialized.");
                      return;
                    }
                    const obj = /* @__PURE__ */ Object.create(null);
                    obj.role = node.role;
                    obj.children = [];
                    parent.children.push(obj);
                    const alt = node.dict.get("Alt");
                    if (typeof alt === "string") {
                      obj.alt = (0, _util.stringToPDFString)(alt);
                    }
                    const lang = node.dict.get("Lang");
                    if (typeof lang === "string") {
                      obj.lang = (0, _util.stringToPDFString)(lang);
                    }
                    for (const kid of node.kids) {
                      const kidElement = kid.type === StructElementType.ELEMENT ? kid.parentNode : null;
                      if (kidElement) {
                        nodeToSerializable(kidElement, obj, level + 1);
                        continue;
                      } else if (kid.type === StructElementType.PAGE_CONTENT || kid.type === StructElementType.STREAM_CONTENT) {
                        obj.children.push({
                          type: "content",
                          id: `page${kid.pageObjId}_mcid${kid.mcid}`
                        });
                      } else if (kid.type === StructElementType.OBJECT) {
                        obj.children.push({
                          type: "object",
                          id: kid.refObjId
                        });
                      }
                    }
                  }
                  __name(nodeToSerializable, "nodeToSerializable");
                  const root = /* @__PURE__ */ Object.create(null);
                  root.children = [];
                  root.role = "Root";
                  for (const child of this.nodes) {
                    if (!child) {
                      continue;
                    }
                    nodeToSerializable(child, root);
                  }
                  return root;
                }
              };
              __name(_StructTreePage, "StructTreePage");
              let StructTreePage = _StructTreePage;
              exports2.StructTreePage = StructTreePage;
            },
            /* 200 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.ObjectLoader = void 0;
              var _primitives = __w_pdfjs_require__2(130);
              var _base_stream = __w_pdfjs_require__2(132);
              var _core_utils = __w_pdfjs_require__2(131);
              var _util = __w_pdfjs_require__2(2);
              function mayHaveChildren(value) {
                return value instanceof _primitives.Ref || value instanceof _primitives.Dict || value instanceof _base_stream.BaseStream || Array.isArray(value);
              }
              __name(mayHaveChildren, "mayHaveChildren");
              function addChildren(node, nodesToVisit) {
                if (node instanceof _primitives.Dict) {
                  node = node.getRawValues();
                } else if (node instanceof _base_stream.BaseStream) {
                  node = node.dict.getRawValues();
                } else if (!Array.isArray(node)) {
                  return;
                }
                for (const rawValue of node) {
                  if (mayHaveChildren(rawValue)) {
                    nodesToVisit.push(rawValue);
                  }
                }
              }
              __name(addChildren, "addChildren");
              const _ObjectLoader = class _ObjectLoader {
                constructor(dict, keys, xref) {
                  this.dict = dict;
                  this.keys = keys;
                  this.xref = xref;
                  this.refSet = null;
                }
                async load() {
                  if (this.xref.stream.isDataLoaded) {
                    return void 0;
                  }
                  const {
                    keys,
                    dict
                  } = this;
                  this.refSet = new _primitives.RefSet();
                  const nodesToVisit = [];
                  for (let i = 0, ii = keys.length; i < ii; i++) {
                    const rawValue = dict.getRaw(keys[i]);
                    if (rawValue !== void 0) {
                      nodesToVisit.push(rawValue);
                    }
                  }
                  return this._walk(nodesToVisit);
                }
                async _walk(nodesToVisit) {
                  const nodesToRevisit = [];
                  const pendingRequests = [];
                  while (nodesToVisit.length) {
                    let currentNode = nodesToVisit.pop();
                    if (currentNode instanceof _primitives.Ref) {
                      if (this.refSet.has(currentNode)) {
                        continue;
                      }
                      try {
                        this.refSet.put(currentNode);
                        currentNode = this.xref.fetch(currentNode);
                      } catch (ex) {
                        if (!(ex instanceof _core_utils.MissingDataException)) {
                          (0, _util.warn)(`ObjectLoader._walk - requesting all data: "${ex}".`);
                          this.refSet = null;
                          const {
                            manager
                          } = this.xref.stream;
                          return manager.requestAllChunks();
                        }
                        nodesToRevisit.push(currentNode);
                        pendingRequests.push({
                          begin: ex.begin,
                          end: ex.end
                        });
                      }
                    }
                    if (currentNode instanceof _base_stream.BaseStream) {
                      const baseStreams = currentNode.getBaseStreams();
                      if (baseStreams) {
                        let foundMissingData = false;
                        for (const stream of baseStreams) {
                          if (stream.isDataLoaded) {
                            continue;
                          }
                          foundMissingData = true;
                          pendingRequests.push({
                            begin: stream.start,
                            end: stream.end
                          });
                        }
                        if (foundMissingData) {
                          nodesToRevisit.push(currentNode);
                        }
                      }
                    }
                    addChildren(currentNode, nodesToVisit);
                  }
                  if (pendingRequests.length) {
                    await this.xref.stream.manager.requestRanges(pendingRequests);
                    for (const node of nodesToRevisit) {
                      if (node instanceof _primitives.Ref) {
                        this.refSet.remove(node);
                      }
                    }
                    return this._walk(nodesToRevisit);
                  }
                  this.refSet = null;
                  return void 0;
                }
              };
              __name(_ObjectLoader, "ObjectLoader");
              let ObjectLoader = _ObjectLoader;
              exports2.ObjectLoader = ObjectLoader;
            },
            /* 201 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.XFAFactory = void 0;
              var _xfa_object = __w_pdfjs_require__2(202);
              var _bind = __w_pdfjs_require__2(206);
              var _data = __w_pdfjs_require__2(212);
              var _fonts = __w_pdfjs_require__2(210);
              var _utils = __w_pdfjs_require__2(203);
              var _util = __w_pdfjs_require__2(2);
              var _parser = __w_pdfjs_require__2(213);
              var _xhtml = __w_pdfjs_require__2(223);
              const _XFAFactory = class _XFAFactory {
                constructor(data) {
                  try {
                    this.root = new _parser.XFAParser().parse(_XFAFactory._createDocument(data));
                    const binder = new _bind.Binder(this.root);
                    this.form = binder.bind();
                    this.dataHandler = new _data.DataHandler(this.root, binder.getData());
                    this.form[_xfa_object.$globalData].template = this.form;
                  } catch (e) {
                    (0, _util.warn)(`XFA - an error occurred during parsing and binding: ${e}`);
                  }
                }
                isValid() {
                  return this.root && this.form;
                }
                _createPagesHelper() {
                  const iterator = this.form[_xfa_object.$toPages]();
                  return new Promise((resolve, reject) => {
                    const nextIteration = /* @__PURE__ */ __name(() => {
                      try {
                        const value = iterator.next();
                        if (value.done) {
                          resolve(value.value);
                        } else {
                          setTimeout(nextIteration, 0);
                        }
                      } catch (e) {
                        reject(e);
                      }
                    }, "nextIteration");
                    setTimeout(nextIteration, 0);
                  });
                }
                async _createPages() {
                  try {
                    this.pages = await this._createPagesHelper();
                    this.dims = this.pages.children.map((c) => {
                      const {
                        width,
                        height
                      } = c.attributes.style;
                      return [0, 0, parseInt(width), parseInt(height)];
                    });
                  } catch (e) {
                    (0, _util.warn)(`XFA - an error occurred during layout: ${e}`);
                  }
                }
                getBoundingBox(pageIndex) {
                  return this.dims[pageIndex];
                }
                async getNumPages() {
                  if (!this.pages) {
                    await this._createPages();
                  }
                  return this.dims.length;
                }
                setImages(images) {
                  this.form[_xfa_object.$globalData].images = images;
                }
                setFonts(fonts) {
                  this.form[_xfa_object.$globalData].fontFinder = new _fonts.FontFinder(fonts);
                  const missingFonts = [];
                  for (let typeface of this.form[_xfa_object.$globalData].usedTypefaces) {
                    typeface = (0, _utils.stripQuotes)(typeface);
                    const font = this.form[_xfa_object.$globalData].fontFinder.find(typeface);
                    if (!font) {
                      missingFonts.push(typeface);
                    }
                  }
                  if (missingFonts.length > 0) {
                    return missingFonts;
                  }
                  return null;
                }
                appendFonts(fonts, reallyMissingFonts) {
                  this.form[_xfa_object.$globalData].fontFinder.add(fonts, reallyMissingFonts);
                }
                async getPages() {
                  if (!this.pages) {
                    await this._createPages();
                  }
                  const pages = this.pages;
                  this.pages = null;
                  return pages;
                }
                serializeData(storage) {
                  return this.dataHandler.serialize(storage);
                }
                static _createDocument(data) {
                  if (!data["/xdp:xdp"]) {
                    return data["xdp:xdp"];
                  }
                  return Object.values(data).join("");
                }
                static getRichTextAsHtml(rc) {
                  if (!rc || typeof rc !== "string") {
                    return null;
                  }
                  try {
                    let root = new _parser.XFAParser(_xhtml.XhtmlNamespace, true).parse(rc);
                    if (!["body", "xhtml"].includes(root[_xfa_object.$nodeName])) {
                      const newRoot = _xhtml.XhtmlNamespace.body({});
                      newRoot[_xfa_object.$appendChild](root);
                      root = newRoot;
                    }
                    const result = root[_xfa_object.$toHTML]();
                    if (!result.success) {
                      return null;
                    }
                    const {
                      html
                    } = result;
                    const {
                      attributes
                    } = html;
                    if (attributes) {
                      if (attributes.class) {
                        attributes.class = attributes.class.filter((attr) => !attr.startsWith("xfa"));
                      }
                      attributes.dir = "auto";
                    }
                    return {
                      html,
                      str: root[_xfa_object.$text]()
                    };
                  } catch (e) {
                    (0, _util.warn)(`XFA - an error occurred during parsing of rich text: ${e}`);
                  }
                  return null;
                }
              };
              __name(_XFAFactory, "XFAFactory");
              let XFAFactory = _XFAFactory;
              exports2.XFAFactory = XFAFactory;
            },
            /* 202 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.XmlObject = exports2.XFAObjectArray = exports2.XFAObject = exports2.XFAAttribute = exports2.StringObject = exports2.OptionObject = exports2.Option10 = exports2.Option01 = exports2.IntegerObject = exports2.ContentObject = exports2.$uid = exports2.$toStyle = exports2.$toString = exports2.$toPages = exports2.$toHTML = exports2.$text = exports2.$tabIndex = exports2.$setValue = exports2.$setSetAttributes = exports2.$setId = exports2.$searchNode = exports2.$root = exports2.$resolvePrototypes = exports2.$removeChild = exports2.$pushPara = exports2.$pushGlyphs = exports2.$popPara = exports2.$onText = exports2.$onChildCheck = exports2.$onChild = exports2.$nsAttributes = exports2.$nodeName = exports2.$namespaceId = exports2.$isUsable = exports2.$isTransparent = exports2.$isThereMoreWidth = exports2.$isSplittable = exports2.$isNsAgnostic = exports2.$isDescendent = exports2.$isDataValue = exports2.$isCDATAXml = exports2.$isBindable = exports2.$insertAt = exports2.$indexOf = exports2.$ids = exports2.$hasSettableValue = exports2.$globalData = exports2.$getTemplateRoot = exports2.$getSubformParent = exports2.$getRealChildrenByNameIt = exports2.$getParent = exports2.$getNextPage = exports2.$getExtra = exports2.$getDataValue = exports2.$getContainedChildren = exports2.$getChildrenByNameIt = exports2.$getChildrenByName = exports2.$getChildrenByClass = exports2.$getChildren = exports2.$getAvailableSpace = exports2.$getAttributes = exports2.$getAttributeIt = exports2.$flushHTML = exports2.$finalize = exports2.$extra = exports2.$dump = exports2.$data = exports2.$content = exports2.$consumed = exports2.$clone = exports2.$cleanup = exports2.$cleanPage = exports2.$clean = exports2.$childrenToHTML = exports2.$appendChild = exports2.$addHTML = exports2.$acceptWhitespace = void 0;
              var _utils = __w_pdfjs_require__2(203);
              var _util = __w_pdfjs_require__2(2);
              var _core_utils = __w_pdfjs_require__2(131);
              var _namespaces = __w_pdfjs_require__2(204);
              var _som = __w_pdfjs_require__2(205);
              const $acceptWhitespace = Symbol();
              exports2.$acceptWhitespace = $acceptWhitespace;
              const $addHTML = Symbol();
              exports2.$addHTML = $addHTML;
              const $appendChild = Symbol();
              exports2.$appendChild = $appendChild;
              const $childrenToHTML = Symbol();
              exports2.$childrenToHTML = $childrenToHTML;
              const $clean = Symbol();
              exports2.$clean = $clean;
              const $cleanPage = Symbol();
              exports2.$cleanPage = $cleanPage;
              const $cleanup = Symbol();
              exports2.$cleanup = $cleanup;
              const $clone = Symbol();
              exports2.$clone = $clone;
              const $consumed = Symbol();
              exports2.$consumed = $consumed;
              const $content = Symbol("content");
              exports2.$content = $content;
              const $data = Symbol("data");
              exports2.$data = $data;
              const $dump = Symbol();
              exports2.$dump = $dump;
              const $extra = Symbol("extra");
              exports2.$extra = $extra;
              const $finalize = Symbol();
              exports2.$finalize = $finalize;
              const $flushHTML = Symbol();
              exports2.$flushHTML = $flushHTML;
              const $getAttributeIt = Symbol();
              exports2.$getAttributeIt = $getAttributeIt;
              const $getAttributes = Symbol();
              exports2.$getAttributes = $getAttributes;
              const $getAvailableSpace = Symbol();
              exports2.$getAvailableSpace = $getAvailableSpace;
              const $getChildrenByClass = Symbol();
              exports2.$getChildrenByClass = $getChildrenByClass;
              const $getChildrenByName = Symbol();
              exports2.$getChildrenByName = $getChildrenByName;
              const $getChildrenByNameIt = Symbol();
              exports2.$getChildrenByNameIt = $getChildrenByNameIt;
              const $getDataValue = Symbol();
              exports2.$getDataValue = $getDataValue;
              const $getExtra = Symbol();
              exports2.$getExtra = $getExtra;
              const $getRealChildrenByNameIt = Symbol();
              exports2.$getRealChildrenByNameIt = $getRealChildrenByNameIt;
              const $getChildren = Symbol();
              exports2.$getChildren = $getChildren;
              const $getContainedChildren = Symbol();
              exports2.$getContainedChildren = $getContainedChildren;
              const $getNextPage = Symbol();
              exports2.$getNextPage = $getNextPage;
              const $getSubformParent = Symbol();
              exports2.$getSubformParent = $getSubformParent;
              const $getParent = Symbol();
              exports2.$getParent = $getParent;
              const $getTemplateRoot = Symbol();
              exports2.$getTemplateRoot = $getTemplateRoot;
              const $globalData = Symbol();
              exports2.$globalData = $globalData;
              const $hasSettableValue = Symbol();
              exports2.$hasSettableValue = $hasSettableValue;
              const $ids = Symbol();
              exports2.$ids = $ids;
              const $indexOf = Symbol();
              exports2.$indexOf = $indexOf;
              const $insertAt = Symbol();
              exports2.$insertAt = $insertAt;
              const $isCDATAXml = Symbol();
              exports2.$isCDATAXml = $isCDATAXml;
              const $isBindable = Symbol();
              exports2.$isBindable = $isBindable;
              const $isDataValue = Symbol();
              exports2.$isDataValue = $isDataValue;
              const $isDescendent = Symbol();
              exports2.$isDescendent = $isDescendent;
              const $isNsAgnostic = Symbol();
              exports2.$isNsAgnostic = $isNsAgnostic;
              const $isSplittable = Symbol();
              exports2.$isSplittable = $isSplittable;
              const $isThereMoreWidth = Symbol();
              exports2.$isThereMoreWidth = $isThereMoreWidth;
              const $isTransparent = Symbol();
              exports2.$isTransparent = $isTransparent;
              const $isUsable = Symbol();
              exports2.$isUsable = $isUsable;
              const $lastAttribute = Symbol();
              const $namespaceId = Symbol("namespaceId");
              exports2.$namespaceId = $namespaceId;
              const $nodeName = Symbol("nodeName");
              exports2.$nodeName = $nodeName;
              const $nsAttributes = Symbol();
              exports2.$nsAttributes = $nsAttributes;
              const $onChild = Symbol();
              exports2.$onChild = $onChild;
              const $onChildCheck = Symbol();
              exports2.$onChildCheck = $onChildCheck;
              const $onText = Symbol();
              exports2.$onText = $onText;
              const $pushGlyphs = Symbol();
              exports2.$pushGlyphs = $pushGlyphs;
              const $popPara = Symbol();
              exports2.$popPara = $popPara;
              const $pushPara = Symbol();
              exports2.$pushPara = $pushPara;
              const $removeChild = Symbol();
              exports2.$removeChild = $removeChild;
              const $root = Symbol("root");
              exports2.$root = $root;
              const $resolvePrototypes = Symbol();
              exports2.$resolvePrototypes = $resolvePrototypes;
              const $searchNode = Symbol();
              exports2.$searchNode = $searchNode;
              const $setId = Symbol();
              exports2.$setId = $setId;
              const $setSetAttributes = Symbol();
              exports2.$setSetAttributes = $setSetAttributes;
              const $setValue = Symbol();
              exports2.$setValue = $setValue;
              const $tabIndex = Symbol();
              exports2.$tabIndex = $tabIndex;
              const $text = Symbol();
              exports2.$text = $text;
              const $toPages = Symbol();
              exports2.$toPages = $toPages;
              const $toHTML = Symbol();
              exports2.$toHTML = $toHTML;
              const $toString = Symbol();
              exports2.$toString = $toString;
              const $toStyle = Symbol();
              exports2.$toStyle = $toStyle;
              const $uid = Symbol("uid");
              exports2.$uid = $uid;
              const _applyPrototype = Symbol();
              const _attributes = Symbol();
              const _attributeNames = Symbol();
              const _children = Symbol("_children");
              const _cloneAttribute = Symbol();
              const _dataValue = Symbol();
              const _defaultValue = Symbol();
              const _filteredChildrenGenerator = Symbol();
              const _getPrototype = Symbol();
              const _getUnsetAttributes = Symbol();
              const _hasChildren = Symbol();
              const _max = Symbol();
              const _options = Symbol();
              const _parent = Symbol("parent");
              const _resolvePrototypesHelper = Symbol();
              const _setAttributes = Symbol();
              const _validator = Symbol();
              let uid = 0;
              const NS_DATASETS = _namespaces.NamespaceIds.datasets.id;
              const _XFAObject = class _XFAObject {
                constructor(nsId, name) {
                  let hasChildren = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                  this[$namespaceId] = nsId;
                  this[$nodeName] = name;
                  this[_hasChildren] = hasChildren;
                  this[_parent] = null;
                  this[_children] = [];
                  this[$uid] = `${name}${uid++}`;
                  this[$globalData] = null;
                }
                [$onChild](child) {
                  if (!this[_hasChildren] || !this[$onChildCheck](child)) {
                    return false;
                  }
                  const name = child[$nodeName];
                  const node = this[name];
                  if (node instanceof XFAObjectArray) {
                    if (node.push(child)) {
                      this[$appendChild](child);
                      return true;
                    }
                  } else {
                    if (node !== null) {
                      this[$removeChild](node);
                    }
                    this[name] = child;
                    this[$appendChild](child);
                    return true;
                  }
                  let id = "";
                  if (this.id) {
                    id = ` (id: ${this.id})`;
                  } else if (this.name) {
                    id = ` (name: ${this.name} ${this.h.value})`;
                  }
                  (0, _util.warn)(`XFA - node "${this[$nodeName]}"${id} has already enough "${name}"!`);
                  return false;
                }
                [$onChildCheck](child) {
                  return this.hasOwnProperty(child[$nodeName]) && child[$namespaceId] === this[$namespaceId];
                }
                [$isNsAgnostic]() {
                  return false;
                }
                [$acceptWhitespace]() {
                  return false;
                }
                [$isCDATAXml]() {
                  return false;
                }
                [$isBindable]() {
                  return false;
                }
                [$popPara]() {
                  if (this.para) {
                    this[$getTemplateRoot]()[$extra].paraStack.pop();
                  }
                }
                [$pushPara]() {
                  this[$getTemplateRoot]()[$extra].paraStack.push(this.para);
                }
                [$setId](ids) {
                  if (this.id && this[$namespaceId] === _namespaces.NamespaceIds.template.id) {
                    ids.set(this.id, this);
                  }
                }
                [$getTemplateRoot]() {
                  return this[$globalData].template;
                }
                [$isSplittable]() {
                  return false;
                }
                [$isThereMoreWidth]() {
                  return false;
                }
                [$appendChild](child) {
                  child[_parent] = this;
                  this[_children].push(child);
                  if (!child[$globalData] && this[$globalData]) {
                    child[$globalData] = this[$globalData];
                  }
                }
                [$removeChild](child) {
                  const i = this[_children].indexOf(child);
                  this[_children].splice(i, 1);
                }
                [$hasSettableValue]() {
                  return this.hasOwnProperty("value");
                }
                [$setValue](_) {
                }
                [$onText](_) {
                }
                [$finalize]() {
                }
                [$clean](builder) {
                  delete this[_hasChildren];
                  if (this[$cleanup]) {
                    builder.clean(this[$cleanup]);
                    delete this[$cleanup];
                  }
                }
                [$indexOf](child) {
                  return this[_children].indexOf(child);
                }
                [$insertAt](i, child) {
                  child[_parent] = this;
                  this[_children].splice(i, 0, child);
                  if (!child[$globalData] && this[$globalData]) {
                    child[$globalData] = this[$globalData];
                  }
                }
                [$isTransparent]() {
                  return !this.name;
                }
                [$lastAttribute]() {
                  return "";
                }
                [$text]() {
                  if (this[_children].length === 0) {
                    return this[$content];
                  }
                  return this[_children].map((c) => c[$text]()).join("");
                }
                get [_attributeNames]() {
                  const proto = Object.getPrototypeOf(this);
                  if (!proto._attributes) {
                    const attributes = proto._attributes = /* @__PURE__ */ new Set();
                    for (const name of Object.getOwnPropertyNames(this)) {
                      if (this[name] === null || this[name] instanceof _XFAObject || this[name] instanceof XFAObjectArray) {
                        break;
                      }
                      attributes.add(name);
                    }
                  }
                  return (0, _util.shadow)(this, _attributeNames, proto._attributes);
                }
                [$isDescendent](parent) {
                  let node = this;
                  while (node) {
                    if (node === parent) {
                      return true;
                    }
                    node = node[$getParent]();
                  }
                  return false;
                }
                [$getParent]() {
                  return this[_parent];
                }
                [$getSubformParent]() {
                  return this[$getParent]();
                }
                [$getChildren]() {
                  let name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                  if (!name) {
                    return this[_children];
                  }
                  return this[name];
                }
                [$dump]() {
                  const dumped = /* @__PURE__ */ Object.create(null);
                  if (this[$content]) {
                    dumped.$content = this[$content];
                  }
                  for (const name of Object.getOwnPropertyNames(this)) {
                    const value = this[name];
                    if (value === null) {
                      continue;
                    }
                    if (value instanceof _XFAObject) {
                      dumped[name] = value[$dump]();
                    } else if (value instanceof XFAObjectArray) {
                      if (!value.isEmpty()) {
                        dumped[name] = value.dump();
                      }
                    } else {
                      dumped[name] = value;
                    }
                  }
                  return dumped;
                }
                [$toStyle]() {
                  return null;
                }
                [$toHTML]() {
                  return _utils.HTMLResult.EMPTY;
                }
                *[$getContainedChildren]() {
                  for (const node of this[$getChildren]()) {
                    yield node;
                  }
                }
                *[_filteredChildrenGenerator](filter, include) {
                  for (const node of this[$getContainedChildren]()) {
                    if (!filter || include === filter.has(node[$nodeName])) {
                      const availableSpace = this[$getAvailableSpace]();
                      const res = node[$toHTML](availableSpace);
                      if (!res.success) {
                        this[$extra].failingNode = node;
                      }
                      yield res;
                    }
                  }
                }
                [$flushHTML]() {
                  return null;
                }
                [$addHTML](html, bbox) {
                  this[$extra].children.push(html);
                }
                [$getAvailableSpace]() {
                }
                [$childrenToHTML](_ref) {
                  let {
                    filter = null,
                    include = true
                  } = _ref;
                  if (!this[$extra].generator) {
                    this[$extra].generator = this[_filteredChildrenGenerator](filter, include);
                  } else {
                    const availableSpace = this[$getAvailableSpace]();
                    const res = this[$extra].failingNode[$toHTML](availableSpace);
                    if (!res.success) {
                      return res;
                    }
                    if (res.html) {
                      this[$addHTML](res.html, res.bbox);
                    }
                    delete this[$extra].failingNode;
                  }
                  while (true) {
                    const gen = this[$extra].generator.next();
                    if (gen.done) {
                      break;
                    }
                    const res = gen.value;
                    if (!res.success) {
                      return res;
                    }
                    if (res.html) {
                      this[$addHTML](res.html, res.bbox);
                    }
                  }
                  this[$extra].generator = null;
                  return _utils.HTMLResult.EMPTY;
                }
                [$setSetAttributes](attributes) {
                  this[_setAttributes] = new Set(Object.keys(attributes));
                }
                [_getUnsetAttributes](protoAttributes) {
                  const allAttr = this[_attributeNames];
                  const setAttr = this[_setAttributes];
                  return [...protoAttributes].filter((x) => allAttr.has(x) && !setAttr.has(x));
                }
                [$resolvePrototypes](ids) {
                  let ancestors = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : /* @__PURE__ */ new Set();
                  for (const child of this[_children]) {
                    child[_resolvePrototypesHelper](ids, ancestors);
                  }
                }
                [_resolvePrototypesHelper](ids, ancestors) {
                  const proto = this[_getPrototype](ids, ancestors);
                  if (proto) {
                    this[_applyPrototype](proto, ids, ancestors);
                  } else {
                    this[$resolvePrototypes](ids, ancestors);
                  }
                }
                [_getPrototype](ids, ancestors) {
                  const {
                    use,
                    usehref
                  } = this;
                  if (!use && !usehref) {
                    return null;
                  }
                  let proto = null;
                  let somExpression = null;
                  let id = null;
                  let ref = use;
                  if (usehref) {
                    ref = usehref;
                    if (usehref.startsWith("#som(") && usehref.endsWith(")")) {
                      somExpression = usehref.slice("#som(".length, usehref.length - 1);
                    } else if (usehref.startsWith(".#som(") && usehref.endsWith(")")) {
                      somExpression = usehref.slice(".#som(".length, usehref.length - 1);
                    } else if (usehref.startsWith("#")) {
                      id = usehref.slice(1);
                    } else if (usehref.startsWith(".#")) {
                      id = usehref.slice(2);
                    }
                  } else if (use.startsWith("#")) {
                    id = use.slice(1);
                  } else {
                    somExpression = use;
                  }
                  this.use = this.usehref = "";
                  if (id) {
                    proto = ids.get(id);
                  } else {
                    proto = (0, _som.searchNode)(ids.get($root), this, somExpression, true, false);
                    if (proto) {
                      proto = proto[0];
                    }
                  }
                  if (!proto) {
                    (0, _util.warn)(`XFA - Invalid prototype reference: ${ref}.`);
                    return null;
                  }
                  if (proto[$nodeName] !== this[$nodeName]) {
                    (0, _util.warn)(`XFA - Incompatible prototype: ${proto[$nodeName]} !== ${this[$nodeName]}.`);
                    return null;
                  }
                  if (ancestors.has(proto)) {
                    (0, _util.warn)(`XFA - Cycle detected in prototypes use.`);
                    return null;
                  }
                  ancestors.add(proto);
                  const protoProto = proto[_getPrototype](ids, ancestors);
                  if (protoProto) {
                    proto[_applyPrototype](protoProto, ids, ancestors);
                  }
                  proto[$resolvePrototypes](ids, ancestors);
                  ancestors.delete(proto);
                  return proto;
                }
                [_applyPrototype](proto, ids, ancestors) {
                  if (ancestors.has(proto)) {
                    (0, _util.warn)(`XFA - Cycle detected in prototypes use.`);
                    return;
                  }
                  if (!this[$content] && proto[$content]) {
                    this[$content] = proto[$content];
                  }
                  const newAncestors = new Set(ancestors);
                  newAncestors.add(proto);
                  for (const unsetAttrName of this[_getUnsetAttributes](proto[_setAttributes])) {
                    this[unsetAttrName] = proto[unsetAttrName];
                    if (this[_setAttributes]) {
                      this[_setAttributes].add(unsetAttrName);
                    }
                  }
                  for (const name of Object.getOwnPropertyNames(this)) {
                    if (this[_attributeNames].has(name)) {
                      continue;
                    }
                    const value = this[name];
                    const protoValue = proto[name];
                    if (value instanceof XFAObjectArray) {
                      for (const child of value[_children]) {
                        child[_resolvePrototypesHelper](ids, ancestors);
                      }
                      for (let i = value[_children].length, ii = protoValue[_children].length; i < ii; i++) {
                        const child = proto[_children][i][$clone]();
                        if (value.push(child)) {
                          child[_parent] = this;
                          this[_children].push(child);
                          child[_resolvePrototypesHelper](ids, ancestors);
                        } else {
                          break;
                        }
                      }
                      continue;
                    }
                    if (value !== null) {
                      value[$resolvePrototypes](ids, ancestors);
                      if (protoValue) {
                        value[_applyPrototype](protoValue, ids, ancestors);
                      }
                      continue;
                    }
                    if (protoValue !== null) {
                      const child = protoValue[$clone]();
                      child[_parent] = this;
                      this[name] = child;
                      this[_children].push(child);
                      child[_resolvePrototypesHelper](ids, ancestors);
                    }
                  }
                }
                static [_cloneAttribute](obj) {
                  if (Array.isArray(obj)) {
                    return obj.map((x) => _XFAObject[_cloneAttribute](x));
                  }
                  if (typeof obj === "object" && obj !== null) {
                    return Object.assign({}, obj);
                  }
                  return obj;
                }
                [$clone]() {
                  const clone = Object.create(Object.getPrototypeOf(this));
                  for (const $symbol of Object.getOwnPropertySymbols(this)) {
                    try {
                      clone[$symbol] = this[$symbol];
                    } catch (_) {
                      (0, _util.shadow)(clone, $symbol, this[$symbol]);
                    }
                  }
                  clone[$uid] = `${clone[$nodeName]}${uid++}`;
                  clone[_children] = [];
                  for (const name of Object.getOwnPropertyNames(this)) {
                    if (this[_attributeNames].has(name)) {
                      clone[name] = _XFAObject[_cloneAttribute](this[name]);
                      continue;
                    }
                    const value = this[name];
                    if (value instanceof XFAObjectArray) {
                      clone[name] = new XFAObjectArray(value[_max]);
                    } else {
                      clone[name] = null;
                    }
                  }
                  for (const child of this[_children]) {
                    const name = child[$nodeName];
                    const clonedChild = child[$clone]();
                    clone[_children].push(clonedChild);
                    clonedChild[_parent] = clone;
                    if (clone[name] === null) {
                      clone[name] = clonedChild;
                    } else {
                      clone[name][_children].push(clonedChild);
                    }
                  }
                  return clone;
                }
                [$getChildren]() {
                  let name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                  if (!name) {
                    return this[_children];
                  }
                  return this[_children].filter((c) => c[$nodeName] === name);
                }
                [$getChildrenByClass](name) {
                  return this[name];
                }
                [$getChildrenByName](name, allTransparent) {
                  let first = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
                  return Array.from(this[$getChildrenByNameIt](name, allTransparent, first));
                }
                *[$getChildrenByNameIt](name, allTransparent) {
                  let first = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
                  if (name === "parent") {
                    yield this[_parent];
                    return;
                  }
                  for (const child of this[_children]) {
                    if (child[$nodeName] === name) {
                      yield child;
                    }
                    if (child.name === name) {
                      yield child;
                    }
                    if (allTransparent || child[$isTransparent]()) {
                      yield* child[$getChildrenByNameIt](name, allTransparent, false);
                    }
                  }
                  if (first && this[_attributeNames].has(name)) {
                    yield new XFAAttribute(this, name, this[name]);
                  }
                }
              };
              __name(_XFAObject, "XFAObject");
              let XFAObject = _XFAObject;
              exports2.XFAObject = XFAObject;
              const _XFAObjectArray = class _XFAObjectArray {
                constructor() {
                  let max = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Infinity;
                  this[_max] = max;
                  this[_children] = [];
                }
                push(child) {
                  const len = this[_children].length;
                  if (len <= this[_max]) {
                    this[_children].push(child);
                    return true;
                  }
                  (0, _util.warn)(`XFA - node "${child[$nodeName]}" accepts no more than ${this[_max]} children`);
                  return false;
                }
                isEmpty() {
                  return this[_children].length === 0;
                }
                dump() {
                  return this[_children].length === 1 ? this[_children][0][$dump]() : this[_children].map((x) => x[$dump]());
                }
                [$clone]() {
                  const clone = new _XFAObjectArray(this[_max]);
                  clone[_children] = this[_children].map((c) => c[$clone]());
                  return clone;
                }
                get children() {
                  return this[_children];
                }
                clear() {
                  this[_children].length = 0;
                }
              };
              __name(_XFAObjectArray, "XFAObjectArray");
              let XFAObjectArray = _XFAObjectArray;
              exports2.XFAObjectArray = XFAObjectArray;
              const _XFAAttribute = class _XFAAttribute {
                constructor(node, name, value) {
                  this[_parent] = node;
                  this[$nodeName] = name;
                  this[$content] = value;
                  this[$consumed] = false;
                  this[$uid] = `attribute${uid++}`;
                }
                [$getParent]() {
                  return this[_parent];
                }
                [$isDataValue]() {
                  return true;
                }
                [$getDataValue]() {
                  return this[$content].trim();
                }
                [$setValue](value) {
                  value = value.value || "";
                  this[$content] = value.toString();
                }
                [$text]() {
                  return this[$content];
                }
                [$isDescendent](parent) {
                  return this[_parent] === parent || this[_parent][$isDescendent](parent);
                }
              };
              __name(_XFAAttribute, "XFAAttribute");
              let XFAAttribute = _XFAAttribute;
              exports2.XFAAttribute = XFAAttribute;
              const _XmlObject = class _XmlObject extends XFAObject {
                constructor(nsId, name) {
                  let attributes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                  super(nsId, name);
                  this[$content] = "";
                  this[_dataValue] = null;
                  if (name !== "#text") {
                    const map = /* @__PURE__ */ new Map();
                    this[_attributes] = map;
                    for (const [attrName, value] of Object.entries(attributes)) {
                      map.set(attrName, new XFAAttribute(this, attrName, value));
                    }
                    if (attributes.hasOwnProperty($nsAttributes)) {
                      const dataNode = attributes[$nsAttributes].xfa.dataNode;
                      if (dataNode !== void 0) {
                        if (dataNode === "dataGroup") {
                          this[_dataValue] = false;
                        } else if (dataNode === "dataValue") {
                          this[_dataValue] = true;
                        }
                      }
                    }
                  }
                  this[$consumed] = false;
                }
                [$toString](buf) {
                  const tagName = this[$nodeName];
                  if (tagName === "#text") {
                    buf.push((0, _core_utils.encodeToXmlString)(this[$content]));
                    return;
                  }
                  const utf8TagName = (0, _util.utf8StringToString)(tagName);
                  const prefix = this[$namespaceId] === NS_DATASETS ? "xfa:" : "";
                  buf.push(`<${prefix}${utf8TagName}`);
                  for (const [name, value] of this[_attributes].entries()) {
                    const utf8Name = (0, _util.utf8StringToString)(name);
                    buf.push(` ${utf8Name}="${(0, _core_utils.encodeToXmlString)(value[$content])}"`);
                  }
                  if (this[_dataValue] !== null) {
                    if (this[_dataValue]) {
                      buf.push(` xfa:dataNode="dataValue"`);
                    } else {
                      buf.push(` xfa:dataNode="dataGroup"`);
                    }
                  }
                  if (!this[$content] && this[_children].length === 0) {
                    buf.push("/>");
                    return;
                  }
                  buf.push(">");
                  if (this[$content]) {
                    if (typeof this[$content] === "string") {
                      buf.push((0, _core_utils.encodeToXmlString)(this[$content]));
                    } else {
                      this[$content][$toString](buf);
                    }
                  } else {
                    for (const child of this[_children]) {
                      child[$toString](buf);
                    }
                  }
                  buf.push(`</${prefix}${utf8TagName}>`);
                }
                [$onChild](child) {
                  if (this[$content]) {
                    const node = new _XmlObject(this[$namespaceId], "#text");
                    this[$appendChild](node);
                    node[$content] = this[$content];
                    this[$content] = "";
                  }
                  this[$appendChild](child);
                  return true;
                }
                [$onText](str) {
                  this[$content] += str;
                }
                [$finalize]() {
                  if (this[$content] && this[_children].length > 0) {
                    const node = new _XmlObject(this[$namespaceId], "#text");
                    this[$appendChild](node);
                    node[$content] = this[$content];
                    delete this[$content];
                  }
                }
                [$toHTML]() {
                  if (this[$nodeName] === "#text") {
                    return _utils.HTMLResult.success({
                      name: "#text",
                      value: this[$content]
                    });
                  }
                  return _utils.HTMLResult.EMPTY;
                }
                [$getChildren]() {
                  let name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                  if (!name) {
                    return this[_children];
                  }
                  return this[_children].filter((c) => c[$nodeName] === name);
                }
                [$getAttributes]() {
                  return this[_attributes];
                }
                [$getChildrenByClass](name) {
                  const value = this[_attributes].get(name);
                  if (value !== void 0) {
                    return value;
                  }
                  return this[$getChildren](name);
                }
                *[$getChildrenByNameIt](name, allTransparent) {
                  const value = this[_attributes].get(name);
                  if (value) {
                    yield value;
                  }
                  for (const child of this[_children]) {
                    if (child[$nodeName] === name) {
                      yield child;
                    }
                    if (allTransparent) {
                      yield* child[$getChildrenByNameIt](name, allTransparent);
                    }
                  }
                }
                *[$getAttributeIt](name, skipConsumed) {
                  const value = this[_attributes].get(name);
                  if (value && (!skipConsumed || !value[$consumed])) {
                    yield value;
                  }
                  for (const child of this[_children]) {
                    yield* child[$getAttributeIt](name, skipConsumed);
                  }
                }
                *[$getRealChildrenByNameIt](name, allTransparent, skipConsumed) {
                  for (const child of this[_children]) {
                    if (child[$nodeName] === name && (!skipConsumed || !child[$consumed])) {
                      yield child;
                    }
                    if (allTransparent) {
                      yield* child[$getRealChildrenByNameIt](name, allTransparent, skipConsumed);
                    }
                  }
                }
                [$isDataValue]() {
                  if (this[_dataValue] === null) {
                    return this[_children].length === 0 || this[_children][0][$namespaceId] === _namespaces.NamespaceIds.xhtml.id;
                  }
                  return this[_dataValue];
                }
                [$getDataValue]() {
                  if (this[_dataValue] === null) {
                    if (this[_children].length === 0) {
                      return this[$content].trim();
                    }
                    if (this[_children][0][$namespaceId] === _namespaces.NamespaceIds.xhtml.id) {
                      return this[_children][0][$text]().trim();
                    }
                    return null;
                  }
                  return this[$content].trim();
                }
                [$setValue](value) {
                  value = value.value || "";
                  this[$content] = value.toString();
                }
                [$dump]() {
                  let hasNS = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  const dumped = /* @__PURE__ */ Object.create(null);
                  if (hasNS) {
                    dumped.$ns = this[$namespaceId];
                  }
                  if (this[$content]) {
                    dumped.$content = this[$content];
                  }
                  dumped.$name = this[$nodeName];
                  dumped.children = [];
                  for (const child of this[_children]) {
                    dumped.children.push(child[$dump](hasNS));
                  }
                  dumped.attributes = /* @__PURE__ */ Object.create(null);
                  for (const [name, value] of this[_attributes]) {
                    dumped.attributes[name] = value[$content];
                  }
                  return dumped;
                }
              };
              __name(_XmlObject, "XmlObject");
              let XmlObject = _XmlObject;
              exports2.XmlObject = XmlObject;
              const _ContentObject = class _ContentObject extends XFAObject {
                constructor(nsId, name) {
                  super(nsId, name);
                  this[$content] = "";
                }
                [$onText](text) {
                  this[$content] += text;
                }
                [$finalize]() {
                }
              };
              __name(_ContentObject, "ContentObject");
              let ContentObject = _ContentObject;
              exports2.ContentObject = ContentObject;
              const _OptionObject = class _OptionObject extends ContentObject {
                constructor(nsId, name, options) {
                  super(nsId, name);
                  this[_options] = options;
                }
                [$finalize]() {
                  this[$content] = (0, _utils.getKeyword)({
                    data: this[$content],
                    defaultValue: this[_options][0],
                    validate: (k) => this[_options].includes(k)
                  });
                }
                [$clean](builder) {
                  super[$clean](builder);
                  delete this[_options];
                }
              };
              __name(_OptionObject, "OptionObject");
              let OptionObject = _OptionObject;
              exports2.OptionObject = OptionObject;
              const _StringObject = class _StringObject extends ContentObject {
                [$finalize]() {
                  this[$content] = this[$content].trim();
                }
              };
              __name(_StringObject, "StringObject");
              let StringObject = _StringObject;
              exports2.StringObject = StringObject;
              const _IntegerObject = class _IntegerObject extends ContentObject {
                constructor(nsId, name, defaultValue, validator) {
                  super(nsId, name);
                  this[_defaultValue] = defaultValue;
                  this[_validator] = validator;
                }
                [$finalize]() {
                  this[$content] = (0, _utils.getInteger)({
                    data: this[$content],
                    defaultValue: this[_defaultValue],
                    validate: this[_validator]
                  });
                }
                [$clean](builder) {
                  super[$clean](builder);
                  delete this[_defaultValue];
                  delete this[_validator];
                }
              };
              __name(_IntegerObject, "IntegerObject");
              let IntegerObject = _IntegerObject;
              exports2.IntegerObject = IntegerObject;
              const _Option01 = class _Option01 extends IntegerObject {
                constructor(nsId, name) {
                  super(nsId, name, 0, (n) => n === 1);
                }
              };
              __name(_Option01, "Option01");
              let Option01 = _Option01;
              exports2.Option01 = Option01;
              const _Option10 = class _Option10 extends IntegerObject {
                constructor(nsId, name) {
                  super(nsId, name, 1, (n) => n === 0);
                }
              };
              __name(_Option10, "Option10");
              let Option10 = _Option10;
              exports2.Option10 = Option10;
            },
            /* 203 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.HTMLResult = void 0;
              exports2.getBBox = getBBox;
              exports2.getColor = getColor;
              exports2.getFloat = getFloat;
              exports2.getInteger = getInteger;
              exports2.getKeyword = getKeyword;
              exports2.getMeasurement = getMeasurement;
              exports2.getRatio = getRatio;
              exports2.getRelevant = getRelevant;
              exports2.getStringOption = getStringOption;
              exports2.stripQuotes = stripQuotes;
              var _util = __w_pdfjs_require__2(2);
              const dimConverters = {
                pt: (x) => x,
                cm: (x) => x / 2.54 * 72,
                mm: (x) => x / (10 * 2.54) * 72,
                in: (x) => x * 72,
                px: (x) => x
              };
              const measurementPattern = /([+-]?\d+\.?\d*)(.*)/;
              function stripQuotes(str) {
                if (str.startsWith("'") || str.startsWith('"')) {
                  return str.slice(1, str.length - 1);
                }
                return str;
              }
              __name(stripQuotes, "stripQuotes");
              function getInteger(_ref) {
                let {
                  data,
                  defaultValue,
                  validate
                } = _ref;
                if (!data) {
                  return defaultValue;
                }
                data = data.trim();
                const n = parseInt(data, 10);
                if (!isNaN(n) && validate(n)) {
                  return n;
                }
                return defaultValue;
              }
              __name(getInteger, "getInteger");
              function getFloat(_ref2) {
                let {
                  data,
                  defaultValue,
                  validate
                } = _ref2;
                if (!data) {
                  return defaultValue;
                }
                data = data.trim();
                const n = parseFloat(data);
                if (!isNaN(n) && validate(n)) {
                  return n;
                }
                return defaultValue;
              }
              __name(getFloat, "getFloat");
              function getKeyword(_ref3) {
                let {
                  data,
                  defaultValue,
                  validate
                } = _ref3;
                if (!data) {
                  return defaultValue;
                }
                data = data.trim();
                if (validate(data)) {
                  return data;
                }
                return defaultValue;
              }
              __name(getKeyword, "getKeyword");
              function getStringOption(data, options) {
                return getKeyword({
                  data,
                  defaultValue: options[0],
                  validate: (k) => options.includes(k)
                });
              }
              __name(getStringOption, "getStringOption");
              function getMeasurement(str) {
                let def = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "0";
                def = def || "0";
                if (!str) {
                  return getMeasurement(def);
                }
                const match = str.trim().match(measurementPattern);
                if (!match) {
                  return getMeasurement(def);
                }
                const [, valueStr, unit] = match;
                const value = parseFloat(valueStr);
                if (isNaN(value)) {
                  return getMeasurement(def);
                }
                if (value === 0) {
                  return 0;
                }
                const conv = dimConverters[unit];
                if (conv) {
                  return conv(value);
                }
                return value;
              }
              __name(getMeasurement, "getMeasurement");
              function getRatio(data) {
                if (!data) {
                  return {
                    num: 1,
                    den: 1
                  };
                }
                const ratio = data.trim().split(/\s*:\s*/).map((x) => parseFloat(x)).filter((x) => !isNaN(x));
                if (ratio.length === 1) {
                  ratio.push(1);
                }
                if (ratio.length === 0) {
                  return {
                    num: 1,
                    den: 1
                  };
                }
                const [num, den] = ratio;
                return {
                  num,
                  den
                };
              }
              __name(getRatio, "getRatio");
              function getRelevant(data) {
                if (!data) {
                  return [];
                }
                return data.trim().split(/\s+/).map((e) => {
                  return {
                    excluded: e[0] === "-",
                    viewname: e.substring(1)
                  };
                });
              }
              __name(getRelevant, "getRelevant");
              function getColor(data) {
                let def = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
                let [r, g, b] = def;
                if (!data) {
                  return {
                    r,
                    g,
                    b
                  };
                }
                const color = data.trim().split(/\s*,\s*/).map((c) => Math.min(Math.max(0, parseInt(c.trim(), 10)), 255)).map((c) => isNaN(c) ? 0 : c);
                if (color.length < 3) {
                  return {
                    r,
                    g,
                    b
                  };
                }
                [r, g, b] = color;
                return {
                  r,
                  g,
                  b
                };
              }
              __name(getColor, "getColor");
              function getBBox(data) {
                const def = -1;
                if (!data) {
                  return {
                    x: def,
                    y: def,
                    width: def,
                    height: def
                  };
                }
                const bbox = data.trim().split(/\s*,\s*/).map((m) => getMeasurement(m, "-1"));
                if (bbox.length < 4 || bbox[2] < 0 || bbox[3] < 0) {
                  return {
                    x: def,
                    y: def,
                    width: def,
                    height: def
                  };
                }
                const [x, y, width, height] = bbox;
                return {
                  x,
                  y,
                  width,
                  height
                };
              }
              __name(getBBox, "getBBox");
              const _HTMLResult = class _HTMLResult {
                static get FAILURE() {
                  return (0, _util.shadow)(this, "FAILURE", new _HTMLResult(false, null, null, null));
                }
                static get EMPTY() {
                  return (0, _util.shadow)(this, "EMPTY", new _HTMLResult(true, null, null, null));
                }
                constructor(success, html, bbox, breakNode) {
                  this.success = success;
                  this.html = html;
                  this.bbox = bbox;
                  this.breakNode = breakNode;
                }
                isBreak() {
                  return !!this.breakNode;
                }
                static breakNode(node) {
                  return new _HTMLResult(false, null, null, node);
                }
                static success(html) {
                  let bbox = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                  return new _HTMLResult(true, html, bbox, null);
                }
              };
              __name(_HTMLResult, "HTMLResult");
              let HTMLResult = _HTMLResult;
              exports2.HTMLResult = HTMLResult;
            },
            /* 204 */
            /***/
            (__unused_webpack_module, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.NamespaceIds = exports2.$buildXFAObject = void 0;
              const $buildXFAObject = Symbol();
              exports2.$buildXFAObject = $buildXFAObject;
              const NamespaceIds = {
                config: {
                  id: 0,
                  check: (ns) => ns.startsWith("http://www.xfa.org/schema/xci/")
                },
                connectionSet: {
                  id: 1,
                  check: (ns) => ns.startsWith("http://www.xfa.org/schema/xfa-connection-set/")
                },
                datasets: {
                  id: 2,
                  check: (ns) => ns.startsWith("http://www.xfa.org/schema/xfa-data/")
                },
                form: {
                  id: 3,
                  check: (ns) => ns.startsWith("http://www.xfa.org/schema/xfa-form/")
                },
                localeSet: {
                  id: 4,
                  check: (ns) => ns.startsWith("http://www.xfa.org/schema/xfa-locale-set/")
                },
                pdf: {
                  id: 5,
                  check: (ns) => ns === "http://ns.adobe.com/xdp/pdf/"
                },
                signature: {
                  id: 6,
                  check: (ns) => ns === "http://www.w3.org/2000/09/xmldsig#"
                },
                sourceSet: {
                  id: 7,
                  check: (ns) => ns.startsWith("http://www.xfa.org/schema/xfa-source-set/")
                },
                stylesheet: {
                  id: 8,
                  check: (ns) => ns === "http://www.w3.org/1999/XSL/Transform"
                },
                template: {
                  id: 9,
                  check: (ns) => ns.startsWith("http://www.xfa.org/schema/xfa-template/")
                },
                xdc: {
                  id: 10,
                  check: (ns) => ns.startsWith("http://www.xfa.org/schema/xdc/")
                },
                xdp: {
                  id: 11,
                  check: (ns) => ns === "http://ns.adobe.com/xdp/"
                },
                xfdf: {
                  id: 12,
                  check: (ns) => ns === "http://ns.adobe.com/xfdf/"
                },
                xhtml: {
                  id: 13,
                  check: (ns) => ns === "http://www.w3.org/1999/xhtml"
                },
                xmpmeta: {
                  id: 14,
                  check: (ns) => ns === "http://ns.adobe.com/xmpmeta/"
                }
              };
              exports2.NamespaceIds = NamespaceIds;
            },
            /* 205 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.createDataNode = createDataNode;
              exports2.searchNode = searchNode;
              var _xfa_object = __w_pdfjs_require__2(202);
              var _namespaces = __w_pdfjs_require__2(204);
              var _util = __w_pdfjs_require__2(2);
              const namePattern = /^[^.[]+/;
              const indexPattern = /^[^\]]+/;
              const operators = {
                dot: 0,
                dotDot: 1,
                dotHash: 2,
                dotBracket: 3,
                dotParen: 4
              };
              const shortcuts = /* @__PURE__ */ new Map([["$data", (root, current) => root.datasets ? root.datasets.data : root], ["$record", (root, current) => (root.datasets ? root.datasets.data : root)[_xfa_object.$getChildren]()[0]], ["$template", (root, current) => root.template], ["$connectionSet", (root, current) => root.connectionSet], ["$form", (root, current) => root.form], ["$layout", (root, current) => root.layout], ["$host", (root, current) => root.host], ["$dataWindow", (root, current) => root.dataWindow], ["$event", (root, current) => root.event], ["!", (root, current) => root.datasets], ["$xfa", (root, current) => root], ["xfa", (root, current) => root], ["$", (root, current) => current]]);
              const somCache = /* @__PURE__ */ new WeakMap();
              const NS_DATASETS = _namespaces.NamespaceIds.datasets.id;
              function parseIndex(index) {
                index = index.trim();
                if (index === "*") {
                  return Infinity;
                }
                return parseInt(index, 10) || 0;
              }
              __name(parseIndex, "parseIndex");
              function parseExpression(expr, dotDotAllowed) {
                let noExpr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
                let match = expr.match(namePattern);
                if (!match) {
                  return null;
                }
                let [name] = match;
                const parsed = [{
                  name,
                  cacheName: "." + name,
                  index: 0,
                  js: null,
                  formCalc: null,
                  operator: operators.dot
                }];
                let pos = name.length;
                while (pos < expr.length) {
                  const spos = pos;
                  const char = expr.charAt(pos++);
                  if (char === "[") {
                    match = expr.slice(pos).match(indexPattern);
                    if (!match) {
                      (0, _util.warn)("XFA - Invalid index in SOM expression");
                      return null;
                    }
                    parsed.at(-1).index = parseIndex(match[0]);
                    pos += match[0].length + 1;
                    continue;
                  }
                  let operator;
                  switch (expr.charAt(pos)) {
                    case ".":
                      if (!dotDotAllowed) {
                        return null;
                      }
                      pos++;
                      operator = operators.dotDot;
                      break;
                    case "#":
                      pos++;
                      operator = operators.dotHash;
                      break;
                    case "[":
                      if (noExpr) {
                        (0, _util.warn)("XFA - SOM expression contains a FormCalc subexpression which is not supported for now.");
                        return null;
                      }
                      operator = operators.dotBracket;
                      break;
                    case "(":
                      if (noExpr) {
                        (0, _util.warn)("XFA - SOM expression contains a JavaScript subexpression which is not supported for now.");
                        return null;
                      }
                      operator = operators.dotParen;
                      break;
                    default:
                      operator = operators.dot;
                      break;
                  }
                  match = expr.slice(pos).match(namePattern);
                  if (!match) {
                    break;
                  }
                  [name] = match;
                  pos += name.length;
                  parsed.push({
                    name,
                    cacheName: expr.slice(spos, pos),
                    operator,
                    index: 0,
                    js: null,
                    formCalc: null
                  });
                }
                return parsed;
              }
              __name(parseExpression, "parseExpression");
              function searchNode(root, container, expr) {
                let dotDotAllowed = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
                let useCache = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
                const parsed = parseExpression(expr, dotDotAllowed);
                if (!parsed) {
                  return null;
                }
                const fn = shortcuts.get(parsed[0].name);
                let i = 0;
                let isQualified;
                if (fn) {
                  isQualified = true;
                  root = [fn(root, container)];
                  i = 1;
                } else {
                  isQualified = container === null;
                  root = [container || root];
                }
                for (let ii = parsed.length; i < ii; i++) {
                  const {
                    name,
                    cacheName,
                    operator,
                    index
                  } = parsed[i];
                  const nodes = [];
                  for (const node of root) {
                    if (!(node instanceof _xfa_object.XFAObject)) {
                      continue;
                    }
                    let children, cached;
                    if (useCache) {
                      cached = somCache.get(node);
                      if (!cached) {
                        cached = /* @__PURE__ */ new Map();
                        somCache.set(node, cached);
                      }
                      children = cached.get(cacheName);
                    }
                    if (!children) {
                      switch (operator) {
                        case operators.dot:
                          children = node[_xfa_object.$getChildrenByName](name, false);
                          break;
                        case operators.dotDot:
                          children = node[_xfa_object.$getChildrenByName](name, true);
                          break;
                        case operators.dotHash:
                          children = node[_xfa_object.$getChildrenByClass](name);
                          if (children instanceof _xfa_object.XFAObjectArray) {
                            children = children.children;
                          } else {
                            children = [children];
                          }
                          break;
                      }
                      if (useCache) {
                        cached.set(cacheName, children);
                      }
                    }
                    if (children.length > 0) {
                      nodes.push(children);
                    }
                  }
                  if (nodes.length === 0 && !isQualified && i === 0) {
                    const parent = container[_xfa_object.$getParent]();
                    container = parent;
                    if (!container) {
                      return null;
                    }
                    i = -1;
                    root = [container];
                    continue;
                  }
                  if (isFinite(index)) {
                    root = nodes.filter((node) => index < node.length).map((node) => node[index]);
                  } else {
                    root = nodes.flat();
                  }
                }
                if (root.length === 0) {
                  return null;
                }
                return root;
              }
              __name(searchNode, "searchNode");
              function createNodes(root, path) {
                let node = null;
                for (const {
                  name,
                  index
                } of path) {
                  for (let i = 0, ii = !isFinite(index) ? 0 : index; i <= ii; i++) {
                    const nsId = root[_xfa_object.$namespaceId] === NS_DATASETS ? -1 : root[_xfa_object.$namespaceId];
                    node = new _xfa_object.XmlObject(nsId, name);
                    root[_xfa_object.$appendChild](node);
                  }
                  root = node;
                }
                return node;
              }
              __name(createNodes, "createNodes");
              function createDataNode(root, container, expr) {
                const parsed = parseExpression(expr);
                if (!parsed) {
                  return null;
                }
                if (parsed.some((x) => x.operator === operators.dotDot)) {
                  return null;
                }
                const fn = shortcuts.get(parsed[0].name);
                let i = 0;
                if (fn) {
                  root = fn(root, container);
                  i = 1;
                } else {
                  root = container || root;
                }
                for (let ii = parsed.length; i < ii; i++) {
                  const {
                    name,
                    operator,
                    index
                  } = parsed[i];
                  if (!isFinite(index)) {
                    parsed[i].index = 0;
                    return createNodes(root, parsed.slice(i));
                  }
                  let children;
                  switch (operator) {
                    case operators.dot:
                      children = root[_xfa_object.$getChildrenByName](name, false);
                      break;
                    case operators.dotDot:
                      children = root[_xfa_object.$getChildrenByName](name, true);
                      break;
                    case operators.dotHash:
                      children = root[_xfa_object.$getChildrenByClass](name);
                      if (children instanceof _xfa_object.XFAObjectArray) {
                        children = children.children;
                      } else {
                        children = [children];
                      }
                      break;
                  }
                  if (children.length === 0) {
                    return createNodes(root, parsed.slice(i));
                  }
                  if (index < children.length) {
                    const child = children[index];
                    if (!(child instanceof _xfa_object.XFAObject)) {
                      (0, _util.warn)(`XFA - Cannot create a node.`);
                      return null;
                    }
                    root = child;
                  } else {
                    parsed[i].index = index - children.length;
                    return createNodes(root, parsed.slice(i));
                  }
                }
                return null;
              }
              __name(createDataNode, "createDataNode");
            },
            /* 206 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Binder = void 0;
              var _xfa_object = __w_pdfjs_require__2(202);
              var _template = __w_pdfjs_require__2(207);
              var _som = __w_pdfjs_require__2(205);
              var _namespaces = __w_pdfjs_require__2(204);
              var _util = __w_pdfjs_require__2(2);
              const NS_DATASETS = _namespaces.NamespaceIds.datasets.id;
              function createText(content) {
                const node = new _template.Text({});
                node[_xfa_object.$content] = content;
                return node;
              }
              __name(createText, "createText");
              const _Binder = class _Binder {
                constructor(root) {
                  this.root = root;
                  this.datasets = root.datasets;
                  if (root.datasets && root.datasets.data) {
                    this.data = root.datasets.data;
                  } else {
                    this.data = new _xfa_object.XmlObject(_namespaces.NamespaceIds.datasets.id, "data");
                  }
                  this.emptyMerge = this.data[_xfa_object.$getChildren]().length === 0;
                  this.root.form = this.form = root.template[_xfa_object.$clone]();
                }
                _isConsumeData() {
                  return !this.emptyMerge && this._mergeMode;
                }
                _isMatchTemplate() {
                  return !this._isConsumeData();
                }
                bind() {
                  this._bindElement(this.form, this.data);
                  return this.form;
                }
                getData() {
                  return this.data;
                }
                _bindValue(formNode, data, picture) {
                  formNode[_xfa_object.$data] = data;
                  if (formNode[_xfa_object.$hasSettableValue]()) {
                    if (data[_xfa_object.$isDataValue]()) {
                      const value = data[_xfa_object.$getDataValue]();
                      formNode[_xfa_object.$setValue](createText(value));
                    } else if (formNode instanceof _template.Field && formNode.ui && formNode.ui.choiceList && formNode.ui.choiceList.open === "multiSelect") {
                      const value = data[_xfa_object.$getChildren]().map((child) => child[_xfa_object.$content].trim()).join("\n");
                      formNode[_xfa_object.$setValue](createText(value));
                    } else if (this._isConsumeData()) {
                      (0, _util.warn)(`XFA - Nodes haven't the same type.`);
                    }
                  } else if (!data[_xfa_object.$isDataValue]() || this._isMatchTemplate()) {
                    this._bindElement(formNode, data);
                  } else {
                    (0, _util.warn)(`XFA - Nodes haven't the same type.`);
                  }
                }
                _findDataByNameToConsume(name, isValue, dataNode, global2) {
                  if (!name) {
                    return null;
                  }
                  let generator, match;
                  for (let i = 0; i < 3; i++) {
                    generator = dataNode[_xfa_object.$getRealChildrenByNameIt](name, false, true);
                    while (true) {
                      match = generator.next().value;
                      if (!match) {
                        break;
                      }
                      if (isValue === match[_xfa_object.$isDataValue]()) {
                        return match;
                      }
                    }
                    if (dataNode[_xfa_object.$namespaceId] === _namespaces.NamespaceIds.datasets.id && dataNode[_xfa_object.$nodeName] === "data") {
                      break;
                    }
                    dataNode = dataNode[_xfa_object.$getParent]();
                  }
                  if (!global2) {
                    return null;
                  }
                  generator = this.data[_xfa_object.$getRealChildrenByNameIt](name, true, false);
                  match = generator.next().value;
                  if (match) {
                    return match;
                  }
                  generator = this.data[_xfa_object.$getAttributeIt](name, true);
                  match = generator.next().value;
                  if (match && match[_xfa_object.$isDataValue]()) {
                    return match;
                  }
                  return null;
                }
                _setProperties(formNode, dataNode) {
                  if (!formNode.hasOwnProperty("setProperty")) {
                    return;
                  }
                  for (const {
                    ref,
                    target,
                    connection
                  } of formNode.setProperty.children) {
                    if (connection) {
                      continue;
                    }
                    if (!ref) {
                      continue;
                    }
                    const nodes = (0, _som.searchNode)(this.root, dataNode, ref, false, false);
                    if (!nodes) {
                      (0, _util.warn)(`XFA - Invalid reference: ${ref}.`);
                      continue;
                    }
                    const [node] = nodes;
                    if (!node[_xfa_object.$isDescendent](this.data)) {
                      (0, _util.warn)(`XFA - Invalid node: must be a data node.`);
                      continue;
                    }
                    const targetNodes = (0, _som.searchNode)(this.root, formNode, target, false, false);
                    if (!targetNodes) {
                      (0, _util.warn)(`XFA - Invalid target: ${target}.`);
                      continue;
                    }
                    const [targetNode] = targetNodes;
                    if (!targetNode[_xfa_object.$isDescendent](formNode)) {
                      (0, _util.warn)(`XFA - Invalid target: must be a property or subproperty.`);
                      continue;
                    }
                    const targetParent = targetNode[_xfa_object.$getParent]();
                    if (targetNode instanceof _template.SetProperty || targetParent instanceof _template.SetProperty) {
                      (0, _util.warn)(`XFA - Invalid target: cannot be a setProperty or one of its properties.`);
                      continue;
                    }
                    if (targetNode instanceof _template.BindItems || targetParent instanceof _template.BindItems) {
                      (0, _util.warn)(`XFA - Invalid target: cannot be a bindItems or one of its properties.`);
                      continue;
                    }
                    const content = node[_xfa_object.$text]();
                    const name = targetNode[_xfa_object.$nodeName];
                    if (targetNode instanceof _xfa_object.XFAAttribute) {
                      const attrs = /* @__PURE__ */ Object.create(null);
                      attrs[name] = content;
                      const obj = Reflect.construct(Object.getPrototypeOf(targetParent).constructor, [attrs]);
                      targetParent[name] = obj[name];
                      continue;
                    }
                    if (!targetNode.hasOwnProperty(_xfa_object.$content)) {
                      (0, _util.warn)(`XFA - Invalid node to use in setProperty`);
                      continue;
                    }
                    targetNode[_xfa_object.$data] = node;
                    targetNode[_xfa_object.$content] = content;
                    targetNode[_xfa_object.$finalize]();
                  }
                }
                _bindItems(formNode, dataNode) {
                  if (!formNode.hasOwnProperty("items") || !formNode.hasOwnProperty("bindItems") || formNode.bindItems.isEmpty()) {
                    return;
                  }
                  for (const item of formNode.items.children) {
                    formNode[_xfa_object.$removeChild](item);
                  }
                  formNode.items.clear();
                  const labels = new _template.Items({});
                  const values = new _template.Items({});
                  formNode[_xfa_object.$appendChild](labels);
                  formNode.items.push(labels);
                  formNode[_xfa_object.$appendChild](values);
                  formNode.items.push(values);
                  for (const {
                    ref,
                    labelRef,
                    valueRef,
                    connection
                  } of formNode.bindItems.children) {
                    if (connection) {
                      continue;
                    }
                    if (!ref) {
                      continue;
                    }
                    const nodes = (0, _som.searchNode)(this.root, dataNode, ref, false, false);
                    if (!nodes) {
                      (0, _util.warn)(`XFA - Invalid reference: ${ref}.`);
                      continue;
                    }
                    for (const node of nodes) {
                      if (!node[_xfa_object.$isDescendent](this.datasets)) {
                        (0, _util.warn)(`XFA - Invalid ref (${ref}): must be a datasets child.`);
                        continue;
                      }
                      const labelNodes = (0, _som.searchNode)(this.root, node, labelRef, true, false);
                      if (!labelNodes) {
                        (0, _util.warn)(`XFA - Invalid label: ${labelRef}.`);
                        continue;
                      }
                      const [labelNode] = labelNodes;
                      if (!labelNode[_xfa_object.$isDescendent](this.datasets)) {
                        (0, _util.warn)(`XFA - Invalid label: must be a datasets child.`);
                        continue;
                      }
                      const valueNodes = (0, _som.searchNode)(this.root, node, valueRef, true, false);
                      if (!valueNodes) {
                        (0, _util.warn)(`XFA - Invalid value: ${valueRef}.`);
                        continue;
                      }
                      const [valueNode] = valueNodes;
                      if (!valueNode[_xfa_object.$isDescendent](this.datasets)) {
                        (0, _util.warn)(`XFA - Invalid value: must be a datasets child.`);
                        continue;
                      }
                      const label = createText(labelNode[_xfa_object.$text]());
                      const value = createText(valueNode[_xfa_object.$text]());
                      labels[_xfa_object.$appendChild](label);
                      labels.text.push(label);
                      values[_xfa_object.$appendChild](value);
                      values.text.push(value);
                    }
                  }
                }
                _bindOccurrences(formNode, matches, picture) {
                  let baseClone;
                  if (matches.length > 1) {
                    baseClone = formNode[_xfa_object.$clone]();
                    baseClone[_xfa_object.$removeChild](baseClone.occur);
                    baseClone.occur = null;
                  }
                  this._bindValue(formNode, matches[0], picture);
                  this._setProperties(formNode, matches[0]);
                  this._bindItems(formNode, matches[0]);
                  if (matches.length === 1) {
                    return;
                  }
                  const parent = formNode[_xfa_object.$getParent]();
                  const name = formNode[_xfa_object.$nodeName];
                  const pos = parent[_xfa_object.$indexOf](formNode);
                  for (let i = 1, ii = matches.length; i < ii; i++) {
                    const match = matches[i];
                    const clone = baseClone[_xfa_object.$clone]();
                    parent[name].push(clone);
                    parent[_xfa_object.$insertAt](pos + i, clone);
                    this._bindValue(clone, match, picture);
                    this._setProperties(clone, match);
                    this._bindItems(clone, match);
                  }
                }
                _createOccurrences(formNode) {
                  if (!this.emptyMerge) {
                    return;
                  }
                  const {
                    occur
                  } = formNode;
                  if (!occur || occur.initial <= 1) {
                    return;
                  }
                  const parent = formNode[_xfa_object.$getParent]();
                  const name = formNode[_xfa_object.$nodeName];
                  if (!(parent[name] instanceof _xfa_object.XFAObjectArray)) {
                    return;
                  }
                  let currentNumber;
                  if (formNode.name) {
                    currentNumber = parent[name].children.filter((e) => e.name === formNode.name).length;
                  } else {
                    currentNumber = parent[name].children.length;
                  }
                  const pos = parent[_xfa_object.$indexOf](formNode) + 1;
                  const ii = occur.initial - currentNumber;
                  if (ii) {
                    const nodeClone = formNode[_xfa_object.$clone]();
                    nodeClone[_xfa_object.$removeChild](nodeClone.occur);
                    nodeClone.occur = null;
                    parent[name].push(nodeClone);
                    parent[_xfa_object.$insertAt](pos, nodeClone);
                    for (let i = 1; i < ii; i++) {
                      const clone = nodeClone[_xfa_object.$clone]();
                      parent[name].push(clone);
                      parent[_xfa_object.$insertAt](pos + i, clone);
                    }
                  }
                }
                _getOccurInfo(formNode) {
                  const {
                    name,
                    occur
                  } = formNode;
                  if (!occur || !name) {
                    return [1, 1];
                  }
                  const max = occur.max === -1 ? Infinity : occur.max;
                  return [occur.min, max];
                }
                _setAndBind(formNode, dataNode) {
                  this._setProperties(formNode, dataNode);
                  this._bindItems(formNode, dataNode);
                  this._bindElement(formNode, dataNode);
                }
                _bindElement(formNode, dataNode) {
                  const uselessNodes = [];
                  this._createOccurrences(formNode);
                  for (const child of formNode[_xfa_object.$getChildren]()) {
                    if (child[_xfa_object.$data]) {
                      continue;
                    }
                    if (this._mergeMode === void 0 && child[_xfa_object.$nodeName] === "subform") {
                      this._mergeMode = child.mergeMode === "consumeData";
                      const dataChildren = dataNode[_xfa_object.$getChildren]();
                      if (dataChildren.length > 0) {
                        this._bindOccurrences(child, [dataChildren[0]], null);
                      } else if (this.emptyMerge) {
                        const nsId = dataNode[_xfa_object.$namespaceId] === NS_DATASETS ? -1 : dataNode[_xfa_object.$namespaceId];
                        const dataChild = child[_xfa_object.$data] = new _xfa_object.XmlObject(nsId, child.name || "root");
                        dataNode[_xfa_object.$appendChild](dataChild);
                        this._bindElement(child, dataChild);
                      }
                      continue;
                    }
                    if (!child[_xfa_object.$isBindable]()) {
                      continue;
                    }
                    let global2 = false;
                    let picture = null;
                    let ref = null;
                    let match = null;
                    if (child.bind) {
                      switch (child.bind.match) {
                        case "none":
                          this._setAndBind(child, dataNode);
                          continue;
                        case "global":
                          global2 = true;
                          break;
                        case "dataRef":
                          if (!child.bind.ref) {
                            (0, _util.warn)(`XFA - ref is empty in node ${child[_xfa_object.$nodeName]}.`);
                            this._setAndBind(child, dataNode);
                            continue;
                          }
                          ref = child.bind.ref;
                          break;
                      }
                      if (child.bind.picture) {
                        picture = child.bind.picture[_xfa_object.$content];
                      }
                    }
                    const [min, max] = this._getOccurInfo(child);
                    if (ref) {
                      match = (0, _som.searchNode)(this.root, dataNode, ref, true, false);
                      if (match === null) {
                        match = (0, _som.createDataNode)(this.data, dataNode, ref);
                        if (!match) {
                          continue;
                        }
                        if (this._isConsumeData()) {
                          match[_xfa_object.$consumed] = true;
                        }
                        this._setAndBind(child, match);
                        continue;
                      } else {
                        if (this._isConsumeData()) {
                          match = match.filter((node) => !node[_xfa_object.$consumed]);
                        }
                        if (match.length > max) {
                          match = match.slice(0, max);
                        } else if (match.length === 0) {
                          match = null;
                        }
                        if (match && this._isConsumeData()) {
                          match.forEach((node) => {
                            node[_xfa_object.$consumed] = true;
                          });
                        }
                      }
                    } else {
                      if (!child.name) {
                        this._setAndBind(child, dataNode);
                        continue;
                      }
                      if (this._isConsumeData()) {
                        const matches = [];
                        while (matches.length < max) {
                          const found = this._findDataByNameToConsume(child.name, child[_xfa_object.$hasSettableValue](), dataNode, global2);
                          if (!found) {
                            break;
                          }
                          found[_xfa_object.$consumed] = true;
                          matches.push(found);
                        }
                        match = matches.length > 0 ? matches : null;
                      } else {
                        match = dataNode[_xfa_object.$getRealChildrenByNameIt](child.name, false, this.emptyMerge).next().value;
                        if (!match) {
                          if (min === 0) {
                            uselessNodes.push(child);
                            continue;
                          }
                          const nsId = dataNode[_xfa_object.$namespaceId] === NS_DATASETS ? -1 : dataNode[_xfa_object.$namespaceId];
                          match = child[_xfa_object.$data] = new _xfa_object.XmlObject(nsId, child.name);
                          if (this.emptyMerge) {
                            match[_xfa_object.$consumed] = true;
                          }
                          dataNode[_xfa_object.$appendChild](match);
                          this._setAndBind(child, match);
                          continue;
                        }
                        if (this.emptyMerge) {
                          match[_xfa_object.$consumed] = true;
                        }
                        match = [match];
                      }
                    }
                    if (match) {
                      this._bindOccurrences(child, match, picture);
                    } else if (min > 0) {
                      this._setAndBind(child, dataNode);
                    } else {
                      uselessNodes.push(child);
                    }
                  }
                  uselessNodes.forEach((node) => node[_xfa_object.$getParent]()[_xfa_object.$removeChild](node));
                }
              };
              __name(_Binder, "Binder");
              let Binder = _Binder;
              exports2.Binder = Binder;
            },
            /* 207 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Value = exports2.Text = exports2.TemplateNamespace = exports2.Template = exports2.SetProperty = exports2.Items = exports2.Field = exports2.BindItems = void 0;
              var _xfa_object = __w_pdfjs_require__2(202);
              var _namespaces = __w_pdfjs_require__2(204);
              var _layout = __w_pdfjs_require__2(208);
              var _html_utils = __w_pdfjs_require__2(209);
              var _utils = __w_pdfjs_require__2(203);
              var _util = __w_pdfjs_require__2(2);
              var _fonts = __w_pdfjs_require__2(210);
              var _core_utils = __w_pdfjs_require__2(131);
              var _som = __w_pdfjs_require__2(205);
              const TEMPLATE_NS_ID = _namespaces.NamespaceIds.template.id;
              const SVG_NS = "http://www.w3.org/2000/svg";
              const MAX_ATTEMPTS_FOR_LRTB_LAYOUT = 2;
              const MAX_EMPTY_PAGES = 3;
              const DEFAULT_TAB_INDEX = 5e3;
              const HEADING_PATTERN = /^H(\d+)$/;
              const MIMES = /* @__PURE__ */ new Set(["image/gif", "image/jpeg", "image/jpg", "image/pjpeg", "image/png", "image/apng", "image/x-png", "image/bmp", "image/x-ms-bmp", "image/tiff", "image/tif", "application/octet-stream"]);
              const IMAGES_HEADERS = [[[66, 77], "image/bmp"], [[255, 216, 255], "image/jpeg"], [[73, 73, 42, 0], "image/tiff"], [[77, 77, 0, 42], "image/tiff"], [[71, 73, 70, 56, 57, 97], "image/gif"], [[137, 80, 78, 71, 13, 10, 26, 10], "image/png"]];
              function getBorderDims(node) {
                if (!node || !node.border) {
                  return {
                    w: 0,
                    h: 0
                  };
                }
                const borderExtra = node.border[_xfa_object.$getExtra]();
                if (!borderExtra) {
                  return {
                    w: 0,
                    h: 0
                  };
                }
                return {
                  w: borderExtra.widths[0] + borderExtra.widths[2] + borderExtra.insets[0] + borderExtra.insets[2],
                  h: borderExtra.widths[1] + borderExtra.widths[3] + borderExtra.insets[1] + borderExtra.insets[3]
                };
              }
              __name(getBorderDims, "getBorderDims");
              function hasMargin(node) {
                return node.margin && (node.margin.topInset || node.margin.rightInset || node.margin.bottomInset || node.margin.leftInset);
              }
              __name(hasMargin, "hasMargin");
              function _setValue(templateNode, value) {
                if (!templateNode.value) {
                  const nodeValue = new Value({});
                  templateNode[_xfa_object.$appendChild](nodeValue);
                  templateNode.value = nodeValue;
                }
                templateNode.value[_xfa_object.$setValue](value);
              }
              __name(_setValue, "_setValue");
              function* getContainedChildren(node) {
                for (const child of node[_xfa_object.$getChildren]()) {
                  if (child instanceof SubformSet) {
                    yield* child[_xfa_object.$getContainedChildren]();
                    continue;
                  }
                  yield child;
                }
              }
              __name(getContainedChildren, "getContainedChildren");
              function isRequired(node) {
                return node.validate && node.validate.nullTest === "error";
              }
              __name(isRequired, "isRequired");
              function setTabIndex(node) {
                while (node) {
                  if (!node.traversal) {
                    node[_xfa_object.$tabIndex] = node[_xfa_object.$getParent]()[_xfa_object.$tabIndex];
                    return;
                  }
                  if (node[_xfa_object.$tabIndex]) {
                    return;
                  }
                  let next = null;
                  for (const child of node.traversal[_xfa_object.$getChildren]()) {
                    if (child.operation === "next") {
                      next = child;
                      break;
                    }
                  }
                  if (!next || !next.ref) {
                    node[_xfa_object.$tabIndex] = node[_xfa_object.$getParent]()[_xfa_object.$tabIndex];
                    return;
                  }
                  const root = node[_xfa_object.$getTemplateRoot]();
                  node[_xfa_object.$tabIndex] = ++root[_xfa_object.$tabIndex];
                  const ref = root[_xfa_object.$searchNode](next.ref, node);
                  if (!ref) {
                    return;
                  }
                  node = ref[0];
                }
              }
              __name(setTabIndex, "setTabIndex");
              function applyAssist(obj, attributes) {
                const assist = obj.assist;
                if (assist) {
                  const assistTitle = assist[_xfa_object.$toHTML]();
                  if (assistTitle) {
                    attributes.title = assistTitle;
                  }
                  const role = assist.role;
                  const match = role.match(HEADING_PATTERN);
                  if (match) {
                    const ariaRole = "heading";
                    const ariaLevel = match[1];
                    attributes.role = ariaRole;
                    attributes["aria-level"] = ariaLevel;
                  }
                }
                if (obj.layout === "table") {
                  attributes.role = "table";
                } else if (obj.layout === "row") {
                  attributes.role = "row";
                } else {
                  const parent = obj[_xfa_object.$getParent]();
                  if (parent.layout === "row") {
                    if (parent.assist && parent.assist.role === "TH") {
                      attributes.role = "columnheader";
                    } else {
                      attributes.role = "cell";
                    }
                  }
                }
              }
              __name(applyAssist, "applyAssist");
              function ariaLabel(obj) {
                if (!obj.assist) {
                  return null;
                }
                const assist = obj.assist;
                if (assist.speak && assist.speak[_xfa_object.$content] !== "") {
                  return assist.speak[_xfa_object.$content];
                }
                if (assist.toolTip) {
                  return assist.toolTip[_xfa_object.$content];
                }
                return null;
              }
              __name(ariaLabel, "ariaLabel");
              function valueToHtml(value) {
                return _utils.HTMLResult.success({
                  name: "div",
                  attributes: {
                    class: ["xfaRich"],
                    style: /* @__PURE__ */ Object.create(null)
                  },
                  children: [{
                    name: "span",
                    attributes: {
                      style: /* @__PURE__ */ Object.create(null)
                    },
                    value
                  }]
                });
              }
              __name(valueToHtml, "valueToHtml");
              function setFirstUnsplittable(node) {
                const root = node[_xfa_object.$getTemplateRoot]();
                if (root[_xfa_object.$extra].firstUnsplittable === null) {
                  root[_xfa_object.$extra].firstUnsplittable = node;
                  root[_xfa_object.$extra].noLayoutFailure = true;
                }
              }
              __name(setFirstUnsplittable, "setFirstUnsplittable");
              function unsetFirstUnsplittable(node) {
                const root = node[_xfa_object.$getTemplateRoot]();
                if (root[_xfa_object.$extra].firstUnsplittable === node) {
                  root[_xfa_object.$extra].noLayoutFailure = false;
                }
              }
              __name(unsetFirstUnsplittable, "unsetFirstUnsplittable");
              function handleBreak(node) {
                if (node[_xfa_object.$extra]) {
                  return false;
                }
                node[_xfa_object.$extra] = /* @__PURE__ */ Object.create(null);
                if (node.targetType === "auto") {
                  return false;
                }
                const root = node[_xfa_object.$getTemplateRoot]();
                let target = null;
                if (node.target) {
                  target = root[_xfa_object.$searchNode](node.target, node[_xfa_object.$getParent]());
                  if (!target) {
                    return false;
                  }
                  target = target[0];
                }
                const {
                  currentPageArea,
                  currentContentArea
                } = root[_xfa_object.$extra];
                if (node.targetType === "pageArea") {
                  if (!(target instanceof PageArea)) {
                    target = null;
                  }
                  if (node.startNew) {
                    node[_xfa_object.$extra].target = target || currentPageArea;
                    return true;
                  } else if (target && target !== currentPageArea) {
                    node[_xfa_object.$extra].target = target;
                    return true;
                  }
                  return false;
                }
                if (!(target instanceof ContentArea)) {
                  target = null;
                }
                const pageArea = target && target[_xfa_object.$getParent]();
                let index;
                let nextPageArea = pageArea;
                if (node.startNew) {
                  if (target) {
                    const contentAreas = pageArea.contentArea.children;
                    const indexForCurrent = contentAreas.indexOf(currentContentArea);
                    const indexForTarget = contentAreas.indexOf(target);
                    if (indexForCurrent !== -1 && indexForCurrent < indexForTarget) {
                      nextPageArea = null;
                    }
                    index = indexForTarget - 1;
                  } else {
                    index = currentPageArea.contentArea.children.indexOf(currentContentArea);
                  }
                } else if (target && target !== currentContentArea) {
                  const contentAreas = pageArea.contentArea.children;
                  index = contentAreas.indexOf(target) - 1;
                  nextPageArea = pageArea === currentPageArea ? null : pageArea;
                } else {
                  return false;
                }
                node[_xfa_object.$extra].target = nextPageArea;
                node[_xfa_object.$extra].index = index;
                return true;
              }
              __name(handleBreak, "handleBreak");
              function handleOverflow(node, extraNode, space) {
                const root = node[_xfa_object.$getTemplateRoot]();
                const saved = root[_xfa_object.$extra].noLayoutFailure;
                const savedMethod = extraNode[_xfa_object.$getSubformParent];
                extraNode[_xfa_object.$getSubformParent] = () => node;
                root[_xfa_object.$extra].noLayoutFailure = true;
                const res = extraNode[_xfa_object.$toHTML](space);
                node[_xfa_object.$addHTML](res.html, res.bbox);
                root[_xfa_object.$extra].noLayoutFailure = saved;
                extraNode[_xfa_object.$getSubformParent] = savedMethod;
              }
              __name(handleOverflow, "handleOverflow");
              const _AppearanceFilter = class _AppearanceFilter extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "appearanceFilter");
                  this.id = attributes.id || "";
                  this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              };
              __name(_AppearanceFilter, "AppearanceFilter");
              let AppearanceFilter = _AppearanceFilter;
              const _Arc = class _Arc extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "arc", true);
                  this.circular = (0, _utils.getInteger)({
                    data: attributes.circular,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.hand = (0, _utils.getStringOption)(attributes.hand, ["even", "left", "right"]);
                  this.id = attributes.id || "";
                  this.startAngle = (0, _utils.getFloat)({
                    data: attributes.startAngle,
                    defaultValue: 0,
                    validate: (x) => true
                  });
                  this.sweepAngle = (0, _utils.getFloat)({
                    data: attributes.sweepAngle,
                    defaultValue: 360,
                    validate: (x) => true
                  });
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.edge = null;
                  this.fill = null;
                }
                [_xfa_object.$toHTML]() {
                  const edge = this.edge || new Edge({});
                  const edgeStyle = edge[_xfa_object.$toStyle]();
                  const style = /* @__PURE__ */ Object.create(null);
                  if (this.fill && this.fill.presence === "visible") {
                    Object.assign(style, this.fill[_xfa_object.$toStyle]());
                  } else {
                    style.fill = "transparent";
                  }
                  style.strokeWidth = (0, _html_utils.measureToString)(edge.presence === "visible" ? edge.thickness : 0);
                  style.stroke = edgeStyle.color;
                  let arc;
                  const attributes = {
                    xmlns: SVG_NS,
                    style: {
                      width: "100%",
                      height: "100%",
                      overflow: "visible"
                    }
                  };
                  if (this.sweepAngle === 360) {
                    arc = {
                      name: "ellipse",
                      attributes: {
                        xmlns: SVG_NS,
                        cx: "50%",
                        cy: "50%",
                        rx: "50%",
                        ry: "50%",
                        style
                      }
                    };
                  } else {
                    const startAngle = this.startAngle * Math.PI / 180;
                    const sweepAngle = this.sweepAngle * Math.PI / 180;
                    const largeArc = this.sweepAngle > 180 ? 1 : 0;
                    const [x1, y1, x2, y2] = [50 * (1 + Math.cos(startAngle)), 50 * (1 - Math.sin(startAngle)), 50 * (1 + Math.cos(startAngle + sweepAngle)), 50 * (1 - Math.sin(startAngle + sweepAngle))];
                    arc = {
                      name: "path",
                      attributes: {
                        xmlns: SVG_NS,
                        d: `M ${x1} ${y1} A 50 50 0 ${largeArc} 0 ${x2} ${y2}`,
                        vectorEffect: "non-scaling-stroke",
                        style
                      }
                    };
                    Object.assign(attributes, {
                      viewBox: "0 0 100 100",
                      preserveAspectRatio: "none"
                    });
                  }
                  const svg = {
                    name: "svg",
                    children: [arc],
                    attributes
                  };
                  const parent = this[_xfa_object.$getParent]()[_xfa_object.$getParent]();
                  if (hasMargin(parent)) {
                    return _utils.HTMLResult.success({
                      name: "div",
                      attributes: {
                        style: {
                          display: "inline",
                          width: "100%",
                          height: "100%"
                        }
                      },
                      children: [svg]
                    });
                  }
                  svg.attributes.style.position = "absolute";
                  return _utils.HTMLResult.success(svg);
                }
              };
              __name(_Arc, "Arc");
              let Arc = _Arc;
              const _Area = class _Area extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "area", true);
                  this.colSpan = (0, _utils.getInteger)({
                    data: attributes.colSpan,
                    defaultValue: 1,
                    validate: (n) => n >= 1 || n === -1
                  });
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.relevant = (0, _utils.getRelevant)(attributes.relevant);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.x = (0, _utils.getMeasurement)(attributes.x, "0pt");
                  this.y = (0, _utils.getMeasurement)(attributes.y, "0pt");
                  this.desc = null;
                  this.extras = null;
                  this.area = new _xfa_object.XFAObjectArray();
                  this.draw = new _xfa_object.XFAObjectArray();
                  this.exObject = new _xfa_object.XFAObjectArray();
                  this.exclGroup = new _xfa_object.XFAObjectArray();
                  this.field = new _xfa_object.XFAObjectArray();
                  this.subform = new _xfa_object.XFAObjectArray();
                  this.subformSet = new _xfa_object.XFAObjectArray();
                }
                *[_xfa_object.$getContainedChildren]() {
                  yield* getContainedChildren(this);
                }
                [_xfa_object.$isTransparent]() {
                  return true;
                }
                [_xfa_object.$isBindable]() {
                  return true;
                }
                [_xfa_object.$addHTML](html, bbox) {
                  const [x, y, w, h] = bbox;
                  this[_xfa_object.$extra].width = Math.max(this[_xfa_object.$extra].width, x + w);
                  this[_xfa_object.$extra].height = Math.max(this[_xfa_object.$extra].height, y + h);
                  this[_xfa_object.$extra].children.push(html);
                }
                [_xfa_object.$getAvailableSpace]() {
                  return this[_xfa_object.$extra].availableSpace;
                }
                [_xfa_object.$toHTML](availableSpace) {
                  const style = (0, _html_utils.toStyle)(this, "position");
                  const attributes = {
                    style,
                    id: this[_xfa_object.$uid],
                    class: ["xfaArea"]
                  };
                  if ((0, _html_utils.isPrintOnly)(this)) {
                    attributes.class.push("xfaPrintOnly");
                  }
                  if (this.name) {
                    attributes.xfaName = this.name;
                  }
                  const children = [];
                  this[_xfa_object.$extra] = {
                    children,
                    width: 0,
                    height: 0,
                    availableSpace
                  };
                  const result = this[_xfa_object.$childrenToHTML]({
                    filter: /* @__PURE__ */ new Set(["area", "draw", "field", "exclGroup", "subform", "subformSet"]),
                    include: true
                  });
                  if (!result.success) {
                    if (result.isBreak()) {
                      return result;
                    }
                    delete this[_xfa_object.$extra];
                    return _utils.HTMLResult.FAILURE;
                  }
                  style.width = (0, _html_utils.measureToString)(this[_xfa_object.$extra].width);
                  style.height = (0, _html_utils.measureToString)(this[_xfa_object.$extra].height);
                  const html = {
                    name: "div",
                    attributes,
                    children
                  };
                  const bbox = [this.x, this.y, this[_xfa_object.$extra].width, this[_xfa_object.$extra].height];
                  delete this[_xfa_object.$extra];
                  return _utils.HTMLResult.success(html, bbox);
                }
              };
              __name(_Area, "Area");
              let Area = _Area;
              const _Assist = class _Assist extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "assist", true);
                  this.id = attributes.id || "";
                  this.role = attributes.role || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.speak = null;
                  this.toolTip = null;
                }
                [_xfa_object.$toHTML]() {
                  return this.toolTip && this.toolTip[_xfa_object.$content] ? this.toolTip[_xfa_object.$content] : null;
                }
              };
              __name(_Assist, "Assist");
              let Assist = _Assist;
              const _Barcode = class _Barcode extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "barcode", true);
                  this.charEncoding = (0, _utils.getKeyword)({
                    data: attributes.charEncoding ? attributes.charEncoding.toLowerCase() : "",
                    defaultValue: "",
                    validate: (k) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(k) || k.match(/iso-8859-\d{2}/)
                  });
                  this.checksum = (0, _utils.getStringOption)(attributes.checksum, ["none", "1mod10", "1mod10_1mod11", "2mod10", "auto"]);
                  this.dataColumnCount = (0, _utils.getInteger)({
                    data: attributes.dataColumnCount,
                    defaultValue: -1,
                    validate: (x) => x >= 0
                  });
                  this.dataLength = (0, _utils.getInteger)({
                    data: attributes.dataLength,
                    defaultValue: -1,
                    validate: (x) => x >= 0
                  });
                  this.dataPrep = (0, _utils.getStringOption)(attributes.dataPrep, ["none", "flateCompress"]);
                  this.dataRowCount = (0, _utils.getInteger)({
                    data: attributes.dataRowCount,
                    defaultValue: -1,
                    validate: (x) => x >= 0
                  });
                  this.endChar = attributes.endChar || "";
                  this.errorCorrectionLevel = (0, _utils.getInteger)({
                    data: attributes.errorCorrectionLevel,
                    defaultValue: -1,
                    validate: (x) => x >= 0 && x <= 8
                  });
                  this.id = attributes.id || "";
                  this.moduleHeight = (0, _utils.getMeasurement)(attributes.moduleHeight, "5mm");
                  this.moduleWidth = (0, _utils.getMeasurement)(attributes.moduleWidth, "0.25mm");
                  this.printCheckDigit = (0, _utils.getInteger)({
                    data: attributes.printCheckDigit,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.rowColumnRatio = (0, _utils.getRatio)(attributes.rowColumnRatio);
                  this.startChar = attributes.startChar || "";
                  this.textLocation = (0, _utils.getStringOption)(attributes.textLocation, ["below", "above", "aboveEmbedded", "belowEmbedded", "none"]);
                  this.truncate = (0, _utils.getInteger)({
                    data: attributes.truncate,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.type = (0, _utils.getStringOption)(attributes.type ? attributes.type.toLowerCase() : "", ["aztec", "codabar", "code2of5industrial", "code2of5interleaved", "code2of5matrix", "code2of5standard", "code3of9", "code3of9extended", "code11", "code49", "code93", "code128", "code128a", "code128b", "code128c", "code128sscc", "datamatrix", "ean8", "ean8add2", "ean8add5", "ean13", "ean13add2", "ean13add5", "ean13pwcd", "fim", "logmars", "maxicode", "msi", "pdf417", "pdf417macro", "plessey", "postauscust2", "postauscust3", "postausreplypaid", "postausstandard", "postukrm4scc", "postusdpbc", "postusimb", "postusstandard", "postus5zip", "qrcode", "rfid", "rss14", "rss14expanded", "rss14limited", "rss14stacked", "rss14stackedomni", "rss14truncated", "telepen", "ucc128", "ucc128random", "ucc128sscc", "upca", "upcaadd2", "upcaadd5", "upcapwcd", "upce", "upceadd2", "upceadd5", "upcean2", "upcean5", "upsmaxicode"]);
                  this.upsMode = (0, _utils.getStringOption)(attributes.upsMode, ["usCarrier", "internationalCarrier", "secureSymbol", "standardSymbol"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.wideNarrowRatio = (0, _utils.getRatio)(attributes.wideNarrowRatio);
                  this.encrypt = null;
                  this.extras = null;
                }
              };
              __name(_Barcode, "Barcode");
              let Barcode = _Barcode;
              const _Bind = class _Bind extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "bind", true);
                  this.match = (0, _utils.getStringOption)(attributes.match, ["once", "dataRef", "global", "none"]);
                  this.ref = attributes.ref || "";
                  this.picture = null;
                }
              };
              __name(_Bind, "Bind");
              let Bind = _Bind;
              const _BindItems = class _BindItems extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "bindItems");
                  this.connection = attributes.connection || "";
                  this.labelRef = attributes.labelRef || "";
                  this.ref = attributes.ref || "";
                  this.valueRef = attributes.valueRef || "";
                }
              };
              __name(_BindItems, "BindItems");
              let BindItems = _BindItems;
              exports2.BindItems = BindItems;
              const _Bookend = class _Bookend extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "bookend");
                  this.id = attributes.id || "";
                  this.leader = attributes.leader || "";
                  this.trailer = attributes.trailer || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              };
              __name(_Bookend, "Bookend");
              let Bookend = _Bookend;
              const _BooleanElement = class _BooleanElement extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "boolean");
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
                [_xfa_object.$toHTML](availableSpace) {
                  return valueToHtml(this[_xfa_object.$content] === 1 ? "1" : "0");
                }
              };
              __name(_BooleanElement, "BooleanElement");
              let BooleanElement = _BooleanElement;
              const _Border = class _Border extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "border", true);
                  this.break = (0, _utils.getStringOption)(attributes.break, ["close", "open"]);
                  this.hand = (0, _utils.getStringOption)(attributes.hand, ["even", "left", "right"]);
                  this.id = attributes.id || "";
                  this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
                  this.relevant = (0, _utils.getRelevant)(attributes.relevant);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.corner = new _xfa_object.XFAObjectArray(4);
                  this.edge = new _xfa_object.XFAObjectArray(4);
                  this.extras = null;
                  this.fill = null;
                  this.margin = null;
                }
                [_xfa_object.$getExtra]() {
                  if (!this[_xfa_object.$extra]) {
                    const edges = this.edge.children.slice();
                    if (edges.length < 4) {
                      const defaultEdge = edges.at(-1) || new Edge({});
                      for (let i = edges.length; i < 4; i++) {
                        edges.push(defaultEdge);
                      }
                    }
                    const widths = edges.map((edge) => edge.thickness);
                    const insets = [0, 0, 0, 0];
                    if (this.margin) {
                      insets[0] = this.margin.topInset;
                      insets[1] = this.margin.rightInset;
                      insets[2] = this.margin.bottomInset;
                      insets[3] = this.margin.leftInset;
                    }
                    this[_xfa_object.$extra] = {
                      widths,
                      insets,
                      edges
                    };
                  }
                  return this[_xfa_object.$extra];
                }
                [_xfa_object.$toStyle]() {
                  const {
                    edges
                  } = this[_xfa_object.$getExtra]();
                  const edgeStyles = edges.map((node) => {
                    const style2 = node[_xfa_object.$toStyle]();
                    style2.color = style2.color || "#000000";
                    return style2;
                  });
                  const style = /* @__PURE__ */ Object.create(null);
                  if (this.margin) {
                    Object.assign(style, this.margin[_xfa_object.$toStyle]());
                  }
                  if (this.fill && this.fill.presence === "visible") {
                    Object.assign(style, this.fill[_xfa_object.$toStyle]());
                  }
                  if (this.corner.children.some((node) => node.radius !== 0)) {
                    const cornerStyles = this.corner.children.map((node) => node[_xfa_object.$toStyle]());
                    if (cornerStyles.length === 2 || cornerStyles.length === 3) {
                      const last = cornerStyles.at(-1);
                      for (let i = cornerStyles.length; i < 4; i++) {
                        cornerStyles.push(last);
                      }
                    }
                    style.borderRadius = cornerStyles.map((s) => s.radius).join(" ");
                  }
                  switch (this.presence) {
                    case "invisible":
                    case "hidden":
                      style.borderStyle = "";
                      break;
                    case "inactive":
                      style.borderStyle = "none";
                      break;
                    default:
                      style.borderStyle = edgeStyles.map((s) => s.style).join(" ");
                      break;
                  }
                  style.borderWidth = edgeStyles.map((s) => s.width).join(" ");
                  style.borderColor = edgeStyles.map((s) => s.color).join(" ");
                  return style;
                }
              };
              __name(_Border, "Border");
              let Border = _Border;
              const _Break = class _Break extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "break", true);
                  this.after = (0, _utils.getStringOption)(attributes.after, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]);
                  this.afterTarget = attributes.afterTarget || "";
                  this.before = (0, _utils.getStringOption)(attributes.before, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]);
                  this.beforeTarget = attributes.beforeTarget || "";
                  this.bookendLeader = attributes.bookendLeader || "";
                  this.bookendTrailer = attributes.bookendTrailer || "";
                  this.id = attributes.id || "";
                  this.overflowLeader = attributes.overflowLeader || "";
                  this.overflowTarget = attributes.overflowTarget || "";
                  this.overflowTrailer = attributes.overflowTrailer || "";
                  this.startNew = (0, _utils.getInteger)({
                    data: attributes.startNew,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.extras = null;
                }
              };
              __name(_Break, "Break");
              let Break = _Break;
              const _BreakAfter = class _BreakAfter extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "breakAfter", true);
                  this.id = attributes.id || "";
                  this.leader = attributes.leader || "";
                  this.startNew = (0, _utils.getInteger)({
                    data: attributes.startNew,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.target = attributes.target || "";
                  this.targetType = (0, _utils.getStringOption)(attributes.targetType, ["auto", "contentArea", "pageArea"]);
                  this.trailer = attributes.trailer || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.script = null;
                }
              };
              __name(_BreakAfter, "BreakAfter");
              let BreakAfter = _BreakAfter;
              const _BreakBefore = class _BreakBefore extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "breakBefore", true);
                  this.id = attributes.id || "";
                  this.leader = attributes.leader || "";
                  this.startNew = (0, _utils.getInteger)({
                    data: attributes.startNew,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.target = attributes.target || "";
                  this.targetType = (0, _utils.getStringOption)(attributes.targetType, ["auto", "contentArea", "pageArea"]);
                  this.trailer = attributes.trailer || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.script = null;
                }
                [_xfa_object.$toHTML](availableSpace) {
                  this[_xfa_object.$extra] = {};
                  return _utils.HTMLResult.FAILURE;
                }
              };
              __name(_BreakBefore, "BreakBefore");
              let BreakBefore = _BreakBefore;
              const _Button = class _Button extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "button", true);
                  this.highlight = (0, _utils.getStringOption)(attributes.highlight, ["inverted", "none", "outline", "push"]);
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.extras = null;
                }
                [_xfa_object.$toHTML](availableSpace) {
                  const parent = this[_xfa_object.$getParent]();
                  const grandpa = parent[_xfa_object.$getParent]();
                  const htmlButton = {
                    name: "button",
                    attributes: {
                      id: this[_xfa_object.$uid],
                      class: ["xfaButton"],
                      style: {}
                    },
                    children: []
                  };
                  for (const event of grandpa.event.children) {
                    if (event.activity !== "click" || !event.script) {
                      continue;
                    }
                    const jsURL = (0, _core_utils.recoverJsURL)(event.script[_xfa_object.$content]);
                    if (!jsURL) {
                      continue;
                    }
                    const href = (0, _html_utils.fixURL)(jsURL.url);
                    if (!href) {
                      continue;
                    }
                    htmlButton.children.push({
                      name: "a",
                      attributes: {
                        id: "link" + this[_xfa_object.$uid],
                        href,
                        newWindow: jsURL.newWindow,
                        class: ["xfaLink"],
                        style: {}
                      },
                      children: []
                    });
                  }
                  return _utils.HTMLResult.success(htmlButton);
                }
              };
              __name(_Button, "Button");
              let Button = _Button;
              const _Calculate = class _Calculate extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "calculate", true);
                  this.id = attributes.id || "";
                  this.override = (0, _utils.getStringOption)(attributes.override, ["disabled", "error", "ignore", "warning"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.extras = null;
                  this.message = null;
                  this.script = null;
                }
              };
              __name(_Calculate, "Calculate");
              let Calculate = _Calculate;
              const _Caption = class _Caption extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "caption", true);
                  this.id = attributes.id || "";
                  this.placement = (0, _utils.getStringOption)(attributes.placement, ["left", "bottom", "inline", "right", "top"]);
                  this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
                  this.reserve = Math.ceil((0, _utils.getMeasurement)(attributes.reserve));
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.extras = null;
                  this.font = null;
                  this.margin = null;
                  this.para = null;
                  this.value = null;
                }
                [_xfa_object.$setValue](value) {
                  _setValue(this, value);
                }
                [_xfa_object.$getExtra](availableSpace) {
                  if (!this[_xfa_object.$extra]) {
                    let {
                      width,
                      height
                    } = availableSpace;
                    switch (this.placement) {
                      case "left":
                      case "right":
                      case "inline":
                        width = this.reserve <= 0 ? width : this.reserve;
                        break;
                      case "top":
                      case "bottom":
                        height = this.reserve <= 0 ? height : this.reserve;
                        break;
                    }
                    this[_xfa_object.$extra] = (0, _html_utils.layoutNode)(this, {
                      width,
                      height
                    });
                  }
                  return this[_xfa_object.$extra];
                }
                [_xfa_object.$toHTML](availableSpace) {
                  if (!this.value) {
                    return _utils.HTMLResult.EMPTY;
                  }
                  this[_xfa_object.$pushPara]();
                  const value = this.value[_xfa_object.$toHTML](availableSpace).html;
                  if (!value) {
                    this[_xfa_object.$popPara]();
                    return _utils.HTMLResult.EMPTY;
                  }
                  const savedReserve = this.reserve;
                  if (this.reserve <= 0) {
                    const {
                      w,
                      h
                    } = this[_xfa_object.$getExtra](availableSpace);
                    switch (this.placement) {
                      case "left":
                      case "right":
                      case "inline":
                        this.reserve = w;
                        break;
                      case "top":
                      case "bottom":
                        this.reserve = h;
                        break;
                    }
                  }
                  const children = [];
                  if (typeof value === "string") {
                    children.push({
                      name: "#text",
                      value
                    });
                  } else {
                    children.push(value);
                  }
                  const style = (0, _html_utils.toStyle)(this, "font", "margin", "visibility");
                  switch (this.placement) {
                    case "left":
                    case "right":
                      if (this.reserve > 0) {
                        style.width = (0, _html_utils.measureToString)(this.reserve);
                      }
                      break;
                    case "top":
                    case "bottom":
                      if (this.reserve > 0) {
                        style.height = (0, _html_utils.measureToString)(this.reserve);
                      }
                      break;
                  }
                  (0, _html_utils.setPara)(this, null, value);
                  this[_xfa_object.$popPara]();
                  this.reserve = savedReserve;
                  return _utils.HTMLResult.success({
                    name: "div",
                    attributes: {
                      style,
                      class: ["xfaCaption"]
                    },
                    children
                  });
                }
              };
              __name(_Caption, "Caption");
              let Caption = _Caption;
              const _Certificate = class _Certificate extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "certificate");
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              };
              __name(_Certificate, "Certificate");
              let Certificate = _Certificate;
              const _Certificates = class _Certificates extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "certificates", true);
                  this.credentialServerPolicy = (0, _utils.getStringOption)(attributes.credentialServerPolicy, ["optional", "required"]);
                  this.id = attributes.id || "";
                  this.url = attributes.url || "";
                  this.urlPolicy = attributes.urlPolicy || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.encryption = null;
                  this.issuers = null;
                  this.keyUsage = null;
                  this.oids = null;
                  this.signing = null;
                  this.subjectDNs = null;
                }
              };
              __name(_Certificates, "Certificates");
              let Certificates = _Certificates;
              const _CheckButton = class _CheckButton extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "checkButton", true);
                  this.id = attributes.id || "";
                  this.mark = (0, _utils.getStringOption)(attributes.mark, ["default", "check", "circle", "cross", "diamond", "square", "star"]);
                  this.shape = (0, _utils.getStringOption)(attributes.shape, ["square", "round"]);
                  this.size = (0, _utils.getMeasurement)(attributes.size, "10pt");
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.border = null;
                  this.extras = null;
                  this.margin = null;
                }
                [_xfa_object.$toHTML](availableSpace) {
                  const style = (0, _html_utils.toStyle)("margin");
                  const size = (0, _html_utils.measureToString)(this.size);
                  style.width = style.height = size;
                  let type;
                  let className;
                  let groupId;
                  const field = this[_xfa_object.$getParent]()[_xfa_object.$getParent]();
                  const items = field.items.children.length && field.items.children[0][_xfa_object.$toHTML]().html || [];
                  const exportedValue = {
                    on: (items[0] !== void 0 ? items[0] : "on").toString(),
                    off: (items[1] !== void 0 ? items[1] : "off").toString()
                  };
                  const value = field.value && field.value[_xfa_object.$text]() || "off";
                  const checked = value === exportedValue.on || void 0;
                  const container = field[_xfa_object.$getSubformParent]();
                  const fieldId = field[_xfa_object.$uid];
                  let dataId;
                  if (container instanceof ExclGroup) {
                    groupId = container[_xfa_object.$uid];
                    type = "radio";
                    className = "xfaRadio";
                    dataId = container[_xfa_object.$data] && container[_xfa_object.$data][_xfa_object.$uid] || container[_xfa_object.$uid];
                  } else {
                    type = "checkbox";
                    className = "xfaCheckbox";
                    dataId = field[_xfa_object.$data] && field[_xfa_object.$data][_xfa_object.$uid] || field[_xfa_object.$uid];
                  }
                  const input = {
                    name: "input",
                    attributes: {
                      class: [className],
                      style,
                      fieldId,
                      dataId,
                      type,
                      checked,
                      xfaOn: exportedValue.on,
                      xfaOff: exportedValue.off,
                      "aria-label": ariaLabel(field),
                      "aria-required": false
                    }
                  };
                  if (groupId) {
                    input.attributes.name = groupId;
                  }
                  if (isRequired(field)) {
                    input.attributes["aria-required"] = true;
                    input.attributes.required = true;
                  }
                  return _utils.HTMLResult.success({
                    name: "label",
                    attributes: {
                      class: ["xfaLabel"]
                    },
                    children: [input]
                  });
                }
              };
              __name(_CheckButton, "CheckButton");
              let CheckButton = _CheckButton;
              const _ChoiceList = class _ChoiceList extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "choiceList", true);
                  this.commitOn = (0, _utils.getStringOption)(attributes.commitOn, ["select", "exit"]);
                  this.id = attributes.id || "";
                  this.open = (0, _utils.getStringOption)(attributes.open, ["userControl", "always", "multiSelect", "onEntry"]);
                  this.textEntry = (0, _utils.getInteger)({
                    data: attributes.textEntry,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.border = null;
                  this.extras = null;
                  this.margin = null;
                }
                [_xfa_object.$toHTML](availableSpace) {
                  const style = (0, _html_utils.toStyle)(this, "border", "margin");
                  const ui = this[_xfa_object.$getParent]();
                  const field = ui[_xfa_object.$getParent]();
                  const fontSize = field.font && field.font.size || 10;
                  const optionStyle = {
                    fontSize: `calc(${fontSize}px * var(--scale-factor))`
                  };
                  const children = [];
                  if (field.items.children.length > 0) {
                    const items = field.items;
                    let displayedIndex = 0;
                    let saveIndex = 0;
                    if (items.children.length === 2) {
                      displayedIndex = items.children[0].save;
                      saveIndex = 1 - displayedIndex;
                    }
                    const displayed = items.children[displayedIndex][_xfa_object.$toHTML]().html;
                    const values = items.children[saveIndex][_xfa_object.$toHTML]().html;
                    let selected = false;
                    const value = field.value && field.value[_xfa_object.$text]() || "";
                    for (let i = 0, ii = displayed.length; i < ii; i++) {
                      const option = {
                        name: "option",
                        attributes: {
                          value: values[i] || displayed[i],
                          style: optionStyle
                        },
                        value: displayed[i]
                      };
                      if (values[i] === value) {
                        option.attributes.selected = selected = true;
                      }
                      children.push(option);
                    }
                    if (!selected) {
                      children.splice(0, 0, {
                        name: "option",
                        attributes: {
                          hidden: true,
                          selected: true
                        },
                        value: " "
                      });
                    }
                  }
                  const selectAttributes = {
                    class: ["xfaSelect"],
                    fieldId: field[_xfa_object.$uid],
                    dataId: field[_xfa_object.$data] && field[_xfa_object.$data][_xfa_object.$uid] || field[_xfa_object.$uid],
                    style,
                    "aria-label": ariaLabel(field),
                    "aria-required": false
                  };
                  if (isRequired(field)) {
                    selectAttributes["aria-required"] = true;
                    selectAttributes.required = true;
                  }
                  if (this.open === "multiSelect") {
                    selectAttributes.multiple = true;
                  }
                  return _utils.HTMLResult.success({
                    name: "label",
                    attributes: {
                      class: ["xfaLabel"]
                    },
                    children: [{
                      name: "select",
                      children,
                      attributes: selectAttributes
                    }]
                  });
                }
              };
              __name(_ChoiceList, "ChoiceList");
              let ChoiceList = _ChoiceList;
              const _Color = class _Color extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "color", true);
                  this.cSpace = (0, _utils.getStringOption)(attributes.cSpace, ["SRGB"]);
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.value = attributes.value ? (0, _utils.getColor)(attributes.value) : "";
                  this.extras = null;
                }
                [_xfa_object.$hasSettableValue]() {
                  return false;
                }
                [_xfa_object.$toStyle]() {
                  return this.value ? _util.Util.makeHexColor(this.value.r, this.value.g, this.value.b) : null;
                }
              };
              __name(_Color, "Color");
              let Color = _Color;
              const _Comb = class _Comb extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "comb");
                  this.id = attributes.id || "";
                  this.numberOfCells = (0, _utils.getInteger)({
                    data: attributes.numberOfCells,
                    defaultValue: 0,
                    validate: (x) => x >= 0
                  });
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              };
              __name(_Comb, "Comb");
              let Comb = _Comb;
              const _Connect = class _Connect extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "connect", true);
                  this.connection = attributes.connection || "";
                  this.id = attributes.id || "";
                  this.ref = attributes.ref || "";
                  this.usage = (0, _utils.getStringOption)(attributes.usage, ["exportAndImport", "exportOnly", "importOnly"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.picture = null;
                }
              };
              __name(_Connect, "Connect");
              let Connect = _Connect;
              const _ContentArea = class _ContentArea extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "contentArea", true);
                  this.h = (0, _utils.getMeasurement)(attributes.h);
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.relevant = (0, _utils.getRelevant)(attributes.relevant);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.w = (0, _utils.getMeasurement)(attributes.w);
                  this.x = (0, _utils.getMeasurement)(attributes.x, "0pt");
                  this.y = (0, _utils.getMeasurement)(attributes.y, "0pt");
                  this.desc = null;
                  this.extras = null;
                }
                [_xfa_object.$toHTML](availableSpace) {
                  const left = (0, _html_utils.measureToString)(this.x);
                  const top = (0, _html_utils.measureToString)(this.y);
                  const style = {
                    left,
                    top,
                    width: (0, _html_utils.measureToString)(this.w),
                    height: (0, _html_utils.measureToString)(this.h)
                  };
                  const classNames = ["xfaContentarea"];
                  if ((0, _html_utils.isPrintOnly)(this)) {
                    classNames.push("xfaPrintOnly");
                  }
                  return _utils.HTMLResult.success({
                    name: "div",
                    children: [],
                    attributes: {
                      style,
                      class: classNames,
                      id: this[_xfa_object.$uid]
                    }
                  });
                }
              };
              __name(_ContentArea, "ContentArea");
              let ContentArea = _ContentArea;
              const _Corner = class _Corner extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "corner", true);
                  this.id = attributes.id || "";
                  this.inverted = (0, _utils.getInteger)({
                    data: attributes.inverted,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.join = (0, _utils.getStringOption)(attributes.join, ["square", "round"]);
                  this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
                  this.radius = (0, _utils.getMeasurement)(attributes.radius);
                  this.stroke = (0, _utils.getStringOption)(attributes.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]);
                  this.thickness = (0, _utils.getMeasurement)(attributes.thickness, "0.5pt");
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.color = null;
                  this.extras = null;
                }
                [_xfa_object.$toStyle]() {
                  const style = (0, _html_utils.toStyle)(this, "visibility");
                  style.radius = (0, _html_utils.measureToString)(this.join === "square" ? 0 : this.radius);
                  return style;
                }
              };
              __name(_Corner, "Corner");
              let Corner = _Corner;
              const _DateElement = class _DateElement extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "date");
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
                [_xfa_object.$finalize]() {
                  const date = this[_xfa_object.$content].trim();
                  this[_xfa_object.$content] = date ? new Date(date) : null;
                }
                [_xfa_object.$toHTML](availableSpace) {
                  return valueToHtml(this[_xfa_object.$content] ? this[_xfa_object.$content].toString() : "");
                }
              };
              __name(_DateElement, "DateElement");
              let DateElement = _DateElement;
              const _DateTime = class _DateTime extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "dateTime");
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
                [_xfa_object.$finalize]() {
                  const date = this[_xfa_object.$content].trim();
                  this[_xfa_object.$content] = date ? new Date(date) : null;
                }
                [_xfa_object.$toHTML](availableSpace) {
                  return valueToHtml(this[_xfa_object.$content] ? this[_xfa_object.$content].toString() : "");
                }
              };
              __name(_DateTime, "DateTime");
              let DateTime = _DateTime;
              const _DateTimeEdit = class _DateTimeEdit extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "dateTimeEdit", true);
                  this.hScrollPolicy = (0, _utils.getStringOption)(attributes.hScrollPolicy, ["auto", "off", "on"]);
                  this.id = attributes.id || "";
                  this.picker = (0, _utils.getStringOption)(attributes.picker, ["host", "none"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.border = null;
                  this.comb = null;
                  this.extras = null;
                  this.margin = null;
                }
                [_xfa_object.$toHTML](availableSpace) {
                  const style = (0, _html_utils.toStyle)(this, "border", "font", "margin");
                  const field = this[_xfa_object.$getParent]()[_xfa_object.$getParent]();
                  const html = {
                    name: "input",
                    attributes: {
                      type: "text",
                      fieldId: field[_xfa_object.$uid],
                      dataId: field[_xfa_object.$data] && field[_xfa_object.$data][_xfa_object.$uid] || field[_xfa_object.$uid],
                      class: ["xfaTextfield"],
                      style,
                      "aria-label": ariaLabel(field),
                      "aria-required": false
                    }
                  };
                  if (isRequired(field)) {
                    html.attributes["aria-required"] = true;
                    html.attributes.required = true;
                  }
                  return _utils.HTMLResult.success({
                    name: "label",
                    attributes: {
                      class: ["xfaLabel"]
                    },
                    children: [html]
                  });
                }
              };
              __name(_DateTimeEdit, "DateTimeEdit");
              let DateTimeEdit = _DateTimeEdit;
              const _Decimal = class _Decimal extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "decimal");
                  this.fracDigits = (0, _utils.getInteger)({
                    data: attributes.fracDigits,
                    defaultValue: 2,
                    validate: (x) => true
                  });
                  this.id = attributes.id || "";
                  this.leadDigits = (0, _utils.getInteger)({
                    data: attributes.leadDigits,
                    defaultValue: -1,
                    validate: (x) => true
                  });
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
                [_xfa_object.$finalize]() {
                  const number = parseFloat(this[_xfa_object.$content].trim());
                  this[_xfa_object.$content] = isNaN(number) ? null : number;
                }
                [_xfa_object.$toHTML](availableSpace) {
                  return valueToHtml(this[_xfa_object.$content] !== null ? this[_xfa_object.$content].toString() : "");
                }
              };
              __name(_Decimal, "Decimal");
              let Decimal = _Decimal;
              const _DefaultUi = class _DefaultUi extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "defaultUi", true);
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.extras = null;
                }
              };
              __name(_DefaultUi, "DefaultUi");
              let DefaultUi = _DefaultUi;
              const _Desc = class _Desc extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "desc", true);
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.boolean = new _xfa_object.XFAObjectArray();
                  this.date = new _xfa_object.XFAObjectArray();
                  this.dateTime = new _xfa_object.XFAObjectArray();
                  this.decimal = new _xfa_object.XFAObjectArray();
                  this.exData = new _xfa_object.XFAObjectArray();
                  this.float = new _xfa_object.XFAObjectArray();
                  this.image = new _xfa_object.XFAObjectArray();
                  this.integer = new _xfa_object.XFAObjectArray();
                  this.text = new _xfa_object.XFAObjectArray();
                  this.time = new _xfa_object.XFAObjectArray();
                }
              };
              __name(_Desc, "Desc");
              let Desc = _Desc;
              const _DigestMethod = class _DigestMethod extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "digestMethod", ["", "SHA1", "SHA256", "SHA512", "RIPEMD160"]);
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              };
              __name(_DigestMethod, "DigestMethod");
              let DigestMethod = _DigestMethod;
              const _DigestMethods = class _DigestMethods extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "digestMethods", true);
                  this.id = attributes.id || "";
                  this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.digestMethod = new _xfa_object.XFAObjectArray();
                }
              };
              __name(_DigestMethods, "DigestMethods");
              let DigestMethods = _DigestMethods;
              const _Draw = class _Draw extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "draw", true);
                  this.anchorType = (0, _utils.getStringOption)(attributes.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
                  this.colSpan = (0, _utils.getInteger)({
                    data: attributes.colSpan,
                    defaultValue: 1,
                    validate: (n) => n >= 1 || n === -1
                  });
                  this.h = attributes.h ? (0, _utils.getMeasurement)(attributes.h) : "";
                  this.hAlign = (0, _utils.getStringOption)(attributes.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
                  this.id = attributes.id || "";
                  this.locale = attributes.locale || "";
                  this.maxH = (0, _utils.getMeasurement)(attributes.maxH, "0pt");
                  this.maxW = (0, _utils.getMeasurement)(attributes.maxW, "0pt");
                  this.minH = (0, _utils.getMeasurement)(attributes.minH, "0pt");
                  this.minW = (0, _utils.getMeasurement)(attributes.minW, "0pt");
                  this.name = attributes.name || "";
                  this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
                  this.relevant = (0, _utils.getRelevant)(attributes.relevant);
                  this.rotate = (0, _utils.getInteger)({
                    data: attributes.rotate,
                    defaultValue: 0,
                    validate: (x) => x % 90 === 0
                  });
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.w = attributes.w ? (0, _utils.getMeasurement)(attributes.w) : "";
                  this.x = (0, _utils.getMeasurement)(attributes.x, "0pt");
                  this.y = (0, _utils.getMeasurement)(attributes.y, "0pt");
                  this.assist = null;
                  this.border = null;
                  this.caption = null;
                  this.desc = null;
                  this.extras = null;
                  this.font = null;
                  this.keep = null;
                  this.margin = null;
                  this.para = null;
                  this.traversal = null;
                  this.ui = null;
                  this.value = null;
                  this.setProperty = new _xfa_object.XFAObjectArray();
                }
                [_xfa_object.$setValue](value) {
                  _setValue(this, value);
                }
                [_xfa_object.$toHTML](availableSpace) {
                  setTabIndex(this);
                  if (this.presence === "hidden" || this.presence === "inactive") {
                    return _utils.HTMLResult.EMPTY;
                  }
                  (0, _html_utils.fixDimensions)(this);
                  this[_xfa_object.$pushPara]();
                  const savedW = this.w;
                  const savedH = this.h;
                  const {
                    w,
                    h,
                    isBroken
                  } = (0, _html_utils.layoutNode)(this, availableSpace);
                  if (w && this.w === "") {
                    if (isBroken && this[_xfa_object.$getSubformParent]()[_xfa_object.$isThereMoreWidth]()) {
                      this[_xfa_object.$popPara]();
                      return _utils.HTMLResult.FAILURE;
                    }
                    this.w = w;
                  }
                  if (h && this.h === "") {
                    this.h = h;
                  }
                  setFirstUnsplittable(this);
                  if (!(0, _layout.checkDimensions)(this, availableSpace)) {
                    this.w = savedW;
                    this.h = savedH;
                    this[_xfa_object.$popPara]();
                    return _utils.HTMLResult.FAILURE;
                  }
                  unsetFirstUnsplittable(this);
                  const style = (0, _html_utils.toStyle)(this, "font", "hAlign", "dimensions", "position", "presence", "rotate", "anchorType", "border", "margin");
                  (0, _html_utils.setMinMaxDimensions)(this, style);
                  if (style.margin) {
                    style.padding = style.margin;
                    delete style.margin;
                  }
                  const classNames = ["xfaDraw"];
                  if (this.font) {
                    classNames.push("xfaFont");
                  }
                  if ((0, _html_utils.isPrintOnly)(this)) {
                    classNames.push("xfaPrintOnly");
                  }
                  const attributes = {
                    style,
                    id: this[_xfa_object.$uid],
                    class: classNames
                  };
                  if (this.name) {
                    attributes.xfaName = this.name;
                  }
                  const html = {
                    name: "div",
                    attributes,
                    children: []
                  };
                  applyAssist(this, attributes);
                  const bbox = (0, _html_utils.computeBbox)(this, html, availableSpace);
                  const value = this.value ? this.value[_xfa_object.$toHTML](availableSpace).html : null;
                  if (value === null) {
                    this.w = savedW;
                    this.h = savedH;
                    this[_xfa_object.$popPara]();
                    return _utils.HTMLResult.success((0, _html_utils.createWrapper)(this, html), bbox);
                  }
                  html.children.push(value);
                  (0, _html_utils.setPara)(this, style, value);
                  this.w = savedW;
                  this.h = savedH;
                  this[_xfa_object.$popPara]();
                  return _utils.HTMLResult.success((0, _html_utils.createWrapper)(this, html), bbox);
                }
              };
              __name(_Draw, "Draw");
              let Draw = _Draw;
              const _Edge = class _Edge extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "edge", true);
                  this.cap = (0, _utils.getStringOption)(attributes.cap, ["square", "butt", "round"]);
                  this.id = attributes.id || "";
                  this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
                  this.stroke = (0, _utils.getStringOption)(attributes.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]);
                  this.thickness = (0, _utils.getMeasurement)(attributes.thickness, "0.5pt");
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.color = null;
                  this.extras = null;
                }
                [_xfa_object.$toStyle]() {
                  const style = (0, _html_utils.toStyle)(this, "visibility");
                  Object.assign(style, {
                    linecap: this.cap,
                    width: (0, _html_utils.measureToString)(this.thickness),
                    color: this.color ? this.color[_xfa_object.$toStyle]() : "#000000",
                    style: ""
                  });
                  if (this.presence !== "visible") {
                    style.style = "none";
                  } else {
                    switch (this.stroke) {
                      case "solid":
                        style.style = "solid";
                        break;
                      case "dashDot":
                        style.style = "dashed";
                        break;
                      case "dashDotDot":
                        style.style = "dashed";
                        break;
                      case "dashed":
                        style.style = "dashed";
                        break;
                      case "dotted":
                        style.style = "dotted";
                        break;
                      case "embossed":
                        style.style = "ridge";
                        break;
                      case "etched":
                        style.style = "groove";
                        break;
                      case "lowered":
                        style.style = "inset";
                        break;
                      case "raised":
                        style.style = "outset";
                        break;
                    }
                  }
                  return style;
                }
              };
              __name(_Edge, "Edge");
              let Edge = _Edge;
              const _Encoding = class _Encoding extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "encoding", ["adbe.x509.rsa_sha1", "adbe.pkcs7.detached", "adbe.pkcs7.sha1"]);
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              };
              __name(_Encoding, "Encoding");
              let Encoding = _Encoding;
              const _Encodings = class _Encodings extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "encodings", true);
                  this.id = attributes.id || "";
                  this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.encoding = new _xfa_object.XFAObjectArray();
                }
              };
              __name(_Encodings, "Encodings");
              let Encodings = _Encodings;
              const _Encrypt = class _Encrypt extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "encrypt", true);
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.certificate = null;
                }
              };
              __name(_Encrypt, "Encrypt");
              let Encrypt = _Encrypt;
              const _EncryptData = class _EncryptData extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "encryptData", true);
                  this.id = attributes.id || "";
                  this.operation = (0, _utils.getStringOption)(attributes.operation, ["encrypt", "decrypt"]);
                  this.target = attributes.target || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.filter = null;
                  this.manifest = null;
                }
              };
              __name(_EncryptData, "EncryptData");
              let EncryptData = _EncryptData;
              const _Encryption = class _Encryption extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "encryption", true);
                  this.id = attributes.id || "";
                  this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.certificate = new _xfa_object.XFAObjectArray();
                }
              };
              __name(_Encryption, "Encryption");
              let Encryption = _Encryption;
              const _EncryptionMethod = class _EncryptionMethod extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "encryptionMethod", ["", "AES256-CBC", "TRIPLEDES-CBC", "AES128-CBC", "AES192-CBC"]);
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              };
              __name(_EncryptionMethod, "EncryptionMethod");
              let EncryptionMethod = _EncryptionMethod;
              const _EncryptionMethods = class _EncryptionMethods extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "encryptionMethods", true);
                  this.id = attributes.id || "";
                  this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.encryptionMethod = new _xfa_object.XFAObjectArray();
                }
              };
              __name(_EncryptionMethods, "EncryptionMethods");
              let EncryptionMethods = _EncryptionMethods;
              const _Event = class _Event extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "event", true);
                  this.activity = (0, _utils.getStringOption)(attributes.activity, ["click", "change", "docClose", "docReady", "enter", "exit", "full", "indexChange", "initialize", "mouseDown", "mouseEnter", "mouseExit", "mouseUp", "postExecute", "postOpen", "postPrint", "postSave", "postSign", "postSubmit", "preExecute", "preOpen", "prePrint", "preSave", "preSign", "preSubmit", "ready", "validationState"]);
                  this.id = attributes.id || "";
                  this.listen = (0, _utils.getStringOption)(attributes.listen, ["refOnly", "refAndDescendents"]);
                  this.name = attributes.name || "";
                  this.ref = attributes.ref || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.extras = null;
                  this.encryptData = null;
                  this.execute = null;
                  this.script = null;
                  this.signData = null;
                  this.submit = null;
                }
              };
              __name(_Event, "Event");
              let Event = _Event;
              const _ExData = class _ExData extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "exData");
                  this.contentType = attributes.contentType || "";
                  this.href = attributes.href || "";
                  this.id = attributes.id || "";
                  this.maxLength = (0, _utils.getInteger)({
                    data: attributes.maxLength,
                    defaultValue: -1,
                    validate: (x) => x >= -1
                  });
                  this.name = attributes.name || "";
                  this.rid = attributes.rid || "";
                  this.transferEncoding = (0, _utils.getStringOption)(attributes.transferEncoding, ["none", "base64", "package"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
                [_xfa_object.$isCDATAXml]() {
                  return this.contentType === "text/html";
                }
                [_xfa_object.$onChild](child) {
                  if (this.contentType === "text/html" && child[_xfa_object.$namespaceId] === _namespaces.NamespaceIds.xhtml.id) {
                    this[_xfa_object.$content] = child;
                    return true;
                  }
                  if (this.contentType === "text/xml") {
                    this[_xfa_object.$content] = child;
                    return true;
                  }
                  return false;
                }
                [_xfa_object.$toHTML](availableSpace) {
                  if (this.contentType !== "text/html" || !this[_xfa_object.$content]) {
                    return _utils.HTMLResult.EMPTY;
                  }
                  return this[_xfa_object.$content][_xfa_object.$toHTML](availableSpace);
                }
              };
              __name(_ExData, "ExData");
              let ExData = _ExData;
              const _ExObject = class _ExObject extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "exObject", true);
                  this.archive = attributes.archive || "";
                  this.classId = attributes.classId || "";
                  this.codeBase = attributes.codeBase || "";
                  this.codeType = attributes.codeType || "";
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.extras = null;
                  this.boolean = new _xfa_object.XFAObjectArray();
                  this.date = new _xfa_object.XFAObjectArray();
                  this.dateTime = new _xfa_object.XFAObjectArray();
                  this.decimal = new _xfa_object.XFAObjectArray();
                  this.exData = new _xfa_object.XFAObjectArray();
                  this.exObject = new _xfa_object.XFAObjectArray();
                  this.float = new _xfa_object.XFAObjectArray();
                  this.image = new _xfa_object.XFAObjectArray();
                  this.integer = new _xfa_object.XFAObjectArray();
                  this.text = new _xfa_object.XFAObjectArray();
                  this.time = new _xfa_object.XFAObjectArray();
                }
              };
              __name(_ExObject, "ExObject");
              let ExObject = _ExObject;
              const _ExclGroup = class _ExclGroup extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "exclGroup", true);
                  this.access = (0, _utils.getStringOption)(attributes.access, ["open", "nonInteractive", "protected", "readOnly"]);
                  this.accessKey = attributes.accessKey || "";
                  this.anchorType = (0, _utils.getStringOption)(attributes.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
                  this.colSpan = (0, _utils.getInteger)({
                    data: attributes.colSpan,
                    defaultValue: 1,
                    validate: (n) => n >= 1 || n === -1
                  });
                  this.h = attributes.h ? (0, _utils.getMeasurement)(attributes.h) : "";
                  this.hAlign = (0, _utils.getStringOption)(attributes.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
                  this.id = attributes.id || "";
                  this.layout = (0, _utils.getStringOption)(attributes.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]);
                  this.maxH = (0, _utils.getMeasurement)(attributes.maxH, "0pt");
                  this.maxW = (0, _utils.getMeasurement)(attributes.maxW, "0pt");
                  this.minH = (0, _utils.getMeasurement)(attributes.minH, "0pt");
                  this.minW = (0, _utils.getMeasurement)(attributes.minW, "0pt");
                  this.name = attributes.name || "";
                  this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
                  this.relevant = (0, _utils.getRelevant)(attributes.relevant);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.w = attributes.w ? (0, _utils.getMeasurement)(attributes.w) : "";
                  this.x = (0, _utils.getMeasurement)(attributes.x, "0pt");
                  this.y = (0, _utils.getMeasurement)(attributes.y, "0pt");
                  this.assist = null;
                  this.bind = null;
                  this.border = null;
                  this.calculate = null;
                  this.caption = null;
                  this.desc = null;
                  this.extras = null;
                  this.margin = null;
                  this.para = null;
                  this.traversal = null;
                  this.validate = null;
                  this.connect = new _xfa_object.XFAObjectArray();
                  this.event = new _xfa_object.XFAObjectArray();
                  this.field = new _xfa_object.XFAObjectArray();
                  this.setProperty = new _xfa_object.XFAObjectArray();
                }
                [_xfa_object.$isBindable]() {
                  return true;
                }
                [_xfa_object.$hasSettableValue]() {
                  return true;
                }
                [_xfa_object.$setValue](value) {
                  for (const field of this.field.children) {
                    if (!field.value) {
                      const nodeValue = new Value({});
                      field[_xfa_object.$appendChild](nodeValue);
                      field.value = nodeValue;
                    }
                    field.value[_xfa_object.$setValue](value);
                  }
                }
                [_xfa_object.$isThereMoreWidth]() {
                  return this.layout.endsWith("-tb") && this[_xfa_object.$extra].attempt === 0 && this[_xfa_object.$extra].numberInLine > 0 || this[_xfa_object.$getParent]()[_xfa_object.$isThereMoreWidth]();
                }
                [_xfa_object.$isSplittable]() {
                  const parent = this[_xfa_object.$getSubformParent]();
                  if (!parent[_xfa_object.$isSplittable]()) {
                    return false;
                  }
                  if (this[_xfa_object.$extra]._isSplittable !== void 0) {
                    return this[_xfa_object.$extra]._isSplittable;
                  }
                  if (this.layout === "position" || this.layout.includes("row")) {
                    this[_xfa_object.$extra]._isSplittable = false;
                    return false;
                  }
                  if (parent.layout && parent.layout.endsWith("-tb") && parent[_xfa_object.$extra].numberInLine !== 0) {
                    return false;
                  }
                  this[_xfa_object.$extra]._isSplittable = true;
                  return true;
                }
                [_xfa_object.$flushHTML]() {
                  return (0, _layout.flushHTML)(this);
                }
                [_xfa_object.$addHTML](html, bbox) {
                  (0, _layout.addHTML)(this, html, bbox);
                }
                [_xfa_object.$getAvailableSpace]() {
                  return (0, _layout.getAvailableSpace)(this);
                }
                [_xfa_object.$toHTML](availableSpace) {
                  setTabIndex(this);
                  if (this.presence === "hidden" || this.presence === "inactive" || this.h === 0 || this.w === 0) {
                    return _utils.HTMLResult.EMPTY;
                  }
                  (0, _html_utils.fixDimensions)(this);
                  const children = [];
                  const attributes = {
                    id: this[_xfa_object.$uid],
                    class: []
                  };
                  (0, _html_utils.setAccess)(this, attributes.class);
                  if (!this[_xfa_object.$extra]) {
                    this[_xfa_object.$extra] = /* @__PURE__ */ Object.create(null);
                  }
                  Object.assign(this[_xfa_object.$extra], {
                    children,
                    attributes,
                    attempt: 0,
                    line: null,
                    numberInLine: 0,
                    availableSpace: {
                      width: Math.min(this.w || Infinity, availableSpace.width),
                      height: Math.min(this.h || Infinity, availableSpace.height)
                    },
                    width: 0,
                    height: 0,
                    prevHeight: 0,
                    currentWidth: 0
                  });
                  const isSplittable = this[_xfa_object.$isSplittable]();
                  if (!isSplittable) {
                    setFirstUnsplittable(this);
                  }
                  if (!(0, _layout.checkDimensions)(this, availableSpace)) {
                    return _utils.HTMLResult.FAILURE;
                  }
                  const filter = /* @__PURE__ */ new Set(["field"]);
                  if (this.layout.includes("row")) {
                    const columnWidths = this[_xfa_object.$getSubformParent]().columnWidths;
                    if (Array.isArray(columnWidths) && columnWidths.length > 0) {
                      this[_xfa_object.$extra].columnWidths = columnWidths;
                      this[_xfa_object.$extra].currentColumn = 0;
                    }
                  }
                  const style = (0, _html_utils.toStyle)(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign");
                  const classNames = ["xfaExclgroup"];
                  const cl = (0, _html_utils.layoutClass)(this);
                  if (cl) {
                    classNames.push(cl);
                  }
                  if ((0, _html_utils.isPrintOnly)(this)) {
                    classNames.push("xfaPrintOnly");
                  }
                  attributes.style = style;
                  attributes.class = classNames;
                  if (this.name) {
                    attributes.xfaName = this.name;
                  }
                  this[_xfa_object.$pushPara]();
                  const isLrTb = this.layout === "lr-tb" || this.layout === "rl-tb";
                  const maxRun = isLrTb ? MAX_ATTEMPTS_FOR_LRTB_LAYOUT : 1;
                  for (; this[_xfa_object.$extra].attempt < maxRun; this[_xfa_object.$extra].attempt++) {
                    if (isLrTb && this[_xfa_object.$extra].attempt === MAX_ATTEMPTS_FOR_LRTB_LAYOUT - 1) {
                      this[_xfa_object.$extra].numberInLine = 0;
                    }
                    const result = this[_xfa_object.$childrenToHTML]({
                      filter,
                      include: true
                    });
                    if (result.success) {
                      break;
                    }
                    if (result.isBreak()) {
                      this[_xfa_object.$popPara]();
                      return result;
                    }
                    if (isLrTb && this[_xfa_object.$extra].attempt === 0 && this[_xfa_object.$extra].numberInLine === 0 && !this[_xfa_object.$getTemplateRoot]()[_xfa_object.$extra].noLayoutFailure) {
                      this[_xfa_object.$extra].attempt = maxRun;
                      break;
                    }
                  }
                  this[_xfa_object.$popPara]();
                  if (!isSplittable) {
                    unsetFirstUnsplittable(this);
                  }
                  if (this[_xfa_object.$extra].attempt === maxRun) {
                    if (!isSplittable) {
                      delete this[_xfa_object.$extra];
                    }
                    return _utils.HTMLResult.FAILURE;
                  }
                  let marginH = 0;
                  let marginV = 0;
                  if (this.margin) {
                    marginH = this.margin.leftInset + this.margin.rightInset;
                    marginV = this.margin.topInset + this.margin.bottomInset;
                  }
                  const width = Math.max(this[_xfa_object.$extra].width + marginH, this.w || 0);
                  const height = Math.max(this[_xfa_object.$extra].height + marginV, this.h || 0);
                  const bbox = [this.x, this.y, width, height];
                  if (this.w === "") {
                    style.width = (0, _html_utils.measureToString)(width);
                  }
                  if (this.h === "") {
                    style.height = (0, _html_utils.measureToString)(height);
                  }
                  const html = {
                    name: "div",
                    attributes,
                    children
                  };
                  applyAssist(this, attributes);
                  delete this[_xfa_object.$extra];
                  return _utils.HTMLResult.success((0, _html_utils.createWrapper)(this, html), bbox);
                }
              };
              __name(_ExclGroup, "ExclGroup");
              let ExclGroup = _ExclGroup;
              const _Execute = class _Execute extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "execute");
                  this.connection = attributes.connection || "";
                  this.executeType = (0, _utils.getStringOption)(attributes.executeType, ["import", "remerge"]);
                  this.id = attributes.id || "";
                  this.runAt = (0, _utils.getStringOption)(attributes.runAt, ["client", "both", "server"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              };
              __name(_Execute, "Execute");
              let Execute = _Execute;
              const _Extras = class _Extras extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "extras", true);
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.boolean = new _xfa_object.XFAObjectArray();
                  this.date = new _xfa_object.XFAObjectArray();
                  this.dateTime = new _xfa_object.XFAObjectArray();
                  this.decimal = new _xfa_object.XFAObjectArray();
                  this.exData = new _xfa_object.XFAObjectArray();
                  this.extras = new _xfa_object.XFAObjectArray();
                  this.float = new _xfa_object.XFAObjectArray();
                  this.image = new _xfa_object.XFAObjectArray();
                  this.integer = new _xfa_object.XFAObjectArray();
                  this.text = new _xfa_object.XFAObjectArray();
                  this.time = new _xfa_object.XFAObjectArray();
                }
              };
              __name(_Extras, "Extras");
              let Extras = _Extras;
              const _Field = class _Field extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "field", true);
                  this.access = (0, _utils.getStringOption)(attributes.access, ["open", "nonInteractive", "protected", "readOnly"]);
                  this.accessKey = attributes.accessKey || "";
                  this.anchorType = (0, _utils.getStringOption)(attributes.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
                  this.colSpan = (0, _utils.getInteger)({
                    data: attributes.colSpan,
                    defaultValue: 1,
                    validate: (n) => n >= 1 || n === -1
                  });
                  this.h = attributes.h ? (0, _utils.getMeasurement)(attributes.h) : "";
                  this.hAlign = (0, _utils.getStringOption)(attributes.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
                  this.id = attributes.id || "";
                  this.locale = attributes.locale || "";
                  this.maxH = (0, _utils.getMeasurement)(attributes.maxH, "0pt");
                  this.maxW = (0, _utils.getMeasurement)(attributes.maxW, "0pt");
                  this.minH = (0, _utils.getMeasurement)(attributes.minH, "0pt");
                  this.minW = (0, _utils.getMeasurement)(attributes.minW, "0pt");
                  this.name = attributes.name || "";
                  this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
                  this.relevant = (0, _utils.getRelevant)(attributes.relevant);
                  this.rotate = (0, _utils.getInteger)({
                    data: attributes.rotate,
                    defaultValue: 0,
                    validate: (x) => x % 90 === 0
                  });
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.w = attributes.w ? (0, _utils.getMeasurement)(attributes.w) : "";
                  this.x = (0, _utils.getMeasurement)(attributes.x, "0pt");
                  this.y = (0, _utils.getMeasurement)(attributes.y, "0pt");
                  this.assist = null;
                  this.bind = null;
                  this.border = null;
                  this.calculate = null;
                  this.caption = null;
                  this.desc = null;
                  this.extras = null;
                  this.font = null;
                  this.format = null;
                  this.items = new _xfa_object.XFAObjectArray(2);
                  this.keep = null;
                  this.margin = null;
                  this.para = null;
                  this.traversal = null;
                  this.ui = null;
                  this.validate = null;
                  this.value = null;
                  this.bindItems = new _xfa_object.XFAObjectArray();
                  this.connect = new _xfa_object.XFAObjectArray();
                  this.event = new _xfa_object.XFAObjectArray();
                  this.setProperty = new _xfa_object.XFAObjectArray();
                }
                [_xfa_object.$isBindable]() {
                  return true;
                }
                [_xfa_object.$setValue](value) {
                  _setValue(this, value);
                }
                [_xfa_object.$toHTML](availableSpace) {
                  setTabIndex(this);
                  if (!this.ui) {
                    this.ui = new Ui({});
                    this.ui[_xfa_object.$globalData] = this[_xfa_object.$globalData];
                    this[_xfa_object.$appendChild](this.ui);
                    let node;
                    switch (this.items.children.length) {
                      case 0:
                        node = new TextEdit({});
                        this.ui.textEdit = node;
                        break;
                      case 1:
                        node = new CheckButton({});
                        this.ui.checkButton = node;
                        break;
                      case 2:
                        node = new ChoiceList({});
                        this.ui.choiceList = node;
                        break;
                    }
                    this.ui[_xfa_object.$appendChild](node);
                  }
                  if (!this.ui || this.presence === "hidden" || this.presence === "inactive" || this.h === 0 || this.w === 0) {
                    return _utils.HTMLResult.EMPTY;
                  }
                  if (this.caption) {
                    delete this.caption[_xfa_object.$extra];
                  }
                  this[_xfa_object.$pushPara]();
                  const caption = this.caption ? this.caption[_xfa_object.$toHTML](availableSpace).html : null;
                  const savedW = this.w;
                  const savedH = this.h;
                  let marginH = 0;
                  let marginV = 0;
                  if (this.margin) {
                    marginH = this.margin.leftInset + this.margin.rightInset;
                    marginV = this.margin.topInset + this.margin.bottomInset;
                  }
                  let borderDims = null;
                  if (this.w === "" || this.h === "") {
                    let width = null;
                    let height = null;
                    let uiW = 0;
                    let uiH = 0;
                    if (this.ui.checkButton) {
                      uiW = uiH = this.ui.checkButton.size;
                    } else {
                      const {
                        w,
                        h
                      } = (0, _html_utils.layoutNode)(this, availableSpace);
                      if (w !== null) {
                        uiW = w;
                        uiH = h;
                      } else {
                        uiH = (0, _fonts.getMetrics)(this.font, true).lineNoGap;
                      }
                    }
                    borderDims = getBorderDims(this.ui[_xfa_object.$getExtra]());
                    uiW += borderDims.w;
                    uiH += borderDims.h;
                    if (this.caption) {
                      const {
                        w,
                        h,
                        isBroken
                      } = this.caption[_xfa_object.$getExtra](availableSpace);
                      if (isBroken && this[_xfa_object.$getSubformParent]()[_xfa_object.$isThereMoreWidth]()) {
                        this[_xfa_object.$popPara]();
                        return _utils.HTMLResult.FAILURE;
                      }
                      width = w;
                      height = h;
                      switch (this.caption.placement) {
                        case "left":
                        case "right":
                        case "inline":
                          width += uiW;
                          break;
                        case "top":
                        case "bottom":
                          height += uiH;
                          break;
                      }
                    } else {
                      width = uiW;
                      height = uiH;
                    }
                    if (width && this.w === "") {
                      width += marginH;
                      this.w = Math.min(this.maxW <= 0 ? Infinity : this.maxW, this.minW + 1 < width ? width : this.minW);
                    }
                    if (height && this.h === "") {
                      height += marginV;
                      this.h = Math.min(this.maxH <= 0 ? Infinity : this.maxH, this.minH + 1 < height ? height : this.minH);
                    }
                  }
                  this[_xfa_object.$popPara]();
                  (0, _html_utils.fixDimensions)(this);
                  setFirstUnsplittable(this);
                  if (!(0, _layout.checkDimensions)(this, availableSpace)) {
                    this.w = savedW;
                    this.h = savedH;
                    this[_xfa_object.$popPara]();
                    return _utils.HTMLResult.FAILURE;
                  }
                  unsetFirstUnsplittable(this);
                  const style = (0, _html_utils.toStyle)(this, "font", "dimensions", "position", "rotate", "anchorType", "presence", "margin", "hAlign");
                  (0, _html_utils.setMinMaxDimensions)(this, style);
                  const classNames = ["xfaField"];
                  if (this.font) {
                    classNames.push("xfaFont");
                  }
                  if ((0, _html_utils.isPrintOnly)(this)) {
                    classNames.push("xfaPrintOnly");
                  }
                  const attributes = {
                    style,
                    id: this[_xfa_object.$uid],
                    class: classNames
                  };
                  if (style.margin) {
                    style.padding = style.margin;
                    delete style.margin;
                  }
                  (0, _html_utils.setAccess)(this, classNames);
                  if (this.name) {
                    attributes.xfaName = this.name;
                  }
                  const children = [];
                  const html = {
                    name: "div",
                    attributes,
                    children
                  };
                  applyAssist(this, attributes);
                  const borderStyle = this.border ? this.border[_xfa_object.$toStyle]() : null;
                  const bbox = (0, _html_utils.computeBbox)(this, html, availableSpace);
                  const ui = this.ui[_xfa_object.$toHTML]().html;
                  if (!ui) {
                    Object.assign(style, borderStyle);
                    return _utils.HTMLResult.success((0, _html_utils.createWrapper)(this, html), bbox);
                  }
                  if (this[_xfa_object.$tabIndex]) {
                    if (ui.children && ui.children[0]) {
                      ui.children[0].attributes.tabindex = this[_xfa_object.$tabIndex];
                    } else {
                      ui.attributes.tabindex = this[_xfa_object.$tabIndex];
                    }
                  }
                  if (!ui.attributes.style) {
                    ui.attributes.style = /* @__PURE__ */ Object.create(null);
                  }
                  let aElement = null;
                  if (this.ui.button) {
                    if (ui.children.length === 1) {
                      [aElement] = ui.children.splice(0, 1);
                    }
                    Object.assign(ui.attributes.style, borderStyle);
                  } else {
                    Object.assign(style, borderStyle);
                  }
                  children.push(ui);
                  if (this.value) {
                    if (this.ui.imageEdit) {
                      ui.children.push(this.value[_xfa_object.$toHTML]().html);
                    } else if (!this.ui.button) {
                      let value = "";
                      if (this.value.exData) {
                        value = this.value.exData[_xfa_object.$text]();
                      } else if (this.value.text) {
                        value = this.value.text[_xfa_object.$getExtra]();
                      } else {
                        const htmlValue = this.value[_xfa_object.$toHTML]().html;
                        if (htmlValue !== null) {
                          value = htmlValue.children[0].value;
                        }
                      }
                      if (this.ui.textEdit && this.value.text && this.value.text.maxChars) {
                        ui.children[0].attributes.maxLength = this.value.text.maxChars;
                      }
                      if (value) {
                        if (this.ui.numericEdit) {
                          value = parseFloat(value);
                          value = isNaN(value) ? "" : value.toString();
                        }
                        if (ui.children[0].name === "textarea") {
                          ui.children[0].attributes.textContent = value;
                        } else {
                          ui.children[0].attributes.value = value;
                        }
                      }
                    }
                  }
                  if (!this.ui.imageEdit && ui.children && ui.children[0] && this.h) {
                    borderDims = borderDims || getBorderDims(this.ui[_xfa_object.$getExtra]());
                    let captionHeight = 0;
                    if (this.caption && ["top", "bottom"].includes(this.caption.placement)) {
                      captionHeight = this.caption.reserve;
                      if (captionHeight <= 0) {
                        captionHeight = this.caption[_xfa_object.$getExtra](availableSpace).h;
                      }
                      const inputHeight = this.h - captionHeight - marginV - borderDims.h;
                      ui.children[0].attributes.style.height = (0, _html_utils.measureToString)(inputHeight);
                    } else {
                      ui.children[0].attributes.style.height = "100%";
                    }
                  }
                  if (aElement) {
                    ui.children.push(aElement);
                  }
                  if (!caption) {
                    if (ui.attributes.class) {
                      ui.attributes.class.push("xfaLeft");
                    }
                    this.w = savedW;
                    this.h = savedH;
                    return _utils.HTMLResult.success((0, _html_utils.createWrapper)(this, html), bbox);
                  }
                  if (this.ui.button) {
                    if (style.padding) {
                      delete style.padding;
                    }
                    if (caption.name === "div") {
                      caption.name = "span";
                    }
                    ui.children.push(caption);
                    return _utils.HTMLResult.success(html, bbox);
                  } else if (this.ui.checkButton) {
                    caption.attributes.class[0] = "xfaCaptionForCheckButton";
                  }
                  if (!ui.attributes.class) {
                    ui.attributes.class = [];
                  }
                  ui.children.splice(0, 0, caption);
                  switch (this.caption.placement) {
                    case "left":
                      ui.attributes.class.push("xfaLeft");
                      break;
                    case "right":
                      ui.attributes.class.push("xfaRight");
                      break;
                    case "top":
                      ui.attributes.class.push("xfaTop");
                      break;
                    case "bottom":
                      ui.attributes.class.push("xfaBottom");
                      break;
                    case "inline":
                      ui.attributes.class.push("xfaLeft");
                      break;
                  }
                  this.w = savedW;
                  this.h = savedH;
                  return _utils.HTMLResult.success((0, _html_utils.createWrapper)(this, html), bbox);
                }
              };
              __name(_Field, "Field");
              let Field = _Field;
              exports2.Field = Field;
              const _Fill = class _Fill extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "fill", true);
                  this.id = attributes.id || "";
                  this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.color = null;
                  this.extras = null;
                  this.linear = null;
                  this.pattern = null;
                  this.radial = null;
                  this.solid = null;
                  this.stipple = null;
                }
                [_xfa_object.$toStyle]() {
                  const parent = this[_xfa_object.$getParent]();
                  const grandpa = parent[_xfa_object.$getParent]();
                  const ggrandpa = grandpa[_xfa_object.$getParent]();
                  const style = /* @__PURE__ */ Object.create(null);
                  let propName = "color";
                  let altPropName = propName;
                  if (parent instanceof Border) {
                    propName = "background-color";
                    altPropName = "background";
                    if (ggrandpa instanceof Ui) {
                      style.backgroundColor = "white";
                    }
                  }
                  if (parent instanceof Rectangle || parent instanceof Arc) {
                    propName = altPropName = "fill";
                    style.fill = "white";
                  }
                  for (const name of Object.getOwnPropertyNames(this)) {
                    if (name === "extras" || name === "color") {
                      continue;
                    }
                    const obj = this[name];
                    if (!(obj instanceof _xfa_object.XFAObject)) {
                      continue;
                    }
                    const color = obj[_xfa_object.$toStyle](this.color);
                    if (color) {
                      style[color.startsWith("#") ? propName : altPropName] = color;
                    }
                    return style;
                  }
                  if (this.color && this.color.value) {
                    const color = this.color[_xfa_object.$toStyle]();
                    style[color.startsWith("#") ? propName : altPropName] = color;
                  }
                  return style;
                }
              };
              __name(_Fill, "Fill");
              let Fill = _Fill;
              const _Filter = class _Filter extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "filter", true);
                  this.addRevocationInfo = (0, _utils.getStringOption)(attributes.addRevocationInfo, ["", "required", "optional", "none"]);
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.version = (0, _utils.getInteger)({
                    data: this.version,
                    defaultValue: 5,
                    validate: (x) => x >= 1 && x <= 5
                  });
                  this.appearanceFilter = null;
                  this.certificates = null;
                  this.digestMethods = null;
                  this.encodings = null;
                  this.encryptionMethods = null;
                  this.handler = null;
                  this.lockDocument = null;
                  this.mdp = null;
                  this.reasons = null;
                  this.timeStamp = null;
                }
              };
              __name(_Filter, "Filter");
              let Filter = _Filter;
              const _Float = class _Float extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "float");
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
                [_xfa_object.$finalize]() {
                  const number = parseFloat(this[_xfa_object.$content].trim());
                  this[_xfa_object.$content] = isNaN(number) ? null : number;
                }
                [_xfa_object.$toHTML](availableSpace) {
                  return valueToHtml(this[_xfa_object.$content] !== null ? this[_xfa_object.$content].toString() : "");
                }
              };
              __name(_Float, "Float");
              let Float = _Float;
              const _Font = class _Font extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "font", true);
                  this.baselineShift = (0, _utils.getMeasurement)(attributes.baselineShift);
                  this.fontHorizontalScale = (0, _utils.getFloat)({
                    data: attributes.fontHorizontalScale,
                    defaultValue: 100,
                    validate: (x) => x >= 0
                  });
                  this.fontVerticalScale = (0, _utils.getFloat)({
                    data: attributes.fontVerticalScale,
                    defaultValue: 100,
                    validate: (x) => x >= 0
                  });
                  this.id = attributes.id || "";
                  this.kerningMode = (0, _utils.getStringOption)(attributes.kerningMode, ["none", "pair"]);
                  this.letterSpacing = (0, _utils.getMeasurement)(attributes.letterSpacing, "0");
                  this.lineThrough = (0, _utils.getInteger)({
                    data: attributes.lineThrough,
                    defaultValue: 0,
                    validate: (x) => x === 1 || x === 2
                  });
                  this.lineThroughPeriod = (0, _utils.getStringOption)(attributes.lineThroughPeriod, ["all", "word"]);
                  this.overline = (0, _utils.getInteger)({
                    data: attributes.overline,
                    defaultValue: 0,
                    validate: (x) => x === 1 || x === 2
                  });
                  this.overlinePeriod = (0, _utils.getStringOption)(attributes.overlinePeriod, ["all", "word"]);
                  this.posture = (0, _utils.getStringOption)(attributes.posture, ["normal", "italic"]);
                  this.size = (0, _utils.getMeasurement)(attributes.size, "10pt");
                  this.typeface = attributes.typeface || "Courier";
                  this.underline = (0, _utils.getInteger)({
                    data: attributes.underline,
                    defaultValue: 0,
                    validate: (x) => x === 1 || x === 2
                  });
                  this.underlinePeriod = (0, _utils.getStringOption)(attributes.underlinePeriod, ["all", "word"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.weight = (0, _utils.getStringOption)(attributes.weight, ["normal", "bold"]);
                  this.extras = null;
                  this.fill = null;
                }
                [_xfa_object.$clean](builder) {
                  super[_xfa_object.$clean](builder);
                  this[_xfa_object.$globalData].usedTypefaces.add(this.typeface);
                }
                [_xfa_object.$toStyle]() {
                  const style = (0, _html_utils.toStyle)(this, "fill");
                  const color = style.color;
                  if (color) {
                    if (color === "#000000") {
                      delete style.color;
                    } else if (!color.startsWith("#")) {
                      style.background = color;
                      style.backgroundClip = "text";
                      style.color = "transparent";
                    }
                  }
                  if (this.baselineShift) {
                    style.verticalAlign = (0, _html_utils.measureToString)(this.baselineShift);
                  }
                  style.fontKerning = this.kerningMode === "none" ? "none" : "normal";
                  style.letterSpacing = (0, _html_utils.measureToString)(this.letterSpacing);
                  if (this.lineThrough !== 0) {
                    style.textDecoration = "line-through";
                    if (this.lineThrough === 2) {
                      style.textDecorationStyle = "double";
                    }
                  }
                  if (this.overline !== 0) {
                    style.textDecoration = "overline";
                    if (this.overline === 2) {
                      style.textDecorationStyle = "double";
                    }
                  }
                  style.fontStyle = this.posture;
                  style.fontSize = (0, _html_utils.measureToString)(0.99 * this.size);
                  (0, _html_utils.setFontFamily)(this, this, this[_xfa_object.$globalData].fontFinder, style);
                  if (this.underline !== 0) {
                    style.textDecoration = "underline";
                    if (this.underline === 2) {
                      style.textDecorationStyle = "double";
                    }
                  }
                  style.fontWeight = this.weight;
                  return style;
                }
              };
              __name(_Font, "Font");
              let Font = _Font;
              const _Format = class _Format extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "format", true);
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.extras = null;
                  this.picture = null;
                }
              };
              __name(_Format, "Format");
              let Format = _Format;
              const _Handler = class _Handler extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "handler");
                  this.id = attributes.id || "";
                  this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              };
              __name(_Handler, "Handler");
              let Handler = _Handler;
              const _Hyphenation = class _Hyphenation extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "hyphenation");
                  this.excludeAllCaps = (0, _utils.getInteger)({
                    data: attributes.excludeAllCaps,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.excludeInitialCap = (0, _utils.getInteger)({
                    data: attributes.excludeInitialCap,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.hyphenate = (0, _utils.getInteger)({
                    data: attributes.hyphenate,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.id = attributes.id || "";
                  this.pushCharacterCount = (0, _utils.getInteger)({
                    data: attributes.pushCharacterCount,
                    defaultValue: 3,
                    validate: (x) => x >= 0
                  });
                  this.remainCharacterCount = (0, _utils.getInteger)({
                    data: attributes.remainCharacterCount,
                    defaultValue: 3,
                    validate: (x) => x >= 0
                  });
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.wordCharacterCount = (0, _utils.getInteger)({
                    data: attributes.wordCharacterCount,
                    defaultValue: 7,
                    validate: (x) => x >= 0
                  });
                }
              };
              __name(_Hyphenation, "Hyphenation");
              let Hyphenation = _Hyphenation;
              const _Image = class _Image extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "image");
                  this.aspect = (0, _utils.getStringOption)(attributes.aspect, ["fit", "actual", "height", "none", "width"]);
                  this.contentType = attributes.contentType || "";
                  this.href = attributes.href || "";
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.transferEncoding = (0, _utils.getStringOption)(attributes.transferEncoding, ["base64", "none", "package"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
                [_xfa_object.$toHTML]() {
                  if (this.contentType && !MIMES.has(this.contentType.toLowerCase())) {
                    return _utils.HTMLResult.EMPTY;
                  }
                  let buffer = this[_xfa_object.$globalData].images && this[_xfa_object.$globalData].images.get(this.href);
                  if (!buffer && (this.href || !this[_xfa_object.$content])) {
                    return _utils.HTMLResult.EMPTY;
                  }
                  if (!buffer && this.transferEncoding === "base64") {
                    buffer = (0, _util.stringToBytes)(atob(this[_xfa_object.$content]));
                  }
                  if (!buffer) {
                    return _utils.HTMLResult.EMPTY;
                  }
                  if (!this.contentType) {
                    for (const [header, type] of IMAGES_HEADERS) {
                      if (buffer.length > header.length && header.every((x, i) => x === buffer[i])) {
                        this.contentType = type;
                        break;
                      }
                    }
                    if (!this.contentType) {
                      return _utils.HTMLResult.EMPTY;
                    }
                  }
                  const blob = new Blob([buffer], {
                    type: this.contentType
                  });
                  let style;
                  switch (this.aspect) {
                    case "fit":
                    case "actual":
                      break;
                    case "height":
                      style = {
                        height: "100%",
                        objectFit: "fill"
                      };
                      break;
                    case "none":
                      style = {
                        width: "100%",
                        height: "100%",
                        objectFit: "fill"
                      };
                      break;
                    case "width":
                      style = {
                        width: "100%",
                        objectFit: "fill"
                      };
                      break;
                  }
                  const parent = this[_xfa_object.$getParent]();
                  return _utils.HTMLResult.success({
                    name: "img",
                    attributes: {
                      class: ["xfaImage"],
                      style,
                      src: URL.createObjectURL(blob),
                      alt: parent ? ariaLabel(parent[_xfa_object.$getParent]()) : null
                    }
                  });
                }
              };
              __name(_Image, "Image");
              let Image = _Image;
              const _ImageEdit = class _ImageEdit extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "imageEdit", true);
                  this.data = (0, _utils.getStringOption)(attributes.data, ["link", "embed"]);
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.border = null;
                  this.extras = null;
                  this.margin = null;
                }
                [_xfa_object.$toHTML](availableSpace) {
                  if (this.data === "embed") {
                    return _utils.HTMLResult.success({
                      name: "div",
                      children: [],
                      attributes: {}
                    });
                  }
                  return _utils.HTMLResult.EMPTY;
                }
              };
              __name(_ImageEdit, "ImageEdit");
              let ImageEdit = _ImageEdit;
              const _Integer = class _Integer extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "integer");
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
                [_xfa_object.$finalize]() {
                  const number = parseInt(this[_xfa_object.$content].trim(), 10);
                  this[_xfa_object.$content] = isNaN(number) ? null : number;
                }
                [_xfa_object.$toHTML](availableSpace) {
                  return valueToHtml(this[_xfa_object.$content] !== null ? this[_xfa_object.$content].toString() : "");
                }
              };
              __name(_Integer, "Integer");
              let Integer = _Integer;
              const _Issuers = class _Issuers extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "issuers", true);
                  this.id = attributes.id || "";
                  this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.certificate = new _xfa_object.XFAObjectArray();
                }
              };
              __name(_Issuers, "Issuers");
              let Issuers = _Issuers;
              const _Items = class _Items extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "items", true);
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
                  this.ref = attributes.ref || "";
                  this.save = (0, _utils.getInteger)({
                    data: attributes.save,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.boolean = new _xfa_object.XFAObjectArray();
                  this.date = new _xfa_object.XFAObjectArray();
                  this.dateTime = new _xfa_object.XFAObjectArray();
                  this.decimal = new _xfa_object.XFAObjectArray();
                  this.exData = new _xfa_object.XFAObjectArray();
                  this.float = new _xfa_object.XFAObjectArray();
                  this.image = new _xfa_object.XFAObjectArray();
                  this.integer = new _xfa_object.XFAObjectArray();
                  this.text = new _xfa_object.XFAObjectArray();
                  this.time = new _xfa_object.XFAObjectArray();
                }
                [_xfa_object.$toHTML]() {
                  const output = [];
                  for (const child of this[_xfa_object.$getChildren]()) {
                    output.push(child[_xfa_object.$text]());
                  }
                  return _utils.HTMLResult.success(output);
                }
              };
              __name(_Items, "Items");
              let Items = _Items;
              exports2.Items = Items;
              const _Keep = class _Keep extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "keep", true);
                  this.id = attributes.id || "";
                  const options = ["none", "contentArea", "pageArea"];
                  this.intact = (0, _utils.getStringOption)(attributes.intact, options);
                  this.next = (0, _utils.getStringOption)(attributes.next, options);
                  this.previous = (0, _utils.getStringOption)(attributes.previous, options);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.extras = null;
                }
              };
              __name(_Keep, "Keep");
              let Keep = _Keep;
              const _KeyUsage = class _KeyUsage extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "keyUsage");
                  const options = ["", "yes", "no"];
                  this.crlSign = (0, _utils.getStringOption)(attributes.crlSign, options);
                  this.dataEncipherment = (0, _utils.getStringOption)(attributes.dataEncipherment, options);
                  this.decipherOnly = (0, _utils.getStringOption)(attributes.decipherOnly, options);
                  this.digitalSignature = (0, _utils.getStringOption)(attributes.digitalSignature, options);
                  this.encipherOnly = (0, _utils.getStringOption)(attributes.encipherOnly, options);
                  this.id = attributes.id || "";
                  this.keyAgreement = (0, _utils.getStringOption)(attributes.keyAgreement, options);
                  this.keyCertSign = (0, _utils.getStringOption)(attributes.keyCertSign, options);
                  this.keyEncipherment = (0, _utils.getStringOption)(attributes.keyEncipherment, options);
                  this.nonRepudiation = (0, _utils.getStringOption)(attributes.nonRepudiation, options);
                  this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              };
              __name(_KeyUsage, "KeyUsage");
              let KeyUsage = _KeyUsage;
              const _Line = class _Line extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "line", true);
                  this.hand = (0, _utils.getStringOption)(attributes.hand, ["even", "left", "right"]);
                  this.id = attributes.id || "";
                  this.slope = (0, _utils.getStringOption)(attributes.slope, ["\\", "/"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.edge = null;
                }
                [_xfa_object.$toHTML]() {
                  const parent = this[_xfa_object.$getParent]()[_xfa_object.$getParent]();
                  const edge = this.edge || new Edge({});
                  const edgeStyle = edge[_xfa_object.$toStyle]();
                  const style = /* @__PURE__ */ Object.create(null);
                  const thickness = edge.presence === "visible" ? edge.thickness : 0;
                  style.strokeWidth = (0, _html_utils.measureToString)(thickness);
                  style.stroke = edgeStyle.color;
                  let x1, y1, x2, y2;
                  let width = "100%";
                  let height = "100%";
                  if (parent.w <= thickness) {
                    [x1, y1, x2, y2] = ["50%", 0, "50%", "100%"];
                    width = style.strokeWidth;
                  } else if (parent.h <= thickness) {
                    [x1, y1, x2, y2] = [0, "50%", "100%", "50%"];
                    height = style.strokeWidth;
                  } else {
                    if (this.slope === "\\") {
                      [x1, y1, x2, y2] = [0, 0, "100%", "100%"];
                    } else {
                      [x1, y1, x2, y2] = [0, "100%", "100%", 0];
                    }
                  }
                  const line = {
                    name: "line",
                    attributes: {
                      xmlns: SVG_NS,
                      x1,
                      y1,
                      x2,
                      y2,
                      style
                    }
                  };
                  const svg = {
                    name: "svg",
                    children: [line],
                    attributes: {
                      xmlns: SVG_NS,
                      width,
                      height,
                      style: {
                        overflow: "visible"
                      }
                    }
                  };
                  if (hasMargin(parent)) {
                    return _utils.HTMLResult.success({
                      name: "div",
                      attributes: {
                        style: {
                          display: "inline",
                          width: "100%",
                          height: "100%"
                        }
                      },
                      children: [svg]
                    });
                  }
                  svg.attributes.style.position = "absolute";
                  return _utils.HTMLResult.success(svg);
                }
              };
              __name(_Line, "Line");
              let Line = _Line;
              const _Linear = class _Linear extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "linear", true);
                  this.id = attributes.id || "";
                  this.type = (0, _utils.getStringOption)(attributes.type, ["toRight", "toBottom", "toLeft", "toTop"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.color = null;
                  this.extras = null;
                }
                [_xfa_object.$toStyle](startColor) {
                  startColor = startColor ? startColor[_xfa_object.$toStyle]() : "#FFFFFF";
                  const transf = this.type.replace(/([RBLT])/, " $1").toLowerCase();
                  const endColor = this.color ? this.color[_xfa_object.$toStyle]() : "#000000";
                  return `linear-gradient(${transf}, ${startColor}, ${endColor})`;
                }
              };
              __name(_Linear, "Linear");
              let Linear = _Linear;
              const _LockDocument = class _LockDocument extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "lockDocument");
                  this.id = attributes.id || "";
                  this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
                [_xfa_object.$finalize]() {
                  this[_xfa_object.$content] = (0, _utils.getStringOption)(this[_xfa_object.$content], ["auto", "0", "1"]);
                }
              };
              __name(_LockDocument, "LockDocument");
              let LockDocument = _LockDocument;
              const _Manifest = class _Manifest extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "manifest", true);
                  this.action = (0, _utils.getStringOption)(attributes.action, ["include", "all", "exclude"]);
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.extras = null;
                  this.ref = new _xfa_object.XFAObjectArray();
                }
              };
              __name(_Manifest, "Manifest");
              let Manifest = _Manifest;
              const _Margin = class _Margin extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "margin", true);
                  this.bottomInset = (0, _utils.getMeasurement)(attributes.bottomInset, "0");
                  this.id = attributes.id || "";
                  this.leftInset = (0, _utils.getMeasurement)(attributes.leftInset, "0");
                  this.rightInset = (0, _utils.getMeasurement)(attributes.rightInset, "0");
                  this.topInset = (0, _utils.getMeasurement)(attributes.topInset, "0");
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.extras = null;
                }
                [_xfa_object.$toStyle]() {
                  return {
                    margin: (0, _html_utils.measureToString)(this.topInset) + " " + (0, _html_utils.measureToString)(this.rightInset) + " " + (0, _html_utils.measureToString)(this.bottomInset) + " " + (0, _html_utils.measureToString)(this.leftInset)
                  };
                }
              };
              __name(_Margin, "Margin");
              let Margin = _Margin;
              const _Mdp = class _Mdp extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "mdp");
                  this.id = attributes.id || "";
                  this.permissions = (0, _utils.getInteger)({
                    data: attributes.permissions,
                    defaultValue: 2,
                    validate: (x) => x === 1 || x === 3
                  });
                  this.signatureType = (0, _utils.getStringOption)(attributes.signatureType, ["filler", "author"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              };
              __name(_Mdp, "Mdp");
              let Mdp = _Mdp;
              const _Medium = class _Medium extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "medium");
                  this.id = attributes.id || "";
                  this.imagingBBox = (0, _utils.getBBox)(attributes.imagingBBox);
                  this.long = (0, _utils.getMeasurement)(attributes.long);
                  this.orientation = (0, _utils.getStringOption)(attributes.orientation, ["portrait", "landscape"]);
                  this.short = (0, _utils.getMeasurement)(attributes.short);
                  this.stock = attributes.stock || "";
                  this.trayIn = (0, _utils.getStringOption)(attributes.trayIn, ["auto", "delegate", "pageFront"]);
                  this.trayOut = (0, _utils.getStringOption)(attributes.trayOut, ["auto", "delegate"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              };
              __name(_Medium, "Medium");
              let Medium = _Medium;
              const _Message = class _Message extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "message", true);
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.text = new _xfa_object.XFAObjectArray();
                }
              };
              __name(_Message, "Message");
              let Message = _Message;
              const _NumericEdit = class _NumericEdit extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "numericEdit", true);
                  this.hScrollPolicy = (0, _utils.getStringOption)(attributes.hScrollPolicy, ["auto", "off", "on"]);
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.border = null;
                  this.comb = null;
                  this.extras = null;
                  this.margin = null;
                }
                [_xfa_object.$toHTML](availableSpace) {
                  const style = (0, _html_utils.toStyle)(this, "border", "font", "margin");
                  const field = this[_xfa_object.$getParent]()[_xfa_object.$getParent]();
                  const html = {
                    name: "input",
                    attributes: {
                      type: "text",
                      fieldId: field[_xfa_object.$uid],
                      dataId: field[_xfa_object.$data] && field[_xfa_object.$data][_xfa_object.$uid] || field[_xfa_object.$uid],
                      class: ["xfaTextfield"],
                      style,
                      "aria-label": ariaLabel(field),
                      "aria-required": false
                    }
                  };
                  if (isRequired(field)) {
                    html.attributes["aria-required"] = true;
                    html.attributes.required = true;
                  }
                  return _utils.HTMLResult.success({
                    name: "label",
                    attributes: {
                      class: ["xfaLabel"]
                    },
                    children: [html]
                  });
                }
              };
              __name(_NumericEdit, "NumericEdit");
              let NumericEdit = _NumericEdit;
              const _Occur = class _Occur extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "occur", true);
                  this.id = attributes.id || "";
                  this.initial = attributes.initial !== "" ? (0, _utils.getInteger)({
                    data: attributes.initial,
                    defaultValue: "",
                    validate: (x) => true
                  }) : "";
                  this.max = attributes.max !== "" ? (0, _utils.getInteger)({
                    data: attributes.max,
                    defaultValue: 1,
                    validate: (x) => true
                  }) : "";
                  this.min = attributes.min !== "" ? (0, _utils.getInteger)({
                    data: attributes.min,
                    defaultValue: 1,
                    validate: (x) => true
                  }) : "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.extras = null;
                }
                [_xfa_object.$clean]() {
                  const parent = this[_xfa_object.$getParent]();
                  const originalMin = this.min;
                  if (this.min === "") {
                    this.min = parent instanceof PageArea || parent instanceof PageSet ? 0 : 1;
                  }
                  if (this.max === "") {
                    if (originalMin === "") {
                      this.max = parent instanceof PageArea || parent instanceof PageSet ? -1 : 1;
                    } else {
                      this.max = this.min;
                    }
                  }
                  if (this.max !== -1 && this.max < this.min) {
                    this.max = this.min;
                  }
                  if (this.initial === "") {
                    this.initial = parent instanceof Template ? 1 : this.min;
                  }
                }
              };
              __name(_Occur, "Occur");
              let Occur = _Occur;
              const _Oid = class _Oid extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "oid");
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              };
              __name(_Oid, "Oid");
              let Oid = _Oid;
              const _Oids = class _Oids extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "oids", true);
                  this.id = attributes.id || "";
                  this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.oid = new _xfa_object.XFAObjectArray();
                }
              };
              __name(_Oids, "Oids");
              let Oids = _Oids;
              const _Overflow = class _Overflow extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "overflow");
                  this.id = attributes.id || "";
                  this.leader = attributes.leader || "";
                  this.target = attributes.target || "";
                  this.trailer = attributes.trailer || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
                [_xfa_object.$getExtra]() {
                  if (!this[_xfa_object.$extra]) {
                    const parent = this[_xfa_object.$getParent]();
                    const root = this[_xfa_object.$getTemplateRoot]();
                    const target = root[_xfa_object.$searchNode](this.target, parent);
                    const leader = root[_xfa_object.$searchNode](this.leader, parent);
                    const trailer = root[_xfa_object.$searchNode](this.trailer, parent);
                    this[_xfa_object.$extra] = {
                      target: target && target[0] || null,
                      leader: leader && leader[0] || null,
                      trailer: trailer && trailer[0] || null,
                      addLeader: false,
                      addTrailer: false
                    };
                  }
                  return this[_xfa_object.$extra];
                }
              };
              __name(_Overflow, "Overflow");
              let Overflow = _Overflow;
              const _PageArea = class _PageArea extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "pageArea", true);
                  this.blankOrNotBlank = (0, _utils.getStringOption)(attributes.blankOrNotBlank, ["any", "blank", "notBlank"]);
                  this.id = attributes.id || "";
                  this.initialNumber = (0, _utils.getInteger)({
                    data: attributes.initialNumber,
                    defaultValue: 1,
                    validate: (x) => true
                  });
                  this.name = attributes.name || "";
                  this.numbered = (0, _utils.getInteger)({
                    data: attributes.numbered,
                    defaultValue: 1,
                    validate: (x) => true
                  });
                  this.oddOrEven = (0, _utils.getStringOption)(attributes.oddOrEven, ["any", "even", "odd"]);
                  this.pagePosition = (0, _utils.getStringOption)(attributes.pagePosition, ["any", "first", "last", "only", "rest"]);
                  this.relevant = (0, _utils.getRelevant)(attributes.relevant);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.desc = null;
                  this.extras = null;
                  this.medium = null;
                  this.occur = null;
                  this.area = new _xfa_object.XFAObjectArray();
                  this.contentArea = new _xfa_object.XFAObjectArray();
                  this.draw = new _xfa_object.XFAObjectArray();
                  this.exclGroup = new _xfa_object.XFAObjectArray();
                  this.field = new _xfa_object.XFAObjectArray();
                  this.subform = new _xfa_object.XFAObjectArray();
                }
                [_xfa_object.$isUsable]() {
                  if (!this[_xfa_object.$extra]) {
                    this[_xfa_object.$extra] = {
                      numberOfUse: 0
                    };
                    return true;
                  }
                  return !this.occur || this.occur.max === -1 || this[_xfa_object.$extra].numberOfUse < this.occur.max;
                }
                [_xfa_object.$cleanPage]() {
                  delete this[_xfa_object.$extra];
                }
                [_xfa_object.$getNextPage]() {
                  if (!this[_xfa_object.$extra]) {
                    this[_xfa_object.$extra] = {
                      numberOfUse: 0
                    };
                  }
                  const parent = this[_xfa_object.$getParent]();
                  if (parent.relation === "orderedOccurrence") {
                    if (this[_xfa_object.$isUsable]()) {
                      this[_xfa_object.$extra].numberOfUse += 1;
                      return this;
                    }
                  }
                  return parent[_xfa_object.$getNextPage]();
                }
                [_xfa_object.$getAvailableSpace]() {
                  return this[_xfa_object.$extra].space || {
                    width: 0,
                    height: 0
                  };
                }
                [_xfa_object.$toHTML]() {
                  if (!this[_xfa_object.$extra]) {
                    this[_xfa_object.$extra] = {
                      numberOfUse: 1
                    };
                  }
                  const children = [];
                  this[_xfa_object.$extra].children = children;
                  const style = /* @__PURE__ */ Object.create(null);
                  if (this.medium && this.medium.short && this.medium.long) {
                    style.width = (0, _html_utils.measureToString)(this.medium.short);
                    style.height = (0, _html_utils.measureToString)(this.medium.long);
                    this[_xfa_object.$extra].space = {
                      width: this.medium.short,
                      height: this.medium.long
                    };
                    if (this.medium.orientation === "landscape") {
                      const x = style.width;
                      style.width = style.height;
                      style.height = x;
                      this[_xfa_object.$extra].space = {
                        width: this.medium.long,
                        height: this.medium.short
                      };
                    }
                  } else {
                    (0, _util.warn)("XFA - No medium specified in pageArea: please file a bug.");
                  }
                  this[_xfa_object.$childrenToHTML]({
                    filter: /* @__PURE__ */ new Set(["area", "draw", "field", "subform"]),
                    include: true
                  });
                  this[_xfa_object.$childrenToHTML]({
                    filter: /* @__PURE__ */ new Set(["contentArea"]),
                    include: true
                  });
                  return _utils.HTMLResult.success({
                    name: "div",
                    children,
                    attributes: {
                      class: ["xfaPage"],
                      id: this[_xfa_object.$uid],
                      style,
                      xfaName: this.name
                    }
                  });
                }
              };
              __name(_PageArea, "PageArea");
              let PageArea = _PageArea;
              const _PageSet = class _PageSet extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "pageSet", true);
                  this.duplexImposition = (0, _utils.getStringOption)(attributes.duplexImposition, ["longEdge", "shortEdge"]);
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.relation = (0, _utils.getStringOption)(attributes.relation, ["orderedOccurrence", "duplexPaginated", "simplexPaginated"]);
                  this.relevant = (0, _utils.getRelevant)(attributes.relevant);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.extras = null;
                  this.occur = null;
                  this.pageArea = new _xfa_object.XFAObjectArray();
                  this.pageSet = new _xfa_object.XFAObjectArray();
                }
                [_xfa_object.$cleanPage]() {
                  for (const page of this.pageArea.children) {
                    page[_xfa_object.$cleanPage]();
                  }
                  for (const page of this.pageSet.children) {
                    page[_xfa_object.$cleanPage]();
                  }
                }
                [_xfa_object.$isUsable]() {
                  return !this.occur || this.occur.max === -1 || this[_xfa_object.$extra].numberOfUse < this.occur.max;
                }
                [_xfa_object.$getNextPage]() {
                  if (!this[_xfa_object.$extra]) {
                    this[_xfa_object.$extra] = {
                      numberOfUse: 1,
                      pageIndex: -1,
                      pageSetIndex: -1
                    };
                  }
                  if (this.relation === "orderedOccurrence") {
                    if (this[_xfa_object.$extra].pageIndex + 1 < this.pageArea.children.length) {
                      this[_xfa_object.$extra].pageIndex += 1;
                      const pageArea = this.pageArea.children[this[_xfa_object.$extra].pageIndex];
                      return pageArea[_xfa_object.$getNextPage]();
                    }
                    if (this[_xfa_object.$extra].pageSetIndex + 1 < this.pageSet.children.length) {
                      this[_xfa_object.$extra].pageSetIndex += 1;
                      return this.pageSet.children[this[_xfa_object.$extra].pageSetIndex][_xfa_object.$getNextPage]();
                    }
                    if (this[_xfa_object.$isUsable]()) {
                      this[_xfa_object.$extra].numberOfUse += 1;
                      this[_xfa_object.$extra].pageIndex = -1;
                      this[_xfa_object.$extra].pageSetIndex = -1;
                      return this[_xfa_object.$getNextPage]();
                    }
                    const parent = this[_xfa_object.$getParent]();
                    if (parent instanceof _PageSet) {
                      return parent[_xfa_object.$getNextPage]();
                    }
                    this[_xfa_object.$cleanPage]();
                    return this[_xfa_object.$getNextPage]();
                  }
                  const pageNumber = this[_xfa_object.$getTemplateRoot]()[_xfa_object.$extra].pageNumber;
                  const parity = pageNumber % 2 === 0 ? "even" : "odd";
                  const position = pageNumber === 0 ? "first" : "rest";
                  let page = this.pageArea.children.find((p) => p.oddOrEven === parity && p.pagePosition === position);
                  if (page) {
                    return page;
                  }
                  page = this.pageArea.children.find((p) => p.oddOrEven === "any" && p.pagePosition === position);
                  if (page) {
                    return page;
                  }
                  page = this.pageArea.children.find((p) => p.oddOrEven === "any" && p.pagePosition === "any");
                  if (page) {
                    return page;
                  }
                  return this.pageArea.children[0];
                }
              };
              __name(_PageSet, "PageSet");
              let PageSet = _PageSet;
              const _Para = class _Para extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "para", true);
                  this.hAlign = (0, _utils.getStringOption)(attributes.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
                  this.id = attributes.id || "";
                  this.lineHeight = attributes.lineHeight ? (0, _utils.getMeasurement)(attributes.lineHeight, "0pt") : "";
                  this.marginLeft = attributes.marginLeft ? (0, _utils.getMeasurement)(attributes.marginLeft, "0pt") : "";
                  this.marginRight = attributes.marginRight ? (0, _utils.getMeasurement)(attributes.marginRight, "0pt") : "";
                  this.orphans = (0, _utils.getInteger)({
                    data: attributes.orphans,
                    defaultValue: 0,
                    validate: (x) => x >= 0
                  });
                  this.preserve = attributes.preserve || "";
                  this.radixOffset = attributes.radixOffset ? (0, _utils.getMeasurement)(attributes.radixOffset, "0pt") : "";
                  this.spaceAbove = attributes.spaceAbove ? (0, _utils.getMeasurement)(attributes.spaceAbove, "0pt") : "";
                  this.spaceBelow = attributes.spaceBelow ? (0, _utils.getMeasurement)(attributes.spaceBelow, "0pt") : "";
                  this.tabDefault = attributes.tabDefault ? (0, _utils.getMeasurement)(this.tabDefault) : "";
                  this.tabStops = (attributes.tabStops || "").trim().split(/\s+/).map((x, i) => i % 2 === 1 ? (0, _utils.getMeasurement)(x) : x);
                  this.textIndent = attributes.textIndent ? (0, _utils.getMeasurement)(attributes.textIndent, "0pt") : "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.vAlign = (0, _utils.getStringOption)(attributes.vAlign, ["top", "bottom", "middle"]);
                  this.widows = (0, _utils.getInteger)({
                    data: attributes.widows,
                    defaultValue: 0,
                    validate: (x) => x >= 0
                  });
                  this.hyphenation = null;
                }
                [_xfa_object.$toStyle]() {
                  const style = (0, _html_utils.toStyle)(this, "hAlign");
                  if (this.marginLeft !== "") {
                    style.paddingLeft = (0, _html_utils.measureToString)(this.marginLeft);
                  }
                  if (this.marginRight !== "") {
                    style.paddingight = (0, _html_utils.measureToString)(this.marginRight);
                  }
                  if (this.spaceAbove !== "") {
                    style.paddingTop = (0, _html_utils.measureToString)(this.spaceAbove);
                  }
                  if (this.spaceBelow !== "") {
                    style.paddingBottom = (0, _html_utils.measureToString)(this.spaceBelow);
                  }
                  if (this.textIndent !== "") {
                    style.textIndent = (0, _html_utils.measureToString)(this.textIndent);
                    (0, _html_utils.fixTextIndent)(style);
                  }
                  if (this.lineHeight > 0) {
                    style.lineHeight = (0, _html_utils.measureToString)(this.lineHeight);
                  }
                  if (this.tabDefault !== "") {
                    style.tabSize = (0, _html_utils.measureToString)(this.tabDefault);
                  }
                  if (this.tabStops.length > 0)
                    ;
                  if (this.hyphenatation) {
                    Object.assign(style, this.hyphenatation[_xfa_object.$toStyle]());
                  }
                  return style;
                }
              };
              __name(_Para, "Para");
              let Para = _Para;
              const _PasswordEdit = class _PasswordEdit extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "passwordEdit", true);
                  this.hScrollPolicy = (0, _utils.getStringOption)(attributes.hScrollPolicy, ["auto", "off", "on"]);
                  this.id = attributes.id || "";
                  this.passwordChar = attributes.passwordChar || "*";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.border = null;
                  this.extras = null;
                  this.margin = null;
                }
              };
              __name(_PasswordEdit, "PasswordEdit");
              let PasswordEdit = _PasswordEdit;
              const _Pattern = class _Pattern extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "pattern", true);
                  this.id = attributes.id || "";
                  this.type = (0, _utils.getStringOption)(attributes.type, ["crossHatch", "crossDiagonal", "diagonalLeft", "diagonalRight", "horizontal", "vertical"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.color = null;
                  this.extras = null;
                }
                [_xfa_object.$toStyle](startColor) {
                  startColor = startColor ? startColor[_xfa_object.$toStyle]() : "#FFFFFF";
                  const endColor = this.color ? this.color[_xfa_object.$toStyle]() : "#000000";
                  const width = 5;
                  const cmd = "repeating-linear-gradient";
                  const colors = `${startColor},${startColor} ${width}px,${endColor} ${width}px,${endColor} ${2 * width}px`;
                  switch (this.type) {
                    case "crossHatch":
                      return `${cmd}(to top,${colors}) ${cmd}(to right,${colors})`;
                    case "crossDiagonal":
                      return `${cmd}(45deg,${colors}) ${cmd}(-45deg,${colors})`;
                    case "diagonalLeft":
                      return `${cmd}(45deg,${colors})`;
                    case "diagonalRight":
                      return `${cmd}(-45deg,${colors})`;
                    case "horizontal":
                      return `${cmd}(to top,${colors})`;
                    case "vertical":
                      return `${cmd}(to right,${colors})`;
                  }
                  return "";
                }
              };
              __name(_Pattern, "Pattern");
              let Pattern = _Pattern;
              const _Picture = class _Picture extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "picture");
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              };
              __name(_Picture, "Picture");
              let Picture = _Picture;
              const _Proto = class _Proto extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "proto", true);
                  this.appearanceFilter = new _xfa_object.XFAObjectArray();
                  this.arc = new _xfa_object.XFAObjectArray();
                  this.area = new _xfa_object.XFAObjectArray();
                  this.assist = new _xfa_object.XFAObjectArray();
                  this.barcode = new _xfa_object.XFAObjectArray();
                  this.bindItems = new _xfa_object.XFAObjectArray();
                  this.bookend = new _xfa_object.XFAObjectArray();
                  this.boolean = new _xfa_object.XFAObjectArray();
                  this.border = new _xfa_object.XFAObjectArray();
                  this.break = new _xfa_object.XFAObjectArray();
                  this.breakAfter = new _xfa_object.XFAObjectArray();
                  this.breakBefore = new _xfa_object.XFAObjectArray();
                  this.button = new _xfa_object.XFAObjectArray();
                  this.calculate = new _xfa_object.XFAObjectArray();
                  this.caption = new _xfa_object.XFAObjectArray();
                  this.certificate = new _xfa_object.XFAObjectArray();
                  this.certificates = new _xfa_object.XFAObjectArray();
                  this.checkButton = new _xfa_object.XFAObjectArray();
                  this.choiceList = new _xfa_object.XFAObjectArray();
                  this.color = new _xfa_object.XFAObjectArray();
                  this.comb = new _xfa_object.XFAObjectArray();
                  this.connect = new _xfa_object.XFAObjectArray();
                  this.contentArea = new _xfa_object.XFAObjectArray();
                  this.corner = new _xfa_object.XFAObjectArray();
                  this.date = new _xfa_object.XFAObjectArray();
                  this.dateTime = new _xfa_object.XFAObjectArray();
                  this.dateTimeEdit = new _xfa_object.XFAObjectArray();
                  this.decimal = new _xfa_object.XFAObjectArray();
                  this.defaultUi = new _xfa_object.XFAObjectArray();
                  this.desc = new _xfa_object.XFAObjectArray();
                  this.digestMethod = new _xfa_object.XFAObjectArray();
                  this.digestMethods = new _xfa_object.XFAObjectArray();
                  this.draw = new _xfa_object.XFAObjectArray();
                  this.edge = new _xfa_object.XFAObjectArray();
                  this.encoding = new _xfa_object.XFAObjectArray();
                  this.encodings = new _xfa_object.XFAObjectArray();
                  this.encrypt = new _xfa_object.XFAObjectArray();
                  this.encryptData = new _xfa_object.XFAObjectArray();
                  this.encryption = new _xfa_object.XFAObjectArray();
                  this.encryptionMethod = new _xfa_object.XFAObjectArray();
                  this.encryptionMethods = new _xfa_object.XFAObjectArray();
                  this.event = new _xfa_object.XFAObjectArray();
                  this.exData = new _xfa_object.XFAObjectArray();
                  this.exObject = new _xfa_object.XFAObjectArray();
                  this.exclGroup = new _xfa_object.XFAObjectArray();
                  this.execute = new _xfa_object.XFAObjectArray();
                  this.extras = new _xfa_object.XFAObjectArray();
                  this.field = new _xfa_object.XFAObjectArray();
                  this.fill = new _xfa_object.XFAObjectArray();
                  this.filter = new _xfa_object.XFAObjectArray();
                  this.float = new _xfa_object.XFAObjectArray();
                  this.font = new _xfa_object.XFAObjectArray();
                  this.format = new _xfa_object.XFAObjectArray();
                  this.handler = new _xfa_object.XFAObjectArray();
                  this.hyphenation = new _xfa_object.XFAObjectArray();
                  this.image = new _xfa_object.XFAObjectArray();
                  this.imageEdit = new _xfa_object.XFAObjectArray();
                  this.integer = new _xfa_object.XFAObjectArray();
                  this.issuers = new _xfa_object.XFAObjectArray();
                  this.items = new _xfa_object.XFAObjectArray();
                  this.keep = new _xfa_object.XFAObjectArray();
                  this.keyUsage = new _xfa_object.XFAObjectArray();
                  this.line = new _xfa_object.XFAObjectArray();
                  this.linear = new _xfa_object.XFAObjectArray();
                  this.lockDocument = new _xfa_object.XFAObjectArray();
                  this.manifest = new _xfa_object.XFAObjectArray();
                  this.margin = new _xfa_object.XFAObjectArray();
                  this.mdp = new _xfa_object.XFAObjectArray();
                  this.medium = new _xfa_object.XFAObjectArray();
                  this.message = new _xfa_object.XFAObjectArray();
                  this.numericEdit = new _xfa_object.XFAObjectArray();
                  this.occur = new _xfa_object.XFAObjectArray();
                  this.oid = new _xfa_object.XFAObjectArray();
                  this.oids = new _xfa_object.XFAObjectArray();
                  this.overflow = new _xfa_object.XFAObjectArray();
                  this.pageArea = new _xfa_object.XFAObjectArray();
                  this.pageSet = new _xfa_object.XFAObjectArray();
                  this.para = new _xfa_object.XFAObjectArray();
                  this.passwordEdit = new _xfa_object.XFAObjectArray();
                  this.pattern = new _xfa_object.XFAObjectArray();
                  this.picture = new _xfa_object.XFAObjectArray();
                  this.radial = new _xfa_object.XFAObjectArray();
                  this.reason = new _xfa_object.XFAObjectArray();
                  this.reasons = new _xfa_object.XFAObjectArray();
                  this.rectangle = new _xfa_object.XFAObjectArray();
                  this.ref = new _xfa_object.XFAObjectArray();
                  this.script = new _xfa_object.XFAObjectArray();
                  this.setProperty = new _xfa_object.XFAObjectArray();
                  this.signData = new _xfa_object.XFAObjectArray();
                  this.signature = new _xfa_object.XFAObjectArray();
                  this.signing = new _xfa_object.XFAObjectArray();
                  this.solid = new _xfa_object.XFAObjectArray();
                  this.speak = new _xfa_object.XFAObjectArray();
                  this.stipple = new _xfa_object.XFAObjectArray();
                  this.subform = new _xfa_object.XFAObjectArray();
                  this.subformSet = new _xfa_object.XFAObjectArray();
                  this.subjectDN = new _xfa_object.XFAObjectArray();
                  this.subjectDNs = new _xfa_object.XFAObjectArray();
                  this.submit = new _xfa_object.XFAObjectArray();
                  this.text = new _xfa_object.XFAObjectArray();
                  this.textEdit = new _xfa_object.XFAObjectArray();
                  this.time = new _xfa_object.XFAObjectArray();
                  this.timeStamp = new _xfa_object.XFAObjectArray();
                  this.toolTip = new _xfa_object.XFAObjectArray();
                  this.traversal = new _xfa_object.XFAObjectArray();
                  this.traverse = new _xfa_object.XFAObjectArray();
                  this.ui = new _xfa_object.XFAObjectArray();
                  this.validate = new _xfa_object.XFAObjectArray();
                  this.value = new _xfa_object.XFAObjectArray();
                  this.variables = new _xfa_object.XFAObjectArray();
                }
              };
              __name(_Proto, "Proto");
              let Proto = _Proto;
              const _Radial = class _Radial extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "radial", true);
                  this.id = attributes.id || "";
                  this.type = (0, _utils.getStringOption)(attributes.type, ["toEdge", "toCenter"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.color = null;
                  this.extras = null;
                }
                [_xfa_object.$toStyle](startColor) {
                  startColor = startColor ? startColor[_xfa_object.$toStyle]() : "#FFFFFF";
                  const endColor = this.color ? this.color[_xfa_object.$toStyle]() : "#000000";
                  const colors = this.type === "toEdge" ? `${startColor},${endColor}` : `${endColor},${startColor}`;
                  return `radial-gradient(circle at center, ${colors})`;
                }
              };
              __name(_Radial, "Radial");
              let Radial = _Radial;
              const _Reason = class _Reason extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "reason");
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              };
              __name(_Reason, "Reason");
              let Reason = _Reason;
              const _Reasons = class _Reasons extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "reasons", true);
                  this.id = attributes.id || "";
                  this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.reason = new _xfa_object.XFAObjectArray();
                }
              };
              __name(_Reasons, "Reasons");
              let Reasons = _Reasons;
              const _Rectangle = class _Rectangle extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "rectangle", true);
                  this.hand = (0, _utils.getStringOption)(attributes.hand, ["even", "left", "right"]);
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.corner = new _xfa_object.XFAObjectArray(4);
                  this.edge = new _xfa_object.XFAObjectArray(4);
                  this.fill = null;
                }
                [_xfa_object.$toHTML]() {
                  const edge = this.edge.children.length ? this.edge.children[0] : new Edge({});
                  const edgeStyle = edge[_xfa_object.$toStyle]();
                  const style = /* @__PURE__ */ Object.create(null);
                  if (this.fill && this.fill.presence === "visible") {
                    Object.assign(style, this.fill[_xfa_object.$toStyle]());
                  } else {
                    style.fill = "transparent";
                  }
                  style.strokeWidth = (0, _html_utils.measureToString)(edge.presence === "visible" ? edge.thickness : 0);
                  style.stroke = edgeStyle.color;
                  const corner = this.corner.children.length ? this.corner.children[0] : new Corner({});
                  const cornerStyle = corner[_xfa_object.$toStyle]();
                  const rect = {
                    name: "rect",
                    attributes: {
                      xmlns: SVG_NS,
                      width: "100%",
                      height: "100%",
                      x: 0,
                      y: 0,
                      rx: cornerStyle.radius,
                      ry: cornerStyle.radius,
                      style
                    }
                  };
                  const svg = {
                    name: "svg",
                    children: [rect],
                    attributes: {
                      xmlns: SVG_NS,
                      style: {
                        overflow: "visible"
                      },
                      width: "100%",
                      height: "100%"
                    }
                  };
                  const parent = this[_xfa_object.$getParent]()[_xfa_object.$getParent]();
                  if (hasMargin(parent)) {
                    return _utils.HTMLResult.success({
                      name: "div",
                      attributes: {
                        style: {
                          display: "inline",
                          width: "100%",
                          height: "100%"
                        }
                      },
                      children: [svg]
                    });
                  }
                  svg.attributes.style.position = "absolute";
                  return _utils.HTMLResult.success(svg);
                }
              };
              __name(_Rectangle, "Rectangle");
              let Rectangle = _Rectangle;
              const _RefElement = class _RefElement extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "ref");
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              };
              __name(_RefElement, "RefElement");
              let RefElement = _RefElement;
              const _Script = class _Script extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "script");
                  this.binding = attributes.binding || "";
                  this.contentType = attributes.contentType || "";
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.runAt = (0, _utils.getStringOption)(attributes.runAt, ["client", "both", "server"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              };
              __name(_Script, "Script");
              let Script = _Script;
              const _SetProperty = class _SetProperty extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "setProperty");
                  this.connection = attributes.connection || "";
                  this.ref = attributes.ref || "";
                  this.target = attributes.target || "";
                }
              };
              __name(_SetProperty, "SetProperty");
              let SetProperty = _SetProperty;
              exports2.SetProperty = SetProperty;
              const _SignData = class _SignData extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "signData", true);
                  this.id = attributes.id || "";
                  this.operation = (0, _utils.getStringOption)(attributes.operation, ["sign", "clear", "verify"]);
                  this.ref = attributes.ref || "";
                  this.target = attributes.target || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.filter = null;
                  this.manifest = null;
                }
              };
              __name(_SignData, "SignData");
              let SignData = _SignData;
              const _Signature = class _Signature extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "signature", true);
                  this.id = attributes.id || "";
                  this.type = (0, _utils.getStringOption)(attributes.type, ["PDF1.3", "PDF1.6"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.border = null;
                  this.extras = null;
                  this.filter = null;
                  this.manifest = null;
                  this.margin = null;
                }
              };
              __name(_Signature, "Signature");
              let Signature = _Signature;
              const _Signing = class _Signing extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "signing", true);
                  this.id = attributes.id || "";
                  this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.certificate = new _xfa_object.XFAObjectArray();
                }
              };
              __name(_Signing, "Signing");
              let Signing = _Signing;
              const _Solid = class _Solid extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "solid", true);
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.extras = null;
                }
                [_xfa_object.$toStyle](startColor) {
                  return startColor ? startColor[_xfa_object.$toStyle]() : "#FFFFFF";
                }
              };
              __name(_Solid, "Solid");
              let Solid = _Solid;
              const _Speak = class _Speak extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "speak");
                  this.disable = (0, _utils.getInteger)({
                    data: attributes.disable,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.id = attributes.id || "";
                  this.priority = (0, _utils.getStringOption)(attributes.priority, ["custom", "caption", "name", "toolTip"]);
                  this.rid = attributes.rid || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              };
              __name(_Speak, "Speak");
              let Speak = _Speak;
              const _Stipple = class _Stipple extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "stipple", true);
                  this.id = attributes.id || "";
                  this.rate = (0, _utils.getInteger)({
                    data: attributes.rate,
                    defaultValue: 50,
                    validate: (x) => x >= 0 && x <= 100
                  });
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.color = null;
                  this.extras = null;
                }
                [_xfa_object.$toStyle](bgColor) {
                  const alpha = this.rate / 100;
                  return _util.Util.makeHexColor(Math.round(bgColor.value.r * (1 - alpha) + this.value.r * alpha), Math.round(bgColor.value.g * (1 - alpha) + this.value.g * alpha), Math.round(bgColor.value.b * (1 - alpha) + this.value.b * alpha));
                }
              };
              __name(_Stipple, "Stipple");
              let Stipple = _Stipple;
              const _Subform = class _Subform extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "subform", true);
                  this.access = (0, _utils.getStringOption)(attributes.access, ["open", "nonInteractive", "protected", "readOnly"]);
                  this.allowMacro = (0, _utils.getInteger)({
                    data: attributes.allowMacro,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.anchorType = (0, _utils.getStringOption)(attributes.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
                  this.colSpan = (0, _utils.getInteger)({
                    data: attributes.colSpan,
                    defaultValue: 1,
                    validate: (n) => n >= 1 || n === -1
                  });
                  this.columnWidths = (attributes.columnWidths || "").trim().split(/\s+/).map((x) => x === "-1" ? -1 : (0, _utils.getMeasurement)(x));
                  this.h = attributes.h ? (0, _utils.getMeasurement)(attributes.h) : "";
                  this.hAlign = (0, _utils.getStringOption)(attributes.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
                  this.id = attributes.id || "";
                  this.layout = (0, _utils.getStringOption)(attributes.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]);
                  this.locale = attributes.locale || "";
                  this.maxH = (0, _utils.getMeasurement)(attributes.maxH, "0pt");
                  this.maxW = (0, _utils.getMeasurement)(attributes.maxW, "0pt");
                  this.mergeMode = (0, _utils.getStringOption)(attributes.mergeMode, ["consumeData", "matchTemplate"]);
                  this.minH = (0, _utils.getMeasurement)(attributes.minH, "0pt");
                  this.minW = (0, _utils.getMeasurement)(attributes.minW, "0pt");
                  this.name = attributes.name || "";
                  this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
                  this.relevant = (0, _utils.getRelevant)(attributes.relevant);
                  this.restoreState = (0, _utils.getStringOption)(attributes.restoreState, ["manual", "auto"]);
                  this.scope = (0, _utils.getStringOption)(attributes.scope, ["name", "none"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.w = attributes.w ? (0, _utils.getMeasurement)(attributes.w) : "";
                  this.x = (0, _utils.getMeasurement)(attributes.x, "0pt");
                  this.y = (0, _utils.getMeasurement)(attributes.y, "0pt");
                  this.assist = null;
                  this.bind = null;
                  this.bookend = null;
                  this.border = null;
                  this.break = null;
                  this.calculate = null;
                  this.desc = null;
                  this.extras = null;
                  this.keep = null;
                  this.margin = null;
                  this.occur = null;
                  this.overflow = null;
                  this.pageSet = null;
                  this.para = null;
                  this.traversal = null;
                  this.validate = null;
                  this.variables = null;
                  this.area = new _xfa_object.XFAObjectArray();
                  this.breakAfter = new _xfa_object.XFAObjectArray();
                  this.breakBefore = new _xfa_object.XFAObjectArray();
                  this.connect = new _xfa_object.XFAObjectArray();
                  this.draw = new _xfa_object.XFAObjectArray();
                  this.event = new _xfa_object.XFAObjectArray();
                  this.exObject = new _xfa_object.XFAObjectArray();
                  this.exclGroup = new _xfa_object.XFAObjectArray();
                  this.field = new _xfa_object.XFAObjectArray();
                  this.proto = new _xfa_object.XFAObjectArray();
                  this.setProperty = new _xfa_object.XFAObjectArray();
                  this.subform = new _xfa_object.XFAObjectArray();
                  this.subformSet = new _xfa_object.XFAObjectArray();
                }
                [_xfa_object.$getSubformParent]() {
                  const parent = this[_xfa_object.$getParent]();
                  if (parent instanceof SubformSet) {
                    return parent[_xfa_object.$getSubformParent]();
                  }
                  return parent;
                }
                [_xfa_object.$isBindable]() {
                  return true;
                }
                [_xfa_object.$isThereMoreWidth]() {
                  return this.layout.endsWith("-tb") && this[_xfa_object.$extra].attempt === 0 && this[_xfa_object.$extra].numberInLine > 0 || this[_xfa_object.$getParent]()[_xfa_object.$isThereMoreWidth]();
                }
                *[_xfa_object.$getContainedChildren]() {
                  yield* getContainedChildren(this);
                }
                [_xfa_object.$flushHTML]() {
                  return (0, _layout.flushHTML)(this);
                }
                [_xfa_object.$addHTML](html, bbox) {
                  (0, _layout.addHTML)(this, html, bbox);
                }
                [_xfa_object.$getAvailableSpace]() {
                  return (0, _layout.getAvailableSpace)(this);
                }
                [_xfa_object.$isSplittable]() {
                  const parent = this[_xfa_object.$getSubformParent]();
                  if (!parent[_xfa_object.$isSplittable]()) {
                    return false;
                  }
                  if (this[_xfa_object.$extra]._isSplittable !== void 0) {
                    return this[_xfa_object.$extra]._isSplittable;
                  }
                  if (this.layout === "position" || this.layout.includes("row")) {
                    this[_xfa_object.$extra]._isSplittable = false;
                    return false;
                  }
                  if (this.keep && this.keep.intact !== "none") {
                    this[_xfa_object.$extra]._isSplittable = false;
                    return false;
                  }
                  if (parent.layout && parent.layout.endsWith("-tb") && parent[_xfa_object.$extra].numberInLine !== 0) {
                    return false;
                  }
                  this[_xfa_object.$extra]._isSplittable = true;
                  return true;
                }
                [_xfa_object.$toHTML](availableSpace) {
                  setTabIndex(this);
                  if (this.break) {
                    if (this.break.after !== "auto" || this.break.afterTarget !== "") {
                      const node = new BreakAfter({
                        targetType: this.break.after,
                        target: this.break.afterTarget,
                        startNew: this.break.startNew.toString()
                      });
                      node[_xfa_object.$globalData] = this[_xfa_object.$globalData];
                      this[_xfa_object.$appendChild](node);
                      this.breakAfter.push(node);
                    }
                    if (this.break.before !== "auto" || this.break.beforeTarget !== "") {
                      const node = new BreakBefore({
                        targetType: this.break.before,
                        target: this.break.beforeTarget,
                        startNew: this.break.startNew.toString()
                      });
                      node[_xfa_object.$globalData] = this[_xfa_object.$globalData];
                      this[_xfa_object.$appendChild](node);
                      this.breakBefore.push(node);
                    }
                    if (this.break.overflowTarget !== "") {
                      const node = new Overflow({
                        target: this.break.overflowTarget,
                        leader: this.break.overflowLeader,
                        trailer: this.break.overflowTrailer
                      });
                      node[_xfa_object.$globalData] = this[_xfa_object.$globalData];
                      this[_xfa_object.$appendChild](node);
                      this.overflow.push(node);
                    }
                    this[_xfa_object.$removeChild](this.break);
                    this.break = null;
                  }
                  if (this.presence === "hidden" || this.presence === "inactive") {
                    return _utils.HTMLResult.EMPTY;
                  }
                  if (this.breakBefore.children.length > 1 || this.breakAfter.children.length > 1) {
                    (0, _util.warn)("XFA - Several breakBefore or breakAfter in subforms: please file a bug.");
                  }
                  if (this.breakBefore.children.length >= 1) {
                    const breakBefore = this.breakBefore.children[0];
                    if (handleBreak(breakBefore)) {
                      return _utils.HTMLResult.breakNode(breakBefore);
                    }
                  }
                  if (this[_xfa_object.$extra] && this[_xfa_object.$extra].afterBreakAfter) {
                    return _utils.HTMLResult.EMPTY;
                  }
                  (0, _html_utils.fixDimensions)(this);
                  const children = [];
                  const attributes = {
                    id: this[_xfa_object.$uid],
                    class: []
                  };
                  (0, _html_utils.setAccess)(this, attributes.class);
                  if (!this[_xfa_object.$extra]) {
                    this[_xfa_object.$extra] = /* @__PURE__ */ Object.create(null);
                  }
                  Object.assign(this[_xfa_object.$extra], {
                    children,
                    line: null,
                    attributes,
                    attempt: 0,
                    numberInLine: 0,
                    availableSpace: {
                      width: Math.min(this.w || Infinity, availableSpace.width),
                      height: Math.min(this.h || Infinity, availableSpace.height)
                    },
                    width: 0,
                    height: 0,
                    prevHeight: 0,
                    currentWidth: 0
                  });
                  const root = this[_xfa_object.$getTemplateRoot]();
                  const savedNoLayoutFailure = root[_xfa_object.$extra].noLayoutFailure;
                  const isSplittable = this[_xfa_object.$isSplittable]();
                  if (!isSplittable) {
                    setFirstUnsplittable(this);
                  }
                  if (!(0, _layout.checkDimensions)(this, availableSpace)) {
                    return _utils.HTMLResult.FAILURE;
                  }
                  const filter = /* @__PURE__ */ new Set(["area", "draw", "exclGroup", "field", "subform", "subformSet"]);
                  if (this.layout.includes("row")) {
                    const columnWidths = this[_xfa_object.$getSubformParent]().columnWidths;
                    if (Array.isArray(columnWidths) && columnWidths.length > 0) {
                      this[_xfa_object.$extra].columnWidths = columnWidths;
                      this[_xfa_object.$extra].currentColumn = 0;
                    }
                  }
                  const style = (0, _html_utils.toStyle)(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign");
                  const classNames = ["xfaSubform"];
                  const cl = (0, _html_utils.layoutClass)(this);
                  if (cl) {
                    classNames.push(cl);
                  }
                  attributes.style = style;
                  attributes.class = classNames;
                  if (this.name) {
                    attributes.xfaName = this.name;
                  }
                  if (this.overflow) {
                    const overflowExtra = this.overflow[_xfa_object.$getExtra]();
                    if (overflowExtra.addLeader) {
                      overflowExtra.addLeader = false;
                      handleOverflow(this, overflowExtra.leader, availableSpace);
                    }
                  }
                  this[_xfa_object.$pushPara]();
                  const isLrTb = this.layout === "lr-tb" || this.layout === "rl-tb";
                  const maxRun = isLrTb ? MAX_ATTEMPTS_FOR_LRTB_LAYOUT : 1;
                  for (; this[_xfa_object.$extra].attempt < maxRun; this[_xfa_object.$extra].attempt++) {
                    if (isLrTb && this[_xfa_object.$extra].attempt === MAX_ATTEMPTS_FOR_LRTB_LAYOUT - 1) {
                      this[_xfa_object.$extra].numberInLine = 0;
                    }
                    const result2 = this[_xfa_object.$childrenToHTML]({
                      filter,
                      include: true
                    });
                    if (result2.success) {
                      break;
                    }
                    if (result2.isBreak()) {
                      this[_xfa_object.$popPara]();
                      return result2;
                    }
                    if (isLrTb && this[_xfa_object.$extra].attempt === 0 && this[_xfa_object.$extra].numberInLine === 0 && !root[_xfa_object.$extra].noLayoutFailure) {
                      this[_xfa_object.$extra].attempt = maxRun;
                      break;
                    }
                  }
                  this[_xfa_object.$popPara]();
                  if (!isSplittable) {
                    unsetFirstUnsplittable(this);
                  }
                  root[_xfa_object.$extra].noLayoutFailure = savedNoLayoutFailure;
                  if (this[_xfa_object.$extra].attempt === maxRun) {
                    if (this.overflow) {
                      this[_xfa_object.$getTemplateRoot]()[_xfa_object.$extra].overflowNode = this.overflow;
                    }
                    if (!isSplittable) {
                      delete this[_xfa_object.$extra];
                    }
                    return _utils.HTMLResult.FAILURE;
                  }
                  if (this.overflow) {
                    const overflowExtra = this.overflow[_xfa_object.$getExtra]();
                    if (overflowExtra.addTrailer) {
                      overflowExtra.addTrailer = false;
                      handleOverflow(this, overflowExtra.trailer, availableSpace);
                    }
                  }
                  let marginH = 0;
                  let marginV = 0;
                  if (this.margin) {
                    marginH = this.margin.leftInset + this.margin.rightInset;
                    marginV = this.margin.topInset + this.margin.bottomInset;
                  }
                  const width = Math.max(this[_xfa_object.$extra].width + marginH, this.w || 0);
                  const height = Math.max(this[_xfa_object.$extra].height + marginV, this.h || 0);
                  const bbox = [this.x, this.y, width, height];
                  if (this.w === "") {
                    style.width = (0, _html_utils.measureToString)(width);
                  }
                  if (this.h === "") {
                    style.height = (0, _html_utils.measureToString)(height);
                  }
                  if ((style.width === "0px" || style.height === "0px") && children.length === 0) {
                    return _utils.HTMLResult.EMPTY;
                  }
                  const html = {
                    name: "div",
                    attributes,
                    children
                  };
                  applyAssist(this, attributes);
                  const result = _utils.HTMLResult.success((0, _html_utils.createWrapper)(this, html), bbox);
                  if (this.breakAfter.children.length >= 1) {
                    const breakAfter = this.breakAfter.children[0];
                    if (handleBreak(breakAfter)) {
                      this[_xfa_object.$extra].afterBreakAfter = result;
                      return _utils.HTMLResult.breakNode(breakAfter);
                    }
                  }
                  delete this[_xfa_object.$extra];
                  return result;
                }
              };
              __name(_Subform, "Subform");
              let Subform = _Subform;
              const _SubformSet = class _SubformSet extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "subformSet", true);
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.relation = (0, _utils.getStringOption)(attributes.relation, ["ordered", "choice", "unordered"]);
                  this.relevant = (0, _utils.getRelevant)(attributes.relevant);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.bookend = null;
                  this.break = null;
                  this.desc = null;
                  this.extras = null;
                  this.occur = null;
                  this.overflow = null;
                  this.breakAfter = new _xfa_object.XFAObjectArray();
                  this.breakBefore = new _xfa_object.XFAObjectArray();
                  this.subform = new _xfa_object.XFAObjectArray();
                  this.subformSet = new _xfa_object.XFAObjectArray();
                }
                *[_xfa_object.$getContainedChildren]() {
                  yield* getContainedChildren(this);
                }
                [_xfa_object.$getSubformParent]() {
                  let parent = this[_xfa_object.$getParent]();
                  while (!(parent instanceof Subform)) {
                    parent = parent[_xfa_object.$getParent]();
                  }
                  return parent;
                }
                [_xfa_object.$isBindable]() {
                  return true;
                }
              };
              __name(_SubformSet, "SubformSet");
              let SubformSet = _SubformSet;
              const _SubjectDN = class _SubjectDN extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "subjectDN");
                  this.delimiter = attributes.delimiter || ",";
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
                [_xfa_object.$finalize]() {
                  this[_xfa_object.$content] = new Map(this[_xfa_object.$content].split(this.delimiter).map((kv) => {
                    kv = kv.split("=", 2);
                    kv[0] = kv[0].trim();
                    return kv;
                  }));
                }
              };
              __name(_SubjectDN, "SubjectDN");
              let SubjectDN = _SubjectDN;
              const _SubjectDNs = class _SubjectDNs extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "subjectDNs", true);
                  this.id = attributes.id || "";
                  this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.subjectDN = new _xfa_object.XFAObjectArray();
                }
              };
              __name(_SubjectDNs, "SubjectDNs");
              let SubjectDNs = _SubjectDNs;
              const _Submit = class _Submit extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "submit", true);
                  this.embedPDF = (0, _utils.getInteger)({
                    data: attributes.embedPDF,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.format = (0, _utils.getStringOption)(attributes.format, ["xdp", "formdata", "pdf", "urlencoded", "xfd", "xml"]);
                  this.id = attributes.id || "";
                  this.target = attributes.target || "";
                  this.textEncoding = (0, _utils.getKeyword)({
                    data: attributes.textEncoding ? attributes.textEncoding.toLowerCase() : "",
                    defaultValue: "",
                    validate: (k) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(k) || k.match(/iso-8859-\d{2}/)
                  });
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.xdpContent = attributes.xdpContent || "";
                  this.encrypt = null;
                  this.encryptData = new _xfa_object.XFAObjectArray();
                  this.signData = new _xfa_object.XFAObjectArray();
                }
              };
              __name(_Submit, "Submit");
              let Submit = _Submit;
              const _Template = class _Template extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "template", true);
                  this.baseProfile = (0, _utils.getStringOption)(attributes.baseProfile, ["full", "interactiveForms"]);
                  this.extras = null;
                  this.subform = new _xfa_object.XFAObjectArray();
                }
                [_xfa_object.$finalize]() {
                  if (this.subform.children.length === 0) {
                    (0, _util.warn)("XFA - No subforms in template node.");
                  }
                  if (this.subform.children.length >= 2) {
                    (0, _util.warn)("XFA - Several subforms in template node: please file a bug.");
                  }
                  this[_xfa_object.$tabIndex] = DEFAULT_TAB_INDEX;
                }
                [_xfa_object.$isSplittable]() {
                  return true;
                }
                [_xfa_object.$searchNode](expr, container) {
                  if (expr.startsWith("#")) {
                    return [this[_xfa_object.$ids].get(expr.slice(1))];
                  }
                  return (0, _som.searchNode)(this, container, expr, true, true);
                }
                *[_xfa_object.$toPages]() {
                  if (!this.subform.children.length) {
                    return _utils.HTMLResult.success({
                      name: "div",
                      children: []
                    });
                  }
                  this[_xfa_object.$extra] = {
                    overflowNode: null,
                    firstUnsplittable: null,
                    currentContentArea: null,
                    currentPageArea: null,
                    noLayoutFailure: false,
                    pageNumber: 1,
                    pagePosition: "first",
                    oddOrEven: "odd",
                    blankOrNotBlank: "nonBlank",
                    paraStack: []
                  };
                  const root = this.subform.children[0];
                  root.pageSet[_xfa_object.$cleanPage]();
                  const pageAreas = root.pageSet.pageArea.children;
                  const mainHtml = {
                    name: "div",
                    children: []
                  };
                  let pageArea = null;
                  let breakBefore = null;
                  let breakBeforeTarget = null;
                  if (root.breakBefore.children.length >= 1) {
                    breakBefore = root.breakBefore.children[0];
                    breakBeforeTarget = breakBefore.target;
                  } else if (root.subform.children.length >= 1 && root.subform.children[0].breakBefore.children.length >= 1) {
                    breakBefore = root.subform.children[0].breakBefore.children[0];
                    breakBeforeTarget = breakBefore.target;
                  } else if (root.break && root.break.beforeTarget) {
                    breakBefore = root.break;
                    breakBeforeTarget = breakBefore.beforeTarget;
                  } else if (root.subform.children.length >= 1 && root.subform.children[0].break && root.subform.children[0].break.beforeTarget) {
                    breakBefore = root.subform.children[0].break;
                    breakBeforeTarget = breakBefore.beforeTarget;
                  }
                  if (breakBefore) {
                    const target = this[_xfa_object.$searchNode](breakBeforeTarget, breakBefore[_xfa_object.$getParent]());
                    if (target instanceof PageArea) {
                      pageArea = target;
                      breakBefore[_xfa_object.$extra] = {};
                    }
                  }
                  if (!pageArea) {
                    pageArea = pageAreas[0];
                  }
                  pageArea[_xfa_object.$extra] = {
                    numberOfUse: 1
                  };
                  const pageAreaParent = pageArea[_xfa_object.$getParent]();
                  pageAreaParent[_xfa_object.$extra] = {
                    numberOfUse: 1,
                    pageIndex: pageAreaParent.pageArea.children.indexOf(pageArea),
                    pageSetIndex: 0
                  };
                  let targetPageArea;
                  let leader = null;
                  let trailer = null;
                  let hasSomething = true;
                  let hasSomethingCounter = 0;
                  let startIndex = 0;
                  while (true) {
                    if (!hasSomething) {
                      mainHtml.children.pop();
                      if (++hasSomethingCounter === MAX_EMPTY_PAGES) {
                        (0, _util.warn)("XFA - Something goes wrong: please file a bug.");
                        return mainHtml;
                      }
                    } else {
                      hasSomethingCounter = 0;
                    }
                    targetPageArea = null;
                    this[_xfa_object.$extra].currentPageArea = pageArea;
                    const page = pageArea[_xfa_object.$toHTML]().html;
                    mainHtml.children.push(page);
                    if (leader) {
                      this[_xfa_object.$extra].noLayoutFailure = true;
                      page.children.push(leader[_xfa_object.$toHTML](pageArea[_xfa_object.$extra].space).html);
                      leader = null;
                    }
                    if (trailer) {
                      this[_xfa_object.$extra].noLayoutFailure = true;
                      page.children.push(trailer[_xfa_object.$toHTML](pageArea[_xfa_object.$extra].space).html);
                      trailer = null;
                    }
                    const contentAreas = pageArea.contentArea.children;
                    const htmlContentAreas = page.children.filter((node) => node.attributes.class.includes("xfaContentarea"));
                    hasSomething = false;
                    this[_xfa_object.$extra].firstUnsplittable = null;
                    this[_xfa_object.$extra].noLayoutFailure = false;
                    const flush = /* @__PURE__ */ __name((index) => {
                      const html = root[_xfa_object.$flushHTML]();
                      if (html) {
                        hasSomething = hasSomething || html.children && html.children.length !== 0;
                        htmlContentAreas[index].children.push(html);
                      }
                    }, "flush");
                    for (let i = startIndex, ii = contentAreas.length; i < ii; i++) {
                      const contentArea = this[_xfa_object.$extra].currentContentArea = contentAreas[i];
                      const space = {
                        width: contentArea.w,
                        height: contentArea.h
                      };
                      startIndex = 0;
                      if (leader) {
                        htmlContentAreas[i].children.push(leader[_xfa_object.$toHTML](space).html);
                        leader = null;
                      }
                      if (trailer) {
                        htmlContentAreas[i].children.push(trailer[_xfa_object.$toHTML](space).html);
                        trailer = null;
                      }
                      const html = root[_xfa_object.$toHTML](space);
                      if (html.success) {
                        if (html.html) {
                          hasSomething = hasSomething || html.html.children && html.html.children.length !== 0;
                          htmlContentAreas[i].children.push(html.html);
                        } else if (!hasSomething && mainHtml.children.length > 1) {
                          mainHtml.children.pop();
                        }
                        return mainHtml;
                      }
                      if (html.isBreak()) {
                        const node = html.breakNode;
                        flush(i);
                        if (node.targetType === "auto") {
                          continue;
                        }
                        if (node.leader) {
                          leader = this[_xfa_object.$searchNode](node.leader, node[_xfa_object.$getParent]());
                          leader = leader ? leader[0] : null;
                        }
                        if (node.trailer) {
                          trailer = this[_xfa_object.$searchNode](node.trailer, node[_xfa_object.$getParent]());
                          trailer = trailer ? trailer[0] : null;
                        }
                        if (node.targetType === "pageArea") {
                          targetPageArea = node[_xfa_object.$extra].target;
                          i = Infinity;
                        } else if (!node[_xfa_object.$extra].target) {
                          i = node[_xfa_object.$extra].index;
                        } else {
                          targetPageArea = node[_xfa_object.$extra].target;
                          startIndex = node[_xfa_object.$extra].index + 1;
                          i = Infinity;
                        }
                        continue;
                      }
                      if (this[_xfa_object.$extra].overflowNode) {
                        const node = this[_xfa_object.$extra].overflowNode;
                        this[_xfa_object.$extra].overflowNode = null;
                        const overflowExtra = node[_xfa_object.$getExtra]();
                        const target = overflowExtra.target;
                        overflowExtra.addLeader = overflowExtra.leader !== null;
                        overflowExtra.addTrailer = overflowExtra.trailer !== null;
                        flush(i);
                        const currentIndex = i;
                        i = Infinity;
                        if (target instanceof PageArea) {
                          targetPageArea = target;
                        } else if (target instanceof ContentArea) {
                          const index = contentAreas.indexOf(target);
                          if (index !== -1) {
                            if (index > currentIndex) {
                              i = index - 1;
                            } else {
                              startIndex = index;
                            }
                          } else {
                            targetPageArea = target[_xfa_object.$getParent]();
                            startIndex = targetPageArea.contentArea.children.indexOf(target);
                          }
                        }
                        continue;
                      }
                      flush(i);
                    }
                    this[_xfa_object.$extra].pageNumber += 1;
                    if (targetPageArea) {
                      if (targetPageArea[_xfa_object.$isUsable]()) {
                        targetPageArea[_xfa_object.$extra].numberOfUse += 1;
                      } else {
                        targetPageArea = null;
                      }
                    }
                    pageArea = targetPageArea || pageArea[_xfa_object.$getNextPage]();
                    yield null;
                  }
                }
              };
              __name(_Template, "Template");
              let Template = _Template;
              exports2.Template = Template;
              const _Text = class _Text extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "text");
                  this.id = attributes.id || "";
                  this.maxChars = (0, _utils.getInteger)({
                    data: attributes.maxChars,
                    defaultValue: 0,
                    validate: (x) => x >= 0
                  });
                  this.name = attributes.name || "";
                  this.rid = attributes.rid || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
                [_xfa_object.$acceptWhitespace]() {
                  return true;
                }
                [_xfa_object.$onChild](child) {
                  if (child[_xfa_object.$namespaceId] === _namespaces.NamespaceIds.xhtml.id) {
                    this[_xfa_object.$content] = child;
                    return true;
                  }
                  (0, _util.warn)(`XFA - Invalid content in Text: ${child[_xfa_object.$nodeName]}.`);
                  return false;
                }
                [_xfa_object.$onText](str) {
                  if (this[_xfa_object.$content] instanceof _xfa_object.XFAObject) {
                    return;
                  }
                  super[_xfa_object.$onText](str);
                }
                [_xfa_object.$finalize]() {
                  if (typeof this[_xfa_object.$content] === "string") {
                    this[_xfa_object.$content] = this[_xfa_object.$content].replace(/\r\n/g, "\n");
                  }
                }
                [_xfa_object.$getExtra]() {
                  if (typeof this[_xfa_object.$content] === "string") {
                    return this[_xfa_object.$content].split(/[\u2029\u2028\n]/).reduce((acc, line) => {
                      if (line) {
                        acc.push(line);
                      }
                      return acc;
                    }, []).join("\n");
                  }
                  return this[_xfa_object.$content][_xfa_object.$text]();
                }
                [_xfa_object.$toHTML](availableSpace) {
                  if (typeof this[_xfa_object.$content] === "string") {
                    const html = valueToHtml(this[_xfa_object.$content]).html;
                    if (this[_xfa_object.$content].includes("\u2029")) {
                      html.name = "div";
                      html.children = [];
                      this[_xfa_object.$content].split("\u2029").map((para) => para.split(/[\u2028\n]/).reduce((acc, line) => {
                        acc.push({
                          name: "span",
                          value: line
                        }, {
                          name: "br"
                        });
                        return acc;
                      }, [])).forEach((lines) => {
                        html.children.push({
                          name: "p",
                          children: lines
                        });
                      });
                    } else if (/[\u2028\n]/.test(this[_xfa_object.$content])) {
                      html.name = "div";
                      html.children = [];
                      this[_xfa_object.$content].split(/[\u2028\n]/).forEach((line) => {
                        html.children.push({
                          name: "span",
                          value: line
                        }, {
                          name: "br"
                        });
                      });
                    }
                    return _utils.HTMLResult.success(html);
                  }
                  return this[_xfa_object.$content][_xfa_object.$toHTML](availableSpace);
                }
              };
              __name(_Text, "Text");
              let Text = _Text;
              exports2.Text = Text;
              const _TextEdit = class _TextEdit extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "textEdit", true);
                  this.allowRichText = (0, _utils.getInteger)({
                    data: attributes.allowRichText,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.hScrollPolicy = (0, _utils.getStringOption)(attributes.hScrollPolicy, ["auto", "off", "on"]);
                  this.id = attributes.id || "";
                  this.multiLine = (0, _utils.getInteger)({
                    data: attributes.multiLine,
                    defaultValue: "",
                    validate: (x) => x === 0 || x === 1
                  });
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.vScrollPolicy = (0, _utils.getStringOption)(attributes.vScrollPolicy, ["auto", "off", "on"]);
                  this.border = null;
                  this.comb = null;
                  this.extras = null;
                  this.margin = null;
                }
                [_xfa_object.$toHTML](availableSpace) {
                  const style = (0, _html_utils.toStyle)(this, "border", "font", "margin");
                  let html;
                  const field = this[_xfa_object.$getParent]()[_xfa_object.$getParent]();
                  if (this.multiLine === "") {
                    this.multiLine = field instanceof Draw ? 1 : 0;
                  }
                  if (this.multiLine === 1) {
                    html = {
                      name: "textarea",
                      attributes: {
                        dataId: field[_xfa_object.$data] && field[_xfa_object.$data][_xfa_object.$uid] || field[_xfa_object.$uid],
                        fieldId: field[_xfa_object.$uid],
                        class: ["xfaTextfield"],
                        style,
                        "aria-label": ariaLabel(field),
                        "aria-required": false
                      }
                    };
                  } else {
                    html = {
                      name: "input",
                      attributes: {
                        type: "text",
                        dataId: field[_xfa_object.$data] && field[_xfa_object.$data][_xfa_object.$uid] || field[_xfa_object.$uid],
                        fieldId: field[_xfa_object.$uid],
                        class: ["xfaTextfield"],
                        style,
                        "aria-label": ariaLabel(field),
                        "aria-required": false
                      }
                    };
                  }
                  if (isRequired(field)) {
                    html.attributes["aria-required"] = true;
                    html.attributes.required = true;
                  }
                  return _utils.HTMLResult.success({
                    name: "label",
                    attributes: {
                      class: ["xfaLabel"]
                    },
                    children: [html]
                  });
                }
              };
              __name(_TextEdit, "TextEdit");
              let TextEdit = _TextEdit;
              const _Time = class _Time extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "time");
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
                [_xfa_object.$finalize]() {
                  const date = this[_xfa_object.$content].trim();
                  this[_xfa_object.$content] = date ? new Date(date) : null;
                }
                [_xfa_object.$toHTML](availableSpace) {
                  return valueToHtml(this[_xfa_object.$content] ? this[_xfa_object.$content].toString() : "");
                }
              };
              __name(_Time, "Time");
              let Time = _Time;
              const _TimeStamp = class _TimeStamp extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "timeStamp");
                  this.id = attributes.id || "";
                  this.server = attributes.server || "";
                  this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              };
              __name(_TimeStamp, "TimeStamp");
              let TimeStamp = _TimeStamp;
              const _ToolTip = class _ToolTip extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "toolTip");
                  this.id = attributes.id || "";
                  this.rid = attributes.rid || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              };
              __name(_ToolTip, "ToolTip");
              let ToolTip = _ToolTip;
              const _Traversal = class _Traversal extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "traversal", true);
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.extras = null;
                  this.traverse = new _xfa_object.XFAObjectArray();
                }
              };
              __name(_Traversal, "Traversal");
              let Traversal = _Traversal;
              const _Traverse = class _Traverse extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "traverse", true);
                  this.id = attributes.id || "";
                  this.operation = (0, _utils.getStringOption)(attributes.operation, ["next", "back", "down", "first", "left", "right", "up"]);
                  this.ref = attributes.ref || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.extras = null;
                  this.script = null;
                }
                get name() {
                  return this.operation;
                }
                [_xfa_object.$isTransparent]() {
                  return false;
                }
              };
              __name(_Traverse, "Traverse");
              let Traverse = _Traverse;
              const _Ui = class _Ui extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "ui", true);
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.extras = null;
                  this.picture = null;
                  this.barcode = null;
                  this.button = null;
                  this.checkButton = null;
                  this.choiceList = null;
                  this.dateTimeEdit = null;
                  this.defaultUi = null;
                  this.imageEdit = null;
                  this.numericEdit = null;
                  this.passwordEdit = null;
                  this.signature = null;
                  this.textEdit = null;
                }
                [_xfa_object.$getExtra]() {
                  if (this[_xfa_object.$extra] === void 0) {
                    for (const name of Object.getOwnPropertyNames(this)) {
                      if (name === "extras" || name === "picture") {
                        continue;
                      }
                      const obj = this[name];
                      if (!(obj instanceof _xfa_object.XFAObject)) {
                        continue;
                      }
                      this[_xfa_object.$extra] = obj;
                      return obj;
                    }
                    this[_xfa_object.$extra] = null;
                  }
                  return this[_xfa_object.$extra];
                }
                [_xfa_object.$toHTML](availableSpace) {
                  const obj = this[_xfa_object.$getExtra]();
                  if (obj) {
                    return obj[_xfa_object.$toHTML](availableSpace);
                  }
                  return _utils.HTMLResult.EMPTY;
                }
              };
              __name(_Ui, "Ui");
              let Ui = _Ui;
              const _Validate = class _Validate extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "validate", true);
                  this.formatTest = (0, _utils.getStringOption)(attributes.formatTest, ["warning", "disabled", "error"]);
                  this.id = attributes.id || "";
                  this.nullTest = (0, _utils.getStringOption)(attributes.nullTest, ["disabled", "error", "warning"]);
                  this.scriptTest = (0, _utils.getStringOption)(attributes.scriptTest, ["error", "disabled", "warning"]);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.extras = null;
                  this.message = null;
                  this.picture = null;
                  this.script = null;
                }
              };
              __name(_Validate, "Validate");
              let Validate = _Validate;
              const _Value = class _Value extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "value", true);
                  this.id = attributes.id || "";
                  this.override = (0, _utils.getInteger)({
                    data: attributes.override,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.relevant = (0, _utils.getRelevant)(attributes.relevant);
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.arc = null;
                  this.boolean = null;
                  this.date = null;
                  this.dateTime = null;
                  this.decimal = null;
                  this.exData = null;
                  this.float = null;
                  this.image = null;
                  this.integer = null;
                  this.line = null;
                  this.rectangle = null;
                  this.text = null;
                  this.time = null;
                }
                [_xfa_object.$setValue](value) {
                  const parent = this[_xfa_object.$getParent]();
                  if (parent instanceof Field) {
                    if (parent.ui && parent.ui.imageEdit) {
                      if (!this.image) {
                        this.image = new Image({});
                        this[_xfa_object.$appendChild](this.image);
                      }
                      this.image[_xfa_object.$content] = value[_xfa_object.$content];
                      return;
                    }
                  }
                  const valueName = value[_xfa_object.$nodeName];
                  if (this[valueName] !== null) {
                    this[valueName][_xfa_object.$content] = value[_xfa_object.$content];
                    return;
                  }
                  for (const name of Object.getOwnPropertyNames(this)) {
                    const obj = this[name];
                    if (obj instanceof _xfa_object.XFAObject) {
                      this[name] = null;
                      this[_xfa_object.$removeChild](obj);
                    }
                  }
                  this[value[_xfa_object.$nodeName]] = value;
                  this[_xfa_object.$appendChild](value);
                }
                [_xfa_object.$text]() {
                  if (this.exData) {
                    if (typeof this.exData[_xfa_object.$content] === "string") {
                      return this.exData[_xfa_object.$content].trim();
                    }
                    return this.exData[_xfa_object.$content][_xfa_object.$text]().trim();
                  }
                  for (const name of Object.getOwnPropertyNames(this)) {
                    if (name === "image") {
                      continue;
                    }
                    const obj = this[name];
                    if (obj instanceof _xfa_object.XFAObject) {
                      return (obj[_xfa_object.$content] || "").toString().trim();
                    }
                  }
                  return null;
                }
                [_xfa_object.$toHTML](availableSpace) {
                  for (const name of Object.getOwnPropertyNames(this)) {
                    const obj = this[name];
                    if (!(obj instanceof _xfa_object.XFAObject)) {
                      continue;
                    }
                    return obj[_xfa_object.$toHTML](availableSpace);
                  }
                  return _utils.HTMLResult.EMPTY;
                }
              };
              __name(_Value, "Value");
              let Value = _Value;
              exports2.Value = Value;
              const _Variables = class _Variables extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(TEMPLATE_NS_ID, "variables", true);
                  this.id = attributes.id || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                  this.boolean = new _xfa_object.XFAObjectArray();
                  this.date = new _xfa_object.XFAObjectArray();
                  this.dateTime = new _xfa_object.XFAObjectArray();
                  this.decimal = new _xfa_object.XFAObjectArray();
                  this.exData = new _xfa_object.XFAObjectArray();
                  this.float = new _xfa_object.XFAObjectArray();
                  this.image = new _xfa_object.XFAObjectArray();
                  this.integer = new _xfa_object.XFAObjectArray();
                  this.manifest = new _xfa_object.XFAObjectArray();
                  this.script = new _xfa_object.XFAObjectArray();
                  this.text = new _xfa_object.XFAObjectArray();
                  this.time = new _xfa_object.XFAObjectArray();
                }
                [_xfa_object.$isTransparent]() {
                  return true;
                }
              };
              __name(_Variables, "Variables");
              let Variables = _Variables;
              const _TemplateNamespace = class _TemplateNamespace {
                static [_namespaces.$buildXFAObject](name, attributes) {
                  if (_TemplateNamespace.hasOwnProperty(name)) {
                    const node = _TemplateNamespace[name](attributes);
                    node[_xfa_object.$setSetAttributes](attributes);
                    return node;
                  }
                  return void 0;
                }
                static appearanceFilter(attrs) {
                  return new AppearanceFilter(attrs);
                }
                static arc(attrs) {
                  return new Arc(attrs);
                }
                static area(attrs) {
                  return new Area(attrs);
                }
                static assist(attrs) {
                  return new Assist(attrs);
                }
                static barcode(attrs) {
                  return new Barcode(attrs);
                }
                static bind(attrs) {
                  return new Bind(attrs);
                }
                static bindItems(attrs) {
                  return new BindItems(attrs);
                }
                static bookend(attrs) {
                  return new Bookend(attrs);
                }
                static boolean(attrs) {
                  return new BooleanElement(attrs);
                }
                static border(attrs) {
                  return new Border(attrs);
                }
                static break(attrs) {
                  return new Break(attrs);
                }
                static breakAfter(attrs) {
                  return new BreakAfter(attrs);
                }
                static breakBefore(attrs) {
                  return new BreakBefore(attrs);
                }
                static button(attrs) {
                  return new Button(attrs);
                }
                static calculate(attrs) {
                  return new Calculate(attrs);
                }
                static caption(attrs) {
                  return new Caption(attrs);
                }
                static certificate(attrs) {
                  return new Certificate(attrs);
                }
                static certificates(attrs) {
                  return new Certificates(attrs);
                }
                static checkButton(attrs) {
                  return new CheckButton(attrs);
                }
                static choiceList(attrs) {
                  return new ChoiceList(attrs);
                }
                static color(attrs) {
                  return new Color(attrs);
                }
                static comb(attrs) {
                  return new Comb(attrs);
                }
                static connect(attrs) {
                  return new Connect(attrs);
                }
                static contentArea(attrs) {
                  return new ContentArea(attrs);
                }
                static corner(attrs) {
                  return new Corner(attrs);
                }
                static date(attrs) {
                  return new DateElement(attrs);
                }
                static dateTime(attrs) {
                  return new DateTime(attrs);
                }
                static dateTimeEdit(attrs) {
                  return new DateTimeEdit(attrs);
                }
                static decimal(attrs) {
                  return new Decimal(attrs);
                }
                static defaultUi(attrs) {
                  return new DefaultUi(attrs);
                }
                static desc(attrs) {
                  return new Desc(attrs);
                }
                static digestMethod(attrs) {
                  return new DigestMethod(attrs);
                }
                static digestMethods(attrs) {
                  return new DigestMethods(attrs);
                }
                static draw(attrs) {
                  return new Draw(attrs);
                }
                static edge(attrs) {
                  return new Edge(attrs);
                }
                static encoding(attrs) {
                  return new Encoding(attrs);
                }
                static encodings(attrs) {
                  return new Encodings(attrs);
                }
                static encrypt(attrs) {
                  return new Encrypt(attrs);
                }
                static encryptData(attrs) {
                  return new EncryptData(attrs);
                }
                static encryption(attrs) {
                  return new Encryption(attrs);
                }
                static encryptionMethod(attrs) {
                  return new EncryptionMethod(attrs);
                }
                static encryptionMethods(attrs) {
                  return new EncryptionMethods(attrs);
                }
                static event(attrs) {
                  return new Event(attrs);
                }
                static exData(attrs) {
                  return new ExData(attrs);
                }
                static exObject(attrs) {
                  return new ExObject(attrs);
                }
                static exclGroup(attrs) {
                  return new ExclGroup(attrs);
                }
                static execute(attrs) {
                  return new Execute(attrs);
                }
                static extras(attrs) {
                  return new Extras(attrs);
                }
                static field(attrs) {
                  return new Field(attrs);
                }
                static fill(attrs) {
                  return new Fill(attrs);
                }
                static filter(attrs) {
                  return new Filter(attrs);
                }
                static float(attrs) {
                  return new Float(attrs);
                }
                static font(attrs) {
                  return new Font(attrs);
                }
                static format(attrs) {
                  return new Format(attrs);
                }
                static handler(attrs) {
                  return new Handler(attrs);
                }
                static hyphenation(attrs) {
                  return new Hyphenation(attrs);
                }
                static image(attrs) {
                  return new Image(attrs);
                }
                static imageEdit(attrs) {
                  return new ImageEdit(attrs);
                }
                static integer(attrs) {
                  return new Integer(attrs);
                }
                static issuers(attrs) {
                  return new Issuers(attrs);
                }
                static items(attrs) {
                  return new Items(attrs);
                }
                static keep(attrs) {
                  return new Keep(attrs);
                }
                static keyUsage(attrs) {
                  return new KeyUsage(attrs);
                }
                static line(attrs) {
                  return new Line(attrs);
                }
                static linear(attrs) {
                  return new Linear(attrs);
                }
                static lockDocument(attrs) {
                  return new LockDocument(attrs);
                }
                static manifest(attrs) {
                  return new Manifest(attrs);
                }
                static margin(attrs) {
                  return new Margin(attrs);
                }
                static mdp(attrs) {
                  return new Mdp(attrs);
                }
                static medium(attrs) {
                  return new Medium(attrs);
                }
                static message(attrs) {
                  return new Message(attrs);
                }
                static numericEdit(attrs) {
                  return new NumericEdit(attrs);
                }
                static occur(attrs) {
                  return new Occur(attrs);
                }
                static oid(attrs) {
                  return new Oid(attrs);
                }
                static oids(attrs) {
                  return new Oids(attrs);
                }
                static overflow(attrs) {
                  return new Overflow(attrs);
                }
                static pageArea(attrs) {
                  return new PageArea(attrs);
                }
                static pageSet(attrs) {
                  return new PageSet(attrs);
                }
                static para(attrs) {
                  return new Para(attrs);
                }
                static passwordEdit(attrs) {
                  return new PasswordEdit(attrs);
                }
                static pattern(attrs) {
                  return new Pattern(attrs);
                }
                static picture(attrs) {
                  return new Picture(attrs);
                }
                static proto(attrs) {
                  return new Proto(attrs);
                }
                static radial(attrs) {
                  return new Radial(attrs);
                }
                static reason(attrs) {
                  return new Reason(attrs);
                }
                static reasons(attrs) {
                  return new Reasons(attrs);
                }
                static rectangle(attrs) {
                  return new Rectangle(attrs);
                }
                static ref(attrs) {
                  return new RefElement(attrs);
                }
                static script(attrs) {
                  return new Script(attrs);
                }
                static setProperty(attrs) {
                  return new SetProperty(attrs);
                }
                static signData(attrs) {
                  return new SignData(attrs);
                }
                static signature(attrs) {
                  return new Signature(attrs);
                }
                static signing(attrs) {
                  return new Signing(attrs);
                }
                static solid(attrs) {
                  return new Solid(attrs);
                }
                static speak(attrs) {
                  return new Speak(attrs);
                }
                static stipple(attrs) {
                  return new Stipple(attrs);
                }
                static subform(attrs) {
                  return new Subform(attrs);
                }
                static subformSet(attrs) {
                  return new SubformSet(attrs);
                }
                static subjectDN(attrs) {
                  return new SubjectDN(attrs);
                }
                static subjectDNs(attrs) {
                  return new SubjectDNs(attrs);
                }
                static submit(attrs) {
                  return new Submit(attrs);
                }
                static template(attrs) {
                  return new Template(attrs);
                }
                static text(attrs) {
                  return new Text(attrs);
                }
                static textEdit(attrs) {
                  return new TextEdit(attrs);
                }
                static time(attrs) {
                  return new Time(attrs);
                }
                static timeStamp(attrs) {
                  return new TimeStamp(attrs);
                }
                static toolTip(attrs) {
                  return new ToolTip(attrs);
                }
                static traversal(attrs) {
                  return new Traversal(attrs);
                }
                static traverse(attrs) {
                  return new Traverse(attrs);
                }
                static ui(attrs) {
                  return new Ui(attrs);
                }
                static validate(attrs) {
                  return new Validate(attrs);
                }
                static value(attrs) {
                  return new Value(attrs);
                }
                static variables(attrs) {
                  return new Variables(attrs);
                }
              };
              __name(_TemplateNamespace, "TemplateNamespace");
              let TemplateNamespace = _TemplateNamespace;
              exports2.TemplateNamespace = TemplateNamespace;
            },
            /* 208 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.addHTML = addHTML;
              exports2.checkDimensions = checkDimensions;
              exports2.flushHTML = flushHTML;
              exports2.getAvailableSpace = getAvailableSpace;
              var _xfa_object = __w_pdfjs_require__2(202);
              var _html_utils = __w_pdfjs_require__2(209);
              function createLine(node, children) {
                return {
                  name: "div",
                  attributes: {
                    class: [node.layout === "lr-tb" ? "xfaLr" : "xfaRl"]
                  },
                  children
                };
              }
              __name(createLine, "createLine");
              function flushHTML(node) {
                if (!node[_xfa_object.$extra]) {
                  return null;
                }
                const attributes = node[_xfa_object.$extra].attributes;
                const html = {
                  name: "div",
                  attributes,
                  children: node[_xfa_object.$extra].children
                };
                if (node[_xfa_object.$extra].failingNode) {
                  const htmlFromFailing = node[_xfa_object.$extra].failingNode[_xfa_object.$flushHTML]();
                  if (htmlFromFailing) {
                    if (node.layout.endsWith("-tb")) {
                      html.children.push(createLine(node, [htmlFromFailing]));
                    } else {
                      html.children.push(htmlFromFailing);
                    }
                  }
                }
                if (html.children.length === 0) {
                  return null;
                }
                return html;
              }
              __name(flushHTML, "flushHTML");
              function addHTML(node, html, bbox) {
                const extra = node[_xfa_object.$extra];
                const availableSpace = extra.availableSpace;
                const [x, y, w, h] = bbox;
                switch (node.layout) {
                  case "position": {
                    extra.width = Math.max(extra.width, x + w);
                    extra.height = Math.max(extra.height, y + h);
                    extra.children.push(html);
                    break;
                  }
                  case "lr-tb":
                  case "rl-tb":
                    if (!extra.line || extra.attempt === 1) {
                      extra.line = createLine(node, []);
                      extra.children.push(extra.line);
                      extra.numberInLine = 0;
                    }
                    extra.numberInLine += 1;
                    extra.line.children.push(html);
                    if (extra.attempt === 0) {
                      extra.currentWidth += w;
                      extra.height = Math.max(extra.height, extra.prevHeight + h);
                    } else {
                      extra.currentWidth = w;
                      extra.prevHeight = extra.height;
                      extra.height += h;
                      extra.attempt = 0;
                    }
                    extra.width = Math.max(extra.width, extra.currentWidth);
                    break;
                  case "rl-row":
                  case "row": {
                    extra.children.push(html);
                    extra.width += w;
                    extra.height = Math.max(extra.height, h);
                    const height = (0, _html_utils.measureToString)(extra.height);
                    for (const child of extra.children) {
                      child.attributes.style.height = height;
                    }
                    break;
                  }
                  case "table": {
                    extra.width = Math.min(availableSpace.width, Math.max(extra.width, w));
                    extra.height += h;
                    extra.children.push(html);
                    break;
                  }
                  case "tb": {
                    extra.width = Math.min(availableSpace.width, Math.max(extra.width, w));
                    extra.height += h;
                    extra.children.push(html);
                    break;
                  }
                }
              }
              __name(addHTML, "addHTML");
              function getAvailableSpace(node) {
                const availableSpace = node[_xfa_object.$extra].availableSpace;
                const marginV = node.margin ? node.margin.topInset + node.margin.bottomInset : 0;
                const marginH = node.margin ? node.margin.leftInset + node.margin.rightInset : 0;
                switch (node.layout) {
                  case "lr-tb":
                  case "rl-tb":
                    if (node[_xfa_object.$extra].attempt === 0) {
                      return {
                        width: availableSpace.width - marginH - node[_xfa_object.$extra].currentWidth,
                        height: availableSpace.height - marginV - node[_xfa_object.$extra].prevHeight
                      };
                    }
                    return {
                      width: availableSpace.width - marginH,
                      height: availableSpace.height - marginV - node[_xfa_object.$extra].height
                    };
                  case "rl-row":
                  case "row":
                    const width = node[_xfa_object.$extra].columnWidths.slice(node[_xfa_object.$extra].currentColumn).reduce((a, x) => a + x);
                    return {
                      width,
                      height: availableSpace.height - marginH
                    };
                  case "table":
                  case "tb":
                    return {
                      width: availableSpace.width - marginH,
                      height: availableSpace.height - marginV - node[_xfa_object.$extra].height
                    };
                  case "position":
                  default:
                    return availableSpace;
                }
              }
              __name(getAvailableSpace, "getAvailableSpace");
              function getTransformedBBox(node) {
                let w = node.w === "" ? NaN : node.w;
                let h = node.h === "" ? NaN : node.h;
                let [centerX, centerY] = [0, 0];
                switch (node.anchorType || "") {
                  case "bottomCenter":
                    [centerX, centerY] = [w / 2, h];
                    break;
                  case "bottomLeft":
                    [centerX, centerY] = [0, h];
                    break;
                  case "bottomRight":
                    [centerX, centerY] = [w, h];
                    break;
                  case "middleCenter":
                    [centerX, centerY] = [w / 2, h / 2];
                    break;
                  case "middleLeft":
                    [centerX, centerY] = [0, h / 2];
                    break;
                  case "middleRight":
                    [centerX, centerY] = [w, h / 2];
                    break;
                  case "topCenter":
                    [centerX, centerY] = [w / 2, 0];
                    break;
                  case "topRight":
                    [centerX, centerY] = [w, 0];
                    break;
                }
                let x, y;
                switch (node.rotate || 0) {
                  case 0:
                    [x, y] = [-centerX, -centerY];
                    break;
                  case 90:
                    [x, y] = [-centerY, centerX];
                    [w, h] = [h, -w];
                    break;
                  case 180:
                    [x, y] = [centerX, centerY];
                    [w, h] = [-w, -h];
                    break;
                  case 270:
                    [x, y] = [centerY, -centerX];
                    [w, h] = [-h, w];
                    break;
                }
                return [node.x + x + Math.min(0, w), node.y + y + Math.min(0, h), Math.abs(w), Math.abs(h)];
              }
              __name(getTransformedBBox, "getTransformedBBox");
              function checkDimensions(node, space) {
                if (node[_xfa_object.$getTemplateRoot]()[_xfa_object.$extra].firstUnsplittable === null) {
                  return true;
                }
                if (node.w === 0 || node.h === 0) {
                  return true;
                }
                const ERROR = 2;
                const parent = node[_xfa_object.$getSubformParent]();
                const attempt = parent[_xfa_object.$extra] && parent[_xfa_object.$extra].attempt || 0;
                const [, y, w, h] = getTransformedBBox(node);
                switch (parent.layout) {
                  case "lr-tb":
                  case "rl-tb":
                    if (attempt === 0) {
                      if (!node[_xfa_object.$getTemplateRoot]()[_xfa_object.$extra].noLayoutFailure) {
                        if (node.h !== "" && Math.round(h - space.height) > ERROR) {
                          return false;
                        }
                        if (node.w !== "") {
                          if (Math.round(w - space.width) <= ERROR) {
                            return true;
                          }
                          if (parent[_xfa_object.$extra].numberInLine === 0) {
                            return space.height > ERROR;
                          }
                          return false;
                        }
                        return space.width > ERROR;
                      }
                      if (node.w !== "") {
                        return Math.round(w - space.width) <= ERROR;
                      }
                      return space.width > ERROR;
                    }
                    if (node[_xfa_object.$getTemplateRoot]()[_xfa_object.$extra].noLayoutFailure) {
                      return true;
                    }
                    if (node.h !== "" && Math.round(h - space.height) > ERROR) {
                      return false;
                    }
                    if (node.w === "" || Math.round(w - space.width) <= ERROR) {
                      return space.height > ERROR;
                    }
                    if (parent[_xfa_object.$isThereMoreWidth]()) {
                      return false;
                    }
                    return space.height > ERROR;
                  case "table":
                  case "tb":
                    if (node[_xfa_object.$getTemplateRoot]()[_xfa_object.$extra].noLayoutFailure) {
                      return true;
                    }
                    if (node.h !== "" && !node[_xfa_object.$isSplittable]()) {
                      return Math.round(h - space.height) <= ERROR;
                    }
                    if (node.w === "" || Math.round(w - space.width) <= ERROR) {
                      return space.height > ERROR;
                    }
                    if (parent[_xfa_object.$isThereMoreWidth]()) {
                      return false;
                    }
                    return space.height > ERROR;
                  case "position":
                    if (node[_xfa_object.$getTemplateRoot]()[_xfa_object.$extra].noLayoutFailure) {
                      return true;
                    }
                    if (node.h === "" || Math.round(h + y - space.height) <= ERROR) {
                      return true;
                    }
                    const area = node[_xfa_object.$getTemplateRoot]()[_xfa_object.$extra].currentContentArea;
                    return h + y > area.h;
                  case "rl-row":
                  case "row":
                    if (node[_xfa_object.$getTemplateRoot]()[_xfa_object.$extra].noLayoutFailure) {
                      return true;
                    }
                    if (node.h !== "") {
                      return Math.round(h - space.height) <= ERROR;
                    }
                    return true;
                  default:
                    return true;
                }
              }
              __name(checkDimensions, "checkDimensions");
            },
            /* 209 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.computeBbox = computeBbox;
              exports2.createWrapper = createWrapper;
              exports2.fixDimensions = fixDimensions;
              exports2.fixTextIndent = fixTextIndent;
              exports2.fixURL = fixURL;
              exports2.isPrintOnly = isPrintOnly;
              exports2.layoutClass = layoutClass;
              exports2.layoutNode = layoutNode;
              exports2.measureToString = measureToString;
              exports2.setAccess = setAccess;
              exports2.setFontFamily = setFontFamily;
              exports2.setMinMaxDimensions = setMinMaxDimensions;
              exports2.setPara = setPara;
              exports2.toStyle = toStyle;
              var _xfa_object = __w_pdfjs_require__2(202);
              var _util = __w_pdfjs_require__2(2);
              var _utils = __w_pdfjs_require__2(203);
              var _fonts = __w_pdfjs_require__2(210);
              var _text = __w_pdfjs_require__2(211);
              function measureToString(m) {
                if (typeof m === "string") {
                  return "0px";
                }
                return Number.isInteger(m) ? `${m}px` : `${m.toFixed(2)}px`;
              }
              __name(measureToString, "measureToString");
              const converters = {
                anchorType(node, style) {
                  const parent = node[_xfa_object.$getSubformParent]();
                  if (!parent || parent.layout && parent.layout !== "position") {
                    return;
                  }
                  if (!("transform" in style)) {
                    style.transform = "";
                  }
                  switch (node.anchorType) {
                    case "bottomCenter":
                      style.transform += "translate(-50%, -100%)";
                      break;
                    case "bottomLeft":
                      style.transform += "translate(0,-100%)";
                      break;
                    case "bottomRight":
                      style.transform += "translate(-100%,-100%)";
                      break;
                    case "middleCenter":
                      style.transform += "translate(-50%,-50%)";
                      break;
                    case "middleLeft":
                      style.transform += "translate(0,-50%)";
                      break;
                    case "middleRight":
                      style.transform += "translate(-100%,-50%)";
                      break;
                    case "topCenter":
                      style.transform += "translate(-50%,0)";
                      break;
                    case "topRight":
                      style.transform += "translate(-100%,0)";
                      break;
                  }
                },
                dimensions(node, style) {
                  const parent = node[_xfa_object.$getSubformParent]();
                  let width = node.w;
                  const height = node.h;
                  if (parent.layout && parent.layout.includes("row")) {
                    const extra = parent[_xfa_object.$extra];
                    const colSpan = node.colSpan;
                    let w;
                    if (colSpan === -1) {
                      w = extra.columnWidths.slice(extra.currentColumn).reduce((a, x) => a + x, 0);
                      extra.currentColumn = 0;
                    } else {
                      w = extra.columnWidths.slice(extra.currentColumn, extra.currentColumn + colSpan).reduce((a, x) => a + x, 0);
                      extra.currentColumn = (extra.currentColumn + node.colSpan) % extra.columnWidths.length;
                    }
                    if (!isNaN(w)) {
                      width = node.w = w;
                    }
                  }
                  if (width !== "") {
                    style.width = measureToString(width);
                  } else {
                    style.width = "auto";
                  }
                  if (height !== "") {
                    style.height = measureToString(height);
                  } else {
                    style.height = "auto";
                  }
                },
                position(node, style) {
                  const parent = node[_xfa_object.$getSubformParent]();
                  if (parent && parent.layout && parent.layout !== "position") {
                    return;
                  }
                  style.position = "absolute";
                  style.left = measureToString(node.x);
                  style.top = measureToString(node.y);
                },
                rotate(node, style) {
                  if (node.rotate) {
                    if (!("transform" in style)) {
                      style.transform = "";
                    }
                    style.transform += `rotate(-${node.rotate}deg)`;
                    style.transformOrigin = "top left";
                  }
                },
                presence(node, style) {
                  switch (node.presence) {
                    case "invisible":
                      style.visibility = "hidden";
                      break;
                    case "hidden":
                    case "inactive":
                      style.display = "none";
                      break;
                  }
                },
                hAlign(node, style) {
                  if (node[_xfa_object.$nodeName] === "para") {
                    switch (node.hAlign) {
                      case "justifyAll":
                        style.textAlign = "justify-all";
                        break;
                      case "radix":
                        style.textAlign = "left";
                        break;
                      default:
                        style.textAlign = node.hAlign;
                    }
                  } else {
                    switch (node.hAlign) {
                      case "left":
                        style.alignSelf = "start";
                        break;
                      case "center":
                        style.alignSelf = "center";
                        break;
                      case "right":
                        style.alignSelf = "end";
                        break;
                    }
                  }
                },
                margin(node, style) {
                  if (node.margin) {
                    style.margin = node.margin[_xfa_object.$toStyle]().margin;
                  }
                }
              };
              function setMinMaxDimensions(node, style) {
                const parent = node[_xfa_object.$getSubformParent]();
                if (parent.layout === "position") {
                  if (node.minW > 0) {
                    style.minWidth = measureToString(node.minW);
                  }
                  if (node.maxW > 0) {
                    style.maxWidth = measureToString(node.maxW);
                  }
                  if (node.minH > 0) {
                    style.minHeight = measureToString(node.minH);
                  }
                  if (node.maxH > 0) {
                    style.maxHeight = measureToString(node.maxH);
                  }
                }
              }
              __name(setMinMaxDimensions, "setMinMaxDimensions");
              function layoutText(text, xfaFont, margin, lineHeight, fontFinder, width) {
                const measure = new _text.TextMeasure(xfaFont, margin, lineHeight, fontFinder);
                if (typeof text === "string") {
                  measure.addString(text);
                } else {
                  text[_xfa_object.$pushGlyphs](measure);
                }
                return measure.compute(width);
              }
              __name(layoutText, "layoutText");
              function layoutNode(node, availableSpace) {
                let height = null;
                let width = null;
                let isBroken = false;
                if ((!node.w || !node.h) && node.value) {
                  let marginH = 0;
                  let marginV = 0;
                  if (node.margin) {
                    marginH = node.margin.leftInset + node.margin.rightInset;
                    marginV = node.margin.topInset + node.margin.bottomInset;
                  }
                  let lineHeight = null;
                  let margin = null;
                  if (node.para) {
                    margin = /* @__PURE__ */ Object.create(null);
                    lineHeight = node.para.lineHeight === "" ? null : node.para.lineHeight;
                    margin.top = node.para.spaceAbove === "" ? 0 : node.para.spaceAbove;
                    margin.bottom = node.para.spaceBelow === "" ? 0 : node.para.spaceBelow;
                    margin.left = node.para.marginLeft === "" ? 0 : node.para.marginLeft;
                    margin.right = node.para.marginRight === "" ? 0 : node.para.marginRight;
                  }
                  let font = node.font;
                  if (!font) {
                    const root = node[_xfa_object.$getTemplateRoot]();
                    let parent = node[_xfa_object.$getParent]();
                    while (parent && parent !== root) {
                      if (parent.font) {
                        font = parent.font;
                        break;
                      }
                      parent = parent[_xfa_object.$getParent]();
                    }
                  }
                  const maxWidth = (node.w || availableSpace.width) - marginH;
                  const fontFinder = node[_xfa_object.$globalData].fontFinder;
                  if (node.value.exData && node.value.exData[_xfa_object.$content] && node.value.exData.contentType === "text/html") {
                    const res = layoutText(node.value.exData[_xfa_object.$content], font, margin, lineHeight, fontFinder, maxWidth);
                    width = res.width;
                    height = res.height;
                    isBroken = res.isBroken;
                  } else {
                    const text = node.value[_xfa_object.$text]();
                    if (text) {
                      const res = layoutText(text, font, margin, lineHeight, fontFinder, maxWidth);
                      width = res.width;
                      height = res.height;
                      isBroken = res.isBroken;
                    }
                  }
                  if (width !== null && !node.w) {
                    width += marginH;
                  }
                  if (height !== null && !node.h) {
                    height += marginV;
                  }
                }
                return {
                  w: width,
                  h: height,
                  isBroken
                };
              }
              __name(layoutNode, "layoutNode");
              function computeBbox(node, html, availableSpace) {
                let bbox;
                if (node.w !== "" && node.h !== "") {
                  bbox = [node.x, node.y, node.w, node.h];
                } else {
                  if (!availableSpace) {
                    return null;
                  }
                  let width = node.w;
                  if (width === "") {
                    if (node.maxW === 0) {
                      const parent = node[_xfa_object.$getSubformParent]();
                      if (parent.layout === "position" && parent.w !== "") {
                        width = 0;
                      } else {
                        width = node.minW;
                      }
                    } else {
                      width = Math.min(node.maxW, availableSpace.width);
                    }
                    html.attributes.style.width = measureToString(width);
                  }
                  let height = node.h;
                  if (height === "") {
                    if (node.maxH === 0) {
                      const parent = node[_xfa_object.$getSubformParent]();
                      if (parent.layout === "position" && parent.h !== "") {
                        height = 0;
                      } else {
                        height = node.minH;
                      }
                    } else {
                      height = Math.min(node.maxH, availableSpace.height);
                    }
                    html.attributes.style.height = measureToString(height);
                  }
                  bbox = [node.x, node.y, width, height];
                }
                return bbox;
              }
              __name(computeBbox, "computeBbox");
              function fixDimensions(node) {
                const parent = node[_xfa_object.$getSubformParent]();
                if (parent.layout && parent.layout.includes("row")) {
                  const extra = parent[_xfa_object.$extra];
                  const colSpan = node.colSpan;
                  let width;
                  if (colSpan === -1) {
                    width = extra.columnWidths.slice(extra.currentColumn).reduce((a, w) => a + w, 0);
                  } else {
                    width = extra.columnWidths.slice(extra.currentColumn, extra.currentColumn + colSpan).reduce((a, w) => a + w, 0);
                  }
                  if (!isNaN(width)) {
                    node.w = width;
                  }
                }
                if (parent.layout && parent.layout !== "position") {
                  node.x = node.y = 0;
                }
                if (node.layout === "table") {
                  if (node.w === "" && Array.isArray(node.columnWidths)) {
                    node.w = node.columnWidths.reduce((a, x) => a + x, 0);
                  }
                }
              }
              __name(fixDimensions, "fixDimensions");
              function layoutClass(node) {
                switch (node.layout) {
                  case "position":
                    return "xfaPosition";
                  case "lr-tb":
                    return "xfaLrTb";
                  case "rl-row":
                    return "xfaRlRow";
                  case "rl-tb":
                    return "xfaRlTb";
                  case "row":
                    return "xfaRow";
                  case "table":
                    return "xfaTable";
                  case "tb":
                    return "xfaTb";
                  default:
                    return "xfaPosition";
                }
              }
              __name(layoutClass, "layoutClass");
              function toStyle(node) {
                const style = /* @__PURE__ */ Object.create(null);
                for (var _len = arguments.length, names = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  names[_key - 1] = arguments[_key];
                }
                for (const name of names) {
                  const value = node[name];
                  if (value === null) {
                    continue;
                  }
                  if (converters.hasOwnProperty(name)) {
                    converters[name](node, style);
                    continue;
                  }
                  if (value instanceof _xfa_object.XFAObject) {
                    const newStyle = value[_xfa_object.$toStyle]();
                    if (newStyle) {
                      Object.assign(style, newStyle);
                    } else {
                      (0, _util.warn)(`(DEBUG) - XFA - style for ${name} not implemented yet`);
                    }
                  }
                }
                return style;
              }
              __name(toStyle, "toStyle");
              function createWrapper(node, html) {
                const {
                  attributes
                } = html;
                const {
                  style
                } = attributes;
                const wrapper = {
                  name: "div",
                  attributes: {
                    class: ["xfaWrapper"],
                    style: /* @__PURE__ */ Object.create(null)
                  },
                  children: []
                };
                attributes.class.push("xfaWrapped");
                if (node.border) {
                  const {
                    widths,
                    insets
                  } = node.border[_xfa_object.$extra];
                  let width, height;
                  let top = insets[0];
                  let left = insets[3];
                  const insetsH = insets[0] + insets[2];
                  const insetsW = insets[1] + insets[3];
                  switch (node.border.hand) {
                    case "even":
                      top -= widths[0] / 2;
                      left -= widths[3] / 2;
                      width = `calc(100% + ${(widths[1] + widths[3]) / 2 - insetsW}px)`;
                      height = `calc(100% + ${(widths[0] + widths[2]) / 2 - insetsH}px)`;
                      break;
                    case "left":
                      top -= widths[0];
                      left -= widths[3];
                      width = `calc(100% + ${widths[1] + widths[3] - insetsW}px)`;
                      height = `calc(100% + ${widths[0] + widths[2] - insetsH}px)`;
                      break;
                    case "right":
                      width = insetsW ? `calc(100% - ${insetsW}px)` : "100%";
                      height = insetsH ? `calc(100% - ${insetsH}px)` : "100%";
                      break;
                  }
                  const classNames = ["xfaBorder"];
                  if (isPrintOnly(node.border)) {
                    classNames.push("xfaPrintOnly");
                  }
                  const border = {
                    name: "div",
                    attributes: {
                      class: classNames,
                      style: {
                        top: `${top}px`,
                        left: `${left}px`,
                        width,
                        height
                      }
                    },
                    children: []
                  };
                  for (const key of ["border", "borderWidth", "borderColor", "borderRadius", "borderStyle"]) {
                    if (style[key] !== void 0) {
                      border.attributes.style[key] = style[key];
                      delete style[key];
                    }
                  }
                  wrapper.children.push(border, html);
                } else {
                  wrapper.children.push(html);
                }
                for (const key of ["background", "backgroundClip", "top", "left", "width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "transform", "transformOrigin", "visibility"]) {
                  if (style[key] !== void 0) {
                    wrapper.attributes.style[key] = style[key];
                    delete style[key];
                  }
                }
                if (style.position === "absolute") {
                  wrapper.attributes.style.position = "absolute";
                } else {
                  wrapper.attributes.style.position = "relative";
                }
                delete style.position;
                if (style.alignSelf) {
                  wrapper.attributes.style.alignSelf = style.alignSelf;
                  delete style.alignSelf;
                }
                return wrapper;
              }
              __name(createWrapper, "createWrapper");
              function fixTextIndent(styles) {
                const indent = (0, _utils.getMeasurement)(styles.textIndent, "0px");
                if (indent >= 0) {
                  return;
                }
                const align = styles.textAlign === "right" ? "right" : "left";
                const name = "padding" + (align === "left" ? "Left" : "Right");
                const padding = (0, _utils.getMeasurement)(styles[name], "0px");
                styles[name] = `${padding - indent}px`;
              }
              __name(fixTextIndent, "fixTextIndent");
              function setAccess(node, classNames) {
                switch (node.access) {
                  case "nonInteractive":
                    classNames.push("xfaNonInteractive");
                    break;
                  case "readOnly":
                    classNames.push("xfaReadOnly");
                    break;
                  case "protected":
                    classNames.push("xfaDisabled");
                    break;
                }
              }
              __name(setAccess, "setAccess");
              function isPrintOnly(node) {
                return node.relevant.length > 0 && !node.relevant[0].excluded && node.relevant[0].viewname === "print";
              }
              __name(isPrintOnly, "isPrintOnly");
              function getCurrentPara(node) {
                const stack = node[_xfa_object.$getTemplateRoot]()[_xfa_object.$extra].paraStack;
                return stack.length ? stack.at(-1) : null;
              }
              __name(getCurrentPara, "getCurrentPara");
              function setPara(node, nodeStyle, value) {
                if (value.attributes.class && value.attributes.class.includes("xfaRich")) {
                  if (nodeStyle) {
                    if (node.h === "") {
                      nodeStyle.height = "auto";
                    }
                    if (node.w === "") {
                      nodeStyle.width = "auto";
                    }
                  }
                  const para = getCurrentPara(node);
                  if (para) {
                    const valueStyle = value.attributes.style;
                    valueStyle.display = "flex";
                    valueStyle.flexDirection = "column";
                    switch (para.vAlign) {
                      case "top":
                        valueStyle.justifyContent = "start";
                        break;
                      case "bottom":
                        valueStyle.justifyContent = "end";
                        break;
                      case "middle":
                        valueStyle.justifyContent = "center";
                        break;
                    }
                    const paraStyle = para[_xfa_object.$toStyle]();
                    for (const [key, val] of Object.entries(paraStyle)) {
                      if (!(key in valueStyle)) {
                        valueStyle[key] = val;
                      }
                    }
                  }
                }
              }
              __name(setPara, "setPara");
              function setFontFamily(xfaFont, node, fontFinder, style) {
                if (!fontFinder) {
                  delete style.fontFamily;
                  return;
                }
                const name = (0, _utils.stripQuotes)(xfaFont.typeface);
                style.fontFamily = `"${name}"`;
                const typeface = fontFinder.find(name);
                if (typeface) {
                  const {
                    fontFamily
                  } = typeface.regular.cssFontInfo;
                  if (fontFamily !== name) {
                    style.fontFamily = `"${fontFamily}"`;
                  }
                  const para = getCurrentPara(node);
                  if (para && para.lineHeight !== "") {
                    return;
                  }
                  if (style.lineHeight) {
                    return;
                  }
                  const pdfFont = (0, _fonts.selectFont)(xfaFont, typeface);
                  if (pdfFont) {
                    style.lineHeight = Math.max(1.2, pdfFont.lineHeight);
                  }
                }
              }
              __name(setFontFamily, "setFontFamily");
              function fixURL(str) {
                const absoluteUrl = (0, _util.createValidAbsoluteUrl)(str, null, {
                  addDefaultProtocol: true,
                  tryConvertEncoding: true
                });
                return absoluteUrl ? absoluteUrl.href : null;
              }
              __name(fixURL, "fixURL");
            },
            /* 210 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.FontFinder = void 0;
              exports2.getMetrics = getMetrics;
              exports2.selectFont = selectFont;
              var _xfa_object = __w_pdfjs_require__2(202);
              var _utils = __w_pdfjs_require__2(203);
              var _util = __w_pdfjs_require__2(2);
              const _FontFinder = class _FontFinder {
                constructor(pdfFonts) {
                  this.fonts = /* @__PURE__ */ new Map();
                  this.cache = /* @__PURE__ */ new Map();
                  this.warned = /* @__PURE__ */ new Set();
                  this.defaultFont = null;
                  this.add(pdfFonts);
                }
                add(pdfFonts) {
                  let reallyMissingFonts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                  for (const pdfFont of pdfFonts) {
                    this.addPdfFont(pdfFont);
                  }
                  for (const pdfFont of this.fonts.values()) {
                    if (!pdfFont.regular) {
                      pdfFont.regular = pdfFont.italic || pdfFont.bold || pdfFont.bolditalic;
                    }
                  }
                  if (!reallyMissingFonts || reallyMissingFonts.size === 0) {
                    return;
                  }
                  const myriad = this.fonts.get("PdfJS-Fallback-PdfJS-XFA");
                  for (const missing of reallyMissingFonts) {
                    this.fonts.set(missing, myriad);
                  }
                }
                addPdfFont(pdfFont) {
                  const cssFontInfo = pdfFont.cssFontInfo;
                  const name = cssFontInfo.fontFamily;
                  let font = this.fonts.get(name);
                  if (!font) {
                    font = /* @__PURE__ */ Object.create(null);
                    this.fonts.set(name, font);
                    if (!this.defaultFont) {
                      this.defaultFont = font;
                    }
                  }
                  let property = "";
                  const fontWeight = parseFloat(cssFontInfo.fontWeight);
                  if (parseFloat(cssFontInfo.italicAngle) !== 0) {
                    property = fontWeight >= 700 ? "bolditalic" : "italic";
                  } else if (fontWeight >= 700) {
                    property = "bold";
                  }
                  if (!property) {
                    if (pdfFont.name.includes("Bold") || pdfFont.psName && pdfFont.psName.includes("Bold")) {
                      property = "bold";
                    }
                    if (pdfFont.name.includes("Italic") || pdfFont.name.endsWith("It") || pdfFont.psName && (pdfFont.psName.includes("Italic") || pdfFont.psName.endsWith("It"))) {
                      property += "italic";
                    }
                  }
                  if (!property) {
                    property = "regular";
                  }
                  font[property] = pdfFont;
                }
                getDefault() {
                  return this.defaultFont;
                }
                find(fontName) {
                  let mustWarn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                  let font = this.fonts.get(fontName) || this.cache.get(fontName);
                  if (font) {
                    return font;
                  }
                  const pattern = /,|-|_| |bolditalic|bold|italic|regular|it/gi;
                  let name = fontName.replace(pattern, "");
                  font = this.fonts.get(name);
                  if (font) {
                    this.cache.set(fontName, font);
                    return font;
                  }
                  name = name.toLowerCase();
                  const maybe = [];
                  for (const [family, pdfFont] of this.fonts.entries()) {
                    if (family.replace(pattern, "").toLowerCase().startsWith(name)) {
                      maybe.push(pdfFont);
                    }
                  }
                  if (maybe.length === 0) {
                    for (const [, pdfFont] of this.fonts.entries()) {
                      if (pdfFont.regular.name && pdfFont.regular.name.replace(pattern, "").toLowerCase().startsWith(name)) {
                        maybe.push(pdfFont);
                      }
                    }
                  }
                  if (maybe.length === 0) {
                    name = name.replace(/psmt|mt/gi, "");
                    for (const [family, pdfFont] of this.fonts.entries()) {
                      if (family.replace(pattern, "").toLowerCase().startsWith(name)) {
                        maybe.push(pdfFont);
                      }
                    }
                  }
                  if (maybe.length === 0) {
                    for (const pdfFont of this.fonts.values()) {
                      if (pdfFont.regular.name && pdfFont.regular.name.replace(pattern, "").toLowerCase().startsWith(name)) {
                        maybe.push(pdfFont);
                      }
                    }
                  }
                  if (maybe.length >= 1) {
                    if (maybe.length !== 1 && mustWarn) {
                      (0, _util.warn)(`XFA - Too many choices to guess the correct font: ${fontName}`);
                    }
                    this.cache.set(fontName, maybe[0]);
                    return maybe[0];
                  }
                  if (mustWarn && !this.warned.has(fontName)) {
                    this.warned.add(fontName);
                    (0, _util.warn)(`XFA - Cannot find the font: ${fontName}`);
                  }
                  return null;
                }
              };
              __name(_FontFinder, "FontFinder");
              let FontFinder = _FontFinder;
              exports2.FontFinder = FontFinder;
              function selectFont(xfaFont, typeface) {
                if (xfaFont.posture === "italic") {
                  if (xfaFont.weight === "bold") {
                    return typeface.bolditalic;
                  }
                  return typeface.italic;
                } else if (xfaFont.weight === "bold") {
                  return typeface.bold;
                }
                return typeface.regular;
              }
              __name(selectFont, "selectFont");
              function getMetrics(xfaFont) {
                let real = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                let pdfFont = null;
                if (xfaFont) {
                  const name = (0, _utils.stripQuotes)(xfaFont.typeface);
                  const typeface = xfaFont[_xfa_object.$globalData].fontFinder.find(name);
                  pdfFont = selectFont(xfaFont, typeface);
                }
                if (!pdfFont) {
                  return {
                    lineHeight: 12,
                    lineGap: 2,
                    lineNoGap: 10
                  };
                }
                const size = xfaFont.size || 10;
                const lineHeight = pdfFont.lineHeight ? Math.max(real ? 0 : 1.2, pdfFont.lineHeight) : 1.2;
                const lineGap = pdfFont.lineGap === void 0 ? 0.2 : pdfFont.lineGap;
                return {
                  lineHeight: lineHeight * size,
                  lineGap: lineGap * size,
                  lineNoGap: Math.max(1, lineHeight - lineGap) * size
                };
              }
              __name(getMetrics, "getMetrics");
            },
            /* 211 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.TextMeasure = void 0;
              var _fonts = __w_pdfjs_require__2(210);
              const WIDTH_FACTOR = 1.02;
              const _FontInfo = class _FontInfo {
                constructor(xfaFont, margin, lineHeight, fontFinder) {
                  this.lineHeight = lineHeight;
                  this.paraMargin = margin || {
                    top: 0,
                    bottom: 0,
                    left: 0,
                    right: 0
                  };
                  if (!xfaFont) {
                    [this.pdfFont, this.xfaFont] = this.defaultFont(fontFinder);
                    return;
                  }
                  this.xfaFont = {
                    typeface: xfaFont.typeface,
                    posture: xfaFont.posture,
                    weight: xfaFont.weight,
                    size: xfaFont.size,
                    letterSpacing: xfaFont.letterSpacing
                  };
                  const typeface = fontFinder.find(xfaFont.typeface);
                  if (!typeface) {
                    [this.pdfFont, this.xfaFont] = this.defaultFont(fontFinder);
                    return;
                  }
                  this.pdfFont = (0, _fonts.selectFont)(xfaFont, typeface);
                  if (!this.pdfFont) {
                    [this.pdfFont, this.xfaFont] = this.defaultFont(fontFinder);
                  }
                }
                defaultFont(fontFinder) {
                  const font = fontFinder.find("Helvetica", false) || fontFinder.find("Myriad Pro", false) || fontFinder.find("Arial", false) || fontFinder.getDefault();
                  if (font && font.regular) {
                    const pdfFont = font.regular;
                    const info = pdfFont.cssFontInfo;
                    const xfaFont2 = {
                      typeface: info.fontFamily,
                      posture: "normal",
                      weight: "normal",
                      size: 10,
                      letterSpacing: 0
                    };
                    return [pdfFont, xfaFont2];
                  }
                  const xfaFont = {
                    typeface: "Courier",
                    posture: "normal",
                    weight: "normal",
                    size: 10,
                    letterSpacing: 0
                  };
                  return [null, xfaFont];
                }
              };
              __name(_FontInfo, "FontInfo");
              let FontInfo = _FontInfo;
              const _FontSelector = class _FontSelector {
                constructor(defaultXfaFont, defaultParaMargin, defaultLineHeight, fontFinder) {
                  this.fontFinder = fontFinder;
                  this.stack = [new FontInfo(defaultXfaFont, defaultParaMargin, defaultLineHeight, fontFinder)];
                }
                pushData(xfaFont, margin, lineHeight) {
                  const lastFont = this.stack.at(-1);
                  for (const name of ["typeface", "posture", "weight", "size", "letterSpacing"]) {
                    if (!xfaFont[name]) {
                      xfaFont[name] = lastFont.xfaFont[name];
                    }
                  }
                  for (const name of ["top", "bottom", "left", "right"]) {
                    if (isNaN(margin[name])) {
                      margin[name] = lastFont.paraMargin[name];
                    }
                  }
                  const fontInfo = new FontInfo(xfaFont, margin, lineHeight || lastFont.lineHeight, this.fontFinder);
                  if (!fontInfo.pdfFont) {
                    fontInfo.pdfFont = lastFont.pdfFont;
                  }
                  this.stack.push(fontInfo);
                }
                popFont() {
                  this.stack.pop();
                }
                topFont() {
                  return this.stack.at(-1);
                }
              };
              __name(_FontSelector, "FontSelector");
              let FontSelector = _FontSelector;
              const _TextMeasure = class _TextMeasure {
                constructor(defaultXfaFont, defaultParaMargin, defaultLineHeight, fonts) {
                  this.glyphs = [];
                  this.fontSelector = new FontSelector(defaultXfaFont, defaultParaMargin, defaultLineHeight, fonts);
                  this.extraHeight = 0;
                }
                pushData(xfaFont, margin, lineHeight) {
                  this.fontSelector.pushData(xfaFont, margin, lineHeight);
                }
                popFont(xfaFont) {
                  return this.fontSelector.popFont();
                }
                addPara() {
                  const lastFont = this.fontSelector.topFont();
                  this.extraHeight += lastFont.paraMargin.top + lastFont.paraMargin.bottom;
                }
                addString(str) {
                  if (!str) {
                    return;
                  }
                  const lastFont = this.fontSelector.topFont();
                  const fontSize = lastFont.xfaFont.size;
                  if (lastFont.pdfFont) {
                    const letterSpacing = lastFont.xfaFont.letterSpacing;
                    const pdfFont = lastFont.pdfFont;
                    const fontLineHeight = pdfFont.lineHeight || 1.2;
                    const lineHeight = lastFont.lineHeight || Math.max(1.2, fontLineHeight) * fontSize;
                    const lineGap = pdfFont.lineGap === void 0 ? 0.2 : pdfFont.lineGap;
                    const noGap = fontLineHeight - lineGap;
                    const firstLineHeight = Math.max(1, noGap) * fontSize;
                    const scale = fontSize / 1e3;
                    const fallbackWidth = pdfFont.defaultWidth || pdfFont.charsToGlyphs(" ")[0].width;
                    for (const line of str.split(/[\u2029\n]/)) {
                      const encodedLine = pdfFont.encodeString(line).join("");
                      const glyphs = pdfFont.charsToGlyphs(encodedLine);
                      for (const glyph of glyphs) {
                        const width = glyph.width || fallbackWidth;
                        this.glyphs.push([width * scale + letterSpacing, lineHeight, firstLineHeight, glyph.unicode, false]);
                      }
                      this.glyphs.push([0, 0, 0, "\n", true]);
                    }
                    this.glyphs.pop();
                    return;
                  }
                  for (const line of str.split(/[\u2029\n]/)) {
                    for (const char of line.split("")) {
                      this.glyphs.push([fontSize, 1.2 * fontSize, fontSize, char, false]);
                    }
                    this.glyphs.push([0, 0, 0, "\n", true]);
                  }
                  this.glyphs.pop();
                }
                compute(maxWidth) {
                  let lastSpacePos = -1, lastSpaceWidth = 0, width = 0, height = 0, currentLineWidth = 0, currentLineHeight = 0;
                  let isBroken = false;
                  let isFirstLine = true;
                  for (let i = 0, ii = this.glyphs.length; i < ii; i++) {
                    const [glyphWidth, lineHeight, firstLineHeight, char, isEOL] = this.glyphs[i];
                    const isSpace = char === " ";
                    const glyphHeight = isFirstLine ? firstLineHeight : lineHeight;
                    if (isEOL) {
                      width = Math.max(width, currentLineWidth);
                      currentLineWidth = 0;
                      height += currentLineHeight;
                      currentLineHeight = glyphHeight;
                      lastSpacePos = -1;
                      lastSpaceWidth = 0;
                      isFirstLine = false;
                      continue;
                    }
                    if (isSpace) {
                      if (currentLineWidth + glyphWidth > maxWidth) {
                        width = Math.max(width, currentLineWidth);
                        currentLineWidth = 0;
                        height += currentLineHeight;
                        currentLineHeight = glyphHeight;
                        lastSpacePos = -1;
                        lastSpaceWidth = 0;
                        isBroken = true;
                        isFirstLine = false;
                      } else {
                        currentLineHeight = Math.max(glyphHeight, currentLineHeight);
                        lastSpaceWidth = currentLineWidth;
                        currentLineWidth += glyphWidth;
                        lastSpacePos = i;
                      }
                      continue;
                    }
                    if (currentLineWidth + glyphWidth > maxWidth) {
                      height += currentLineHeight;
                      currentLineHeight = glyphHeight;
                      if (lastSpacePos !== -1) {
                        i = lastSpacePos;
                        width = Math.max(width, lastSpaceWidth);
                        currentLineWidth = 0;
                        lastSpacePos = -1;
                        lastSpaceWidth = 0;
                      } else {
                        width = Math.max(width, currentLineWidth);
                        currentLineWidth = glyphWidth;
                      }
                      isBroken = true;
                      isFirstLine = false;
                      continue;
                    }
                    currentLineWidth += glyphWidth;
                    currentLineHeight = Math.max(glyphHeight, currentLineHeight);
                  }
                  width = Math.max(width, currentLineWidth);
                  height += currentLineHeight + this.extraHeight;
                  return {
                    width: WIDTH_FACTOR * width,
                    height,
                    isBroken
                  };
                }
              };
              __name(_TextMeasure, "TextMeasure");
              let TextMeasure = _TextMeasure;
              exports2.TextMeasure = TextMeasure;
            },
            /* 212 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.DataHandler = void 0;
              var _xfa_object = __w_pdfjs_require__2(202);
              const _DataHandler = class _DataHandler {
                constructor(root, data) {
                  this.data = data;
                  this.dataset = root.datasets || null;
                }
                serialize(storage) {
                  const stack = [[-1, this.data[_xfa_object.$getChildren]()]];
                  while (stack.length > 0) {
                    const last = stack.at(-1);
                    const [i, children] = last;
                    if (i + 1 === children.length) {
                      stack.pop();
                      continue;
                    }
                    const child = children[++last[0]];
                    const storageEntry = storage.get(child[_xfa_object.$uid]);
                    if (storageEntry) {
                      child[_xfa_object.$setValue](storageEntry);
                    } else {
                      const attributes = child[_xfa_object.$getAttributes]();
                      for (const value of attributes.values()) {
                        const entry = storage.get(value[_xfa_object.$uid]);
                        if (entry) {
                          value[_xfa_object.$setValue](entry);
                          break;
                        }
                      }
                    }
                    const nodes = child[_xfa_object.$getChildren]();
                    if (nodes.length > 0) {
                      stack.push([-1, nodes]);
                    }
                  }
                  const buf = [`<xfa:datasets xmlns:xfa="http://www.xfa.org/schema/xfa-data/1.0/">`];
                  if (this.dataset) {
                    for (const child of this.dataset[_xfa_object.$getChildren]()) {
                      if (child[_xfa_object.$nodeName] !== "data") {
                        child[_xfa_object.$toString](buf);
                      }
                    }
                  }
                  this.data[_xfa_object.$toString](buf);
                  buf.push("</xfa:datasets>");
                  return buf.join("");
                }
              };
              __name(_DataHandler, "DataHandler");
              let DataHandler = _DataHandler;
              exports2.DataHandler = DataHandler;
            },
            /* 213 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.XFAParser = void 0;
              var _xfa_object = __w_pdfjs_require__2(202);
              var _xml_parser = __w_pdfjs_require__2(191);
              var _builder = __w_pdfjs_require__2(214);
              var _util = __w_pdfjs_require__2(2);
              const _XFAParser = class _XFAParser extends _xml_parser.XMLParserBase {
                constructor() {
                  let rootNameSpace = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                  let richText = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  super();
                  this._builder = new _builder.Builder(rootNameSpace);
                  this._stack = [];
                  this._globalData = {
                    usedTypefaces: /* @__PURE__ */ new Set()
                  };
                  this._ids = /* @__PURE__ */ new Map();
                  this._current = this._builder.buildRoot(this._ids);
                  this._errorCode = _xml_parser.XMLParserErrorCode.NoError;
                  this._whiteRegex = /^\s+$/;
                  this._nbsps = /\xa0+/g;
                  this._richText = richText;
                }
                parse(data) {
                  this.parseXml(data);
                  if (this._errorCode !== _xml_parser.XMLParserErrorCode.NoError) {
                    return void 0;
                  }
                  this._current[_xfa_object.$finalize]();
                  return this._current.element;
                }
                onText(text) {
                  text = text.replace(this._nbsps, (match) => match.slice(1) + " ");
                  if (this._richText || this._current[_xfa_object.$acceptWhitespace]()) {
                    this._current[_xfa_object.$onText](text, this._richText);
                    return;
                  }
                  if (this._whiteRegex.test(text)) {
                    return;
                  }
                  this._current[_xfa_object.$onText](text.trim());
                }
                onCdata(text) {
                  this._current[_xfa_object.$onText](text);
                }
                _mkAttributes(attributes, tagName) {
                  let namespace = null;
                  let prefixes = null;
                  const attributeObj = /* @__PURE__ */ Object.create({});
                  for (const {
                    name,
                    value
                  } of attributes) {
                    if (name === "xmlns") {
                      if (!namespace) {
                        namespace = value;
                      } else {
                        (0, _util.warn)(`XFA - multiple namespace definition in <${tagName}>`);
                      }
                    } else if (name.startsWith("xmlns:")) {
                      const prefix = name.substring("xmlns:".length);
                      if (!prefixes) {
                        prefixes = [];
                      }
                      prefixes.push({
                        prefix,
                        value
                      });
                    } else {
                      const i = name.indexOf(":");
                      if (i === -1) {
                        attributeObj[name] = value;
                      } else {
                        let nsAttrs = attributeObj[_xfa_object.$nsAttributes];
                        if (!nsAttrs) {
                          nsAttrs = attributeObj[_xfa_object.$nsAttributes] = /* @__PURE__ */ Object.create(null);
                        }
                        const [ns, attrName] = [name.slice(0, i), name.slice(i + 1)];
                        let attrs = nsAttrs[ns];
                        if (!attrs) {
                          attrs = nsAttrs[ns] = /* @__PURE__ */ Object.create(null);
                        }
                        attrs[attrName] = value;
                      }
                    }
                  }
                  return [namespace, prefixes, attributeObj];
                }
                _getNameAndPrefix(name, nsAgnostic) {
                  const i = name.indexOf(":");
                  if (i === -1) {
                    return [name, null];
                  }
                  return [name.substring(i + 1), nsAgnostic ? "" : name.substring(0, i)];
                }
                onBeginElement(tagName, attributes, isEmpty) {
                  const [namespace, prefixes, attributesObj] = this._mkAttributes(attributes, tagName);
                  const [name, nsPrefix] = this._getNameAndPrefix(tagName, this._builder.isNsAgnostic());
                  const node = this._builder.build({
                    nsPrefix,
                    name,
                    attributes: attributesObj,
                    namespace,
                    prefixes
                  });
                  node[_xfa_object.$globalData] = this._globalData;
                  if (isEmpty) {
                    node[_xfa_object.$finalize]();
                    if (this._current[_xfa_object.$onChild](node)) {
                      node[_xfa_object.$setId](this._ids);
                    }
                    node[_xfa_object.$clean](this._builder);
                    return;
                  }
                  this._stack.push(this._current);
                  this._current = node;
                }
                onEndElement(name) {
                  const node = this._current;
                  if (node[_xfa_object.$isCDATAXml]() && typeof node[_xfa_object.$content] === "string") {
                    const parser = new _XFAParser();
                    parser._globalData = this._globalData;
                    const root = parser.parse(node[_xfa_object.$content]);
                    node[_xfa_object.$content] = null;
                    node[_xfa_object.$onChild](root);
                  }
                  node[_xfa_object.$finalize]();
                  this._current = this._stack.pop();
                  if (this._current[_xfa_object.$onChild](node)) {
                    node[_xfa_object.$setId](this._ids);
                  }
                  node[_xfa_object.$clean](this._builder);
                }
                onError(code) {
                  this._errorCode = code;
                }
              };
              __name(_XFAParser, "XFAParser");
              let XFAParser = _XFAParser;
              exports2.XFAParser = XFAParser;
            },
            /* 214 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Builder = void 0;
              var _namespaces = __w_pdfjs_require__2(204);
              var _xfa_object = __w_pdfjs_require__2(202);
              var _setup = __w_pdfjs_require__2(215);
              var _template = __w_pdfjs_require__2(207);
              var _unknown = __w_pdfjs_require__2(224);
              var _util = __w_pdfjs_require__2(2);
              const _Root = class _Root extends _xfa_object.XFAObject {
                constructor(ids) {
                  super(-1, "root", /* @__PURE__ */ Object.create(null));
                  this.element = null;
                  this[_xfa_object.$ids] = ids;
                }
                [_xfa_object.$onChild](child) {
                  this.element = child;
                  return true;
                }
                [_xfa_object.$finalize]() {
                  super[_xfa_object.$finalize]();
                  if (this.element.template instanceof _template.Template) {
                    this[_xfa_object.$ids].set(_xfa_object.$root, this.element);
                    this.element.template[_xfa_object.$resolvePrototypes](this[_xfa_object.$ids]);
                    this.element.template[_xfa_object.$ids] = this[_xfa_object.$ids];
                  }
                }
              };
              __name(_Root, "Root");
              let Root = _Root;
              const _Empty = class _Empty extends _xfa_object.XFAObject {
                constructor() {
                  super(-1, "", /* @__PURE__ */ Object.create(null));
                }
                [_xfa_object.$onChild](_) {
                  return false;
                }
              };
              __name(_Empty, "Empty");
              let Empty = _Empty;
              const _Builder = class _Builder {
                constructor() {
                  let rootNameSpace = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                  this._namespaceStack = [];
                  this._nsAgnosticLevel = 0;
                  this._namespacePrefixes = /* @__PURE__ */ new Map();
                  this._namespaces = /* @__PURE__ */ new Map();
                  this._nextNsId = Math.max(...Object.values(_namespaces.NamespaceIds).map((_ref) => {
                    let {
                      id
                    } = _ref;
                    return id;
                  }));
                  this._currentNamespace = rootNameSpace || new _unknown.UnknownNamespace(++this._nextNsId);
                }
                buildRoot(ids) {
                  return new Root(ids);
                }
                build(_ref2) {
                  let {
                    nsPrefix,
                    name,
                    attributes,
                    namespace,
                    prefixes
                  } = _ref2;
                  const hasNamespaceDef = namespace !== null;
                  if (hasNamespaceDef) {
                    this._namespaceStack.push(this._currentNamespace);
                    this._currentNamespace = this._searchNamespace(namespace);
                  }
                  if (prefixes) {
                    this._addNamespacePrefix(prefixes);
                  }
                  if (attributes.hasOwnProperty(_xfa_object.$nsAttributes)) {
                    const dataTemplate = _setup.NamespaceSetUp.datasets;
                    const nsAttrs = attributes[_xfa_object.$nsAttributes];
                    let xfaAttrs = null;
                    for (const [ns, attrs] of Object.entries(nsAttrs)) {
                      const nsToUse = this._getNamespaceToUse(ns);
                      if (nsToUse === dataTemplate) {
                        xfaAttrs = {
                          xfa: attrs
                        };
                        break;
                      }
                    }
                    if (xfaAttrs) {
                      attributes[_xfa_object.$nsAttributes] = xfaAttrs;
                    } else {
                      delete attributes[_xfa_object.$nsAttributes];
                    }
                  }
                  const namespaceToUse = this._getNamespaceToUse(nsPrefix);
                  const node = namespaceToUse && namespaceToUse[_namespaces.$buildXFAObject](name, attributes) || new Empty();
                  if (node[_xfa_object.$isNsAgnostic]()) {
                    this._nsAgnosticLevel++;
                  }
                  if (hasNamespaceDef || prefixes || node[_xfa_object.$isNsAgnostic]()) {
                    node[_xfa_object.$cleanup] = {
                      hasNamespace: hasNamespaceDef,
                      prefixes,
                      nsAgnostic: node[_xfa_object.$isNsAgnostic]()
                    };
                  }
                  return node;
                }
                isNsAgnostic() {
                  return this._nsAgnosticLevel > 0;
                }
                _searchNamespace(nsName) {
                  let ns = this._namespaces.get(nsName);
                  if (ns) {
                    return ns;
                  }
                  for (const [name, {
                    check
                  }] of Object.entries(_namespaces.NamespaceIds)) {
                    if (check(nsName)) {
                      ns = _setup.NamespaceSetUp[name];
                      if (ns) {
                        this._namespaces.set(nsName, ns);
                        return ns;
                      }
                      break;
                    }
                  }
                  ns = new _unknown.UnknownNamespace(++this._nextNsId);
                  this._namespaces.set(nsName, ns);
                  return ns;
                }
                _addNamespacePrefix(prefixes) {
                  for (const {
                    prefix,
                    value
                  } of prefixes) {
                    const namespace = this._searchNamespace(value);
                    let prefixStack = this._namespacePrefixes.get(prefix);
                    if (!prefixStack) {
                      prefixStack = [];
                      this._namespacePrefixes.set(prefix, prefixStack);
                    }
                    prefixStack.push(namespace);
                  }
                }
                _getNamespaceToUse(prefix) {
                  if (!prefix) {
                    return this._currentNamespace;
                  }
                  const prefixStack = this._namespacePrefixes.get(prefix);
                  if (prefixStack && prefixStack.length > 0) {
                    return prefixStack.at(-1);
                  }
                  (0, _util.warn)(`Unknown namespace prefix: ${prefix}.`);
                  return null;
                }
                clean(data) {
                  const {
                    hasNamespace,
                    prefixes,
                    nsAgnostic
                  } = data;
                  if (hasNamespace) {
                    this._currentNamespace = this._namespaceStack.pop();
                  }
                  if (prefixes) {
                    prefixes.forEach((_ref3) => {
                      let {
                        prefix
                      } = _ref3;
                      this._namespacePrefixes.get(prefix).pop();
                    });
                  }
                  if (nsAgnostic) {
                    this._nsAgnosticLevel--;
                  }
                }
              };
              __name(_Builder, "Builder");
              let Builder = _Builder;
              exports2.Builder = Builder;
            },
            /* 215 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.NamespaceSetUp = void 0;
              var _config = __w_pdfjs_require__2(216);
              var _connection_set = __w_pdfjs_require__2(217);
              var _datasets = __w_pdfjs_require__2(218);
              var _locale_set = __w_pdfjs_require__2(219);
              var _signature = __w_pdfjs_require__2(220);
              var _stylesheet = __w_pdfjs_require__2(221);
              var _template = __w_pdfjs_require__2(207);
              var _xdp = __w_pdfjs_require__2(222);
              var _xhtml = __w_pdfjs_require__2(223);
              const NamespaceSetUp = {
                config: _config.ConfigNamespace,
                connection: _connection_set.ConnectionSetNamespace,
                datasets: _datasets.DatasetsNamespace,
                localeSet: _locale_set.LocaleSetNamespace,
                signature: _signature.SignatureNamespace,
                stylesheet: _stylesheet.StylesheetNamespace,
                template: _template.TemplateNamespace,
                xdp: _xdp.XdpNamespace,
                xhtml: _xhtml.XhtmlNamespace
              };
              exports2.NamespaceSetUp = NamespaceSetUp;
            },
            /* 216 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.ConfigNamespace = void 0;
              var _namespaces = __w_pdfjs_require__2(204);
              var _xfa_object = __w_pdfjs_require__2(202);
              var _utils = __w_pdfjs_require__2(203);
              var _util = __w_pdfjs_require__2(2);
              const CONFIG_NS_ID = _namespaces.NamespaceIds.config.id;
              const _Acrobat = class _Acrobat extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "acrobat", true);
                  this.acrobat7 = null;
                  this.autoSave = null;
                  this.common = null;
                  this.validate = null;
                  this.validateApprovalSignatures = null;
                  this.submitUrl = new _xfa_object.XFAObjectArray();
                }
              };
              __name(_Acrobat, "Acrobat");
              let Acrobat = _Acrobat;
              const _Acrobat7 = class _Acrobat7 extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "acrobat7", true);
                  this.dynamicRender = null;
                }
              };
              __name(_Acrobat7, "Acrobat7");
              let Acrobat7 = _Acrobat7;
              const _ADBE_JSConsole = class _ADBE_JSConsole extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "ADBE_JSConsole", ["delegate", "Enable", "Disable"]);
                }
              };
              __name(_ADBE_JSConsole, "ADBE_JSConsole");
              let ADBE_JSConsole = _ADBE_JSConsole;
              const _ADBE_JSDebugger = class _ADBE_JSDebugger extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "ADBE_JSDebugger", ["delegate", "Enable", "Disable"]);
                }
              };
              __name(_ADBE_JSDebugger, "ADBE_JSDebugger");
              let ADBE_JSDebugger = _ADBE_JSDebugger;
              const _AddSilentPrint = class _AddSilentPrint extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "addSilentPrint");
                }
              };
              __name(_AddSilentPrint, "AddSilentPrint");
              let AddSilentPrint = _AddSilentPrint;
              const _AddViewerPreferences = class _AddViewerPreferences extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "addViewerPreferences");
                }
              };
              __name(_AddViewerPreferences, "AddViewerPreferences");
              let AddViewerPreferences = _AddViewerPreferences;
              const _AdjustData = class _AdjustData extends _xfa_object.Option10 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "adjustData");
                }
              };
              __name(_AdjustData, "AdjustData");
              let AdjustData = _AdjustData;
              const _AdobeExtensionLevel = class _AdobeExtensionLevel extends _xfa_object.IntegerObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "adobeExtensionLevel", 0, (n) => n >= 1 && n <= 8);
                }
              };
              __name(_AdobeExtensionLevel, "AdobeExtensionLevel");
              let AdobeExtensionLevel = _AdobeExtensionLevel;
              const _Agent = class _Agent extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "agent", true);
                  this.name = attributes.name ? attributes.name.trim() : "";
                  this.common = new _xfa_object.XFAObjectArray();
                }
              };
              __name(_Agent, "Agent");
              let Agent = _Agent;
              const _AlwaysEmbed = class _AlwaysEmbed extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "alwaysEmbed");
                }
              };
              __name(_AlwaysEmbed, "AlwaysEmbed");
              let AlwaysEmbed = _AlwaysEmbed;
              const _Amd = class _Amd extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "amd");
                }
              };
              __name(_Amd, "Amd");
              let Amd = _Amd;
              const _Area = class _Area extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "area");
                  this.level = (0, _utils.getInteger)({
                    data: attributes.level,
                    defaultValue: 0,
                    validate: (n) => n >= 1 && n <= 3
                  });
                  this.name = (0, _utils.getStringOption)(attributes.name, ["", "barcode", "coreinit", "deviceDriver", "font", "general", "layout", "merge", "script", "signature", "sourceSet", "templateCache"]);
                }
              };
              __name(_Area, "Area");
              let Area = _Area;
              const _Attributes = class _Attributes extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "attributes", ["preserve", "delegate", "ignore"]);
                }
              };
              __name(_Attributes, "Attributes");
              let Attributes = _Attributes;
              const _AutoSave = class _AutoSave extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "autoSave", ["disabled", "enabled"]);
                }
              };
              __name(_AutoSave, "AutoSave");
              let AutoSave = _AutoSave;
              const _Base = class _Base extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "base");
                }
              };
              __name(_Base, "Base");
              let Base = _Base;
              const _BatchOutput = class _BatchOutput extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "batchOutput");
                  this.format = (0, _utils.getStringOption)(attributes.format, ["none", "concat", "zip", "zipCompress"]);
                }
              };
              __name(_BatchOutput, "BatchOutput");
              let BatchOutput = _BatchOutput;
              const _BehaviorOverride = class _BehaviorOverride extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "behaviorOverride");
                }
                [_xfa_object.$finalize]() {
                  this[_xfa_object.$content] = new Map(this[_xfa_object.$content].trim().split(/\s+/).filter((x) => x.includes(":")).map((x) => x.split(":", 2)));
                }
              };
              __name(_BehaviorOverride, "BehaviorOverride");
              let BehaviorOverride = _BehaviorOverride;
              const _Cache = class _Cache extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "cache", true);
                  this.templateCache = null;
                }
              };
              __name(_Cache, "Cache");
              let Cache = _Cache;
              const _Change = class _Change extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "change");
                }
              };
              __name(_Change, "Change");
              let Change = _Change;
              const _Common = class _Common extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "common", true);
                  this.data = null;
                  this.locale = null;
                  this.localeSet = null;
                  this.messaging = null;
                  this.suppressBanner = null;
                  this.template = null;
                  this.validationMessaging = null;
                  this.versionControl = null;
                  this.log = new _xfa_object.XFAObjectArray();
                }
              };
              __name(_Common, "Common");
              let Common = _Common;
              const _Compress = class _Compress extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "compress");
                  this.scope = (0, _utils.getStringOption)(attributes.scope, ["imageOnly", "document"]);
                }
              };
              __name(_Compress, "Compress");
              let Compress = _Compress;
              const _CompressLogicalStructure = class _CompressLogicalStructure extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "compressLogicalStructure");
                }
              };
              __name(_CompressLogicalStructure, "CompressLogicalStructure");
              let CompressLogicalStructure = _CompressLogicalStructure;
              const _CompressObjectStream = class _CompressObjectStream extends _xfa_object.Option10 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "compressObjectStream");
                }
              };
              __name(_CompressObjectStream, "CompressObjectStream");
              let CompressObjectStream = _CompressObjectStream;
              const _Compression = class _Compression extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "compression", true);
                  this.compressLogicalStructure = null;
                  this.compressObjectStream = null;
                  this.level = null;
                  this.type = null;
                }
              };
              __name(_Compression, "Compression");
              let Compression = _Compression;
              const _Config = class _Config extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "config", true);
                  this.acrobat = null;
                  this.present = null;
                  this.trace = null;
                  this.agent = new _xfa_object.XFAObjectArray();
                }
              };
              __name(_Config, "Config");
              let Config = _Config;
              const _Conformance = class _Conformance extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "conformance", ["A", "B"]);
                }
              };
              __name(_Conformance, "Conformance");
              let Conformance = _Conformance;
              const _ContentCopy = class _ContentCopy extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "contentCopy");
                }
              };
              __name(_ContentCopy, "ContentCopy");
              let ContentCopy = _ContentCopy;
              const _Copies = class _Copies extends _xfa_object.IntegerObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "copies", 1, (n) => n >= 1);
                }
              };
              __name(_Copies, "Copies");
              let Copies = _Copies;
              const _Creator = class _Creator extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "creator");
                }
              };
              __name(_Creator, "Creator");
              let Creator = _Creator;
              const _CurrentPage = class _CurrentPage extends _xfa_object.IntegerObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "currentPage", 0, (n) => n >= 0);
                }
              };
              __name(_CurrentPage, "CurrentPage");
              let CurrentPage = _CurrentPage;
              const _Data = class _Data extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "data", true);
                  this.adjustData = null;
                  this.attributes = null;
                  this.incrementalLoad = null;
                  this.outputXSL = null;
                  this.range = null;
                  this.record = null;
                  this.startNode = null;
                  this.uri = null;
                  this.window = null;
                  this.xsl = null;
                  this.excludeNS = new _xfa_object.XFAObjectArray();
                  this.transform = new _xfa_object.XFAObjectArray();
                }
              };
              __name(_Data, "Data");
              let Data = _Data;
              const _Debug = class _Debug extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "debug", true);
                  this.uri = null;
                }
              };
              __name(_Debug, "Debug");
              let Debug = _Debug;
              const _DefaultTypeface = class _DefaultTypeface extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "defaultTypeface");
                  this.writingScript = (0, _utils.getStringOption)(attributes.writingScript, ["*", "Arabic", "Cyrillic", "EastEuropeanRoman", "Greek", "Hebrew", "Japanese", "Korean", "Roman", "SimplifiedChinese", "Thai", "TraditionalChinese", "Vietnamese"]);
                }
              };
              __name(_DefaultTypeface, "DefaultTypeface");
              let DefaultTypeface = _DefaultTypeface;
              const _Destination = class _Destination extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "destination", ["pdf", "pcl", "ps", "webClient", "zpl"]);
                }
              };
              __name(_Destination, "Destination");
              let Destination = _Destination;
              const _DocumentAssembly = class _DocumentAssembly extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "documentAssembly");
                }
              };
              __name(_DocumentAssembly, "DocumentAssembly");
              let DocumentAssembly = _DocumentAssembly;
              const _Driver = class _Driver extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "driver", true);
                  this.name = attributes.name ? attributes.name.trim() : "";
                  this.fontInfo = null;
                  this.xdc = null;
                }
              };
              __name(_Driver, "Driver");
              let Driver = _Driver;
              const _DuplexOption = class _DuplexOption extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "duplexOption", ["simplex", "duplexFlipLongEdge", "duplexFlipShortEdge"]);
                }
              };
              __name(_DuplexOption, "DuplexOption");
              let DuplexOption = _DuplexOption;
              const _DynamicRender = class _DynamicRender extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "dynamicRender", ["forbidden", "required"]);
                }
              };
              __name(_DynamicRender, "DynamicRender");
              let DynamicRender = _DynamicRender;
              const _Embed = class _Embed extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "embed");
                }
              };
              __name(_Embed, "Embed");
              let Embed = _Embed;
              const _Encrypt = class _Encrypt extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "encrypt");
                }
              };
              __name(_Encrypt, "Encrypt");
              let Encrypt = _Encrypt;
              const _Encryption = class _Encryption extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "encryption", true);
                  this.encrypt = null;
                  this.encryptionLevel = null;
                  this.permissions = null;
                }
              };
              __name(_Encryption, "Encryption");
              let Encryption = _Encryption;
              const _EncryptionLevel = class _EncryptionLevel extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "encryptionLevel", ["40bit", "128bit"]);
                }
              };
              __name(_EncryptionLevel, "EncryptionLevel");
              let EncryptionLevel = _EncryptionLevel;
              const _Enforce = class _Enforce extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "enforce");
                }
              };
              __name(_Enforce, "Enforce");
              let Enforce = _Enforce;
              const _Equate = class _Equate extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "equate");
                  this.force = (0, _utils.getInteger)({
                    data: attributes.force,
                    defaultValue: 1,
                    validate: (n) => n === 0
                  });
                  this.from = attributes.from || "";
                  this.to = attributes.to || "";
                }
              };
              __name(_Equate, "Equate");
              let Equate = _Equate;
              const _EquateRange = class _EquateRange extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "equateRange");
                  this.from = attributes.from || "";
                  this.to = attributes.to || "";
                  this._unicodeRange = attributes.unicodeRange || "";
                }
                get unicodeRange() {
                  const ranges = [];
                  const unicodeRegex = /U\+([0-9a-fA-F]+)/;
                  const unicodeRange = this._unicodeRange;
                  for (let range of unicodeRange.split(",").map((x) => x.trim()).filter((x) => !!x)) {
                    range = range.split("-", 2).map((x) => {
                      const found = x.match(unicodeRegex);
                      if (!found) {
                        return 0;
                      }
                      return parseInt(found[1], 16);
                    });
                    if (range.length === 1) {
                      range.push(range[0]);
                    }
                    ranges.push(range);
                  }
                  return (0, _util.shadow)(this, "unicodeRange", ranges);
                }
              };
              __name(_EquateRange, "EquateRange");
              let EquateRange = _EquateRange;
              const _Exclude = class _Exclude extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "exclude");
                }
                [_xfa_object.$finalize]() {
                  this[_xfa_object.$content] = this[_xfa_object.$content].trim().split(/\s+/).filter((x) => x && ["calculate", "close", "enter", "exit", "initialize", "ready", "validate"].includes(x));
                }
              };
              __name(_Exclude, "Exclude");
              let Exclude = _Exclude;
              const _ExcludeNS = class _ExcludeNS extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "excludeNS");
                }
              };
              __name(_ExcludeNS, "ExcludeNS");
              let ExcludeNS = _ExcludeNS;
              const _FlipLabel = class _FlipLabel extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "flipLabel", ["usePrinterSetting", "on", "off"]);
                }
              };
              __name(_FlipLabel, "FlipLabel");
              let FlipLabel = _FlipLabel;
              const _FontInfo = class _FontInfo extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "fontInfo", true);
                  this.embed = null;
                  this.map = null;
                  this.subsetBelow = null;
                  this.alwaysEmbed = new _xfa_object.XFAObjectArray();
                  this.defaultTypeface = new _xfa_object.XFAObjectArray();
                  this.neverEmbed = new _xfa_object.XFAObjectArray();
                }
              };
              __name(_FontInfo, "FontInfo");
              let FontInfo = _FontInfo;
              const _FormFieldFilling = class _FormFieldFilling extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "formFieldFilling");
                }
              };
              __name(_FormFieldFilling, "FormFieldFilling");
              let FormFieldFilling = _FormFieldFilling;
              const _GroupParent = class _GroupParent extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "groupParent");
                }
              };
              __name(_GroupParent, "GroupParent");
              let GroupParent = _GroupParent;
              const _IfEmpty = class _IfEmpty extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "ifEmpty", ["dataValue", "dataGroup", "ignore", "remove"]);
                }
              };
              __name(_IfEmpty, "IfEmpty");
              let IfEmpty = _IfEmpty;
              const _IncludeXDPContent = class _IncludeXDPContent extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "includeXDPContent");
                }
              };
              __name(_IncludeXDPContent, "IncludeXDPContent");
              let IncludeXDPContent = _IncludeXDPContent;
              const _IncrementalLoad = class _IncrementalLoad extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "incrementalLoad", ["none", "forwardOnly"]);
                }
              };
              __name(_IncrementalLoad, "IncrementalLoad");
              let IncrementalLoad = _IncrementalLoad;
              const _IncrementalMerge = class _IncrementalMerge extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "incrementalMerge");
                }
              };
              __name(_IncrementalMerge, "IncrementalMerge");
              let IncrementalMerge = _IncrementalMerge;
              const _Interactive = class _Interactive extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "interactive");
                }
              };
              __name(_Interactive, "Interactive");
              let Interactive = _Interactive;
              const _Jog = class _Jog extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "jog", ["usePrinterSetting", "none", "pageSet"]);
                }
              };
              __name(_Jog, "Jog");
              let Jog = _Jog;
              const _LabelPrinter = class _LabelPrinter extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "labelPrinter", true);
                  this.name = (0, _utils.getStringOption)(attributes.name, ["zpl", "dpl", "ipl", "tcpl"]);
                  this.batchOutput = null;
                  this.flipLabel = null;
                  this.fontInfo = null;
                  this.xdc = null;
                }
              };
              __name(_LabelPrinter, "LabelPrinter");
              let LabelPrinter = _LabelPrinter;
              const _Layout = class _Layout extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "layout", ["paginate", "panel"]);
                }
              };
              __name(_Layout, "Layout");
              let Layout = _Layout;
              const _Level = class _Level extends _xfa_object.IntegerObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "level", 0, (n) => n > 0);
                }
              };
              __name(_Level, "Level");
              let Level = _Level;
              const _Linearized = class _Linearized extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "linearized");
                }
              };
              __name(_Linearized, "Linearized");
              let Linearized = _Linearized;
              const _Locale = class _Locale extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "locale");
                }
              };
              __name(_Locale, "Locale");
              let Locale = _Locale;
              const _LocaleSet = class _LocaleSet extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "localeSet");
                }
              };
              __name(_LocaleSet, "LocaleSet");
              let LocaleSet = _LocaleSet;
              const _Log = class _Log extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "log", true);
                  this.mode = null;
                  this.threshold = null;
                  this.to = null;
                  this.uri = null;
                }
              };
              __name(_Log, "Log");
              let Log = _Log;
              const _MapElement = class _MapElement extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "map", true);
                  this.equate = new _xfa_object.XFAObjectArray();
                  this.equateRange = new _xfa_object.XFAObjectArray();
                }
              };
              __name(_MapElement, "MapElement");
              let MapElement = _MapElement;
              const _MediumInfo = class _MediumInfo extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "mediumInfo", true);
                  this.map = null;
                }
              };
              __name(_MediumInfo, "MediumInfo");
              let MediumInfo = _MediumInfo;
              const _Message = class _Message extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "message", true);
                  this.msgId = null;
                  this.severity = null;
                }
              };
              __name(_Message, "Message");
              let Message = _Message;
              const _Messaging = class _Messaging extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "messaging", true);
                  this.message = new _xfa_object.XFAObjectArray();
                }
              };
              __name(_Messaging, "Messaging");
              let Messaging = _Messaging;
              const _Mode = class _Mode extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "mode", ["append", "overwrite"]);
                }
              };
              __name(_Mode, "Mode");
              let Mode = _Mode;
              const _ModifyAnnots = class _ModifyAnnots extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "modifyAnnots");
                }
              };
              __name(_ModifyAnnots, "ModifyAnnots");
              let ModifyAnnots = _ModifyAnnots;
              const _MsgId = class _MsgId extends _xfa_object.IntegerObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "msgId", 1, (n) => n >= 1);
                }
              };
              __name(_MsgId, "MsgId");
              let MsgId = _MsgId;
              const _NameAttr = class _NameAttr extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "nameAttr");
                }
              };
              __name(_NameAttr, "NameAttr");
              let NameAttr = _NameAttr;
              const _NeverEmbed = class _NeverEmbed extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "neverEmbed");
                }
              };
              __name(_NeverEmbed, "NeverEmbed");
              let NeverEmbed = _NeverEmbed;
              const _NumberOfCopies = class _NumberOfCopies extends _xfa_object.IntegerObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "numberOfCopies", null, (n) => n >= 2 && n <= 5);
                }
              };
              __name(_NumberOfCopies, "NumberOfCopies");
              let NumberOfCopies = _NumberOfCopies;
              const _OpenAction = class _OpenAction extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "openAction", true);
                  this.destination = null;
                }
              };
              __name(_OpenAction, "OpenAction");
              let OpenAction = _OpenAction;
              const _Output = class _Output extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "output", true);
                  this.to = null;
                  this.type = null;
                  this.uri = null;
                }
              };
              __name(_Output, "Output");
              let Output = _Output;
              const _OutputBin = class _OutputBin extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "outputBin");
                }
              };
              __name(_OutputBin, "OutputBin");
              let OutputBin = _OutputBin;
              const _OutputXSL = class _OutputXSL extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "outputXSL", true);
                  this.uri = null;
                }
              };
              __name(_OutputXSL, "OutputXSL");
              let OutputXSL = _OutputXSL;
              const _Overprint = class _Overprint extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "overprint", ["none", "both", "draw", "field"]);
                }
              };
              __name(_Overprint, "Overprint");
              let Overprint = _Overprint;
              const _Packets = class _Packets extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "packets");
                }
                [_xfa_object.$finalize]() {
                  if (this[_xfa_object.$content] === "*") {
                    return;
                  }
                  this[_xfa_object.$content] = this[_xfa_object.$content].trim().split(/\s+/).filter((x) => ["config", "datasets", "template", "xfdf", "xslt"].includes(x));
                }
              };
              __name(_Packets, "Packets");
              let Packets = _Packets;
              const _PageOffset = class _PageOffset extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "pageOffset");
                  this.x = (0, _utils.getInteger)({
                    data: attributes.x,
                    defaultValue: "useXDCSetting",
                    validate: (n) => true
                  });
                  this.y = (0, _utils.getInteger)({
                    data: attributes.y,
                    defaultValue: "useXDCSetting",
                    validate: (n) => true
                  });
                }
              };
              __name(_PageOffset, "PageOffset");
              let PageOffset = _PageOffset;
              const _PageRange = class _PageRange extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "pageRange");
                }
                [_xfa_object.$finalize]() {
                  const numbers = this[_xfa_object.$content].trim().split(/\s+/).map((x) => parseInt(x, 10));
                  const ranges = [];
                  for (let i = 0, ii = numbers.length; i < ii; i += 2) {
                    ranges.push(numbers.slice(i, i + 2));
                  }
                  this[_xfa_object.$content] = ranges;
                }
              };
              __name(_PageRange, "PageRange");
              let PageRange = _PageRange;
              const _Pagination = class _Pagination extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "pagination", ["simplex", "duplexShortEdge", "duplexLongEdge"]);
                }
              };
              __name(_Pagination, "Pagination");
              let Pagination = _Pagination;
              const _PaginationOverride = class _PaginationOverride extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "paginationOverride", ["none", "forceDuplex", "forceDuplexLongEdge", "forceDuplexShortEdge", "forceSimplex"]);
                }
              };
              __name(_PaginationOverride, "PaginationOverride");
              let PaginationOverride = _PaginationOverride;
              const _Part = class _Part extends _xfa_object.IntegerObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "part", 1, (n) => false);
                }
              };
              __name(_Part, "Part");
              let Part = _Part;
              const _Pcl = class _Pcl extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "pcl", true);
                  this.name = attributes.name || "";
                  this.batchOutput = null;
                  this.fontInfo = null;
                  this.jog = null;
                  this.mediumInfo = null;
                  this.outputBin = null;
                  this.pageOffset = null;
                  this.staple = null;
                  this.xdc = null;
                }
              };
              __name(_Pcl, "Pcl");
              let Pcl = _Pcl;
              const _Pdf = class _Pdf extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "pdf", true);
                  this.name = attributes.name || "";
                  this.adobeExtensionLevel = null;
                  this.batchOutput = null;
                  this.compression = null;
                  this.creator = null;
                  this.encryption = null;
                  this.fontInfo = null;
                  this.interactive = null;
                  this.linearized = null;
                  this.openAction = null;
                  this.pdfa = null;
                  this.producer = null;
                  this.renderPolicy = null;
                  this.scriptModel = null;
                  this.silentPrint = null;
                  this.submitFormat = null;
                  this.tagged = null;
                  this.version = null;
                  this.viewerPreferences = null;
                  this.xdc = null;
                }
              };
              __name(_Pdf, "Pdf");
              let Pdf = _Pdf;
              const _Pdfa = class _Pdfa extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "pdfa", true);
                  this.amd = null;
                  this.conformance = null;
                  this.includeXDPContent = null;
                  this.part = null;
                }
              };
              __name(_Pdfa, "Pdfa");
              let Pdfa = _Pdfa;
              const _Permissions = class _Permissions extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "permissions", true);
                  this.accessibleContent = null;
                  this.change = null;
                  this.contentCopy = null;
                  this.documentAssembly = null;
                  this.formFieldFilling = null;
                  this.modifyAnnots = null;
                  this.plaintextMetadata = null;
                  this.print = null;
                  this.printHighQuality = null;
                }
              };
              __name(_Permissions, "Permissions");
              let Permissions = _Permissions;
              const _PickTrayByPDFSize = class _PickTrayByPDFSize extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "pickTrayByPDFSize");
                }
              };
              __name(_PickTrayByPDFSize, "PickTrayByPDFSize");
              let PickTrayByPDFSize = _PickTrayByPDFSize;
              const _Picture = class _Picture extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "picture");
                }
              };
              __name(_Picture, "Picture");
              let Picture = _Picture;
              const _PlaintextMetadata = class _PlaintextMetadata extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "plaintextMetadata");
                }
              };
              __name(_PlaintextMetadata, "PlaintextMetadata");
              let PlaintextMetadata = _PlaintextMetadata;
              const _Presence = class _Presence extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "presence", ["preserve", "dissolve", "dissolveStructure", "ignore", "remove"]);
                }
              };
              __name(_Presence, "Presence");
              let Presence = _Presence;
              const _Present = class _Present extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "present", true);
                  this.behaviorOverride = null;
                  this.cache = null;
                  this.common = null;
                  this.copies = null;
                  this.destination = null;
                  this.incrementalMerge = null;
                  this.layout = null;
                  this.output = null;
                  this.overprint = null;
                  this.pagination = null;
                  this.paginationOverride = null;
                  this.script = null;
                  this.validate = null;
                  this.xdp = null;
                  this.driver = new _xfa_object.XFAObjectArray();
                  this.labelPrinter = new _xfa_object.XFAObjectArray();
                  this.pcl = new _xfa_object.XFAObjectArray();
                  this.pdf = new _xfa_object.XFAObjectArray();
                  this.ps = new _xfa_object.XFAObjectArray();
                  this.submitUrl = new _xfa_object.XFAObjectArray();
                  this.webClient = new _xfa_object.XFAObjectArray();
                  this.zpl = new _xfa_object.XFAObjectArray();
                }
              };
              __name(_Present, "Present");
              let Present = _Present;
              const _Print = class _Print extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "print");
                }
              };
              __name(_Print, "Print");
              let Print = _Print;
              const _PrintHighQuality = class _PrintHighQuality extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "printHighQuality");
                }
              };
              __name(_PrintHighQuality, "PrintHighQuality");
              let PrintHighQuality = _PrintHighQuality;
              const _PrintScaling = class _PrintScaling extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "printScaling", ["appdefault", "noScaling"]);
                }
              };
              __name(_PrintScaling, "PrintScaling");
              let PrintScaling = _PrintScaling;
              const _PrinterName = class _PrinterName extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "printerName");
                }
              };
              __name(_PrinterName, "PrinterName");
              let PrinterName = _PrinterName;
              const _Producer = class _Producer extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "producer");
                }
              };
              __name(_Producer, "Producer");
              let Producer = _Producer;
              const _Ps = class _Ps extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "ps", true);
                  this.name = attributes.name || "";
                  this.batchOutput = null;
                  this.fontInfo = null;
                  this.jog = null;
                  this.mediumInfo = null;
                  this.outputBin = null;
                  this.staple = null;
                  this.xdc = null;
                }
              };
              __name(_Ps, "Ps");
              let Ps = _Ps;
              const _Range = class _Range extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "range");
                }
                [_xfa_object.$finalize]() {
                  this[_xfa_object.$content] = this[_xfa_object.$content].trim().split(/\s*,\s*/, 2).map((range) => range.split("-").map((x) => parseInt(x.trim(), 10))).filter((range) => range.every((x) => !isNaN(x))).map((range) => {
                    if (range.length === 1) {
                      range.push(range[0]);
                    }
                    return range;
                  });
                }
              };
              __name(_Range, "Range");
              let Range = _Range;
              const _Record = class _Record extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "record");
                }
                [_xfa_object.$finalize]() {
                  this[_xfa_object.$content] = this[_xfa_object.$content].trim();
                  const n = parseInt(this[_xfa_object.$content], 10);
                  if (!isNaN(n) && n >= 0) {
                    this[_xfa_object.$content] = n;
                  }
                }
              };
              __name(_Record, "Record");
              let Record = _Record;
              const _Relevant = class _Relevant extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "relevant");
                }
                [_xfa_object.$finalize]() {
                  this[_xfa_object.$content] = this[_xfa_object.$content].trim().split(/\s+/);
                }
              };
              __name(_Relevant, "Relevant");
              let Relevant = _Relevant;
              const _Rename = class _Rename extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "rename");
                }
                [_xfa_object.$finalize]() {
                  this[_xfa_object.$content] = this[_xfa_object.$content].trim();
                  if (this[_xfa_object.$content].toLowerCase().startsWith("xml") || this[_xfa_object.$content].match(new RegExp("[\\p{L}_][\\p{L}\\d._\\p{M}-]*", "u"))) {
                    (0, _util.warn)("XFA - Rename: invalid XFA name");
                  }
                }
              };
              __name(_Rename, "Rename");
              let Rename = _Rename;
              const _RenderPolicy = class _RenderPolicy extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "renderPolicy", ["server", "client"]);
                }
              };
              __name(_RenderPolicy, "RenderPolicy");
              let RenderPolicy = _RenderPolicy;
              const _RunScripts = class _RunScripts extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "runScripts", ["both", "client", "none", "server"]);
                }
              };
              __name(_RunScripts, "RunScripts");
              let RunScripts = _RunScripts;
              const _Script = class _Script extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "script", true);
                  this.currentPage = null;
                  this.exclude = null;
                  this.runScripts = null;
                }
              };
              __name(_Script, "Script");
              let Script = _Script;
              const _ScriptModel = class _ScriptModel extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "scriptModel", ["XFA", "none"]);
                }
              };
              __name(_ScriptModel, "ScriptModel");
              let ScriptModel = _ScriptModel;
              const _Severity = class _Severity extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "severity", ["ignore", "error", "information", "trace", "warning"]);
                }
              };
              __name(_Severity, "Severity");
              let Severity = _Severity;
              const _SilentPrint = class _SilentPrint extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "silentPrint", true);
                  this.addSilentPrint = null;
                  this.printerName = null;
                }
              };
              __name(_SilentPrint, "SilentPrint");
              let SilentPrint = _SilentPrint;
              const _Staple = class _Staple extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "staple");
                  this.mode = (0, _utils.getStringOption)(attributes.mode, ["usePrinterSetting", "on", "off"]);
                }
              };
              __name(_Staple, "Staple");
              let Staple = _Staple;
              const _StartNode = class _StartNode extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "startNode");
                }
              };
              __name(_StartNode, "StartNode");
              let StartNode = _StartNode;
              const _StartPage = class _StartPage extends _xfa_object.IntegerObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "startPage", 0, (n) => true);
                }
              };
              __name(_StartPage, "StartPage");
              let StartPage = _StartPage;
              const _SubmitFormat = class _SubmitFormat extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "submitFormat", ["html", "delegate", "fdf", "xml", "pdf"]);
                }
              };
              __name(_SubmitFormat, "SubmitFormat");
              let SubmitFormat = _SubmitFormat;
              const _SubmitUrl = class _SubmitUrl extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "submitUrl");
                }
              };
              __name(_SubmitUrl, "SubmitUrl");
              let SubmitUrl = _SubmitUrl;
              const _SubsetBelow = class _SubsetBelow extends _xfa_object.IntegerObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "subsetBelow", 100, (n) => n >= 0 && n <= 100);
                }
              };
              __name(_SubsetBelow, "SubsetBelow");
              let SubsetBelow = _SubsetBelow;
              const _SuppressBanner = class _SuppressBanner extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "suppressBanner");
                }
              };
              __name(_SuppressBanner, "SuppressBanner");
              let SuppressBanner = _SuppressBanner;
              const _Tagged = class _Tagged extends _xfa_object.Option01 {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "tagged");
                }
              };
              __name(_Tagged, "Tagged");
              let Tagged = _Tagged;
              const _Template = class _Template extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "template", true);
                  this.base = null;
                  this.relevant = null;
                  this.startPage = null;
                  this.uri = null;
                  this.xsl = null;
                }
              };
              __name(_Template, "Template");
              let Template = _Template;
              const _Threshold = class _Threshold extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "threshold", ["trace", "error", "information", "warning"]);
                }
              };
              __name(_Threshold, "Threshold");
              let Threshold = _Threshold;
              const _To = class _To extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "to", ["null", "memory", "stderr", "stdout", "system", "uri"]);
                }
              };
              __name(_To, "To");
              let To = _To;
              const _TemplateCache = class _TemplateCache extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "templateCache");
                  this.maxEntries = (0, _utils.getInteger)({
                    data: attributes.maxEntries,
                    defaultValue: 5,
                    validate: (n) => n >= 0
                  });
                }
              };
              __name(_TemplateCache, "TemplateCache");
              let TemplateCache = _TemplateCache;
              const _Trace = class _Trace extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "trace", true);
                  this.area = new _xfa_object.XFAObjectArray();
                }
              };
              __name(_Trace, "Trace");
              let Trace = _Trace;
              const _Transform = class _Transform extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "transform", true);
                  this.groupParent = null;
                  this.ifEmpty = null;
                  this.nameAttr = null;
                  this.picture = null;
                  this.presence = null;
                  this.rename = null;
                  this.whitespace = null;
                }
              };
              __name(_Transform, "Transform");
              let Transform = _Transform;
              const _Type = class _Type extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "type", ["none", "ascii85", "asciiHex", "ccittfax", "flate", "lzw", "runLength", "native", "xdp", "mergedXDP"]);
                }
              };
              __name(_Type, "Type");
              let Type = _Type;
              const _Uri = class _Uri extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "uri");
                }
              };
              __name(_Uri, "Uri");
              let Uri = _Uri;
              const _Validate = class _Validate extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "validate", ["preSubmit", "prePrint", "preExecute", "preSave"]);
                }
              };
              __name(_Validate, "Validate");
              let Validate = _Validate;
              const _ValidateApprovalSignatures = class _ValidateApprovalSignatures extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "validateApprovalSignatures");
                }
                [_xfa_object.$finalize]() {
                  this[_xfa_object.$content] = this[_xfa_object.$content].trim().split(/\s+/).filter((x) => ["docReady", "postSign"].includes(x));
                }
              };
              __name(_ValidateApprovalSignatures, "ValidateApprovalSignatures");
              let ValidateApprovalSignatures = _ValidateApprovalSignatures;
              const _ValidationMessaging = class _ValidationMessaging extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "validationMessaging", ["allMessagesIndividually", "allMessagesTogether", "firstMessageOnly", "noMessages"]);
                }
              };
              __name(_ValidationMessaging, "ValidationMessaging");
              let ValidationMessaging = _ValidationMessaging;
              const _Version = class _Version extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "version", ["1.7", "1.6", "1.5", "1.4", "1.3", "1.2"]);
                }
              };
              __name(_Version, "Version");
              let Version = _Version;
              const _VersionControl = class _VersionControl extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "VersionControl");
                  this.outputBelow = (0, _utils.getStringOption)(attributes.outputBelow, ["warn", "error", "update"]);
                  this.sourceAbove = (0, _utils.getStringOption)(attributes.sourceAbove, ["warn", "error"]);
                  this.sourceBelow = (0, _utils.getStringOption)(attributes.sourceBelow, ["update", "maintain"]);
                }
              };
              __name(_VersionControl, "VersionControl");
              let VersionControl = _VersionControl;
              const _ViewerPreferences = class _ViewerPreferences extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "viewerPreferences", true);
                  this.ADBE_JSConsole = null;
                  this.ADBE_JSDebugger = null;
                  this.addViewerPreferences = null;
                  this.duplexOption = null;
                  this.enforce = null;
                  this.numberOfCopies = null;
                  this.pageRange = null;
                  this.pickTrayByPDFSize = null;
                  this.printScaling = null;
                }
              };
              __name(_ViewerPreferences, "ViewerPreferences");
              let ViewerPreferences = _ViewerPreferences;
              const _WebClient = class _WebClient extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "webClient", true);
                  this.name = attributes.name ? attributes.name.trim() : "";
                  this.fontInfo = null;
                  this.xdc = null;
                }
              };
              __name(_WebClient, "WebClient");
              let WebClient = _WebClient;
              const _Whitespace = class _Whitespace extends _xfa_object.OptionObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "whitespace", ["preserve", "ltrim", "normalize", "rtrim", "trim"]);
                }
              };
              __name(_Whitespace, "Whitespace");
              let Whitespace = _Whitespace;
              const _Window = class _Window extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "window");
                }
                [_xfa_object.$finalize]() {
                  const pair = this[_xfa_object.$content].trim().split(/\s*,\s*/, 2).map((x) => parseInt(x, 10));
                  if (pair.some((x) => isNaN(x))) {
                    this[_xfa_object.$content] = [0, 0];
                    return;
                  }
                  if (pair.length === 1) {
                    pair.push(pair[0]);
                  }
                  this[_xfa_object.$content] = pair;
                }
              };
              __name(_Window, "Window");
              let Window = _Window;
              const _Xdc = class _Xdc extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "xdc", true);
                  this.uri = new _xfa_object.XFAObjectArray();
                  this.xsl = new _xfa_object.XFAObjectArray();
                }
              };
              __name(_Xdc, "Xdc");
              let Xdc = _Xdc;
              const _Xdp = class _Xdp extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "xdp", true);
                  this.packets = null;
                }
              };
              __name(_Xdp, "Xdp");
              let Xdp = _Xdp;
              const _Xsl = class _Xsl extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "xsl", true);
                  this.debug = null;
                  this.uri = null;
                }
              };
              __name(_Xsl, "Xsl");
              let Xsl = _Xsl;
              const _Zpl = class _Zpl extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONFIG_NS_ID, "zpl", true);
                  this.name = attributes.name ? attributes.name.trim() : "";
                  this.batchOutput = null;
                  this.flipLabel = null;
                  this.fontInfo = null;
                  this.xdc = null;
                }
              };
              __name(_Zpl, "Zpl");
              let Zpl = _Zpl;
              const _ConfigNamespace = class _ConfigNamespace {
                static [_namespaces.$buildXFAObject](name, attributes) {
                  if (_ConfigNamespace.hasOwnProperty(name)) {
                    return _ConfigNamespace[name](attributes);
                  }
                  return void 0;
                }
                static acrobat(attrs) {
                  return new Acrobat(attrs);
                }
                static acrobat7(attrs) {
                  return new Acrobat7(attrs);
                }
                static ADBE_JSConsole(attrs) {
                  return new ADBE_JSConsole(attrs);
                }
                static ADBE_JSDebugger(attrs) {
                  return new ADBE_JSDebugger(attrs);
                }
                static addSilentPrint(attrs) {
                  return new AddSilentPrint(attrs);
                }
                static addViewerPreferences(attrs) {
                  return new AddViewerPreferences(attrs);
                }
                static adjustData(attrs) {
                  return new AdjustData(attrs);
                }
                static adobeExtensionLevel(attrs) {
                  return new AdobeExtensionLevel(attrs);
                }
                static agent(attrs) {
                  return new Agent(attrs);
                }
                static alwaysEmbed(attrs) {
                  return new AlwaysEmbed(attrs);
                }
                static amd(attrs) {
                  return new Amd(attrs);
                }
                static area(attrs) {
                  return new Area(attrs);
                }
                static attributes(attrs) {
                  return new Attributes(attrs);
                }
                static autoSave(attrs) {
                  return new AutoSave(attrs);
                }
                static base(attrs) {
                  return new Base(attrs);
                }
                static batchOutput(attrs) {
                  return new BatchOutput(attrs);
                }
                static behaviorOverride(attrs) {
                  return new BehaviorOverride(attrs);
                }
                static cache(attrs) {
                  return new Cache(attrs);
                }
                static change(attrs) {
                  return new Change(attrs);
                }
                static common(attrs) {
                  return new Common(attrs);
                }
                static compress(attrs) {
                  return new Compress(attrs);
                }
                static compressLogicalStructure(attrs) {
                  return new CompressLogicalStructure(attrs);
                }
                static compressObjectStream(attrs) {
                  return new CompressObjectStream(attrs);
                }
                static compression(attrs) {
                  return new Compression(attrs);
                }
                static config(attrs) {
                  return new Config(attrs);
                }
                static conformance(attrs) {
                  return new Conformance(attrs);
                }
                static contentCopy(attrs) {
                  return new ContentCopy(attrs);
                }
                static copies(attrs) {
                  return new Copies(attrs);
                }
                static creator(attrs) {
                  return new Creator(attrs);
                }
                static currentPage(attrs) {
                  return new CurrentPage(attrs);
                }
                static data(attrs) {
                  return new Data(attrs);
                }
                static debug(attrs) {
                  return new Debug(attrs);
                }
                static defaultTypeface(attrs) {
                  return new DefaultTypeface(attrs);
                }
                static destination(attrs) {
                  return new Destination(attrs);
                }
                static documentAssembly(attrs) {
                  return new DocumentAssembly(attrs);
                }
                static driver(attrs) {
                  return new Driver(attrs);
                }
                static duplexOption(attrs) {
                  return new DuplexOption(attrs);
                }
                static dynamicRender(attrs) {
                  return new DynamicRender(attrs);
                }
                static embed(attrs) {
                  return new Embed(attrs);
                }
                static encrypt(attrs) {
                  return new Encrypt(attrs);
                }
                static encryption(attrs) {
                  return new Encryption(attrs);
                }
                static encryptionLevel(attrs) {
                  return new EncryptionLevel(attrs);
                }
                static enforce(attrs) {
                  return new Enforce(attrs);
                }
                static equate(attrs) {
                  return new Equate(attrs);
                }
                static equateRange(attrs) {
                  return new EquateRange(attrs);
                }
                static exclude(attrs) {
                  return new Exclude(attrs);
                }
                static excludeNS(attrs) {
                  return new ExcludeNS(attrs);
                }
                static flipLabel(attrs) {
                  return new FlipLabel(attrs);
                }
                static fontInfo(attrs) {
                  return new FontInfo(attrs);
                }
                static formFieldFilling(attrs) {
                  return new FormFieldFilling(attrs);
                }
                static groupParent(attrs) {
                  return new GroupParent(attrs);
                }
                static ifEmpty(attrs) {
                  return new IfEmpty(attrs);
                }
                static includeXDPContent(attrs) {
                  return new IncludeXDPContent(attrs);
                }
                static incrementalLoad(attrs) {
                  return new IncrementalLoad(attrs);
                }
                static incrementalMerge(attrs) {
                  return new IncrementalMerge(attrs);
                }
                static interactive(attrs) {
                  return new Interactive(attrs);
                }
                static jog(attrs) {
                  return new Jog(attrs);
                }
                static labelPrinter(attrs) {
                  return new LabelPrinter(attrs);
                }
                static layout(attrs) {
                  return new Layout(attrs);
                }
                static level(attrs) {
                  return new Level(attrs);
                }
                static linearized(attrs) {
                  return new Linearized(attrs);
                }
                static locale(attrs) {
                  return new Locale(attrs);
                }
                static localeSet(attrs) {
                  return new LocaleSet(attrs);
                }
                static log(attrs) {
                  return new Log(attrs);
                }
                static map(attrs) {
                  return new MapElement(attrs);
                }
                static mediumInfo(attrs) {
                  return new MediumInfo(attrs);
                }
                static message(attrs) {
                  return new Message(attrs);
                }
                static messaging(attrs) {
                  return new Messaging(attrs);
                }
                static mode(attrs) {
                  return new Mode(attrs);
                }
                static modifyAnnots(attrs) {
                  return new ModifyAnnots(attrs);
                }
                static msgId(attrs) {
                  return new MsgId(attrs);
                }
                static nameAttr(attrs) {
                  return new NameAttr(attrs);
                }
                static neverEmbed(attrs) {
                  return new NeverEmbed(attrs);
                }
                static numberOfCopies(attrs) {
                  return new NumberOfCopies(attrs);
                }
                static openAction(attrs) {
                  return new OpenAction(attrs);
                }
                static output(attrs) {
                  return new Output(attrs);
                }
                static outputBin(attrs) {
                  return new OutputBin(attrs);
                }
                static outputXSL(attrs) {
                  return new OutputXSL(attrs);
                }
                static overprint(attrs) {
                  return new Overprint(attrs);
                }
                static packets(attrs) {
                  return new Packets(attrs);
                }
                static pageOffset(attrs) {
                  return new PageOffset(attrs);
                }
                static pageRange(attrs) {
                  return new PageRange(attrs);
                }
                static pagination(attrs) {
                  return new Pagination(attrs);
                }
                static paginationOverride(attrs) {
                  return new PaginationOverride(attrs);
                }
                static part(attrs) {
                  return new Part(attrs);
                }
                static pcl(attrs) {
                  return new Pcl(attrs);
                }
                static pdf(attrs) {
                  return new Pdf(attrs);
                }
                static pdfa(attrs) {
                  return new Pdfa(attrs);
                }
                static permissions(attrs) {
                  return new Permissions(attrs);
                }
                static pickTrayByPDFSize(attrs) {
                  return new PickTrayByPDFSize(attrs);
                }
                static picture(attrs) {
                  return new Picture(attrs);
                }
                static plaintextMetadata(attrs) {
                  return new PlaintextMetadata(attrs);
                }
                static presence(attrs) {
                  return new Presence(attrs);
                }
                static present(attrs) {
                  return new Present(attrs);
                }
                static print(attrs) {
                  return new Print(attrs);
                }
                static printHighQuality(attrs) {
                  return new PrintHighQuality(attrs);
                }
                static printScaling(attrs) {
                  return new PrintScaling(attrs);
                }
                static printerName(attrs) {
                  return new PrinterName(attrs);
                }
                static producer(attrs) {
                  return new Producer(attrs);
                }
                static ps(attrs) {
                  return new Ps(attrs);
                }
                static range(attrs) {
                  return new Range(attrs);
                }
                static record(attrs) {
                  return new Record(attrs);
                }
                static relevant(attrs) {
                  return new Relevant(attrs);
                }
                static rename(attrs) {
                  return new Rename(attrs);
                }
                static renderPolicy(attrs) {
                  return new RenderPolicy(attrs);
                }
                static runScripts(attrs) {
                  return new RunScripts(attrs);
                }
                static script(attrs) {
                  return new Script(attrs);
                }
                static scriptModel(attrs) {
                  return new ScriptModel(attrs);
                }
                static severity(attrs) {
                  return new Severity(attrs);
                }
                static silentPrint(attrs) {
                  return new SilentPrint(attrs);
                }
                static staple(attrs) {
                  return new Staple(attrs);
                }
                static startNode(attrs) {
                  return new StartNode(attrs);
                }
                static startPage(attrs) {
                  return new StartPage(attrs);
                }
                static submitFormat(attrs) {
                  return new SubmitFormat(attrs);
                }
                static submitUrl(attrs) {
                  return new SubmitUrl(attrs);
                }
                static subsetBelow(attrs) {
                  return new SubsetBelow(attrs);
                }
                static suppressBanner(attrs) {
                  return new SuppressBanner(attrs);
                }
                static tagged(attrs) {
                  return new Tagged(attrs);
                }
                static template(attrs) {
                  return new Template(attrs);
                }
                static templateCache(attrs) {
                  return new TemplateCache(attrs);
                }
                static threshold(attrs) {
                  return new Threshold(attrs);
                }
                static to(attrs) {
                  return new To(attrs);
                }
                static trace(attrs) {
                  return new Trace(attrs);
                }
                static transform(attrs) {
                  return new Transform(attrs);
                }
                static type(attrs) {
                  return new Type(attrs);
                }
                static uri(attrs) {
                  return new Uri(attrs);
                }
                static validate(attrs) {
                  return new Validate(attrs);
                }
                static validateApprovalSignatures(attrs) {
                  return new ValidateApprovalSignatures(attrs);
                }
                static validationMessaging(attrs) {
                  return new ValidationMessaging(attrs);
                }
                static version(attrs) {
                  return new Version(attrs);
                }
                static versionControl(attrs) {
                  return new VersionControl(attrs);
                }
                static viewerPreferences(attrs) {
                  return new ViewerPreferences(attrs);
                }
                static webClient(attrs) {
                  return new WebClient(attrs);
                }
                static whitespace(attrs) {
                  return new Whitespace(attrs);
                }
                static window(attrs) {
                  return new Window(attrs);
                }
                static xdc(attrs) {
                  return new Xdc(attrs);
                }
                static xdp(attrs) {
                  return new Xdp(attrs);
                }
                static xsl(attrs) {
                  return new Xsl(attrs);
                }
                static zpl(attrs) {
                  return new Zpl(attrs);
                }
              };
              __name(_ConfigNamespace, "ConfigNamespace");
              let ConfigNamespace = _ConfigNamespace;
              exports2.ConfigNamespace = ConfigNamespace;
            },
            /* 217 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.ConnectionSetNamespace = void 0;
              var _namespaces = __w_pdfjs_require__2(204);
              var _xfa_object = __w_pdfjs_require__2(202);
              const CONNECTION_SET_NS_ID = _namespaces.NamespaceIds.connectionSet.id;
              const _ConnectionSet = class _ConnectionSet extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONNECTION_SET_NS_ID, "connectionSet", true);
                  this.wsdlConnection = new _xfa_object.XFAObjectArray();
                  this.xmlConnection = new _xfa_object.XFAObjectArray();
                  this.xsdConnection = new _xfa_object.XFAObjectArray();
                }
              };
              __name(_ConnectionSet, "ConnectionSet");
              let ConnectionSet = _ConnectionSet;
              const _EffectiveInputPolicy = class _EffectiveInputPolicy extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONNECTION_SET_NS_ID, "effectiveInputPolicy");
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              };
              __name(_EffectiveInputPolicy, "EffectiveInputPolicy");
              let EffectiveInputPolicy = _EffectiveInputPolicy;
              const _EffectiveOutputPolicy = class _EffectiveOutputPolicy extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONNECTION_SET_NS_ID, "effectiveOutputPolicy");
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              };
              __name(_EffectiveOutputPolicy, "EffectiveOutputPolicy");
              let EffectiveOutputPolicy = _EffectiveOutputPolicy;
              const _Operation = class _Operation extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONNECTION_SET_NS_ID, "operation");
                  this.id = attributes.id || "";
                  this.input = attributes.input || "";
                  this.name = attributes.name || "";
                  this.output = attributes.output || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              };
              __name(_Operation, "Operation");
              let Operation = _Operation;
              const _RootElement = class _RootElement extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONNECTION_SET_NS_ID, "rootElement");
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              };
              __name(_RootElement, "RootElement");
              let RootElement = _RootElement;
              const _SoapAction = class _SoapAction extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONNECTION_SET_NS_ID, "soapAction");
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              };
              __name(_SoapAction, "SoapAction");
              let SoapAction = _SoapAction;
              const _SoapAddress = class _SoapAddress extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONNECTION_SET_NS_ID, "soapAddress");
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              };
              __name(_SoapAddress, "SoapAddress");
              let SoapAddress = _SoapAddress;
              const _Uri = class _Uri extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONNECTION_SET_NS_ID, "uri");
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              };
              __name(_Uri, "Uri");
              let Uri = _Uri;
              const _WsdlAddress = class _WsdlAddress extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(CONNECTION_SET_NS_ID, "wsdlAddress");
                  this.id = attributes.id || "";
                  this.name = attributes.name || "";
                  this.use = attributes.use || "";
                  this.usehref = attributes.usehref || "";
                }
              };
              __name(_WsdlAddress, "WsdlAddress");
              let WsdlAddress = _WsdlAddress;
              const _WsdlConnection = class _WsdlConnection extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONNECTION_SET_NS_ID, "wsdlConnection", true);
                  this.dataDescription = attributes.dataDescription || "";
                  this.name = attributes.name || "";
                  this.effectiveInputPolicy = null;
                  this.effectiveOutputPolicy = null;
                  this.operation = null;
                  this.soapAction = null;
                  this.soapAddress = null;
                  this.wsdlAddress = null;
                }
              };
              __name(_WsdlConnection, "WsdlConnection");
              let WsdlConnection = _WsdlConnection;
              const _XmlConnection = class _XmlConnection extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONNECTION_SET_NS_ID, "xmlConnection", true);
                  this.dataDescription = attributes.dataDescription || "";
                  this.name = attributes.name || "";
                  this.uri = null;
                }
              };
              __name(_XmlConnection, "XmlConnection");
              let XmlConnection = _XmlConnection;
              const _XsdConnection = class _XsdConnection extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(CONNECTION_SET_NS_ID, "xsdConnection", true);
                  this.dataDescription = attributes.dataDescription || "";
                  this.name = attributes.name || "";
                  this.rootElement = null;
                  this.uri = null;
                }
              };
              __name(_XsdConnection, "XsdConnection");
              let XsdConnection = _XsdConnection;
              const _ConnectionSetNamespace = class _ConnectionSetNamespace {
                static [_namespaces.$buildXFAObject](name, attributes) {
                  if (_ConnectionSetNamespace.hasOwnProperty(name)) {
                    return _ConnectionSetNamespace[name](attributes);
                  }
                  return void 0;
                }
                static connectionSet(attrs) {
                  return new ConnectionSet(attrs);
                }
                static effectiveInputPolicy(attrs) {
                  return new EffectiveInputPolicy(attrs);
                }
                static effectiveOutputPolicy(attrs) {
                  return new EffectiveOutputPolicy(attrs);
                }
                static operation(attrs) {
                  return new Operation(attrs);
                }
                static rootElement(attrs) {
                  return new RootElement(attrs);
                }
                static soapAction(attrs) {
                  return new SoapAction(attrs);
                }
                static soapAddress(attrs) {
                  return new SoapAddress(attrs);
                }
                static uri(attrs) {
                  return new Uri(attrs);
                }
                static wsdlAddress(attrs) {
                  return new WsdlAddress(attrs);
                }
                static wsdlConnection(attrs) {
                  return new WsdlConnection(attrs);
                }
                static xmlConnection(attrs) {
                  return new XmlConnection(attrs);
                }
                static xsdConnection(attrs) {
                  return new XsdConnection(attrs);
                }
              };
              __name(_ConnectionSetNamespace, "ConnectionSetNamespace");
              let ConnectionSetNamespace = _ConnectionSetNamespace;
              exports2.ConnectionSetNamespace = ConnectionSetNamespace;
            },
            /* 218 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.DatasetsNamespace = void 0;
              var _xfa_object = __w_pdfjs_require__2(202);
              var _namespaces = __w_pdfjs_require__2(204);
              const DATASETS_NS_ID = _namespaces.NamespaceIds.datasets.id;
              const _Data = class _Data extends _xfa_object.XmlObject {
                constructor(attributes) {
                  super(DATASETS_NS_ID, "data", attributes);
                }
                [_xfa_object.$isNsAgnostic]() {
                  return true;
                }
              };
              __name(_Data, "Data");
              let Data = _Data;
              const _Datasets = class _Datasets extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(DATASETS_NS_ID, "datasets", true);
                  this.data = null;
                  this.Signature = null;
                }
                [_xfa_object.$onChild](child) {
                  const name = child[_xfa_object.$nodeName];
                  if (name === "data" && child[_xfa_object.$namespaceId] === DATASETS_NS_ID || name === "Signature" && child[_xfa_object.$namespaceId] === _namespaces.NamespaceIds.signature.id) {
                    this[name] = child;
                  }
                  this[_xfa_object.$appendChild](child);
                }
              };
              __name(_Datasets, "Datasets");
              let Datasets = _Datasets;
              const _DatasetsNamespace = class _DatasetsNamespace {
                static [_namespaces.$buildXFAObject](name, attributes) {
                  if (_DatasetsNamespace.hasOwnProperty(name)) {
                    return _DatasetsNamespace[name](attributes);
                  }
                  return void 0;
                }
                static datasets(attributes) {
                  return new Datasets(attributes);
                }
                static data(attributes) {
                  return new Data(attributes);
                }
              };
              __name(_DatasetsNamespace, "DatasetsNamespace");
              let DatasetsNamespace = _DatasetsNamespace;
              exports2.DatasetsNamespace = DatasetsNamespace;
            },
            /* 219 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.LocaleSetNamespace = void 0;
              var _namespaces = __w_pdfjs_require__2(204);
              var _xfa_object = __w_pdfjs_require__2(202);
              var _utils = __w_pdfjs_require__2(203);
              const LOCALE_SET_NS_ID = _namespaces.NamespaceIds.localeSet.id;
              const _CalendarSymbols = class _CalendarSymbols extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "calendarSymbols", true);
                  this.name = "gregorian";
                  this.dayNames = new _xfa_object.XFAObjectArray(2);
                  this.eraNames = null;
                  this.meridiemNames = null;
                  this.monthNames = new _xfa_object.XFAObjectArray(2);
                }
              };
              __name(_CalendarSymbols, "CalendarSymbols");
              let CalendarSymbols = _CalendarSymbols;
              const _CurrencySymbol = class _CurrencySymbol extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "currencySymbol");
                  this.name = (0, _utils.getStringOption)(attributes.name, ["symbol", "isoname", "decimal"]);
                }
              };
              __name(_CurrencySymbol, "CurrencySymbol");
              let CurrencySymbol = _CurrencySymbol;
              const _CurrencySymbols = class _CurrencySymbols extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "currencySymbols", true);
                  this.currencySymbol = new _xfa_object.XFAObjectArray(3);
                }
              };
              __name(_CurrencySymbols, "CurrencySymbols");
              let CurrencySymbols = _CurrencySymbols;
              const _DatePattern = class _DatePattern extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "datePattern");
                  this.name = (0, _utils.getStringOption)(attributes.name, ["full", "long", "med", "short"]);
                }
              };
              __name(_DatePattern, "DatePattern");
              let DatePattern = _DatePattern;
              const _DatePatterns = class _DatePatterns extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "datePatterns", true);
                  this.datePattern = new _xfa_object.XFAObjectArray(4);
                }
              };
              __name(_DatePatterns, "DatePatterns");
              let DatePatterns = _DatePatterns;
              const _DateTimeSymbols = class _DateTimeSymbols extends _xfa_object.ContentObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "dateTimeSymbols");
                }
              };
              __name(_DateTimeSymbols, "DateTimeSymbols");
              let DateTimeSymbols = _DateTimeSymbols;
              const _Day = class _Day extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "day");
                }
              };
              __name(_Day, "Day");
              let Day = _Day;
              const _DayNames = class _DayNames extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "dayNames", true);
                  this.abbr = (0, _utils.getInteger)({
                    data: attributes.abbr,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.day = new _xfa_object.XFAObjectArray(7);
                }
              };
              __name(_DayNames, "DayNames");
              let DayNames = _DayNames;
              const _Era = class _Era extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "era");
                }
              };
              __name(_Era, "Era");
              let Era = _Era;
              const _EraNames = class _EraNames extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "eraNames", true);
                  this.era = new _xfa_object.XFAObjectArray(2);
                }
              };
              __name(_EraNames, "EraNames");
              let EraNames = _EraNames;
              const _Locale = class _Locale extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "locale", true);
                  this.desc = attributes.desc || "";
                  this.name = "isoname";
                  this.calendarSymbols = null;
                  this.currencySymbols = null;
                  this.datePatterns = null;
                  this.dateTimeSymbols = null;
                  this.numberPatterns = null;
                  this.numberSymbols = null;
                  this.timePatterns = null;
                  this.typeFaces = null;
                }
              };
              __name(_Locale, "Locale");
              let Locale = _Locale;
              const _LocaleSet = class _LocaleSet extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "localeSet", true);
                  this.locale = new _xfa_object.XFAObjectArray();
                }
              };
              __name(_LocaleSet, "LocaleSet");
              let LocaleSet = _LocaleSet;
              const _Meridiem = class _Meridiem extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "meridiem");
                }
              };
              __name(_Meridiem, "Meridiem");
              let Meridiem = _Meridiem;
              const _MeridiemNames = class _MeridiemNames extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "meridiemNames", true);
                  this.meridiem = new _xfa_object.XFAObjectArray(2);
                }
              };
              __name(_MeridiemNames, "MeridiemNames");
              let MeridiemNames = _MeridiemNames;
              const _Month = class _Month extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "month");
                }
              };
              __name(_Month, "Month");
              let Month = _Month;
              const _MonthNames = class _MonthNames extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "monthNames", true);
                  this.abbr = (0, _utils.getInteger)({
                    data: attributes.abbr,
                    defaultValue: 0,
                    validate: (x) => x === 1
                  });
                  this.month = new _xfa_object.XFAObjectArray(12);
                }
              };
              __name(_MonthNames, "MonthNames");
              let MonthNames = _MonthNames;
              const _NumberPattern = class _NumberPattern extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "numberPattern");
                  this.name = (0, _utils.getStringOption)(attributes.name, ["full", "long", "med", "short"]);
                }
              };
              __name(_NumberPattern, "NumberPattern");
              let NumberPattern = _NumberPattern;
              const _NumberPatterns = class _NumberPatterns extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "numberPatterns", true);
                  this.numberPattern = new _xfa_object.XFAObjectArray(4);
                }
              };
              __name(_NumberPatterns, "NumberPatterns");
              let NumberPatterns = _NumberPatterns;
              const _NumberSymbol = class _NumberSymbol extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "numberSymbol");
                  this.name = (0, _utils.getStringOption)(attributes.name, ["decimal", "grouping", "percent", "minus", "zero"]);
                }
              };
              __name(_NumberSymbol, "NumberSymbol");
              let NumberSymbol = _NumberSymbol;
              const _NumberSymbols = class _NumberSymbols extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "numberSymbols", true);
                  this.numberSymbol = new _xfa_object.XFAObjectArray(5);
                }
              };
              __name(_NumberSymbols, "NumberSymbols");
              let NumberSymbols = _NumberSymbols;
              const _TimePattern = class _TimePattern extends _xfa_object.StringObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "timePattern");
                  this.name = (0, _utils.getStringOption)(attributes.name, ["full", "long", "med", "short"]);
                }
              };
              __name(_TimePattern, "TimePattern");
              let TimePattern = _TimePattern;
              const _TimePatterns = class _TimePatterns extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "timePatterns", true);
                  this.timePattern = new _xfa_object.XFAObjectArray(4);
                }
              };
              __name(_TimePatterns, "TimePatterns");
              let TimePatterns = _TimePatterns;
              const _TypeFace = class _TypeFace extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "typeFace", true);
                  this.name = attributes.name | "";
                }
              };
              __name(_TypeFace, "TypeFace");
              let TypeFace = _TypeFace;
              const _TypeFaces = class _TypeFaces extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(LOCALE_SET_NS_ID, "typeFaces", true);
                  this.typeFace = new _xfa_object.XFAObjectArray();
                }
              };
              __name(_TypeFaces, "TypeFaces");
              let TypeFaces = _TypeFaces;
              const _LocaleSetNamespace = class _LocaleSetNamespace {
                static [_namespaces.$buildXFAObject](name, attributes) {
                  if (_LocaleSetNamespace.hasOwnProperty(name)) {
                    return _LocaleSetNamespace[name](attributes);
                  }
                  return void 0;
                }
                static calendarSymbols(attrs) {
                  return new CalendarSymbols(attrs);
                }
                static currencySymbol(attrs) {
                  return new CurrencySymbol(attrs);
                }
                static currencySymbols(attrs) {
                  return new CurrencySymbols(attrs);
                }
                static datePattern(attrs) {
                  return new DatePattern(attrs);
                }
                static datePatterns(attrs) {
                  return new DatePatterns(attrs);
                }
                static dateTimeSymbols(attrs) {
                  return new DateTimeSymbols(attrs);
                }
                static day(attrs) {
                  return new Day(attrs);
                }
                static dayNames(attrs) {
                  return new DayNames(attrs);
                }
                static era(attrs) {
                  return new Era(attrs);
                }
                static eraNames(attrs) {
                  return new EraNames(attrs);
                }
                static locale(attrs) {
                  return new Locale(attrs);
                }
                static localeSet(attrs) {
                  return new LocaleSet(attrs);
                }
                static meridiem(attrs) {
                  return new Meridiem(attrs);
                }
                static meridiemNames(attrs) {
                  return new MeridiemNames(attrs);
                }
                static month(attrs) {
                  return new Month(attrs);
                }
                static monthNames(attrs) {
                  return new MonthNames(attrs);
                }
                static numberPattern(attrs) {
                  return new NumberPattern(attrs);
                }
                static numberPatterns(attrs) {
                  return new NumberPatterns(attrs);
                }
                static numberSymbol(attrs) {
                  return new NumberSymbol(attrs);
                }
                static numberSymbols(attrs) {
                  return new NumberSymbols(attrs);
                }
                static timePattern(attrs) {
                  return new TimePattern(attrs);
                }
                static timePatterns(attrs) {
                  return new TimePatterns(attrs);
                }
                static typeFace(attrs) {
                  return new TypeFace(attrs);
                }
                static typeFaces(attrs) {
                  return new TypeFaces(attrs);
                }
              };
              __name(_LocaleSetNamespace, "LocaleSetNamespace");
              let LocaleSetNamespace = _LocaleSetNamespace;
              exports2.LocaleSetNamespace = LocaleSetNamespace;
            },
            /* 220 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.SignatureNamespace = void 0;
              var _namespaces = __w_pdfjs_require__2(204);
              var _xfa_object = __w_pdfjs_require__2(202);
              const SIGNATURE_NS_ID = _namespaces.NamespaceIds.signature.id;
              const _Signature = class _Signature extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(SIGNATURE_NS_ID, "signature", true);
                }
              };
              __name(_Signature, "Signature");
              let Signature = _Signature;
              const _SignatureNamespace = class _SignatureNamespace {
                static [_namespaces.$buildXFAObject](name, attributes) {
                  if (_SignatureNamespace.hasOwnProperty(name)) {
                    return _SignatureNamespace[name](attributes);
                  }
                  return void 0;
                }
                static signature(attributes) {
                  return new Signature(attributes);
                }
              };
              __name(_SignatureNamespace, "SignatureNamespace");
              let SignatureNamespace = _SignatureNamespace;
              exports2.SignatureNamespace = SignatureNamespace;
            },
            /* 221 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.StylesheetNamespace = void 0;
              var _namespaces = __w_pdfjs_require__2(204);
              var _xfa_object = __w_pdfjs_require__2(202);
              const STYLESHEET_NS_ID = _namespaces.NamespaceIds.stylesheet.id;
              const _Stylesheet = class _Stylesheet extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(STYLESHEET_NS_ID, "stylesheet", true);
                }
              };
              __name(_Stylesheet, "Stylesheet");
              let Stylesheet = _Stylesheet;
              const _StylesheetNamespace = class _StylesheetNamespace {
                static [_namespaces.$buildXFAObject](name, attributes) {
                  if (_StylesheetNamespace.hasOwnProperty(name)) {
                    return _StylesheetNamespace[name](attributes);
                  }
                  return void 0;
                }
                static stylesheet(attributes) {
                  return new Stylesheet(attributes);
                }
              };
              __name(_StylesheetNamespace, "StylesheetNamespace");
              let StylesheetNamespace = _StylesheetNamespace;
              exports2.StylesheetNamespace = StylesheetNamespace;
            },
            /* 222 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.XdpNamespace = void 0;
              var _namespaces = __w_pdfjs_require__2(204);
              var _xfa_object = __w_pdfjs_require__2(202);
              const XDP_NS_ID = _namespaces.NamespaceIds.xdp.id;
              const _Xdp = class _Xdp extends _xfa_object.XFAObject {
                constructor(attributes) {
                  super(XDP_NS_ID, "xdp", true);
                  this.uuid = attributes.uuid || "";
                  this.timeStamp = attributes.timeStamp || "";
                  this.config = null;
                  this.connectionSet = null;
                  this.datasets = null;
                  this.localeSet = null;
                  this.stylesheet = new _xfa_object.XFAObjectArray();
                  this.template = null;
                }
                [_xfa_object.$onChildCheck](child) {
                  const ns = _namespaces.NamespaceIds[child[_xfa_object.$nodeName]];
                  return ns && child[_xfa_object.$namespaceId] === ns.id;
                }
              };
              __name(_Xdp, "Xdp");
              let Xdp = _Xdp;
              const _XdpNamespace = class _XdpNamespace {
                static [_namespaces.$buildXFAObject](name, attributes) {
                  if (_XdpNamespace.hasOwnProperty(name)) {
                    return _XdpNamespace[name](attributes);
                  }
                  return void 0;
                }
                static xdp(attributes) {
                  return new Xdp(attributes);
                }
              };
              __name(_XdpNamespace, "XdpNamespace");
              let XdpNamespace = _XdpNamespace;
              exports2.XdpNamespace = XdpNamespace;
            },
            /* 223 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.XhtmlNamespace = void 0;
              var _xfa_object = __w_pdfjs_require__2(202);
              var _namespaces = __w_pdfjs_require__2(204);
              var _html_utils = __w_pdfjs_require__2(209);
              var _utils = __w_pdfjs_require__2(203);
              const XHTML_NS_ID = _namespaces.NamespaceIds.xhtml.id;
              const $richText = Symbol();
              const VALID_STYLES = /* @__PURE__ */ new Set(["color", "font", "font-family", "font-size", "font-stretch", "font-style", "font-weight", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "letter-spacing", "line-height", "orphans", "page-break-after", "page-break-before", "page-break-inside", "tab-interval", "tab-stop", "text-align", "text-decoration", "text-indent", "vertical-align", "widows", "kerning-mode", "xfa-font-horizontal-scale", "xfa-font-vertical-scale", "xfa-spacerun", "xfa-tab-stops"]);
              const StyleMapping = /* @__PURE__ */ new Map([["page-break-after", "breakAfter"], ["page-break-before", "breakBefore"], ["page-break-inside", "breakInside"], ["kerning-mode", (value) => value === "none" ? "none" : "normal"], ["xfa-font-horizontal-scale", (value) => `scaleX(${Math.max(0, Math.min(parseInt(value) / 100)).toFixed(2)})`], ["xfa-font-vertical-scale", (value) => `scaleY(${Math.max(0, Math.min(parseInt(value) / 100)).toFixed(2)})`], ["xfa-spacerun", ""], ["xfa-tab-stops", ""], ["font-size", (value, original) => {
                value = original.fontSize = (0, _utils.getMeasurement)(value);
                return (0, _html_utils.measureToString)(0.99 * value);
              }], ["letter-spacing", (value) => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["line-height", (value) => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["margin", (value) => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["margin-bottom", (value) => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["margin-left", (value) => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["margin-right", (value) => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["margin-top", (value) => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["text-indent", (value) => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["font-family", (value) => value], ["vertical-align", (value) => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))]]);
              const spacesRegExp = /\s+/g;
              const crlfRegExp = /[\r\n]+/g;
              const crlfForRichTextRegExp = /\r\n?/g;
              function mapStyle(styleStr, node, richText) {
                const style = /* @__PURE__ */ Object.create(null);
                if (!styleStr) {
                  return style;
                }
                const original = /* @__PURE__ */ Object.create(null);
                for (const [key, value] of styleStr.split(";").map((s) => s.split(":", 2))) {
                  const mapping = StyleMapping.get(key);
                  if (mapping === "") {
                    continue;
                  }
                  let newValue = value;
                  if (mapping) {
                    if (typeof mapping === "string") {
                      newValue = mapping;
                    } else {
                      newValue = mapping(value, original);
                    }
                  }
                  if (key.endsWith("scale")) {
                    if (style.transform) {
                      style.transform = `${style[key]} ${newValue}`;
                    } else {
                      style.transform = newValue;
                    }
                  } else {
                    style[key.replaceAll(/-([a-zA-Z])/g, (_, x) => x.toUpperCase())] = newValue;
                  }
                }
                if (style.fontFamily) {
                  (0, _html_utils.setFontFamily)({
                    typeface: style.fontFamily,
                    weight: style.fontWeight || "normal",
                    posture: style.fontStyle || "normal",
                    size: original.fontSize || 0
                  }, node, node[_xfa_object.$globalData].fontFinder, style);
                }
                if (richText && style.verticalAlign && style.verticalAlign !== "0px" && style.fontSize) {
                  const SUB_SUPER_SCRIPT_FACTOR = 0.583;
                  const VERTICAL_FACTOR = 0.333;
                  const fontSize = (0, _utils.getMeasurement)(style.fontSize);
                  style.fontSize = (0, _html_utils.measureToString)(fontSize * SUB_SUPER_SCRIPT_FACTOR);
                  style.verticalAlign = (0, _html_utils.measureToString)(Math.sign((0, _utils.getMeasurement)(style.verticalAlign)) * fontSize * VERTICAL_FACTOR);
                }
                if (richText && style.fontSize) {
                  style.fontSize = `calc(${style.fontSize} * var(--scale-factor))`;
                }
                (0, _html_utils.fixTextIndent)(style);
                return style;
              }
              __name(mapStyle, "mapStyle");
              function checkStyle(node) {
                if (!node.style) {
                  return "";
                }
                return node.style.trim().split(/\s*;\s*/).filter((s) => !!s).map((s) => s.split(/\s*:\s*/, 2)).filter((_ref) => {
                  let [key, value] = _ref;
                  if (key === "font-family") {
                    node[_xfa_object.$globalData].usedTypefaces.add(value);
                  }
                  return VALID_STYLES.has(key);
                }).map((kv) => kv.join(":")).join(";");
              }
              __name(checkStyle, "checkStyle");
              const NoWhites = /* @__PURE__ */ new Set(["body", "html"]);
              const _XhtmlObject = class _XhtmlObject extends _xfa_object.XmlObject {
                constructor(attributes, name) {
                  super(XHTML_NS_ID, name);
                  this[$richText] = false;
                  this.style = attributes.style || "";
                }
                [_xfa_object.$clean](builder) {
                  super[_xfa_object.$clean](builder);
                  this.style = checkStyle(this);
                }
                [_xfa_object.$acceptWhitespace]() {
                  return !NoWhites.has(this[_xfa_object.$nodeName]);
                }
                [_xfa_object.$onText](str) {
                  let richText = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  if (!richText) {
                    str = str.replace(crlfRegExp, "");
                    if (!this.style.includes("xfa-spacerun:yes")) {
                      str = str.replace(spacesRegExp, " ");
                    }
                  } else {
                    this[$richText] = true;
                  }
                  if (str) {
                    this[_xfa_object.$content] += str;
                  }
                }
                [_xfa_object.$pushGlyphs](measure) {
                  let mustPop = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                  const xfaFont = /* @__PURE__ */ Object.create(null);
                  const margin = {
                    top: NaN,
                    bottom: NaN,
                    left: NaN,
                    right: NaN
                  };
                  let lineHeight = null;
                  for (const [key, value] of this.style.split(";").map((s) => s.split(":", 2))) {
                    switch (key) {
                      case "font-family":
                        xfaFont.typeface = (0, _utils.stripQuotes)(value);
                        break;
                      case "font-size":
                        xfaFont.size = (0, _utils.getMeasurement)(value);
                        break;
                      case "font-weight":
                        xfaFont.weight = value;
                        break;
                      case "font-style":
                        xfaFont.posture = value;
                        break;
                      case "letter-spacing":
                        xfaFont.letterSpacing = (0, _utils.getMeasurement)(value);
                        break;
                      case "margin":
                        const values = value.split(/ \t/).map((x) => (0, _utils.getMeasurement)(x));
                        switch (values.length) {
                          case 1:
                            margin.top = margin.bottom = margin.left = margin.right = values[0];
                            break;
                          case 2:
                            margin.top = margin.bottom = values[0];
                            margin.left = margin.right = values[1];
                            break;
                          case 3:
                            margin.top = values[0];
                            margin.bottom = values[2];
                            margin.left = margin.right = values[1];
                            break;
                          case 4:
                            margin.top = values[0];
                            margin.left = values[1];
                            margin.bottom = values[2];
                            margin.right = values[3];
                            break;
                        }
                        break;
                      case "margin-top":
                        margin.top = (0, _utils.getMeasurement)(value);
                        break;
                      case "margin-bottom":
                        margin.bottom = (0, _utils.getMeasurement)(value);
                        break;
                      case "margin-left":
                        margin.left = (0, _utils.getMeasurement)(value);
                        break;
                      case "margin-right":
                        margin.right = (0, _utils.getMeasurement)(value);
                        break;
                      case "line-height":
                        lineHeight = (0, _utils.getMeasurement)(value);
                        break;
                    }
                  }
                  measure.pushData(xfaFont, margin, lineHeight);
                  if (this[_xfa_object.$content]) {
                    measure.addString(this[_xfa_object.$content]);
                  } else {
                    for (const child of this[_xfa_object.$getChildren]()) {
                      if (child[_xfa_object.$nodeName] === "#text") {
                        measure.addString(child[_xfa_object.$content]);
                        continue;
                      }
                      child[_xfa_object.$pushGlyphs](measure);
                    }
                  }
                  if (mustPop) {
                    measure.popFont();
                  }
                }
                [_xfa_object.$toHTML](availableSpace) {
                  const children = [];
                  this[_xfa_object.$extra] = {
                    children
                  };
                  this[_xfa_object.$childrenToHTML]({});
                  if (children.length === 0 && !this[_xfa_object.$content]) {
                    return _utils.HTMLResult.EMPTY;
                  }
                  let value;
                  if (this[$richText]) {
                    value = this[_xfa_object.$content] ? this[_xfa_object.$content].replace(crlfForRichTextRegExp, "\n") : void 0;
                  } else {
                    value = this[_xfa_object.$content] || void 0;
                  }
                  return _utils.HTMLResult.success({
                    name: this[_xfa_object.$nodeName],
                    attributes: {
                      href: this.href,
                      style: mapStyle(this.style, this, this[$richText])
                    },
                    children,
                    value
                  });
                }
              };
              __name(_XhtmlObject, "XhtmlObject");
              let XhtmlObject = _XhtmlObject;
              const _A = class _A extends XhtmlObject {
                constructor(attributes) {
                  super(attributes, "a");
                  this.href = (0, _html_utils.fixURL)(attributes.href) || "";
                }
              };
              __name(_A, "A");
              let A = _A;
              const _B = class _B extends XhtmlObject {
                constructor(attributes) {
                  super(attributes, "b");
                }
                [_xfa_object.$pushGlyphs](measure) {
                  measure.pushFont({
                    weight: "bold"
                  });
                  super[_xfa_object.$pushGlyphs](measure);
                  measure.popFont();
                }
              };
              __name(_B, "B");
              let B = _B;
              const _Body = class _Body extends XhtmlObject {
                constructor(attributes) {
                  super(attributes, "body");
                }
                [_xfa_object.$toHTML](availableSpace) {
                  const res = super[_xfa_object.$toHTML](availableSpace);
                  const {
                    html
                  } = res;
                  if (!html) {
                    return _utils.HTMLResult.EMPTY;
                  }
                  html.name = "div";
                  html.attributes.class = ["xfaRich"];
                  return res;
                }
              };
              __name(_Body, "Body");
              let Body = _Body;
              const _Br = class _Br extends XhtmlObject {
                constructor(attributes) {
                  super(attributes, "br");
                }
                [_xfa_object.$text]() {
                  return "\n";
                }
                [_xfa_object.$pushGlyphs](measure) {
                  measure.addString("\n");
                }
                [_xfa_object.$toHTML](availableSpace) {
                  return _utils.HTMLResult.success({
                    name: "br"
                  });
                }
              };
              __name(_Br, "Br");
              let Br = _Br;
              const _Html = class _Html extends XhtmlObject {
                constructor(attributes) {
                  super(attributes, "html");
                }
                [_xfa_object.$toHTML](availableSpace) {
                  const children = [];
                  this[_xfa_object.$extra] = {
                    children
                  };
                  this[_xfa_object.$childrenToHTML]({});
                  if (children.length === 0) {
                    return _utils.HTMLResult.success({
                      name: "div",
                      attributes: {
                        class: ["xfaRich"],
                        style: {}
                      },
                      value: this[_xfa_object.$content] || ""
                    });
                  }
                  if (children.length === 1) {
                    const child = children[0];
                    if (child.attributes && child.attributes.class.includes("xfaRich")) {
                      return _utils.HTMLResult.success(child);
                    }
                  }
                  return _utils.HTMLResult.success({
                    name: "div",
                    attributes: {
                      class: ["xfaRich"],
                      style: {}
                    },
                    children
                  });
                }
              };
              __name(_Html, "Html");
              let Html = _Html;
              const _I = class _I extends XhtmlObject {
                constructor(attributes) {
                  super(attributes, "i");
                }
                [_xfa_object.$pushGlyphs](measure) {
                  measure.pushFont({
                    posture: "italic"
                  });
                  super[_xfa_object.$pushGlyphs](measure);
                  measure.popFont();
                }
              };
              __name(_I, "I");
              let I = _I;
              const _Li = class _Li extends XhtmlObject {
                constructor(attributes) {
                  super(attributes, "li");
                }
              };
              __name(_Li, "Li");
              let Li = _Li;
              const _Ol = class _Ol extends XhtmlObject {
                constructor(attributes) {
                  super(attributes, "ol");
                }
              };
              __name(_Ol, "Ol");
              let Ol = _Ol;
              const _P = class _P extends XhtmlObject {
                constructor(attributes) {
                  super(attributes, "p");
                }
                [_xfa_object.$pushGlyphs](measure) {
                  super[_xfa_object.$pushGlyphs](measure, false);
                  measure.addString("\n");
                  measure.addPara();
                  measure.popFont();
                }
                [_xfa_object.$text]() {
                  const siblings = this[_xfa_object.$getParent]()[_xfa_object.$getChildren]();
                  if (siblings.at(-1) === this) {
                    return super[_xfa_object.$text]();
                  }
                  return super[_xfa_object.$text]() + "\n";
                }
              };
              __name(_P, "P");
              let P = _P;
              const _Span = class _Span extends XhtmlObject {
                constructor(attributes) {
                  super(attributes, "span");
                }
              };
              __name(_Span, "Span");
              let Span = _Span;
              const _Sub = class _Sub extends XhtmlObject {
                constructor(attributes) {
                  super(attributes, "sub");
                }
              };
              __name(_Sub, "Sub");
              let Sub = _Sub;
              const _Sup = class _Sup extends XhtmlObject {
                constructor(attributes) {
                  super(attributes, "sup");
                }
              };
              __name(_Sup, "Sup");
              let Sup = _Sup;
              const _Ul = class _Ul extends XhtmlObject {
                constructor(attributes) {
                  super(attributes, "ul");
                }
              };
              __name(_Ul, "Ul");
              let Ul = _Ul;
              const _XhtmlNamespace = class _XhtmlNamespace {
                static [_namespaces.$buildXFAObject](name, attributes) {
                  if (_XhtmlNamespace.hasOwnProperty(name)) {
                    return _XhtmlNamespace[name](attributes);
                  }
                  return void 0;
                }
                static a(attributes) {
                  return new A(attributes);
                }
                static b(attributes) {
                  return new B(attributes);
                }
                static body(attributes) {
                  return new Body(attributes);
                }
                static br(attributes) {
                  return new Br(attributes);
                }
                static html(attributes) {
                  return new Html(attributes);
                }
                static i(attributes) {
                  return new I(attributes);
                }
                static li(attributes) {
                  return new Li(attributes);
                }
                static ol(attributes) {
                  return new Ol(attributes);
                }
                static p(attributes) {
                  return new P(attributes);
                }
                static span(attributes) {
                  return new Span(attributes);
                }
                static sub(attributes) {
                  return new Sub(attributes);
                }
                static sup(attributes) {
                  return new Sup(attributes);
                }
                static ul(attributes) {
                  return new Ul(attributes);
                }
              };
              __name(_XhtmlNamespace, "XhtmlNamespace");
              let XhtmlNamespace = _XhtmlNamespace;
              exports2.XhtmlNamespace = XhtmlNamespace;
            },
            /* 224 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.UnknownNamespace = void 0;
              var _namespaces = __w_pdfjs_require__2(204);
              var _xfa_object = __w_pdfjs_require__2(202);
              const _UnknownNamespace = class _UnknownNamespace {
                constructor(nsId) {
                  this.namespaceId = nsId;
                }
                [_namespaces.$buildXFAObject](name, attributes) {
                  return new _xfa_object.XmlObject(this.namespaceId, name, attributes);
                }
              };
              __name(_UnknownNamespace, "UnknownNamespace");
              let UnknownNamespace = _UnknownNamespace;
              exports2.UnknownNamespace = UnknownNamespace;
            },
            /* 225 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.DatasetReader = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _core_utils = __w_pdfjs_require__2(131);
              var _xml_parser = __w_pdfjs_require__2(191);
              function decodeString(str) {
                try {
                  return (0, _util.stringToUTF8String)(str);
                } catch (ex) {
                  (0, _util.warn)(`UTF-8 decoding failed: "${ex}".`);
                  return str;
                }
              }
              __name(decodeString, "decodeString");
              const _DatasetXMLParser = class _DatasetXMLParser extends _xml_parser.SimpleXMLParser {
                constructor(options) {
                  super(options);
                  this.node = null;
                }
                onEndElement(name) {
                  const node = super.onEndElement(name);
                  if (node && name === "xfa:datasets") {
                    this.node = node;
                    throw new Error("Aborting DatasetXMLParser.");
                  }
                }
              };
              __name(_DatasetXMLParser, "DatasetXMLParser");
              let DatasetXMLParser = _DatasetXMLParser;
              const _DatasetReader = class _DatasetReader {
                constructor(data) {
                  if (data.datasets) {
                    this.node = new _xml_parser.SimpleXMLParser({
                      hasAttributes: true
                    }).parseFromString(data.datasets).documentElement;
                  } else {
                    const parser = new DatasetXMLParser({
                      hasAttributes: true
                    });
                    try {
                      parser.parseFromString(data["xdp:xdp"]);
                    } catch (_) {
                    }
                    this.node = parser.node;
                  }
                }
                getValue(path) {
                  if (!this.node || !path) {
                    return "";
                  }
                  const node = this.node.searchNode((0, _core_utils.parseXFAPath)(path), 0);
                  if (!node) {
                    return "";
                  }
                  const first = node.firstChild;
                  if (first && first.nodeName === "value") {
                    return node.children.map((child) => decodeString(child.textContent));
                  }
                  return decodeString(node.textContent);
                }
              };
              __name(_DatasetReader, "DatasetReader");
              let DatasetReader = _DatasetReader;
              exports2.DatasetReader = DatasetReader;
            },
            /* 226 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.XRef = void 0;
              var _util = __w_pdfjs_require__2(2);
              var _primitives = __w_pdfjs_require__2(130);
              var _core_utils = __w_pdfjs_require__2(131);
              var _parser = __w_pdfjs_require__2(142);
              var _base_stream = __w_pdfjs_require__2(132);
              var _crypto = __w_pdfjs_require__2(192);
              const _XRef = class _XRef {
                constructor(stream, pdfManager) {
                  this.stream = stream;
                  this.pdfManager = pdfManager;
                  this.entries = [];
                  this.xrefstms = /* @__PURE__ */ Object.create(null);
                  this._cacheMap = /* @__PURE__ */ new Map();
                  this._pendingRefs = new _primitives.RefSet();
                  this.stats = new _core_utils.DocStats(pdfManager.msgHandler);
                  this._newRefNum = null;
                }
                getNewRef() {
                  if (this._newRefNum === null) {
                    this._newRefNum = this.entries.length || 1;
                  }
                  return _primitives.Ref.get(this._newRefNum++, 0);
                }
                resetNewRef() {
                  this._newRefNum = null;
                }
                setStartXRef(startXRef) {
                  this.startXRefQueue = [startXRef];
                }
                parse() {
                  let recoveryMode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  let trailerDict;
                  if (!recoveryMode) {
                    trailerDict = this.readXRef();
                  } else {
                    (0, _util.warn)("Indexing all PDF objects");
                    trailerDict = this.indexObjects();
                  }
                  trailerDict.assignXref(this);
                  this.trailer = trailerDict;
                  let encrypt;
                  try {
                    encrypt = trailerDict.get("Encrypt");
                  } catch (ex) {
                    if (ex instanceof _core_utils.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.warn)(`XRef.parse - Invalid "Encrypt" reference: "${ex}".`);
                  }
                  if (encrypt instanceof _primitives.Dict) {
                    const ids = trailerDict.get("ID");
                    const fileId = ids && ids.length ? ids[0] : "";
                    encrypt.suppressEncryption = true;
                    this.encrypt = new _crypto.CipherTransformFactory(encrypt, fileId, this.pdfManager.password);
                  }
                  let root;
                  try {
                    root = trailerDict.get("Root");
                  } catch (ex) {
                    if (ex instanceof _core_utils.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.warn)(`XRef.parse - Invalid "Root" reference: "${ex}".`);
                  }
                  if (root instanceof _primitives.Dict) {
                    try {
                      const pages = root.get("Pages");
                      if (pages instanceof _primitives.Dict) {
                        this.root = root;
                        return;
                      }
                    } catch (ex) {
                      if (ex instanceof _core_utils.MissingDataException) {
                        throw ex;
                      }
                      (0, _util.warn)(`XRef.parse - Invalid "Pages" reference: "${ex}".`);
                    }
                  }
                  if (!recoveryMode) {
                    throw new _core_utils.XRefParseException();
                  }
                  throw new _util.InvalidPDFException("Invalid Root reference.");
                }
                processXRefTable(parser) {
                  if (!("tableState" in this)) {
                    this.tableState = {
                      entryNum: 0,
                      streamPos: parser.lexer.stream.pos,
                      parserBuf1: parser.buf1,
                      parserBuf2: parser.buf2
                    };
                  }
                  const obj = this.readXRefTable(parser);
                  if (!(0, _primitives.isCmd)(obj, "trailer")) {
                    throw new _util.FormatError("Invalid XRef table: could not find trailer dictionary");
                  }
                  let dict = parser.getObj();
                  if (!(dict instanceof _primitives.Dict) && dict.dict) {
                    dict = dict.dict;
                  }
                  if (!(dict instanceof _primitives.Dict)) {
                    throw new _util.FormatError("Invalid XRef table: could not parse trailer dictionary");
                  }
                  delete this.tableState;
                  return dict;
                }
                readXRefTable(parser) {
                  const stream = parser.lexer.stream;
                  const tableState = this.tableState;
                  stream.pos = tableState.streamPos;
                  parser.buf1 = tableState.parserBuf1;
                  parser.buf2 = tableState.parserBuf2;
                  let obj;
                  while (true) {
                    if (!("firstEntryNum" in tableState) || !("entryCount" in tableState)) {
                      if ((0, _primitives.isCmd)(obj = parser.getObj(), "trailer")) {
                        break;
                      }
                      tableState.firstEntryNum = obj;
                      tableState.entryCount = parser.getObj();
                    }
                    let first = tableState.firstEntryNum;
                    const count = tableState.entryCount;
                    if (!Number.isInteger(first) || !Number.isInteger(count)) {
                      throw new _util.FormatError("Invalid XRef table: wrong types in subsection header");
                    }
                    for (let i = tableState.entryNum; i < count; i++) {
                      tableState.streamPos = stream.pos;
                      tableState.entryNum = i;
                      tableState.parserBuf1 = parser.buf1;
                      tableState.parserBuf2 = parser.buf2;
                      const entry = {};
                      entry.offset = parser.getObj();
                      entry.gen = parser.getObj();
                      const type = parser.getObj();
                      if (type instanceof _primitives.Cmd) {
                        switch (type.cmd) {
                          case "f":
                            entry.free = true;
                            break;
                          case "n":
                            entry.uncompressed = true;
                            break;
                        }
                      }
                      if (!Number.isInteger(entry.offset) || !Number.isInteger(entry.gen) || !(entry.free || entry.uncompressed)) {
                        throw new _util.FormatError(`Invalid entry in XRef subsection: ${first}, ${count}`);
                      }
                      if (i === 0 && entry.free && first === 1) {
                        first = 0;
                      }
                      if (!this.entries[i + first]) {
                        this.entries[i + first] = entry;
                      }
                    }
                    tableState.entryNum = 0;
                    tableState.streamPos = stream.pos;
                    tableState.parserBuf1 = parser.buf1;
                    tableState.parserBuf2 = parser.buf2;
                    delete tableState.firstEntryNum;
                    delete tableState.entryCount;
                  }
                  if (this.entries[0] && !this.entries[0].free) {
                    throw new _util.FormatError("Invalid XRef table: unexpected first object");
                  }
                  return obj;
                }
                processXRefStream(stream) {
                  if (!("streamState" in this)) {
                    const streamParameters = stream.dict;
                    const byteWidths = streamParameters.get("W");
                    let range = streamParameters.get("Index");
                    if (!range) {
                      range = [0, streamParameters.get("Size")];
                    }
                    this.streamState = {
                      entryRanges: range,
                      byteWidths,
                      entryNum: 0,
                      streamPos: stream.pos
                    };
                  }
                  this.readXRefStream(stream);
                  delete this.streamState;
                  return stream.dict;
                }
                readXRefStream(stream) {
                  const streamState = this.streamState;
                  stream.pos = streamState.streamPos;
                  const [typeFieldWidth, offsetFieldWidth, generationFieldWidth] = streamState.byteWidths;
                  const entryRanges = streamState.entryRanges;
                  while (entryRanges.length > 0) {
                    const [first, n] = entryRanges;
                    if (!Number.isInteger(first) || !Number.isInteger(n)) {
                      throw new _util.FormatError(`Invalid XRef range fields: ${first}, ${n}`);
                    }
                    if (!Number.isInteger(typeFieldWidth) || !Number.isInteger(offsetFieldWidth) || !Number.isInteger(generationFieldWidth)) {
                      throw new _util.FormatError(`Invalid XRef entry fields length: ${first}, ${n}`);
                    }
                    for (let i = streamState.entryNum; i < n; ++i) {
                      streamState.entryNum = i;
                      streamState.streamPos = stream.pos;
                      let type = 0, offset = 0, generation = 0;
                      for (let j = 0; j < typeFieldWidth; ++j) {
                        const typeByte = stream.getByte();
                        if (typeByte === -1) {
                          throw new _util.FormatError("Invalid XRef byteWidths 'type'.");
                        }
                        type = type << 8 | typeByte;
                      }
                      if (typeFieldWidth === 0) {
                        type = 1;
                      }
                      for (let j = 0; j < offsetFieldWidth; ++j) {
                        const offsetByte = stream.getByte();
                        if (offsetByte === -1) {
                          throw new _util.FormatError("Invalid XRef byteWidths 'offset'.");
                        }
                        offset = offset << 8 | offsetByte;
                      }
                      for (let j = 0; j < generationFieldWidth; ++j) {
                        const generationByte = stream.getByte();
                        if (generationByte === -1) {
                          throw new _util.FormatError("Invalid XRef byteWidths 'generation'.");
                        }
                        generation = generation << 8 | generationByte;
                      }
                      const entry = {};
                      entry.offset = offset;
                      entry.gen = generation;
                      switch (type) {
                        case 0:
                          entry.free = true;
                          break;
                        case 1:
                          entry.uncompressed = true;
                          break;
                        case 2:
                          break;
                        default:
                          throw new _util.FormatError(`Invalid XRef entry type: ${type}`);
                      }
                      if (!this.entries[first + i]) {
                        this.entries[first + i] = entry;
                      }
                    }
                    streamState.entryNum = 0;
                    streamState.streamPos = stream.pos;
                    entryRanges.splice(0, 2);
                  }
                }
                indexObjects() {
                  const TAB = 9, LF = 10, CR = 13, SPACE = 32;
                  const PERCENT = 37, LT = 60;
                  function readToken(data, offset) {
                    let token = "", ch = data[offset];
                    while (ch !== LF && ch !== CR && ch !== LT) {
                      if (++offset >= data.length) {
                        break;
                      }
                      token += String.fromCharCode(ch);
                      ch = data[offset];
                    }
                    return token;
                  }
                  __name(readToken, "readToken");
                  function skipUntil(data, offset, what) {
                    const length2 = what.length, dataLength = data.length;
                    let skipped = 0;
                    while (offset < dataLength) {
                      let i = 0;
                      while (i < length2 && data[offset + i] === what[i]) {
                        ++i;
                      }
                      if (i >= length2) {
                        break;
                      }
                      offset++;
                      skipped++;
                    }
                    return skipped;
                  }
                  __name(skipUntil, "skipUntil");
                  const objRegExp = /^(\d+)\s+(\d+)\s+obj\b/;
                  const endobjRegExp = /\bendobj[\b\s]$/;
                  const nestedObjRegExp = /\s+(\d+\s+\d+\s+obj[\b\s<])$/;
                  const CHECK_CONTENT_LENGTH = 25;
                  const trailerBytes = new Uint8Array([116, 114, 97, 105, 108, 101, 114]);
                  const startxrefBytes = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]);
                  const objBytes = new Uint8Array([111, 98, 106]);
                  const xrefBytes = new Uint8Array([47, 88, 82, 101, 102]);
                  this.entries.length = 0;
                  this._cacheMap.clear();
                  const stream = this.stream;
                  stream.pos = 0;
                  const buffer = stream.getBytes(), length = buffer.length;
                  let position = stream.start;
                  const trailers = [], xrefStms = [];
                  while (position < length) {
                    let ch = buffer[position];
                    if (ch === TAB || ch === LF || ch === CR || ch === SPACE) {
                      ++position;
                      continue;
                    }
                    if (ch === PERCENT) {
                      do {
                        ++position;
                        if (position >= length) {
                          break;
                        }
                        ch = buffer[position];
                      } while (ch !== LF && ch !== CR);
                      continue;
                    }
                    const token = readToken(buffer, position);
                    let m;
                    if (token.startsWith("xref") && (token.length === 4 || /\s/.test(token[4]))) {
                      position += skipUntil(buffer, position, trailerBytes);
                      trailers.push(position);
                      position += skipUntil(buffer, position, startxrefBytes);
                    } else if (m = objRegExp.exec(token)) {
                      const num = m[1] | 0, gen = m[2] | 0;
                      let contentLength, startPos = position + token.length, updateEntries = false;
                      if (!this.entries[num]) {
                        updateEntries = true;
                      } else if (this.entries[num].gen === gen) {
                        try {
                          const parser = new _parser.Parser({
                            lexer: new _parser.Lexer(stream.makeSubStream(startPos))
                          });
                          parser.getObj();
                          updateEntries = true;
                        } catch (ex) {
                          if (ex instanceof _core_utils.ParserEOFException) {
                            (0, _util.warn)(`indexObjects -- checking object (${token}): "${ex}".`);
                          } else {
                            updateEntries = true;
                          }
                        }
                      }
                      if (updateEntries) {
                        this.entries[num] = {
                          offset: position - stream.start,
                          gen,
                          uncompressed: true
                        };
                      }
                      while (startPos < buffer.length) {
                        const endPos = startPos + skipUntil(buffer, startPos, objBytes) + 4;
                        contentLength = endPos - position;
                        const checkPos = Math.max(endPos - CHECK_CONTENT_LENGTH, startPos);
                        const tokenStr = (0, _util.bytesToString)(buffer.subarray(checkPos, endPos));
                        if (endobjRegExp.test(tokenStr)) {
                          break;
                        } else {
                          const objToken = nestedObjRegExp.exec(tokenStr);
                          if (objToken && objToken[1]) {
                            (0, _util.warn)('indexObjects: Found new "obj" inside of another "obj", caused by missing "endobj" -- trying to recover.');
                            contentLength -= objToken[1].length;
                            break;
                          }
                        }
                        startPos = endPos;
                      }
                      const content = buffer.subarray(position, position + contentLength);
                      const xrefTagOffset = skipUntil(content, 0, xrefBytes);
                      if (xrefTagOffset < contentLength && content[xrefTagOffset + 5] < 64) {
                        xrefStms.push(position - stream.start);
                        this.xrefstms[position - stream.start] = 1;
                      }
                      position += contentLength;
                    } else if (token.startsWith("trailer") && (token.length === 7 || /\s/.test(token[7]))) {
                      trailers.push(position);
                      position += skipUntil(buffer, position, startxrefBytes);
                    } else {
                      position += token.length + 1;
                    }
                  }
                  for (let i = 0, ii = xrefStms.length; i < ii; ++i) {
                    this.startXRefQueue.push(xrefStms[i]);
                    this.readXRef(true);
                  }
                  let trailerDict;
                  for (let i = 0, ii = trailers.length; i < ii; ++i) {
                    stream.pos = trailers[i];
                    const parser = new _parser.Parser({
                      lexer: new _parser.Lexer(stream),
                      xref: this,
                      allowStreams: true,
                      recoveryMode: true
                    });
                    const obj = parser.getObj();
                    if (!(0, _primitives.isCmd)(obj, "trailer")) {
                      continue;
                    }
                    const dict = parser.getObj();
                    if (!(dict instanceof _primitives.Dict)) {
                      continue;
                    }
                    try {
                      const rootDict = dict.get("Root");
                      if (!(rootDict instanceof _primitives.Dict)) {
                        continue;
                      }
                      const pagesDict = rootDict.get("Pages");
                      if (!(pagesDict instanceof _primitives.Dict)) {
                        continue;
                      }
                      const pagesCount = pagesDict.get("Count");
                      if (!Number.isInteger(pagesCount)) {
                        continue;
                      }
                    } catch (ex) {
                      continue;
                    }
                    if (dict.has("ID")) {
                      return dict;
                    }
                    trailerDict = dict;
                  }
                  if (trailerDict) {
                    return trailerDict;
                  }
                  if (this.topDict) {
                    return this.topDict;
                  }
                  throw new _util.InvalidPDFException("Invalid PDF structure.");
                }
                readXRef() {
                  let recoveryMode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  const stream = this.stream;
                  const startXRefParsedCache = /* @__PURE__ */ new Set();
                  try {
                    while (this.startXRefQueue.length) {
                      const startXRef = this.startXRefQueue[0];
                      if (startXRefParsedCache.has(startXRef)) {
                        (0, _util.warn)("readXRef - skipping XRef table since it was already parsed.");
                        this.startXRefQueue.shift();
                        continue;
                      }
                      startXRefParsedCache.add(startXRef);
                      stream.pos = startXRef + stream.start;
                      const parser = new _parser.Parser({
                        lexer: new _parser.Lexer(stream),
                        xref: this,
                        allowStreams: true
                      });
                      let obj = parser.getObj();
                      let dict;
                      if ((0, _primitives.isCmd)(obj, "xref")) {
                        dict = this.processXRefTable(parser);
                        if (!this.topDict) {
                          this.topDict = dict;
                        }
                        obj = dict.get("XRefStm");
                        if (Number.isInteger(obj)) {
                          const pos = obj;
                          if (!(pos in this.xrefstms)) {
                            this.xrefstms[pos] = 1;
                            this.startXRefQueue.push(pos);
                          }
                        }
                      } else if (Number.isInteger(obj)) {
                        if (!Number.isInteger(parser.getObj()) || !(0, _primitives.isCmd)(parser.getObj(), "obj") || !((obj = parser.getObj()) instanceof _base_stream.BaseStream)) {
                          throw new _util.FormatError("Invalid XRef stream");
                        }
                        dict = this.processXRefStream(obj);
                        if (!this.topDict) {
                          this.topDict = dict;
                        }
                        if (!dict) {
                          throw new _util.FormatError("Failed to read XRef stream");
                        }
                      } else {
                        throw new _util.FormatError("Invalid XRef stream header");
                      }
                      obj = dict.get("Prev");
                      if (Number.isInteger(obj)) {
                        this.startXRefQueue.push(obj);
                      } else if (obj instanceof _primitives.Ref) {
                        this.startXRefQueue.push(obj.num);
                      }
                      this.startXRefQueue.shift();
                    }
                    return this.topDict;
                  } catch (e) {
                    if (e instanceof _core_utils.MissingDataException) {
                      throw e;
                    }
                    (0, _util.info)("(while reading XRef): " + e);
                    this.startXRefQueue.shift();
                  }
                  if (recoveryMode) {
                    return void 0;
                  }
                  throw new _core_utils.XRefParseException();
                }
                getEntry(i) {
                  const xrefEntry = this.entries[i];
                  if (xrefEntry && !xrefEntry.free && xrefEntry.offset) {
                    return xrefEntry;
                  }
                  return null;
                }
                fetchIfRef(obj) {
                  let suppressEncryption = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  if (obj instanceof _primitives.Ref) {
                    return this.fetch(obj, suppressEncryption);
                  }
                  return obj;
                }
                fetch(ref) {
                  let suppressEncryption = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  if (!(ref instanceof _primitives.Ref)) {
                    throw new Error("ref object is not a reference");
                  }
                  const num = ref.num;
                  const cacheEntry = this._cacheMap.get(num);
                  if (cacheEntry !== void 0) {
                    if (cacheEntry instanceof _primitives.Dict && !cacheEntry.objId) {
                      cacheEntry.objId = ref.toString();
                    }
                    return cacheEntry;
                  }
                  let xrefEntry = this.getEntry(num);
                  if (xrefEntry === null) {
                    this._cacheMap.set(num, xrefEntry);
                    return xrefEntry;
                  }
                  if (this._pendingRefs.has(ref)) {
                    this._pendingRefs.remove(ref);
                    (0, _util.warn)(`Ignoring circular reference: ${ref}.`);
                    return _primitives.CIRCULAR_REF;
                  }
                  this._pendingRefs.put(ref);
                  try {
                    if (xrefEntry.uncompressed) {
                      xrefEntry = this.fetchUncompressed(ref, xrefEntry, suppressEncryption);
                    } else {
                      xrefEntry = this.fetchCompressed(ref, xrefEntry, suppressEncryption);
                    }
                    this._pendingRefs.remove(ref);
                  } catch (ex) {
                    this._pendingRefs.remove(ref);
                    throw ex;
                  }
                  if (xrefEntry instanceof _primitives.Dict) {
                    xrefEntry.objId = ref.toString();
                  } else if (xrefEntry instanceof _base_stream.BaseStream) {
                    xrefEntry.dict.objId = ref.toString();
                  }
                  return xrefEntry;
                }
                fetchUncompressed(ref, xrefEntry) {
                  let suppressEncryption = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                  const gen = ref.gen;
                  let num = ref.num;
                  if (xrefEntry.gen !== gen) {
                    throw new _core_utils.XRefEntryException(`Inconsistent generation in XRef: ${ref}`);
                  }
                  const stream = this.stream.makeSubStream(xrefEntry.offset + this.stream.start);
                  const parser = new _parser.Parser({
                    lexer: new _parser.Lexer(stream),
                    xref: this,
                    allowStreams: true
                  });
                  const obj1 = parser.getObj();
                  const obj2 = parser.getObj();
                  const obj3 = parser.getObj();
                  if (obj1 !== num || obj2 !== gen || !(obj3 instanceof _primitives.Cmd)) {
                    throw new _core_utils.XRefEntryException(`Bad (uncompressed) XRef entry: ${ref}`);
                  }
                  if (obj3.cmd !== "obj") {
                    if (obj3.cmd.startsWith("obj")) {
                      num = parseInt(obj3.cmd.substring(3), 10);
                      if (!Number.isNaN(num)) {
                        return num;
                      }
                    }
                    throw new _core_utils.XRefEntryException(`Bad (uncompressed) XRef entry: ${ref}`);
                  }
                  if (this.encrypt && !suppressEncryption) {
                    xrefEntry = parser.getObj(this.encrypt.createCipherTransform(num, gen));
                  } else {
                    xrefEntry = parser.getObj();
                  }
                  if (!(xrefEntry instanceof _base_stream.BaseStream)) {
                    this._cacheMap.set(num, xrefEntry);
                  }
                  return xrefEntry;
                }
                fetchCompressed(ref, xrefEntry) {
                  const tableOffset = xrefEntry.offset;
                  const stream = this.fetch(_primitives.Ref.get(tableOffset, 0));
                  if (!(stream instanceof _base_stream.BaseStream)) {
                    throw new _util.FormatError("bad ObjStm stream");
                  }
                  const first = stream.dict.get("First");
                  const n = stream.dict.get("N");
                  if (!Number.isInteger(first) || !Number.isInteger(n)) {
                    throw new _util.FormatError("invalid first and n parameters for ObjStm stream");
                  }
                  let parser = new _parser.Parser({
                    lexer: new _parser.Lexer(stream),
                    xref: this,
                    allowStreams: true
                  });
                  const nums = new Array(n);
                  const offsets = new Array(n);
                  for (let i = 0; i < n; ++i) {
                    const num = parser.getObj();
                    if (!Number.isInteger(num)) {
                      throw new _util.FormatError(`invalid object number in the ObjStm stream: ${num}`);
                    }
                    const offset = parser.getObj();
                    if (!Number.isInteger(offset)) {
                      throw new _util.FormatError(`invalid object offset in the ObjStm stream: ${offset}`);
                    }
                    nums[i] = num;
                    offsets[i] = offset;
                  }
                  const start = (stream.start || 0) + first;
                  const entries = new Array(n);
                  for (let i = 0; i < n; ++i) {
                    const length = i < n - 1 ? offsets[i + 1] - offsets[i] : void 0;
                    if (length < 0) {
                      throw new _util.FormatError("Invalid offset in the ObjStm stream.");
                    }
                    parser = new _parser.Parser({
                      lexer: new _parser.Lexer(stream.makeSubStream(start + offsets[i], length, stream.dict)),
                      xref: this,
                      allowStreams: true
                    });
                    const obj = parser.getObj();
                    entries[i] = obj;
                    if (obj instanceof _base_stream.BaseStream) {
                      continue;
                    }
                    const num = nums[i], entry = this.entries[num];
                    if (entry && entry.offset === tableOffset && entry.gen === i) {
                      this._cacheMap.set(num, obj);
                    }
                  }
                  xrefEntry = entries[xrefEntry.gen];
                  if (xrefEntry === void 0) {
                    throw new _core_utils.XRefEntryException(`Bad (compressed) XRef entry: ${ref}`);
                  }
                  return xrefEntry;
                }
                async fetchIfRefAsync(obj, suppressEncryption) {
                  if (obj instanceof _primitives.Ref) {
                    return this.fetchAsync(obj, suppressEncryption);
                  }
                  return obj;
                }
                async fetchAsync(ref, suppressEncryption) {
                  try {
                    return this.fetch(ref, suppressEncryption);
                  } catch (ex) {
                    if (!(ex instanceof _core_utils.MissingDataException)) {
                      throw ex;
                    }
                    await this.pdfManager.requestRange(ex.begin, ex.end);
                    return this.fetchAsync(ref, suppressEncryption);
                  }
                }
                getCatalogObj() {
                  return this.root;
                }
              };
              __name(_XRef, "XRef");
              let XRef = _XRef;
              exports2.XRef = XRef;
            },
            /* 227 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.MessageHandler = void 0;
              var _util = __w_pdfjs_require__2(2);
              const CallbackKind = {
                UNKNOWN: 0,
                DATA: 1,
                ERROR: 2
              };
              const StreamKind = {
                UNKNOWN: 0,
                CANCEL: 1,
                CANCEL_COMPLETE: 2,
                CLOSE: 3,
                ENQUEUE: 4,
                ERROR: 5,
                PULL: 6,
                PULL_COMPLETE: 7,
                START_COMPLETE: 8
              };
              function wrapReason(reason) {
                if (!(reason instanceof Error || typeof reason === "object" && reason !== null)) {
                  (0, _util.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
                }
                switch (reason.name) {
                  case "AbortException":
                    return new _util.AbortException(reason.message);
                  case "MissingPDFException":
                    return new _util.MissingPDFException(reason.message);
                  case "PasswordException":
                    return new _util.PasswordException(reason.message, reason.code);
                  case "UnexpectedResponseException":
                    return new _util.UnexpectedResponseException(reason.message, reason.status);
                  case "UnknownErrorException":
                    return new _util.UnknownErrorException(reason.message, reason.details);
                  default:
                    return new _util.UnknownErrorException(reason.message, reason.toString());
                }
              }
              __name(wrapReason, "wrapReason");
              const _MessageHandler = class _MessageHandler {
                constructor(sourceName, targetName, comObj) {
                  this.sourceName = sourceName;
                  this.targetName = targetName;
                  this.comObj = comObj;
                  this.callbackId = 1;
                  this.streamId = 1;
                  this.streamSinks = /* @__PURE__ */ Object.create(null);
                  this.streamControllers = /* @__PURE__ */ Object.create(null);
                  this.callbackCapabilities = /* @__PURE__ */ Object.create(null);
                  this.actionHandler = /* @__PURE__ */ Object.create(null);
                  this._onComObjOnMessage = (event) => {
                    const data = event.data;
                    if (data.targetName !== this.sourceName) {
                      return;
                    }
                    if (data.stream) {
                      this._processStreamMessage(data);
                      return;
                    }
                    if (data.callback) {
                      const callbackId = data.callbackId;
                      const capability = this.callbackCapabilities[callbackId];
                      if (!capability) {
                        throw new Error(`Cannot resolve callback ${callbackId}`);
                      }
                      delete this.callbackCapabilities[callbackId];
                      if (data.callback === CallbackKind.DATA) {
                        capability.resolve(data.data);
                      } else if (data.callback === CallbackKind.ERROR) {
                        capability.reject(wrapReason(data.reason));
                      } else {
                        throw new Error("Unexpected callback case");
                      }
                      return;
                    }
                    const action = this.actionHandler[data.action];
                    if (!action) {
                      throw new Error(`Unknown action from worker: ${data.action}`);
                    }
                    if (data.callbackId) {
                      const cbSourceName = this.sourceName;
                      const cbTargetName = data.sourceName;
                      new Promise(function(resolve) {
                        resolve(action(data.data));
                      }).then(function(result) {
                        comObj.postMessage({
                          sourceName: cbSourceName,
                          targetName: cbTargetName,
                          callback: CallbackKind.DATA,
                          callbackId: data.callbackId,
                          data: result
                        });
                      }, function(reason) {
                        comObj.postMessage({
                          sourceName: cbSourceName,
                          targetName: cbTargetName,
                          callback: CallbackKind.ERROR,
                          callbackId: data.callbackId,
                          reason: wrapReason(reason)
                        });
                      });
                      return;
                    }
                    if (data.streamId) {
                      this._createStreamSink(data);
                      return;
                    }
                    action(data.data);
                  };
                  comObj.addEventListener("message", this._onComObjOnMessage);
                }
                on(actionName, handler) {
                  const ah = this.actionHandler;
                  if (ah[actionName]) {
                    throw new Error(`There is already an actionName called "${actionName}"`);
                  }
                  ah[actionName] = handler;
                }
                send(actionName, data, transfers) {
                  this.comObj.postMessage({
                    sourceName: this.sourceName,
                    targetName: this.targetName,
                    action: actionName,
                    data
                  }, transfers);
                }
                sendWithPromise(actionName, data, transfers) {
                  const callbackId = this.callbackId++;
                  const capability = (0, _util.createPromiseCapability)();
                  this.callbackCapabilities[callbackId] = capability;
                  try {
                    this.comObj.postMessage({
                      sourceName: this.sourceName,
                      targetName: this.targetName,
                      action: actionName,
                      callbackId,
                      data
                    }, transfers);
                  } catch (ex) {
                    capability.reject(ex);
                  }
                  return capability.promise;
                }
                sendWithStream(actionName, data, queueingStrategy, transfers) {
                  const streamId = this.streamId++, sourceName = this.sourceName, targetName = this.targetName, comObj = this.comObj;
                  return new ReadableStream({
                    start: (controller) => {
                      const startCapability = (0, _util.createPromiseCapability)();
                      this.streamControllers[streamId] = {
                        controller,
                        startCall: startCapability,
                        pullCall: null,
                        cancelCall: null,
                        isClosed: false
                      };
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        action: actionName,
                        streamId,
                        data,
                        desiredSize: controller.desiredSize
                      }, transfers);
                      return startCapability.promise;
                    },
                    pull: (controller) => {
                      const pullCapability = (0, _util.createPromiseCapability)();
                      this.streamControllers[streamId].pullCall = pullCapability;
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.PULL,
                        streamId,
                        desiredSize: controller.desiredSize
                      });
                      return pullCapability.promise;
                    },
                    cancel: (reason) => {
                      (0, _util.assert)(reason instanceof Error, "cancel must have a valid reason");
                      const cancelCapability = (0, _util.createPromiseCapability)();
                      this.streamControllers[streamId].cancelCall = cancelCapability;
                      this.streamControllers[streamId].isClosed = true;
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.CANCEL,
                        streamId,
                        reason: wrapReason(reason)
                      });
                      return cancelCapability.promise;
                    }
                  }, queueingStrategy);
                }
                _createStreamSink(data) {
                  const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
                  const self2 = this, action = this.actionHandler[data.action];
                  const streamSink = {
                    enqueue(chunk) {
                      let size = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
                      let transfers = arguments.length > 2 ? arguments[2] : void 0;
                      if (this.isCancelled) {
                        return;
                      }
                      const lastDesiredSize = this.desiredSize;
                      this.desiredSize -= size;
                      if (lastDesiredSize > 0 && this.desiredSize <= 0) {
                        this.sinkCapability = (0, _util.createPromiseCapability)();
                        this.ready = this.sinkCapability.promise;
                      }
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.ENQUEUE,
                        streamId,
                        chunk
                      }, transfers);
                    },
                    close() {
                      if (this.isCancelled) {
                        return;
                      }
                      this.isCancelled = true;
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.CLOSE,
                        streamId
                      });
                      delete self2.streamSinks[streamId];
                    },
                    error(reason) {
                      (0, _util.assert)(reason instanceof Error, "error must have a valid reason");
                      if (this.isCancelled) {
                        return;
                      }
                      this.isCancelled = true;
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.ERROR,
                        streamId,
                        reason: wrapReason(reason)
                      });
                    },
                    sinkCapability: (0, _util.createPromiseCapability)(),
                    onPull: null,
                    onCancel: null,
                    isCancelled: false,
                    desiredSize: data.desiredSize,
                    ready: null
                  };
                  streamSink.sinkCapability.resolve();
                  streamSink.ready = streamSink.sinkCapability.promise;
                  this.streamSinks[streamId] = streamSink;
                  new Promise(function(resolve) {
                    resolve(action(data.data, streamSink));
                  }).then(function() {
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.START_COMPLETE,
                      streamId,
                      success: true
                    });
                  }, function(reason) {
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.START_COMPLETE,
                      streamId,
                      reason: wrapReason(reason)
                    });
                  });
                }
                _processStreamMessage(data) {
                  const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
                  const streamController = this.streamControllers[streamId], streamSink = this.streamSinks[streamId];
                  switch (data.stream) {
                    case StreamKind.START_COMPLETE:
                      if (data.success) {
                        streamController.startCall.resolve();
                      } else {
                        streamController.startCall.reject(wrapReason(data.reason));
                      }
                      break;
                    case StreamKind.PULL_COMPLETE:
                      if (data.success) {
                        streamController.pullCall.resolve();
                      } else {
                        streamController.pullCall.reject(wrapReason(data.reason));
                      }
                      break;
                    case StreamKind.PULL:
                      if (!streamSink) {
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.PULL_COMPLETE,
                          streamId,
                          success: true
                        });
                        break;
                      }
                      if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {
                        streamSink.sinkCapability.resolve();
                      }
                      streamSink.desiredSize = data.desiredSize;
                      new Promise(function(resolve) {
                        resolve(streamSink.onPull && streamSink.onPull());
                      }).then(function() {
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.PULL_COMPLETE,
                          streamId,
                          success: true
                        });
                      }, function(reason) {
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.PULL_COMPLETE,
                          streamId,
                          reason: wrapReason(reason)
                        });
                      });
                      break;
                    case StreamKind.ENQUEUE:
                      (0, _util.assert)(streamController, "enqueue should have stream controller");
                      if (streamController.isClosed) {
                        break;
                      }
                      streamController.controller.enqueue(data.chunk);
                      break;
                    case StreamKind.CLOSE:
                      (0, _util.assert)(streamController, "close should have stream controller");
                      if (streamController.isClosed) {
                        break;
                      }
                      streamController.isClosed = true;
                      streamController.controller.close();
                      this._deleteStreamController(streamController, streamId);
                      break;
                    case StreamKind.ERROR:
                      (0, _util.assert)(streamController, "error should have stream controller");
                      streamController.controller.error(wrapReason(data.reason));
                      this._deleteStreamController(streamController, streamId);
                      break;
                    case StreamKind.CANCEL_COMPLETE:
                      if (data.success) {
                        streamController.cancelCall.resolve();
                      } else {
                        streamController.cancelCall.reject(wrapReason(data.reason));
                      }
                      this._deleteStreamController(streamController, streamId);
                      break;
                    case StreamKind.CANCEL:
                      if (!streamSink) {
                        break;
                      }
                      new Promise(function(resolve) {
                        resolve(streamSink.onCancel && streamSink.onCancel(wrapReason(data.reason)));
                      }).then(function() {
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.CANCEL_COMPLETE,
                          streamId,
                          success: true
                        });
                      }, function(reason) {
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.CANCEL_COMPLETE,
                          streamId,
                          reason: wrapReason(reason)
                        });
                      });
                      streamSink.sinkCapability.reject(wrapReason(data.reason));
                      streamSink.isCancelled = true;
                      delete this.streamSinks[streamId];
                      break;
                    default:
                      throw new Error("Unexpected stream case");
                  }
                }
                async _deleteStreamController(streamController, streamId) {
                  await Promise.allSettled([streamController.startCall && streamController.startCall.promise, streamController.pullCall && streamController.pullCall.promise, streamController.cancelCall && streamController.cancelCall.promise]);
                  delete this.streamControllers[streamId];
                }
                destroy() {
                  this.comObj.removeEventListener("message", this._onComObjOnMessage);
                }
              };
              __name(_MessageHandler, "MessageHandler");
              let MessageHandler = _MessageHandler;
              exports2.MessageHandler = MessageHandler;
            },
            /* 228 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFWorkerStream = void 0;
              var _util = __w_pdfjs_require__2(2);
              const _PDFWorkerStream = class _PDFWorkerStream {
                constructor(msgHandler) {
                  this._msgHandler = msgHandler;
                  this._contentLength = null;
                  this._fullRequestReader = null;
                  this._rangeRequestReaders = [];
                }
                getFullReader() {
                  (0, _util.assert)(!this._fullRequestReader, "PDFWorkerStream.getFullReader can only be called once.");
                  this._fullRequestReader = new PDFWorkerStreamReader(this._msgHandler);
                  return this._fullRequestReader;
                }
                getRangeReader(begin, end) {
                  const reader = new PDFWorkerStreamRangeReader(begin, end, this._msgHandler);
                  this._rangeRequestReaders.push(reader);
                  return reader;
                }
                cancelAllRequests(reason) {
                  if (this._fullRequestReader) {
                    this._fullRequestReader.cancel(reason);
                  }
                  for (const reader of this._rangeRequestReaders.slice(0)) {
                    reader.cancel(reason);
                  }
                }
              };
              __name(_PDFWorkerStream, "PDFWorkerStream");
              let PDFWorkerStream = _PDFWorkerStream;
              exports2.PDFWorkerStream = PDFWorkerStream;
              const _PDFWorkerStreamReader = class _PDFWorkerStreamReader {
                constructor(msgHandler) {
                  this._msgHandler = msgHandler;
                  this.onProgress = null;
                  this._contentLength = null;
                  this._isRangeSupported = false;
                  this._isStreamingSupported = false;
                  const readableStream = this._msgHandler.sendWithStream("GetReader");
                  this._reader = readableStream.getReader();
                  this._headersReady = this._msgHandler.sendWithPromise("ReaderHeadersReady").then((data) => {
                    this._isStreamingSupported = data.isStreamingSupported;
                    this._isRangeSupported = data.isRangeSupported;
                    this._contentLength = data.contentLength;
                  });
                }
                get headersReady() {
                  return this._headersReady;
                }
                get contentLength() {
                  return this._contentLength;
                }
                get isStreamingSupported() {
                  return this._isStreamingSupported;
                }
                get isRangeSupported() {
                  return this._isRangeSupported;
                }
                async read() {
                  const {
                    value,
                    done
                  } = await this._reader.read();
                  if (done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  return {
                    value: value.buffer,
                    done: false
                  };
                }
                cancel(reason) {
                  this._reader.cancel(reason);
                }
              };
              __name(_PDFWorkerStreamReader, "PDFWorkerStreamReader");
              let PDFWorkerStreamReader = _PDFWorkerStreamReader;
              const _PDFWorkerStreamRangeReader = class _PDFWorkerStreamRangeReader {
                constructor(begin, end, msgHandler) {
                  this._msgHandler = msgHandler;
                  this.onProgress = null;
                  const readableStream = this._msgHandler.sendWithStream("GetRangeReader", {
                    begin,
                    end
                  });
                  this._reader = readableStream.getReader();
                }
                get isStreamingSupported() {
                  return false;
                }
                async read() {
                  const {
                    value,
                    done
                  } = await this._reader.read();
                  if (done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  return {
                    value: value.buffer,
                    done: false
                  };
                }
                cancel(reason) {
                  this._reader.cancel(reason);
                }
              };
              __name(_PDFWorkerStreamRangeReader, "PDFWorkerStreamRangeReader");
              let PDFWorkerStreamRangeReader = _PDFWorkerStreamRangeReader;
            }
            /******/
          ];
          var __webpack_module_cache__ = {};
          function __w_pdfjs_require__(moduleId) {
            var cachedModule = __webpack_module_cache__[moduleId];
            if (cachedModule !== void 0) {
              return cachedModule.exports;
            }
            var module2 = __webpack_module_cache__[moduleId] = {
              /******/
              // no module.id needed
              /******/
              // no module.loaded needed
              /******/
              exports: {}
              /******/
            };
            __webpack_modules__[moduleId](module2, module2.exports, __w_pdfjs_require__);
            return module2.exports;
          }
          __name(__w_pdfjs_require__, "__w_pdfjs_require__");
          (() => {
            __w_pdfjs_require__.d = (exports2, definition) => {
              for (var key in definition) {
                if (__w_pdfjs_require__.o(definition, key) && !__w_pdfjs_require__.o(exports2, key)) {
                  Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
                }
              }
            };
          })();
          (() => {
            __w_pdfjs_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
          })();
          (() => {
            __w_pdfjs_require__.r = (exports2) => {
              if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
              }
              Object.defineProperty(exports2, "__esModule", { value: true });
            };
          })();
          var __webpack_exports__ = {};
          (() => {
            var exports2 = __webpack_exports__;
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            Object.defineProperty(exports2, "WorkerMessageHandler", {
              enumerable: true,
              get: function() {
                return _worker.WorkerMessageHandler;
              }
            });
            var _worker = __w_pdfjs_require__(1);
          })();
          return __webpack_exports__;
        })()
      );
    });
  })(pdf_worker);
  var pdf_workerExports = pdf_worker.exports;
  (typeof window !== "undefined" ? window : {}).pdfjsWorker = pdf_workerExports;
})();
